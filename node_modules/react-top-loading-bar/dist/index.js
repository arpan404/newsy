var React = require('react');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var noop = function noop() {};

function useInterval(callback, delay, immediate) {
  var savedCallback = React.useRef(noop);
  React.useEffect(function () {
    savedCallback.current = callback;
  });
  React.useEffect(function () {
    if (!immediate) return;
    if (delay === null || delay === false) return;
    savedCallback.current();
  }, [immediate]);
  React.useEffect(function () {
    if (delay === null || delay === false) return undefined;

    var tick = function tick() {
      return savedCallback.current();
    };

    var id = setInterval(tick, delay);
    return function () {
      return clearInterval(id);
    };
  }, [delay]);
}

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
}

var LoadingBar = React.forwardRef(function (_ref, ref) {
  var progress = _ref.progress,
      _ref$height = _ref.height,
      height = _ref$height === void 0 ? 2 : _ref$height,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? 'red' : _ref$color,
      _ref$background = _ref.background,
      background = _ref$background === void 0 ? 'transparent' : _ref$background,
      onLoaderFinished = _ref.onLoaderFinished,
      _ref$transitionTime = _ref.transitionTime,
      transitionTime = _ref$transitionTime === void 0 ? 300 : _ref$transitionTime,
      _ref$loaderSpeed = _ref.loaderSpeed,
      loaderSpeed = _ref$loaderSpeed === void 0 ? 500 : _ref$loaderSpeed,
      _ref$waitingTime = _ref.waitingTime,
      waitingTime = _ref$waitingTime === void 0 ? 1000 : _ref$waitingTime,
      _ref$shadow = _ref.shadow,
      shadow = _ref$shadow === void 0 ? true : _ref$shadow,
      _ref$containerStyle = _ref.containerStyle,
      containerStyle = _ref$containerStyle === void 0 ? {} : _ref$containerStyle,
      _ref$style = _ref.style,
      style = _ref$style === void 0 ? {} : _ref$style,
      _ref$shadowStyle = _ref.shadowStyle,
      shadowStyleProp = _ref$shadowStyle === void 0 ? {} : _ref$shadowStyle,
      _ref$containerClassNa = _ref.containerClassName,
      containerClassName = _ref$containerClassNa === void 0 ? '' : _ref$containerClassNa;
  var isMounted = React.useRef(false);

  var _useState = React.useState(0),
      localProgress = _useState[0],
      localProgressSet = _useState[1];

  var _useState2 = React.useState({
    active: false,
    startingValue: 20,
    refreshRate: 1000
  }),
      pressedContinuous = _useState2[0],
      setPressedContinuous = _useState2[1];

  var _useState3 = React.useState(false),
      usingProps = _useState3[0],
      setUsingProps = _useState3[1];

  var _useState4 = React.useState({
    active: false,
    value: 20
  }),
      pressedStaticStart = _useState4[0],
      setStaticStartPressed = _useState4[1];

  var initialLoaderStyle = {
    height: '100%',
    background: color,
    transition: "all " + loaderSpeed + "ms ease",
    width: '0%'
  };
  var loaderContainerStyle = {
    position: 'fixed',
    top: 0,
    left: 0,
    height: height,
    background: background,
    zIndex: 99999999999,
    width: 100 + '%'
  };
  var initialShadowStyles = {
    boxShadow: "0 0 10px " + color + ", 0 0 10px " + color,
    width: '5%',
    opacity: 1,
    position: 'absolute',
    height: '100%',
    transition: "all " + loaderSpeed + "ms ease",
    transform: 'rotate(3deg) translate(0px, -4px)',
    left: '-10rem'
  };

  var _useState5 = React.useState(initialLoaderStyle),
      loaderStyle = _useState5[0],
      loaderStyleSet = _useState5[1];

  var _useState6 = React.useState(initialShadowStyles),
      shadowStyle = _useState6[0],
      shadowStyleSet = _useState6[1];

  React.useEffect(function () {
    isMounted.current = true;
    return function () {
      isMounted.current = false;
    };
  }, []);
  React.useImperativeHandle(ref, function () {
    return {
      continuousStart: function continuousStart(startingValue, refreshRate) {
        if (refreshRate === void 0) {
          refreshRate = 1000;
        }

        if (pressedStaticStart.active) return;

        if (usingProps) {
          console.warn("react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!");
          return;
        }

        var val = startingValue || randomInt(10, 20);
        setPressedContinuous({
          active: true,
          refreshRate: refreshRate,
          startingValue: startingValue
        });
        localProgressSet(val);
        checkIfFull(val);
      },
      staticStart: function staticStart(startingValue) {
        if (pressedContinuous.active) return;

        if (usingProps) {
          console.warn("react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!");
          return;
        }

        var val = startingValue || randomInt(30, 50);
        setStaticStartPressed({
          active: true,
          value: val
        });
        localProgressSet(val);
        checkIfFull(val);
      },
      complete: function complete() {
        if (usingProps) {
          console.warn("react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!");
          return;
        }

        localProgressSet(100);
        checkIfFull(100);
      }
    };
  });
  React.useEffect(function () {
    loaderStyleSet(_extends({}, loaderStyle, {
      background: color
    }));
    shadowStyleSet(_extends({}, shadowStyle, {
      boxShadow: "0 0 10px " + color + ", 0 0 5px " + color
    }));
  }, [color]);
  React.useEffect(function () {
    if (ref) {
      if (ref && progress !== undefined) {
        console.warn('react-top-loading-bar: You can\'t use both controlling by props and ref methods to control the bar! Please use only props or only ref methods! Ref methods will override props if "ref" property is available.');
        return;
      }

      checkIfFull(localProgress);
      setUsingProps(false);
    } else {
      if (progress) checkIfFull(progress);
      setUsingProps(true);
    }
  }, [progress]);

  var checkIfFull = function checkIfFull(_progress) {
    if (_progress >= 100) {
      loaderStyleSet(_extends({}, loaderStyle, {
        width: '100%'
      }));

      if (shadow) {
        shadowStyleSet(_extends({}, shadowStyle, {
          left: _progress - 10 + '%'
        }));
      }

      setTimeout(function () {
        if (!isMounted.current) {
          return;
        }

        loaderStyleSet(_extends({}, loaderStyle, {
          opacity: 0,
          width: '100%',
          transition: "all " + transitionTime + "ms ease-out",
          color: color
        }));
        setTimeout(function () {
          if (!isMounted.current) {
            return;
          }

          if (pressedContinuous.active) {
            setPressedContinuous(_extends({}, pressedContinuous, {
              active: false
            }));
            localProgressSet(0);
            checkIfFull(0);
          }

          if (pressedStaticStart.active) {
            setStaticStartPressed(_extends({}, pressedStaticStart, {
              active: false
            }));
            localProgressSet(0);
            checkIfFull(0);
          }

          if (onLoaderFinished) onLoaderFinished();
          localProgressSet(0);
          checkIfFull(0);
        }, transitionTime);
      }, waitingTime);
    } else {
      loaderStyleSet(function (_loaderStyle) {
        return _extends({}, _loaderStyle, {
          width: _progress + '%',
          opacity: 1,
          transition: _progress > 0 ? "all " + loaderSpeed + "ms ease" : ''
        });
      });

      if (shadow) {
        shadowStyleSet(_extends({}, shadowStyle, {
          left: _progress - 5.5 + '%',
          transition: _progress > 0 ? "all " + loaderSpeed + "ms ease" : ''
        }));
      }
    }
  };

  useInterval(function () {
    var random = randomInt(10, 20);

    if (localProgress + random < 90) {
      localProgressSet(localProgress + random);
      checkIfFull(localProgress + random);
    }
  }, pressedContinuous.active ? pressedContinuous.refreshRate : null);
  return React.createElement("div", {
    className: containerClassName,
    style: _extends({}, loaderContainerStyle, containerStyle)
  }, React.createElement("div", {
    className: className,
    style: _extends({}, loaderStyle, style)
  }, shadow ? React.createElement("div", {
    style: _extends({}, shadowStyle, shadowStyleProp)
  }) : null));
});

module.exports = LoadingBar;
//# sourceMappingURL=index.js.map
