{"version":3,"file":"index.umd.js","sources":["../src/useInterval.ts","../src/utils.ts","../src/index.tsx"],"sourcesContent":["import { useEffect, useRef } from 'react'\n\n/** keep typescript happy */\nconst noop = () => {}\n\nexport function useInterval(\n  callback: () => void,\n  delay: number | null | false,\n  immediate?: boolean\n) {\n  const savedCallback = useRef(noop)\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback\n  })\n\n  // Execute callback if immediate is set.\n  useEffect(() => {\n    if (!immediate) return\n    if (delay === null || delay === false) return\n    savedCallback.current()\n  }, [immediate])\n\n  // Set up the interval.\n  useEffect(() => {\n    if (delay === null || delay === false) return undefined\n    const tick = () => savedCallback.current()\n    const id = setInterval(tick, delay)\n    return () => clearInterval(id)\n  }, [delay])\n}\n\nexport default useInterval\n","export function randomInt(min: number, max: number): number {\n  // @ts-ignore\n  return Math.floor(Math.random() * (max - min + 1) + min)\n}\n","import * as React from 'react'\nimport {\n  // eslint-disable-next-line no-unused-vars\n  CSSProperties,\n  useEffect,\n  useState,\n  forwardRef,\n  useImperativeHandle,\n  useRef,\n} from 'react'\nimport { useInterval } from './useInterval'\nimport { randomInt } from './utils'\n\ntype IProps = {\n  progress?: number\n  color?: string\n  shadow?: boolean\n  background?: string\n  height?: number\n  onLoaderFinished?: () => void\n  className?: string\n  loaderSpeed?: number\n  transitionTime?: number\n  waitingTime?: number\n}\n\nexport type LoadingBarRef = {\n  continuousStart: (startingValue: number, refreshRate: number) => void\n  staticStart: (startingValue: number) => void\n  complete: () => void;\n}\n\nconst LoadingBar = forwardRef<LoadingBarRef, IProps>(\n  (\n    {\n      progress,\n      height = 2,\n      className = '',\n      color = 'red',\n      background = 'transparent',\n      onLoaderFinished,\n      transitionTime = 300,\n      loaderSpeed = 500,\n      waitingTime = 1000,\n      shadow = true,\n    },\n    ref\n  ) => {\n    const isMounted = useRef(false);\n    const [localProgress, localProgressSet] = useState<number>(0)\n    const [pressedContinuous, setPressedContinuous] = useState<{\n      active: boolean\n      startingValue: number\n      refreshRate: number\n    }>({ active: false, startingValue: 20, refreshRate: 1000 })\n    const [usingProps, setUsingProps] = useState(false)\n\n    const [pressedStaticStart, setStaticStartPressed] = useState<{\n      active: boolean\n      value: number\n    }>({ active: false, value: 20 })\n\n    const initialLoaderStyle: CSSProperties = {\n      height: '100%',\n      background: color,\n      transition: `all ${loaderSpeed}ms ease`,\n      width: '0%',\n    }\n\n    const loaderContainerStyle: CSSProperties = {\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      height,\n      background,\n      zIndex: 99999999999,\n      width: 100 + '%',\n    }\n\n    const initialShadowStyles: CSSProperties = {\n      boxShadow: `0 0 10px ${color}, 0 0 10px ${color}`,\n      width: '5%',\n      opacity: 1,\n      position: 'absolute',\n      height: '100%',\n      transition: `all ${loaderSpeed}ms ease`,\n      transform: 'rotate(3deg) translate(0px, -4px)',\n      left: '-10rem',\n    }\n\n    const [loaderStyle, loaderStyleSet] = useState<CSSProperties>(\n      initialLoaderStyle\n    )\n    const [shadowStyle, shadowStyleSet] = useState<CSSProperties>(\n      initialShadowStyles\n    )\n\n    useEffect(() => {\n      isMounted.current = true;\n      return () => {\n        isMounted.current = false;\n      }\n    }, []);\n\n    useImperativeHandle(ref, () => ({\n      continuousStart(startingValue: number, refreshRate: number = 1000) {\n        if (pressedStaticStart.active) return\n        if (usingProps) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\"\n          )\n          return\n        }\n\n        const val = startingValue || randomInt(10, 20)\n        setPressedContinuous({\n          active: true,\n          refreshRate,\n          startingValue,\n        })\n        localProgressSet(val)\n        checkIfFull(val)\n      },\n      staticStart(startingValue: number) {\n        if (pressedContinuous.active) return\n        if (usingProps) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\"\n          )\n          return\n        }\n\n        const val = startingValue || randomInt(30, 50)\n        setStaticStartPressed({\n          active: true,\n          value: val,\n        })\n        localProgressSet(val)\n        checkIfFull(val)\n      },\n      complete() {\n        if (usingProps) {\n          console.warn(\n            \"react-top-loading-bar: You can't use both controlling by props and ref methods to control the bar!\"\n          )\n          return\n        }\n        localProgressSet(100)\n        checkIfFull(100)\n      },\n    }))\n\n    useEffect(() => {\n      loaderStyleSet({\n        ...loaderStyle,\n        background: color,\n      })\n\n      shadowStyleSet({\n        ...shadowStyle,\n        boxShadow: `0 0 10px ${color}, 0 0 5px ${color}`,\n      })\n    }, [color])\n\n    useEffect(() => {\n      if (ref) {\n        if (ref && progress !== undefined) {\n          console.warn(\n            'react-top-loading-bar: You can\\'t use both controlling by props and ref methods to control the bar! Please use only props or only ref methods! Ref methods will override props if \"ref\" property is available.'\n          )\n          return\n        }\n        checkIfFull(localProgress)\n        setUsingProps(false)\n      } else {\n        if (progress) checkIfFull(progress)\n\n        setUsingProps(true)\n      }\n    }, [progress])\n\n    const checkIfFull = (_progress: number) => {\n      if (_progress >= 100) {\n        // now it should wait a little bit\n        loaderStyleSet({\n          ...loaderStyle,\n          width: '100%',\n        })\n        if (shadow) {\n          shadowStyleSet({\n            ...shadowStyle,\n            left: _progress - 10 + '%',\n          })\n        }\n\n        setTimeout(() => {\n          if (!isMounted.current) {\n            return;\n          }\n          // now it can fade out\n          loaderStyleSet({\n            ...loaderStyle,\n            opacity: 0,\n            width: '100%',\n            transition: `all ${transitionTime}ms ease-out`,\n            color: color,\n          })\n\n          setTimeout(() => {\n            if (!isMounted.current) {\n              return;\n            }\n            // here we wait for it to fade\n            if (pressedContinuous.active) {\n              // if we have continous loader just ending, we kill it and reset it\n              setPressedContinuous({\n                ...pressedContinuous,\n                active: false,\n              })\n              localProgressSet(0)\n              checkIfFull(0)\n            }\n\n            if (pressedStaticStart.active) {\n              setStaticStartPressed({\n                ...pressedStaticStart,\n                active: false,\n              })\n              localProgressSet(0)\n              checkIfFull(0)\n            }\n\n            if (onLoaderFinished) onLoaderFinished()\n            localProgressSet(0)\n            checkIfFull(0)\n          }, transitionTime)\n        }, waitingTime)\n      } else {\n        loaderStyleSet((_loaderStyle) => {\n          return {\n            ..._loaderStyle,\n            width: _progress + '%',\n            opacity: 1,\n            transition: _progress > 0 ? `all ${loaderSpeed}ms ease` : '',\n          }\n        })\n\n        if (shadow) {\n          shadowStyleSet({\n            ...shadowStyle,\n            left: _progress - 5.5 + '%',\n            transition: _progress > 0 ? `all ${loaderSpeed}ms ease` : '',\n          })\n        }\n      }\n    }\n\n    useInterval(\n      () => {\n        const random = randomInt(10, 20)\n\n        if (localProgress + random < 90) {\n          localProgressSet(localProgress + random)\n          checkIfFull(localProgress + random)\n        }\n      },\n      pressedContinuous.active ? pressedContinuous.refreshRate : null\n    )\n\n    return (\n      <div className={className} style={loaderContainerStyle}>\n        <div style={loaderStyle}>\n          {shadow ? <div style={shadowStyle} /> : null}\n        </div>\n      </div>\n    )\n  }\n)\n\nexport {\n  IProps,\n}\n\nexport default LoadingBar\n"],"names":["noop","randomInt","min","max","Math","floor","random","forwardRef","ref","progress","height","className","color","background","onLoaderFinished","transitionTime","loaderSpeed","waitingTime","shadow","isMounted","useRef","useState","localProgress","localProgressSet","active","startingValue","refreshRate","pressedContinuous","setPressedContinuous","usingProps","setUsingProps","value","pressedStaticStart","setStaticStartPressed","loaderContainerStyle","position","top","left","zIndex","width","initialShadowStyles","boxShadow","opacity","transition","transform","loaderStyle","loaderStyleSet","shadowStyle","shadowStyleSet","useEffect","current","useImperativeHandle","continuousStart","console","warn","val","checkIfFull","staticStart","complete","undefined","callback","delay","savedCallback","_progress","setTimeout","_loaderStyle","immediate","id","setInterval","clearInterval","React","style"],"mappings":"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"}