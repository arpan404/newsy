{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  ConcatSource\n} = require(\"webpack-sources\");\n\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\n\nconst Template = require(\"../Template\");\n\nconst propertyAccess = require(\"../util/propertyAccess\");\n\nconst {\n  getEntryRuntime\n} = require(\"../util/runtime\");\n\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\n\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").StartupRenderContext} StartupRenderContext */\n\n/** @typedef {import(\"../util/Hash\")} Hash */\n\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\n\n\nconst KEYWORD_REGEX = /^(await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|super|switch|static|this|throw|try|true|typeof|var|void|while|with|yield)$/;\nconst IDENTIFIER_REGEX = /^[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/iu;\n/**\n * Validates the library name by checking for keywords and valid characters\n * @param {string} name name to be validated\n * @returns {boolean} true, when valid\n */\n\nconst isNameValid = name => {\n  return !KEYWORD_REGEX.test(name) && IDENTIFIER_REGEX.test(name);\n};\n/**\n * @param {string[]} accessor variable plus properties\n * @param {number} existingLength items of accessor that are existing already\n * @param {boolean=} initLast if the last property should also be initialized to an object\n * @returns {string} code to access the accessor while initializing\n */\n\n\nconst accessWithInit = function (accessor, existingLength) {\n  let initLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // This generates for [a, b, c, d]:\n  // (((a = typeof a === \"undefined\" ? {} : a).b = a.b || {}).c = a.b.c || {}).d\n  const base = accessor[0];\n  if (accessor.length === 1 && !initLast) return base;\n  let current = existingLength > 0 ? base : `(${base} = typeof ${base} === \"undefined\" ? {} : ${base})`; // i is the current position in accessor that has been printed\n\n  let i = 1; // all properties printed so far (excluding base)\n\n  let propsSoFar; // if there is existingLength, print all properties until this position as property access\n\n  if (existingLength > i) {\n    propsSoFar = accessor.slice(1, existingLength);\n    i = existingLength;\n    current += propertyAccess(propsSoFar);\n  } else {\n    propsSoFar = [];\n  } // all remaining properties (except the last one when initLast is not set)\n  // should be printed as initializer\n\n\n  const initUntil = initLast ? accessor.length : accessor.length - 1;\n\n  for (; i < initUntil; i++) {\n    const prop = accessor[i];\n    propsSoFar.push(prop);\n    current = `(${current}${propertyAccess([prop])} = ${base}${propertyAccess(propsSoFar)} || {})`;\n  } // print the last property as property access if not yet printed\n\n\n  if (i < accessor.length) current = `${current}${propertyAccess([accessor[accessor.length - 1]])}`;\n  return current;\n};\n/**\n * @typedef {Object} AssignLibraryPluginOptions\n * @property {LibraryType} type\n * @property {string[] | \"global\"} prefix name prefix\n * @property {string | false} declare declare name as variable\n * @property {\"error\"|\"static\"|\"copy\"|\"assign\"} unnamed behavior for unnamed library name\n * @property {\"copy\"|\"assign\"=} named behavior for named library name\n */\n\n/**\n * @typedef {Object} AssignLibraryPluginParsed\n * @property {string | string[]} name\n * @property {string | string[] | undefined} export\n */\n\n/**\n * @typedef {AssignLibraryPluginParsed} T\n * @extends {AbstractLibraryPlugin<AssignLibraryPluginParsed>}\n */\n\n\nclass AssignLibraryPlugin extends AbstractLibraryPlugin {\n  /**\n   * @param {AssignLibraryPluginOptions} options the plugin options\n   */\n  constructor(options) {\n    super({\n      pluginName: \"AssignLibraryPlugin\",\n      type: options.type\n    });\n    this.prefix = options.prefix;\n    this.declare = options.declare;\n    this.unnamed = options.unnamed;\n    this.named = options.named || \"assign\";\n  }\n  /**\n   * @param {LibraryOptions} library normalized library option\n   * @returns {T | false} preprocess as needed by overriding\n   */\n\n\n  parseOptions(library) {\n    const {\n      name\n    } = library;\n\n    if (this.unnamed === \"error\") {\n      if (typeof name !== \"string\" && !Array.isArray(name)) {\n        throw new Error(`Library name must be a string or string array. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    } else {\n      if (name && typeof name !== \"string\" && !Array.isArray(name)) {\n        throw new Error(`Library name must be a string, string array or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n    }\n\n    return {\n      name:\n      /** @type {string|string[]=} */\n      name,\n      export: library.export\n    };\n  }\n  /**\n   * @param {Module} module the exporting entry module\n   * @param {string} entryName the name of the entrypoint\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n\n\n  finishEntryModule(module, entryName, _ref) {\n    let {\n      options,\n      compilation,\n      compilation: {\n        moduleGraph\n      }\n    } = _ref;\n    const runtime = getEntryRuntime(compilation, entryName);\n\n    if (options.export) {\n      const exportsInfo = moduleGraph.getExportInfo(module, Array.isArray(options.export) ? options.export[0] : options.export);\n      exportsInfo.setUsed(UsageState.Used, runtime);\n      exportsInfo.canMangleUse = false;\n    } else {\n      const exportsInfo = moduleGraph.getExportsInfo(module);\n      exportsInfo.setUsedInUnknownWay(runtime);\n    }\n\n    moduleGraph.addExtraReason(module, \"used as library export\");\n  }\n\n  _getPrefix(compilation) {\n    return this.prefix === \"global\" ? [compilation.runtimeTemplate.globalObject] : this.prefix;\n  }\n\n  _getResolvedFullName(options, chunk, compilation) {\n    const prefix = this._getPrefix(compilation);\n\n    const fullName = options.name ? prefix.concat(options.name) : prefix;\n    return fullName.map(n => compilation.getPath(n, {\n      chunk\n    }));\n  }\n  /**\n   * @param {Source} source source\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {Source} source with library export\n   */\n\n\n  render(source, _ref2, _ref3) {\n    let {\n      chunk\n    } = _ref2;\n    let {\n      options,\n      compilation\n    } = _ref3;\n\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n\n    if (this.declare) {\n      const base = fullNameResolved[0];\n\n      if (!isNameValid(base)) {\n        throw new Error(`Library name base (${base}) must be a valid identifier when using a var declaring library type. Either use a valid identifier (e. g. ${Template.toIdentifier(base)}) or use a different library type (e. g. 'type: \"global\"', which assign a property on the global scope instead of declaring a variable). ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`);\n      }\n\n      source = new ConcatSource(`${this.declare} ${base};\\n`, source);\n    }\n\n    return source;\n  }\n  /**\n   * @param {Module} module the exporting entry module\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {string | undefined} bailout reason\n   */\n\n\n  embedInRuntimeBailout(module, _ref4, _ref5) {\n    let {\n      chunk,\n      codeGenerationResults\n    } = _ref4;\n    let {\n      options,\n      compilation\n    } = _ref5;\n    const {\n      data\n    } = codeGenerationResults.get(module, chunk.runtime);\n    const topLevelDeclarations = data && data.get(\"topLevelDeclarations\") || module.buildInfo && module.buildInfo.topLevelDeclarations;\n    if (!topLevelDeclarations) return \"it doesn't tell about top level declarations.\";\n\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n\n    const base = fullNameResolved[0];\n    if (topLevelDeclarations.has(base)) return `it declares '${base}' on top-level, which conflicts with the current library output.`;\n  }\n  /**\n   * @param {RenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {string | undefined} bailout reason\n   */\n\n\n  strictRuntimeBailout(_ref6, _ref7) {\n    let {\n      chunk\n    } = _ref6;\n    let {\n      options,\n      compilation\n    } = _ref7;\n\n    if (this.declare || this.prefix === \"global\" || this.prefix.length > 0 || !options.name) {\n      return;\n    }\n\n    return \"a global variable is assign and maybe created\";\n  }\n  /**\n   * @param {Source} source source\n   * @param {Module} module module\n   * @param {StartupRenderContext} renderContext render context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {Source} source with library export\n   */\n\n\n  renderStartup(source, module, _ref8, _ref9) {\n    let {\n      moduleGraph,\n      chunk\n    } = _ref8;\n    let {\n      options,\n      compilation\n    } = _ref9;\n\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n\n    const staticExports = this.unnamed === \"static\";\n    const exportAccess = options.export ? propertyAccess(Array.isArray(options.export) ? options.export : [options.export]) : \"\";\n    const result = new ConcatSource(source);\n\n    if (staticExports) {\n      const exportsInfo = moduleGraph.getExportsInfo(module);\n      const exportTarget = accessWithInit(fullNameResolved, this._getPrefix(compilation).length, true);\n\n      for (const exportInfo of exportsInfo.orderedExports) {\n        if (!exportInfo.provided) continue;\n        const nameAccess = propertyAccess([exportInfo.name]);\n        result.add(`${exportTarget}${nameAccess} = __webpack_exports__${exportAccess}${nameAccess};\\n`);\n      }\n\n      result.add(`Object.defineProperty(${exportTarget}, \"__esModule\", { value: true });\\n`);\n    } else if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n      result.add(`var __webpack_export_target__ = ${accessWithInit(fullNameResolved, this._getPrefix(compilation).length, true)};\\n`);\n      let exports = \"__webpack_exports__\";\n\n      if (exportAccess) {\n        result.add(`var __webpack_exports_export__ = __webpack_exports__${exportAccess};\\n`);\n        exports = \"__webpack_exports_export__\";\n      }\n\n      result.add(`for(var i in ${exports}) __webpack_export_target__[i] = ${exports}[i];\\n`);\n      result.add(`if(${exports}.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", { value: true });\\n`);\n    } else {\n      result.add(`${accessWithInit(fullNameResolved, this._getPrefix(compilation).length, false)} = __webpack_exports__${exportAccess};\\n`);\n    }\n\n    return result;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Set<string>} set runtime requirements\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n\n\n  runtimeRequirements(chunk, set, libraryContext) {// we don't need to return exports from runtime\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Hash} hash hash\n   * @param {ChunkHashContext} chunkHashContext chunk hash context\n   * @param {LibraryContext<T>} libraryContext context\n   * @returns {void}\n   */\n\n\n  chunkHash(chunk, hash, chunkHashContext, _ref10) {\n    let {\n      options,\n      compilation\n    } = _ref10;\n    hash.update(\"AssignLibraryPlugin\");\n\n    const fullNameResolved = this._getResolvedFullName(options, chunk, compilation);\n\n    if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n      hash.update(\"copy\");\n    }\n\n    if (this.declare) {\n      hash.update(this.declare);\n    }\n\n    hash.update(fullNameResolved.join(\".\"));\n\n    if (options.export) {\n      hash.update(`${options.export}`);\n    }\n  }\n\n}\n\nmodule.exports = AssignLibraryPlugin;","map":{"version":3,"names":["ConcatSource","require","UsageState","Template","propertyAccess","getEntryRuntime","AbstractLibraryPlugin","KEYWORD_REGEX","IDENTIFIER_REGEX","isNameValid","name","test","accessWithInit","accessor","existingLength","initLast","base","length","current","i","propsSoFar","slice","initUntil","prop","push","AssignLibraryPlugin","constructor","options","pluginName","type","prefix","declare","unnamed","named","parseOptions","library","Array","isArray","Error","COMMON_LIBRARY_NAME_MESSAGE","export","finishEntryModule","module","entryName","compilation","moduleGraph","runtime","exportsInfo","getExportInfo","setUsed","Used","canMangleUse","getExportsInfo","setUsedInUnknownWay","addExtraReason","_getPrefix","runtimeTemplate","globalObject","_getResolvedFullName","chunk","fullName","concat","map","n","getPath","render","source","fullNameResolved","toIdentifier","embedInRuntimeBailout","codeGenerationResults","data","get","topLevelDeclarations","buildInfo","has","strictRuntimeBailout","renderStartup","staticExports","exportAccess","result","exportTarget","exportInfo","orderedExports","provided","nameAccess","add","exports","runtimeRequirements","set","libraryContext","chunkHash","hash","chunkHashContext","update","join"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/library/AssignLibraryPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { ConcatSource } = require(\"webpack-sources\");\nconst { UsageState } = require(\"../ExportsInfo\");\nconst Template = require(\"../Template\");\nconst propertyAccess = require(\"../util/propertyAccess\");\nconst { getEntryRuntime } = require(\"../util/runtime\");\nconst AbstractLibraryPlugin = require(\"./AbstractLibraryPlugin\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryOptions} LibraryOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").LibraryType} LibraryType */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\").ChunkHashContext} ChunkHashContext */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").RenderContext} RenderContext */\n/** @typedef {import(\"../javascript/JavascriptModulesPlugin\").StartupRenderContext} StartupRenderContext */\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @template T @typedef {import(\"./AbstractLibraryPlugin\").LibraryContext<T>} LibraryContext<T> */\n\nconst KEYWORD_REGEX =\n\t/^(await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|super|switch|static|this|throw|try|true|typeof|var|void|while|with|yield)$/;\nconst IDENTIFIER_REGEX =\n\t/^[\\p{L}\\p{Nl}$_][\\p{L}\\p{Nl}$\\p{Mn}\\p{Mc}\\p{Nd}\\p{Pc}]*$/iu;\n\n/**\n * Validates the library name by checking for keywords and valid characters\n * @param {string} name name to be validated\n * @returns {boolean} true, when valid\n */\nconst isNameValid = name => {\n\treturn !KEYWORD_REGEX.test(name) && IDENTIFIER_REGEX.test(name);\n};\n\n/**\n * @param {string[]} accessor variable plus properties\n * @param {number} existingLength items of accessor that are existing already\n * @param {boolean=} initLast if the last property should also be initialized to an object\n * @returns {string} code to access the accessor while initializing\n */\nconst accessWithInit = (accessor, existingLength, initLast = false) => {\n\t// This generates for [a, b, c, d]:\n\t// (((a = typeof a === \"undefined\" ? {} : a).b = a.b || {}).c = a.b.c || {}).d\n\tconst base = accessor[0];\n\tif (accessor.length === 1 && !initLast) return base;\n\tlet current =\n\t\texistingLength > 0\n\t\t\t? base\n\t\t\t: `(${base} = typeof ${base} === \"undefined\" ? {} : ${base})`;\n\n\t// i is the current position in accessor that has been printed\n\tlet i = 1;\n\n\t// all properties printed so far (excluding base)\n\tlet propsSoFar;\n\n\t// if there is existingLength, print all properties until this position as property access\n\tif (existingLength > i) {\n\t\tpropsSoFar = accessor.slice(1, existingLength);\n\t\ti = existingLength;\n\t\tcurrent += propertyAccess(propsSoFar);\n\t} else {\n\t\tpropsSoFar = [];\n\t}\n\n\t// all remaining properties (except the last one when initLast is not set)\n\t// should be printed as initializer\n\tconst initUntil = initLast ? accessor.length : accessor.length - 1;\n\tfor (; i < initUntil; i++) {\n\t\tconst prop = accessor[i];\n\t\tpropsSoFar.push(prop);\n\t\tcurrent = `(${current}${propertyAccess([prop])} = ${base}${propertyAccess(\n\t\t\tpropsSoFar\n\t\t)} || {})`;\n\t}\n\n\t// print the last property as property access if not yet printed\n\tif (i < accessor.length)\n\t\tcurrent = `${current}${propertyAccess([accessor[accessor.length - 1]])}`;\n\n\treturn current;\n};\n\n/**\n * @typedef {Object} AssignLibraryPluginOptions\n * @property {LibraryType} type\n * @property {string[] | \"global\"} prefix name prefix\n * @property {string | false} declare declare name as variable\n * @property {\"error\"|\"static\"|\"copy\"|\"assign\"} unnamed behavior for unnamed library name\n * @property {\"copy\"|\"assign\"=} named behavior for named library name\n */\n\n/**\n * @typedef {Object} AssignLibraryPluginParsed\n * @property {string | string[]} name\n * @property {string | string[] | undefined} export\n */\n\n/**\n * @typedef {AssignLibraryPluginParsed} T\n * @extends {AbstractLibraryPlugin<AssignLibraryPluginParsed>}\n */\nclass AssignLibraryPlugin extends AbstractLibraryPlugin {\n\t/**\n\t * @param {AssignLibraryPluginOptions} options the plugin options\n\t */\n\tconstructor(options) {\n\t\tsuper({\n\t\t\tpluginName: \"AssignLibraryPlugin\",\n\t\t\ttype: options.type\n\t\t});\n\t\tthis.prefix = options.prefix;\n\t\tthis.declare = options.declare;\n\t\tthis.unnamed = options.unnamed;\n\t\tthis.named = options.named || \"assign\";\n\t}\n\n\t/**\n\t * @param {LibraryOptions} library normalized library option\n\t * @returns {T | false} preprocess as needed by overriding\n\t */\n\tparseOptions(library) {\n\t\tconst { name } = library;\n\t\tif (this.unnamed === \"error\") {\n\t\t\tif (typeof name !== \"string\" && !Array.isArray(name)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name must be a string or string array. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tif (name && typeof name !== \"string\" && !Array.isArray(name)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name must be a string, string array or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tname: /** @type {string|string[]=} */ (name),\n\t\t\texport: library.export\n\t\t};\n\t}\n\n\t/**\n\t * @param {Module} module the exporting entry module\n\t * @param {string} entryName the name of the entrypoint\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\tfinishEntryModule(\n\t\tmodule,\n\t\tentryName,\n\t\t{ options, compilation, compilation: { moduleGraph } }\n\t) {\n\t\tconst runtime = getEntryRuntime(compilation, entryName);\n\t\tif (options.export) {\n\t\t\tconst exportsInfo = moduleGraph.getExportInfo(\n\t\t\t\tmodule,\n\t\t\t\tArray.isArray(options.export) ? options.export[0] : options.export\n\t\t\t);\n\t\t\texportsInfo.setUsed(UsageState.Used, runtime);\n\t\t\texportsInfo.canMangleUse = false;\n\t\t} else {\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\texportsInfo.setUsedInUnknownWay(runtime);\n\t\t}\n\t\tmoduleGraph.addExtraReason(module, \"used as library export\");\n\t}\n\n\t_getPrefix(compilation) {\n\t\treturn this.prefix === \"global\"\n\t\t\t? [compilation.runtimeTemplate.globalObject]\n\t\t\t: this.prefix;\n\t}\n\n\t_getResolvedFullName(options, chunk, compilation) {\n\t\tconst prefix = this._getPrefix(compilation);\n\t\tconst fullName = options.name ? prefix.concat(options.name) : prefix;\n\t\treturn fullName.map(n =>\n\t\t\tcompilation.getPath(n, {\n\t\t\t\tchunk\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * @param {Source} source source\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {Source} source with library export\n\t */\n\trender(source, { chunk }, { options, compilation }) {\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tif (this.declare) {\n\t\t\tconst base = fullNameResolved[0];\n\t\t\tif (!isNameValid(base)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Library name base (${base}) must be a valid identifier when using a var declaring library type. Either use a valid identifier (e. g. ${Template.toIdentifier(\n\t\t\t\t\t\tbase\n\t\t\t\t\t)}) or use a different library type (e. g. 'type: \"global\"', which assign a property on the global scope instead of declaring a variable). ${\n\t\t\t\t\t\tAbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE\n\t\t\t\t\t}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tsource = new ConcatSource(`${this.declare} ${base};\\n`, source);\n\t\t}\n\t\treturn source;\n\t}\n\n\t/**\n\t * @param {Module} module the exporting entry module\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {string | undefined} bailout reason\n\t */\n\tembedInRuntimeBailout(\n\t\tmodule,\n\t\t{ chunk, codeGenerationResults },\n\t\t{ options, compilation }\n\t) {\n\t\tconst { data } = codeGenerationResults.get(module, chunk.runtime);\n\t\tconst topLevelDeclarations =\n\t\t\t(data && data.get(\"topLevelDeclarations\")) ||\n\t\t\t(module.buildInfo && module.buildInfo.topLevelDeclarations);\n\t\tif (!topLevelDeclarations)\n\t\t\treturn \"it doesn't tell about top level declarations.\";\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tconst base = fullNameResolved[0];\n\t\tif (topLevelDeclarations.has(base))\n\t\t\treturn `it declares '${base}' on top-level, which conflicts with the current library output.`;\n\t}\n\n\t/**\n\t * @param {RenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {string | undefined} bailout reason\n\t */\n\tstrictRuntimeBailout({ chunk }, { options, compilation }) {\n\t\tif (\n\t\t\tthis.declare ||\n\t\t\tthis.prefix === \"global\" ||\n\t\t\tthis.prefix.length > 0 ||\n\t\t\t!options.name\n\t\t) {\n\t\t\treturn;\n\t\t}\n\t\treturn \"a global variable is assign and maybe created\";\n\t}\n\n\t/**\n\t * @param {Source} source source\n\t * @param {Module} module module\n\t * @param {StartupRenderContext} renderContext render context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {Source} source with library export\n\t */\n\trenderStartup(\n\t\tsource,\n\t\tmodule,\n\t\t{ moduleGraph, chunk },\n\t\t{ options, compilation }\n\t) {\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tconst staticExports = this.unnamed === \"static\";\n\t\tconst exportAccess = options.export\n\t\t\t? propertyAccess(\n\t\t\t\t\tArray.isArray(options.export) ? options.export : [options.export]\n\t\t\t  )\n\t\t\t: \"\";\n\t\tconst result = new ConcatSource(source);\n\t\tif (staticExports) {\n\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\tconst exportTarget = accessWithInit(\n\t\t\t\tfullNameResolved,\n\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\ttrue\n\t\t\t);\n\t\t\tfor (const exportInfo of exportsInfo.orderedExports) {\n\t\t\t\tif (!exportInfo.provided) continue;\n\t\t\t\tconst nameAccess = propertyAccess([exportInfo.name]);\n\t\t\t\tresult.add(\n\t\t\t\t\t`${exportTarget}${nameAccess} = __webpack_exports__${exportAccess}${nameAccess};\\n`\n\t\t\t\t);\n\t\t\t}\n\t\t\tresult.add(\n\t\t\t\t`Object.defineProperty(${exportTarget}, \"__esModule\", { value: true });\\n`\n\t\t\t);\n\t\t} else if (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n\t\t\tresult.add(\n\t\t\t\t`var __webpack_export_target__ = ${accessWithInit(\n\t\t\t\t\tfullNameResolved,\n\t\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\t\ttrue\n\t\t\t\t)};\\n`\n\t\t\t);\n\t\t\tlet exports = \"__webpack_exports__\";\n\t\t\tif (exportAccess) {\n\t\t\t\tresult.add(\n\t\t\t\t\t`var __webpack_exports_export__ = __webpack_exports__${exportAccess};\\n`\n\t\t\t\t);\n\t\t\t\texports = \"__webpack_exports_export__\";\n\t\t\t}\n\t\t\tresult.add(\n\t\t\t\t`for(var i in ${exports}) __webpack_export_target__[i] = ${exports}[i];\\n`\n\t\t\t);\n\t\t\tresult.add(\n\t\t\t\t`if(${exports}.__esModule) Object.defineProperty(__webpack_export_target__, \"__esModule\", { value: true });\\n`\n\t\t\t);\n\t\t} else {\n\t\t\tresult.add(\n\t\t\t\t`${accessWithInit(\n\t\t\t\t\tfullNameResolved,\n\t\t\t\t\tthis._getPrefix(compilation).length,\n\t\t\t\t\tfalse\n\t\t\t\t)} = __webpack_exports__${exportAccess};\\n`\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Set<string>} set runtime requirements\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\truntimeRequirements(chunk, set, libraryContext) {\n\t\t// we don't need to return exports from runtime\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Hash} hash hash\n\t * @param {ChunkHashContext} chunkHashContext chunk hash context\n\t * @param {LibraryContext<T>} libraryContext context\n\t * @returns {void}\n\t */\n\tchunkHash(chunk, hash, chunkHashContext, { options, compilation }) {\n\t\thash.update(\"AssignLibraryPlugin\");\n\t\tconst fullNameResolved = this._getResolvedFullName(\n\t\t\toptions,\n\t\t\tchunk,\n\t\t\tcompilation\n\t\t);\n\t\tif (options.name ? this.named === \"copy\" : this.unnamed === \"copy\") {\n\t\t\thash.update(\"copy\");\n\t\t}\n\t\tif (this.declare) {\n\t\t\thash.update(this.declare);\n\t\t}\n\t\thash.update(fullNameResolved.join(\".\"));\n\t\tif (options.export) {\n\t\t\thash.update(`${options.export}`);\n\t\t}\n\t}\n}\n\nmodule.exports = AssignLibraryPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}