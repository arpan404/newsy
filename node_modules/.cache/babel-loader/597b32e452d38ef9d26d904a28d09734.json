{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\n\nconst ArraySerializer = require(\"./ArraySerializer\");\n\nconst DateObjectSerializer = require(\"./DateObjectSerializer\");\n\nconst ErrorObjectSerializer = require(\"./ErrorObjectSerializer\");\n\nconst MapObjectSerializer = require(\"./MapObjectSerializer\");\n\nconst NullPrototypeObjectSerializer = require(\"./NullPrototypeObjectSerializer\");\n\nconst PlainObjectSerializer = require(\"./PlainObjectSerializer\");\n\nconst RegExpObjectSerializer = require(\"./RegExpObjectSerializer\");\n\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\n\nconst SetObjectSerializer = require(\"./SetObjectSerializer\");\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\n/** @typedef {import(\"./types\").ComplexSerializableType} ComplexSerializableType */\n\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/** @typedef {new (...params: any[]) => any} Constructor */\n\n/*\n\nFormat:\n\nFile -> Section*\nSection -> ObjectSection | ReferenceSection | EscapeSection | OtherSection\n\nObjectSection -> ESCAPE (\n\tnumber:relativeOffset (number > 0) |\n\tstring:request (string|null):export\n) Section:value* ESCAPE ESCAPE_END_OBJECT\nReferenceSection -> ESCAPE number:relativeOffset (number < 0)\nEscapeSection -> ESCAPE ESCAPE_ESCAPE_VALUE (escaped value ESCAPE)\nEscapeSection -> ESCAPE ESCAPE_UNDEFINED (escaped value ESCAPE)\nOtherSection -> any (except ESCAPE)\n\nWhy using null as escape value?\nMultiple null values can merged by the BinaryMiddleware, which makes it very efficient\nTechnically any value can be used.\n\n*/\n\n/**\n * @typedef {Object} ObjectSerializerContext\n * @property {function(any): void} write\n */\n\n/**\n * @typedef {Object} ObjectDeserializerContext\n * @property {function(): any} read\n */\n\n/**\n * @typedef {Object} ObjectSerializer\n * @property {function(any, ObjectSerializerContext): void} serialize\n * @property {function(ObjectDeserializerContext): any} deserialize\n */\n\n\nconst setSetSize = (set, size) => {\n  let i = 0;\n\n  for (const item of set) {\n    if (i++ >= size) {\n      set.delete(item);\n    }\n  }\n};\n\nconst setMapSize = (map, size) => {\n  let i = 0;\n\n  for (const item of map.keys()) {\n    if (i++ >= size) {\n      map.delete(item);\n    }\n  }\n};\n/**\n * @param {Buffer} buffer buffer\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\n\n\nconst toHash = (buffer, hashFunction) => {\n  const hash = createHash(hashFunction);\n  hash.update(buffer);\n  return (\n    /** @type {string} */\n    hash.digest(\"latin1\")\n  );\n};\n\nconst ESCAPE = null;\nconst ESCAPE_ESCAPE_VALUE = null;\nconst ESCAPE_END_OBJECT = true;\nconst ESCAPE_UNDEFINED = false;\nconst CURRENT_VERSION = 2;\nconst serializers = new Map();\nconst serializerInversed = new Map();\nconst loadedRequests = new Set();\nconst NOT_SERIALIZABLE = {};\nconst jsTypes = new Map();\njsTypes.set(Object, new PlainObjectSerializer());\njsTypes.set(Array, new ArraySerializer());\njsTypes.set(null, new NullPrototypeObjectSerializer());\njsTypes.set(Map, new MapObjectSerializer());\njsTypes.set(Set, new SetObjectSerializer());\njsTypes.set(Date, new DateObjectSerializer());\njsTypes.set(RegExp, new RegExpObjectSerializer());\njsTypes.set(Error, new ErrorObjectSerializer(Error));\njsTypes.set(EvalError, new ErrorObjectSerializer(EvalError));\njsTypes.set(RangeError, new ErrorObjectSerializer(RangeError));\njsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError));\njsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError));\njsTypes.set(TypeError, new ErrorObjectSerializer(TypeError)); // If in a sandboxed environment (e. g. jest), this escapes the sandbox and registers\n// real Object and Array types to. These types may occur in the wild too, e. g. when\n// using Structured Clone in postMessage.\n\nif (exports.constructor !== Object) {\n  const Obj =\n  /** @type {typeof Object} */\n  exports.constructor;\n  const Fn =\n  /** @type {typeof Function} */\n  Obj.constructor;\n\n  for (const [type, config] of Array.from(jsTypes)) {\n    if (type) {\n      const Type = new Fn(`return ${type.name};`)();\n      jsTypes.set(Type, config);\n    }\n  }\n}\n\n{\n  let i = 1;\n\n  for (const [type, serializer] of jsTypes) {\n    serializers.set(type, {\n      request: \"\",\n      name: i++,\n      serializer\n    });\n  }\n}\n\nfor (const {\n  request,\n  name,\n  serializer\n} of serializers.values()) {\n  serializerInversed.set(`${request}/${name}`, serializer);\n}\n/** @type {Map<RegExp, (request: string) => boolean>} */\n\n\nconst loaders = new Map();\n/**\n * @typedef {ComplexSerializableType[]} DeserializedType\n * @typedef {PrimitiveSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\n\nclass ObjectMiddleware extends SerializerMiddleware {\n  /**\n   * @param {function(any): void} extendContext context extensions\n   * @param {string | Hash} hashFunction hash function to use\n   */\n  constructor(extendContext) {\n    let hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n    super();\n    this.extendContext = extendContext;\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {RegExp} regExp RegExp for which the request is tested\n   * @param {function(string): boolean} loader loader to load the request, returns true when successful\n   * @returns {void}\n   */\n\n\n  static registerLoader(regExp, loader) {\n    loaders.set(regExp, loader);\n  }\n  /**\n   * @param {Constructor} Constructor the constructor\n   * @param {string} request the request which will be required when deserializing\n   * @param {string} name the name to make multiple serializer unique when sharing a request\n   * @param {ObjectSerializer} serializer the serializer\n   * @returns {void}\n   */\n\n\n  static register(Constructor, request, name, serializer) {\n    const key = request + \"/\" + name;\n\n    if (serializers.has(Constructor)) {\n      throw new Error(`ObjectMiddleware.register: serializer for ${Constructor.name} is already registered`);\n    }\n\n    if (serializerInversed.has(key)) {\n      throw new Error(`ObjectMiddleware.register: serializer for ${key} is already registered`);\n    }\n\n    serializers.set(Constructor, {\n      request,\n      name,\n      serializer\n    });\n    serializerInversed.set(key, serializer);\n  }\n  /**\n   * @param {Constructor} Constructor the constructor\n   * @returns {void}\n   */\n\n\n  static registerNotSerializable(Constructor) {\n    if (serializers.has(Constructor)) {\n      throw new Error(`ObjectMiddleware.registerNotSerializable: serializer for ${Constructor.name} is already registered`);\n    }\n\n    serializers.set(Constructor, NOT_SERIALIZABLE);\n  }\n\n  static getSerializerFor(object) {\n    const proto = Object.getPrototypeOf(object);\n    let c;\n\n    if (proto === null) {\n      // Object created with Object.create(null)\n      c = null;\n    } else {\n      c = proto.constructor;\n\n      if (!c) {\n        throw new Error(\"Serialization of objects with prototype without valid constructor property not possible\");\n      }\n    }\n\n    const config = serializers.get(c);\n    if (!config) throw new Error(`No serializer registered for ${c.name}`);\n    if (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;\n    return config;\n  }\n\n  static getDeserializerFor(request, name) {\n    const key = request + \"/\" + name;\n    const serializer = serializerInversed.get(key);\n\n    if (serializer === undefined) {\n      throw new Error(`No deserializer registered for ${key}`);\n    }\n\n    return serializer;\n  }\n\n  static _getDeserializerForWithoutError(request, name) {\n    const key = request + \"/\" + name;\n    const serializer = serializerInversed.get(key);\n    return serializer;\n  }\n  /**\n   * @param {DeserializedType} data data\n   * @param {Object} context context object\n   * @returns {SerializedType|Promise<SerializedType>} serialized data\n   */\n\n\n  serialize(data, context) {\n    /** @type {any[]} */\n    let result = [CURRENT_VERSION];\n    let currentPos = 0;\n    let referenceable = new Map();\n\n    const addReferenceable = item => {\n      referenceable.set(item, currentPos++);\n    };\n\n    let bufferDedupeMap = new Map();\n\n    const dedupeBuffer = buf => {\n      const len = buf.length;\n      const entry = bufferDedupeMap.get(len);\n\n      if (entry === undefined) {\n        bufferDedupeMap.set(len, buf);\n        return buf;\n      }\n\n      if (Buffer.isBuffer(entry)) {\n        if (len < 32) {\n          if (buf.equals(entry)) {\n            return entry;\n          }\n\n          bufferDedupeMap.set(len, [entry, buf]);\n          return buf;\n        } else {\n          const hash = toHash(entry, this._hashFunction);\n          const newMap = new Map();\n          newMap.set(hash, entry);\n          bufferDedupeMap.set(len, newMap);\n          const hashBuf = toHash(buf, this._hashFunction);\n\n          if (hash === hashBuf) {\n            return entry;\n          }\n\n          return buf;\n        }\n      } else if (Array.isArray(entry)) {\n        if (entry.length < 16) {\n          for (const item of entry) {\n            if (buf.equals(item)) {\n              return item;\n            }\n          }\n\n          entry.push(buf);\n          return buf;\n        } else {\n          const newMap = new Map();\n          const hash = toHash(buf, this._hashFunction);\n          let found;\n\n          for (const item of entry) {\n            const itemHash = toHash(item, this._hashFunction);\n            newMap.set(itemHash, item);\n            if (found === undefined && itemHash === hash) found = item;\n          }\n\n          bufferDedupeMap.set(len, newMap);\n\n          if (found === undefined) {\n            newMap.set(hash, buf);\n            return buf;\n          } else {\n            return found;\n          }\n        }\n      } else {\n        const hash = toHash(buf, this._hashFunction);\n        const item = entry.get(hash);\n\n        if (item !== undefined) {\n          return item;\n        }\n\n        entry.set(hash, buf);\n        return buf;\n      }\n    };\n\n    let currentPosTypeLookup = 0;\n    let objectTypeLookup = new Map();\n    const cycleStack = new Set();\n\n    const stackToString = item => {\n      const arr = Array.from(cycleStack);\n      arr.push(item);\n      return arr.map(item => {\n        if (typeof item === \"string\") {\n          if (item.length > 100) {\n            return `String ${JSON.stringify(item.slice(0, 100)).slice(0, -1)}...\"`;\n          }\n\n          return `String ${JSON.stringify(item)}`;\n        }\n\n        try {\n          const {\n            request,\n            name\n          } = ObjectMiddleware.getSerializerFor(item);\n\n          if (request) {\n            return `${request}${name ? `.${name}` : \"\"}`;\n          }\n        } catch (e) {// ignore -> fallback\n        }\n\n        if (typeof item === \"object\" && item !== null) {\n          if (item.constructor) {\n            if (item.constructor === Object) return `Object { ${Object.keys(item).join(\", \")} }`;\n            if (item.constructor === Map) return `Map { ${item.size} items }`;\n            if (item.constructor === Array) return `Array { ${item.length} items }`;\n            if (item.constructor === Set) return `Set { ${item.size} items }`;\n            if (item.constructor === RegExp) return item.toString();\n            return `${item.constructor.name}`;\n          }\n\n          return `Object [null prototype] { ${Object.keys(item).join(\", \")} }`;\n        }\n\n        try {\n          return `${item}`;\n        } catch (e) {\n          return `(${e.message})`;\n        }\n      }).join(\" -> \");\n    };\n\n    let hasDebugInfoAttached;\n    let ctx = {\n      write(value, key) {\n        try {\n          process(value);\n        } catch (e) {\n          if (e !== NOT_SERIALIZABLE) {\n            if (hasDebugInfoAttached === undefined) hasDebugInfoAttached = new WeakSet();\n\n            if (!hasDebugInfoAttached.has(e)) {\n              e.message += `\\nwhile serializing ${stackToString(value)}`;\n              hasDebugInfoAttached.add(e);\n            }\n          }\n\n          throw e;\n        }\n      },\n\n      setCircularReference(ref) {\n        addReferenceable(ref);\n      },\n\n      snapshot() {\n        return {\n          length: result.length,\n          cycleStackSize: cycleStack.size,\n          referenceableSize: referenceable.size,\n          currentPos,\n          objectTypeLookupSize: objectTypeLookup.size,\n          currentPosTypeLookup\n        };\n      },\n\n      rollback(snapshot) {\n        result.length = snapshot.length;\n        setSetSize(cycleStack, snapshot.cycleStackSize);\n        setMapSize(referenceable, snapshot.referenceableSize);\n        currentPos = snapshot.currentPos;\n        setMapSize(objectTypeLookup, snapshot.objectTypeLookupSize);\n        currentPosTypeLookup = snapshot.currentPosTypeLookup;\n      },\n\n      ...context\n    };\n    this.extendContext(ctx);\n\n    const process = item => {\n      if (Buffer.isBuffer(item)) {\n        // check if we can emit a reference\n        const ref = referenceable.get(item);\n\n        if (ref !== undefined) {\n          result.push(ESCAPE, ref - currentPos);\n          return;\n        }\n\n        const alreadyUsedBuffer = dedupeBuffer(item);\n\n        if (alreadyUsedBuffer !== item) {\n          const ref = referenceable.get(alreadyUsedBuffer);\n\n          if (ref !== undefined) {\n            referenceable.set(item, ref);\n            result.push(ESCAPE, ref - currentPos);\n            return;\n          }\n\n          item = alreadyUsedBuffer;\n        }\n\n        addReferenceable(item);\n        result.push(item);\n      } else if (item === ESCAPE) {\n        result.push(ESCAPE, ESCAPE_ESCAPE_VALUE);\n      } else if (typeof item === \"object\" // We don't have to check for null as ESCAPE is null and this has been checked before\n      ) {\n        // check if we can emit a reference\n        const ref = referenceable.get(item);\n\n        if (ref !== undefined) {\n          result.push(ESCAPE, ref - currentPos);\n          return;\n        }\n\n        if (cycleStack.has(item)) {\n          throw new Error(`This is a circular references. To serialize circular references use 'setCircularReference' somewhere in the circle during serialize and deserialize.`);\n        }\n\n        const {\n          request,\n          name,\n          serializer\n        } = ObjectMiddleware.getSerializerFor(item);\n        const key = `${request}/${name}`;\n        const lastIndex = objectTypeLookup.get(key);\n\n        if (lastIndex === undefined) {\n          objectTypeLookup.set(key, currentPosTypeLookup++);\n          result.push(ESCAPE, request, name);\n        } else {\n          result.push(ESCAPE, currentPosTypeLookup - lastIndex);\n        }\n\n        cycleStack.add(item);\n\n        try {\n          serializer.serialize(item, ctx);\n        } finally {\n          cycleStack.delete(item);\n        }\n\n        result.push(ESCAPE, ESCAPE_END_OBJECT);\n        addReferenceable(item);\n      } else if (typeof item === \"string\") {\n        if (item.length > 1) {\n          // short strings are shorter when not emitting a reference (this saves 1 byte per empty string)\n          // check if we can emit a reference\n          const ref = referenceable.get(item);\n\n          if (ref !== undefined) {\n            result.push(ESCAPE, ref - currentPos);\n            return;\n          }\n\n          addReferenceable(item);\n        }\n\n        if (item.length > 102400 && context.logger) {\n          context.logger.warn(`Serializing big strings (${Math.round(item.length / 1024)}kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)`);\n        }\n\n        result.push(item);\n      } else if (typeof item === \"function\") {\n        if (!SerializerMiddleware.isLazy(item)) throw new Error(\"Unexpected function \" + item);\n        /** @type {SerializedType} */\n\n        const serializedData = SerializerMiddleware.getLazySerializedValue(item);\n\n        if (serializedData !== undefined) {\n          if (typeof serializedData === \"function\") {\n            result.push(serializedData);\n          } else {\n            throw new Error(\"Not implemented\");\n          }\n        } else if (SerializerMiddleware.isLazy(item, this)) {\n          throw new Error(\"Not implemented\");\n        } else {\n          const data = SerializerMiddleware.serializeLazy(item, data => this.serialize([data], context));\n          SerializerMiddleware.setLazySerializedValue(item, data);\n          result.push(data);\n        }\n      } else if (item === undefined) {\n        result.push(ESCAPE, ESCAPE_UNDEFINED);\n      } else {\n        result.push(item);\n      }\n    };\n\n    try {\n      for (const item of data) {\n        process(item);\n      }\n\n      return result;\n    } catch (e) {\n      if (e === NOT_SERIALIZABLE) return null;\n      throw e;\n    } finally {\n      // Get rid of these references to avoid leaking memory\n      // This happens because the optimized code v8 generates\n      // is optimized for our \"ctx.write\" method so it will reference\n      // it from e. g. Dependency.prototype.serialize -(IC)-> ctx.write\n      data = result = referenceable = bufferDedupeMap = objectTypeLookup = ctx = undefined;\n    }\n  }\n  /**\n   * @param {SerializedType} data data\n   * @param {Object} context context object\n   * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n   */\n\n\n  deserialize(data, context) {\n    let currentDataPos = 0;\n\n    const read = () => {\n      if (currentDataPos >= data.length) throw new Error(\"Unexpected end of stream\");\n      return data[currentDataPos++];\n    };\n\n    if (read() !== CURRENT_VERSION) throw new Error(\"Version mismatch, serializer changed\");\n    let currentPos = 0;\n    let referenceable = [];\n\n    const addReferenceable = item => {\n      referenceable.push(item);\n      currentPos++;\n    };\n\n    let currentPosTypeLookup = 0;\n    let objectTypeLookup = [];\n    let result = [];\n    let ctx = {\n      read() {\n        return decodeValue();\n      },\n\n      setCircularReference(ref) {\n        addReferenceable(ref);\n      },\n\n      ...context\n    };\n    this.extendContext(ctx);\n\n    const decodeValue = () => {\n      const item = read();\n\n      if (item === ESCAPE) {\n        const nextItem = read();\n\n        if (nextItem === ESCAPE_ESCAPE_VALUE) {\n          return ESCAPE;\n        } else if (nextItem === ESCAPE_UNDEFINED) {\n          return undefined;\n        } else if (nextItem === ESCAPE_END_OBJECT) {\n          throw new Error(`Unexpected end of object at position ${currentDataPos - 1}`);\n        } else {\n          const request = nextItem;\n          let serializer;\n\n          if (typeof request === \"number\") {\n            if (request < 0) {\n              // relative reference\n              return referenceable[currentPos + request];\n            }\n\n            serializer = objectTypeLookup[currentPosTypeLookup - request];\n          } else {\n            if (typeof request !== \"string\") {\n              throw new Error(`Unexpected type (${typeof request}) of request ` + `at position ${currentDataPos - 1}`);\n            }\n\n            const name = read();\n            serializer = ObjectMiddleware._getDeserializerForWithoutError(request, name);\n\n            if (serializer === undefined) {\n              if (request && !loadedRequests.has(request)) {\n                let loaded = false;\n\n                for (const [regExp, loader] of loaders) {\n                  if (regExp.test(request)) {\n                    if (loader(request)) {\n                      loaded = true;\n                      break;\n                    }\n                  }\n                }\n\n                if (!loaded) {\n                  require(request);\n                }\n\n                loadedRequests.add(request);\n              }\n\n              serializer = ObjectMiddleware.getDeserializerFor(request, name);\n            }\n\n            objectTypeLookup.push(serializer);\n            currentPosTypeLookup++;\n          }\n\n          try {\n            const item = serializer.deserialize(ctx);\n            const end1 = read();\n\n            if (end1 !== ESCAPE) {\n              throw new Error(\"Expected end of object\");\n            }\n\n            const end2 = read();\n\n            if (end2 !== ESCAPE_END_OBJECT) {\n              throw new Error(\"Expected end of object\");\n            }\n\n            addReferenceable(item);\n            return item;\n          } catch (err) {\n            // As this is only for error handling, we omit creating a Map for\n            // faster access to this information, as this would affect performance\n            // in the good case\n            let serializerEntry;\n\n            for (const entry of serializers) {\n              if (entry[1].serializer === serializer) {\n                serializerEntry = entry;\n                break;\n              }\n            }\n\n            const name = !serializerEntry ? \"unknown\" : !serializerEntry[1].request ? serializerEntry[0].name : serializerEntry[1].name ? `${serializerEntry[1].request} ${serializerEntry[1].name}` : serializerEntry[1].request;\n            err.message += `\\n(during deserialization of ${name})`;\n            throw err;\n          }\n        }\n      } else if (typeof item === \"string\") {\n        if (item.length > 1) {\n          addReferenceable(item);\n        }\n\n        return item;\n      } else if (Buffer.isBuffer(item)) {\n        addReferenceable(item);\n        return item;\n      } else if (typeof item === \"function\") {\n        return SerializerMiddleware.deserializeLazy(item, data => this.deserialize(data, context)[0]);\n      } else {\n        return item;\n      }\n    };\n\n    try {\n      while (currentDataPos < data.length) {\n        result.push(decodeValue());\n      }\n\n      return result;\n    } finally {\n      // Get rid of these references to avoid leaking memory\n      // This happens because the optimized code v8 generates\n      // is optimized for our \"ctx.read\" method so it will reference\n      // it from e. g. Dependency.prototype.deserialize -(IC)-> ctx.read\n      result = referenceable = data = objectTypeLookup = ctx = undefined;\n    }\n  }\n\n}\n\nmodule.exports = ObjectMiddleware;\nmodule.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;","map":{"version":3,"names":["createHash","require","ArraySerializer","DateObjectSerializer","ErrorObjectSerializer","MapObjectSerializer","NullPrototypeObjectSerializer","PlainObjectSerializer","RegExpObjectSerializer","SerializerMiddleware","SetObjectSerializer","setSetSize","set","size","i","item","delete","setMapSize","map","keys","toHash","buffer","hashFunction","hash","update","digest","ESCAPE","ESCAPE_ESCAPE_VALUE","ESCAPE_END_OBJECT","ESCAPE_UNDEFINED","CURRENT_VERSION","serializers","Map","serializerInversed","loadedRequests","Set","NOT_SERIALIZABLE","jsTypes","Object","Array","Date","RegExp","Error","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","exports","constructor","Obj","Fn","type","config","from","Type","name","serializer","request","values","loaders","ObjectMiddleware","extendContext","_hashFunction","registerLoader","regExp","loader","register","Constructor","key","has","registerNotSerializable","getSerializerFor","object","proto","getPrototypeOf","c","get","getDeserializerFor","undefined","_getDeserializerForWithoutError","serialize","data","context","result","currentPos","referenceable","addReferenceable","bufferDedupeMap","dedupeBuffer","buf","len","length","entry","Buffer","isBuffer","equals","newMap","hashBuf","isArray","push","found","itemHash","currentPosTypeLookup","objectTypeLookup","cycleStack","stackToString","arr","JSON","stringify","slice","e","join","toString","message","hasDebugInfoAttached","ctx","write","value","process","WeakSet","add","setCircularReference","ref","snapshot","cycleStackSize","referenceableSize","objectTypeLookupSize","rollback","alreadyUsedBuffer","lastIndex","logger","warn","Math","round","isLazy","serializedData","getLazySerializedValue","serializeLazy","setLazySerializedValue","deserialize","currentDataPos","read","decodeValue","nextItem","loaded","test","end1","end2","err","serializerEntry","deserializeLazy","module"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/serialization/ObjectMiddleware.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\nconst ArraySerializer = require(\"./ArraySerializer\");\nconst DateObjectSerializer = require(\"./DateObjectSerializer\");\nconst ErrorObjectSerializer = require(\"./ErrorObjectSerializer\");\nconst MapObjectSerializer = require(\"./MapObjectSerializer\");\nconst NullPrototypeObjectSerializer = require(\"./NullPrototypeObjectSerializer\");\nconst PlainObjectSerializer = require(\"./PlainObjectSerializer\");\nconst RegExpObjectSerializer = require(\"./RegExpObjectSerializer\");\nconst SerializerMiddleware = require(\"./SerializerMiddleware\");\nconst SetObjectSerializer = require(\"./SetObjectSerializer\");\n\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"./types\").ComplexSerializableType} ComplexSerializableType */\n/** @typedef {import(\"./types\").PrimitiveSerializableType} PrimitiveSerializableType */\n\n/** @typedef {new (...params: any[]) => any} Constructor */\n\n/*\n\nFormat:\n\nFile -> Section*\nSection -> ObjectSection | ReferenceSection | EscapeSection | OtherSection\n\nObjectSection -> ESCAPE (\n\tnumber:relativeOffset (number > 0) |\n\tstring:request (string|null):export\n) Section:value* ESCAPE ESCAPE_END_OBJECT\nReferenceSection -> ESCAPE number:relativeOffset (number < 0)\nEscapeSection -> ESCAPE ESCAPE_ESCAPE_VALUE (escaped value ESCAPE)\nEscapeSection -> ESCAPE ESCAPE_UNDEFINED (escaped value ESCAPE)\nOtherSection -> any (except ESCAPE)\n\nWhy using null as escape value?\nMultiple null values can merged by the BinaryMiddleware, which makes it very efficient\nTechnically any value can be used.\n\n*/\n\n/**\n * @typedef {Object} ObjectSerializerContext\n * @property {function(any): void} write\n */\n\n/**\n * @typedef {Object} ObjectDeserializerContext\n * @property {function(): any} read\n */\n\n/**\n * @typedef {Object} ObjectSerializer\n * @property {function(any, ObjectSerializerContext): void} serialize\n * @property {function(ObjectDeserializerContext): any} deserialize\n */\n\nconst setSetSize = (set, size) => {\n\tlet i = 0;\n\tfor (const item of set) {\n\t\tif (i++ >= size) {\n\t\t\tset.delete(item);\n\t\t}\n\t}\n};\n\nconst setMapSize = (map, size) => {\n\tlet i = 0;\n\tfor (const item of map.keys()) {\n\t\tif (i++ >= size) {\n\t\t\tmap.delete(item);\n\t\t}\n\t}\n};\n\n/**\n * @param {Buffer} buffer buffer\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst toHash = (buffer, hashFunction) => {\n\tconst hash = createHash(hashFunction);\n\thash.update(buffer);\n\treturn /** @type {string} */ (hash.digest(\"latin1\"));\n};\n\nconst ESCAPE = null;\nconst ESCAPE_ESCAPE_VALUE = null;\nconst ESCAPE_END_OBJECT = true;\nconst ESCAPE_UNDEFINED = false;\n\nconst CURRENT_VERSION = 2;\n\nconst serializers = new Map();\nconst serializerInversed = new Map();\n\nconst loadedRequests = new Set();\n\nconst NOT_SERIALIZABLE = {};\n\nconst jsTypes = new Map();\njsTypes.set(Object, new PlainObjectSerializer());\njsTypes.set(Array, new ArraySerializer());\njsTypes.set(null, new NullPrototypeObjectSerializer());\njsTypes.set(Map, new MapObjectSerializer());\njsTypes.set(Set, new SetObjectSerializer());\njsTypes.set(Date, new DateObjectSerializer());\njsTypes.set(RegExp, new RegExpObjectSerializer());\njsTypes.set(Error, new ErrorObjectSerializer(Error));\njsTypes.set(EvalError, new ErrorObjectSerializer(EvalError));\njsTypes.set(RangeError, new ErrorObjectSerializer(RangeError));\njsTypes.set(ReferenceError, new ErrorObjectSerializer(ReferenceError));\njsTypes.set(SyntaxError, new ErrorObjectSerializer(SyntaxError));\njsTypes.set(TypeError, new ErrorObjectSerializer(TypeError));\n\n// If in a sandboxed environment (e. g. jest), this escapes the sandbox and registers\n// real Object and Array types to. These types may occur in the wild too, e. g. when\n// using Structured Clone in postMessage.\nif (exports.constructor !== Object) {\n\tconst Obj = /** @type {typeof Object} */ (exports.constructor);\n\tconst Fn = /** @type {typeof Function} */ (Obj.constructor);\n\tfor (const [type, config] of Array.from(jsTypes)) {\n\t\tif (type) {\n\t\t\tconst Type = new Fn(`return ${type.name};`)();\n\t\t\tjsTypes.set(Type, config);\n\t\t}\n\t}\n}\n\n{\n\tlet i = 1;\n\tfor (const [type, serializer] of jsTypes) {\n\t\tserializers.set(type, {\n\t\t\trequest: \"\",\n\t\t\tname: i++,\n\t\t\tserializer\n\t\t});\n\t}\n}\n\nfor (const { request, name, serializer } of serializers.values()) {\n\tserializerInversed.set(`${request}/${name}`, serializer);\n}\n\n/** @type {Map<RegExp, (request: string) => boolean>} */\nconst loaders = new Map();\n\n/**\n * @typedef {ComplexSerializableType[]} DeserializedType\n * @typedef {PrimitiveSerializableType[]} SerializedType\n * @extends {SerializerMiddleware<DeserializedType, SerializedType>}\n */\nclass ObjectMiddleware extends SerializerMiddleware {\n\t/**\n\t * @param {function(any): void} extendContext context extensions\n\t * @param {string | Hash} hashFunction hash function to use\n\t */\n\tconstructor(extendContext, hashFunction = \"md4\") {\n\t\tsuper();\n\t\tthis.extendContext = extendContext;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\t/**\n\t * @param {RegExp} regExp RegExp for which the request is tested\n\t * @param {function(string): boolean} loader loader to load the request, returns true when successful\n\t * @returns {void}\n\t */\n\tstatic registerLoader(regExp, loader) {\n\t\tloaders.set(regExp, loader);\n\t}\n\n\t/**\n\t * @param {Constructor} Constructor the constructor\n\t * @param {string} request the request which will be required when deserializing\n\t * @param {string} name the name to make multiple serializer unique when sharing a request\n\t * @param {ObjectSerializer} serializer the serializer\n\t * @returns {void}\n\t */\n\tstatic register(Constructor, request, name, serializer) {\n\t\tconst key = request + \"/\" + name;\n\n\t\tif (serializers.has(Constructor)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.register: serializer for ${Constructor.name} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tif (serializerInversed.has(key)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.register: serializer for ${key} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tserializers.set(Constructor, {\n\t\t\trequest,\n\t\t\tname,\n\t\t\tserializer\n\t\t});\n\n\t\tserializerInversed.set(key, serializer);\n\t}\n\n\t/**\n\t * @param {Constructor} Constructor the constructor\n\t * @returns {void}\n\t */\n\tstatic registerNotSerializable(Constructor) {\n\t\tif (serializers.has(Constructor)) {\n\t\t\tthrow new Error(\n\t\t\t\t`ObjectMiddleware.registerNotSerializable: serializer for ${Constructor.name} is already registered`\n\t\t\t);\n\t\t}\n\n\t\tserializers.set(Constructor, NOT_SERIALIZABLE);\n\t}\n\n\tstatic getSerializerFor(object) {\n\t\tconst proto = Object.getPrototypeOf(object);\n\t\tlet c;\n\t\tif (proto === null) {\n\t\t\t// Object created with Object.create(null)\n\t\t\tc = null;\n\t\t} else {\n\t\t\tc = proto.constructor;\n\t\t\tif (!c) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"Serialization of objects with prototype without valid constructor property not possible\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tconst config = serializers.get(c);\n\n\t\tif (!config) throw new Error(`No serializer registered for ${c.name}`);\n\t\tif (config === NOT_SERIALIZABLE) throw NOT_SERIALIZABLE;\n\n\t\treturn config;\n\t}\n\n\tstatic getDeserializerFor(request, name) {\n\t\tconst key = request + \"/\" + name;\n\t\tconst serializer = serializerInversed.get(key);\n\n\t\tif (serializer === undefined) {\n\t\t\tthrow new Error(`No deserializer registered for ${key}`);\n\t\t}\n\n\t\treturn serializer;\n\t}\n\n\tstatic _getDeserializerForWithoutError(request, name) {\n\t\tconst key = request + \"/\" + name;\n\t\tconst serializer = serializerInversed.get(key);\n\t\treturn serializer;\n\t}\n\n\t/**\n\t * @param {DeserializedType} data data\n\t * @param {Object} context context object\n\t * @returns {SerializedType|Promise<SerializedType>} serialized data\n\t */\n\tserialize(data, context) {\n\t\t/** @type {any[]} */\n\t\tlet result = [CURRENT_VERSION];\n\t\tlet currentPos = 0;\n\t\tlet referenceable = new Map();\n\t\tconst addReferenceable = item => {\n\t\t\treferenceable.set(item, currentPos++);\n\t\t};\n\t\tlet bufferDedupeMap = new Map();\n\t\tconst dedupeBuffer = buf => {\n\t\t\tconst len = buf.length;\n\t\t\tconst entry = bufferDedupeMap.get(len);\n\t\t\tif (entry === undefined) {\n\t\t\t\tbufferDedupeMap.set(len, buf);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t\tif (Buffer.isBuffer(entry)) {\n\t\t\t\tif (len < 32) {\n\t\t\t\t\tif (buf.equals(entry)) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t\tbufferDedupeMap.set(len, [entry, buf]);\n\t\t\t\t\treturn buf;\n\t\t\t\t} else {\n\t\t\t\t\tconst hash = toHash(entry, this._hashFunction);\n\t\t\t\t\tconst newMap = new Map();\n\t\t\t\t\tnewMap.set(hash, entry);\n\t\t\t\t\tbufferDedupeMap.set(len, newMap);\n\t\t\t\t\tconst hashBuf = toHash(buf, this._hashFunction);\n\t\t\t\t\tif (hash === hashBuf) {\n\t\t\t\t\t\treturn entry;\n\t\t\t\t\t}\n\t\t\t\t\treturn buf;\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(entry)) {\n\t\t\t\tif (entry.length < 16) {\n\t\t\t\t\tfor (const item of entry) {\n\t\t\t\t\t\tif (buf.equals(item)) {\n\t\t\t\t\t\t\treturn item;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tentry.push(buf);\n\t\t\t\t\treturn buf;\n\t\t\t\t} else {\n\t\t\t\t\tconst newMap = new Map();\n\t\t\t\t\tconst hash = toHash(buf, this._hashFunction);\n\t\t\t\t\tlet found;\n\t\t\t\t\tfor (const item of entry) {\n\t\t\t\t\t\tconst itemHash = toHash(item, this._hashFunction);\n\t\t\t\t\t\tnewMap.set(itemHash, item);\n\t\t\t\t\t\tif (found === undefined && itemHash === hash) found = item;\n\t\t\t\t\t}\n\t\t\t\t\tbufferDedupeMap.set(len, newMap);\n\t\t\t\t\tif (found === undefined) {\n\t\t\t\t\t\tnewMap.set(hash, buf);\n\t\t\t\t\t\treturn buf;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn found;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst hash = toHash(buf, this._hashFunction);\n\t\t\t\tconst item = entry.get(hash);\n\t\t\t\tif (item !== undefined) {\n\t\t\t\t\treturn item;\n\t\t\t\t}\n\t\t\t\tentry.set(hash, buf);\n\t\t\t\treturn buf;\n\t\t\t}\n\t\t};\n\t\tlet currentPosTypeLookup = 0;\n\t\tlet objectTypeLookup = new Map();\n\t\tconst cycleStack = new Set();\n\t\tconst stackToString = item => {\n\t\t\tconst arr = Array.from(cycleStack);\n\t\t\tarr.push(item);\n\t\t\treturn arr\n\t\t\t\t.map(item => {\n\t\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\t\tif (item.length > 100) {\n\t\t\t\t\t\t\treturn `String ${JSON.stringify(item.slice(0, 100)).slice(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t-1\n\t\t\t\t\t\t\t)}...\"`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `String ${JSON.stringify(item)}`;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst { request, name } = ObjectMiddleware.getSerializerFor(item);\n\t\t\t\t\t\tif (request) {\n\t\t\t\t\t\t\treturn `${request}${name ? `.${name}` : \"\"}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// ignore -> fallback\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof item === \"object\" && item !== null) {\n\t\t\t\t\t\tif (item.constructor) {\n\t\t\t\t\t\t\tif (item.constructor === Object)\n\t\t\t\t\t\t\t\treturn `Object { ${Object.keys(item).join(\", \")} }`;\n\t\t\t\t\t\t\tif (item.constructor === Map) return `Map { ${item.size} items }`;\n\t\t\t\t\t\t\tif (item.constructor === Array)\n\t\t\t\t\t\t\t\treturn `Array { ${item.length} items }`;\n\t\t\t\t\t\t\tif (item.constructor === Set) return `Set { ${item.size} items }`;\n\t\t\t\t\t\t\tif (item.constructor === RegExp) return item.toString();\n\t\t\t\t\t\t\treturn `${item.constructor.name}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `Object [null prototype] { ${Object.keys(item).join(\n\t\t\t\t\t\t\t\", \"\n\t\t\t\t\t\t)} }`;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn `${item}`;\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn `(${e.message})`;\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t.join(\" -> \");\n\t\t};\n\t\tlet hasDebugInfoAttached;\n\t\tlet ctx = {\n\t\t\twrite(value, key) {\n\t\t\t\ttry {\n\t\t\t\t\tprocess(value);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e !== NOT_SERIALIZABLE) {\n\t\t\t\t\t\tif (hasDebugInfoAttached === undefined)\n\t\t\t\t\t\t\thasDebugInfoAttached = new WeakSet();\n\t\t\t\t\t\tif (!hasDebugInfoAttached.has(e)) {\n\t\t\t\t\t\t\te.message += `\\nwhile serializing ${stackToString(value)}`;\n\t\t\t\t\t\t\thasDebugInfoAttached.add(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t},\n\t\t\tsetCircularReference(ref) {\n\t\t\t\taddReferenceable(ref);\n\t\t\t},\n\t\t\tsnapshot() {\n\t\t\t\treturn {\n\t\t\t\t\tlength: result.length,\n\t\t\t\t\tcycleStackSize: cycleStack.size,\n\t\t\t\t\treferenceableSize: referenceable.size,\n\t\t\t\t\tcurrentPos,\n\t\t\t\t\tobjectTypeLookupSize: objectTypeLookup.size,\n\t\t\t\t\tcurrentPosTypeLookup\n\t\t\t\t};\n\t\t\t},\n\t\t\trollback(snapshot) {\n\t\t\t\tresult.length = snapshot.length;\n\t\t\t\tsetSetSize(cycleStack, snapshot.cycleStackSize);\n\t\t\t\tsetMapSize(referenceable, snapshot.referenceableSize);\n\t\t\t\tcurrentPos = snapshot.currentPos;\n\t\t\t\tsetMapSize(objectTypeLookup, snapshot.objectTypeLookupSize);\n\t\t\t\tcurrentPosTypeLookup = snapshot.currentPosTypeLookup;\n\t\t\t},\n\t\t\t...context\n\t\t};\n\t\tthis.extendContext(ctx);\n\t\tconst process = item => {\n\t\t\tif (Buffer.isBuffer(item)) {\n\t\t\t\t// check if we can emit a reference\n\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst alreadyUsedBuffer = dedupeBuffer(item);\n\t\t\t\tif (alreadyUsedBuffer !== item) {\n\t\t\t\t\tconst ref = referenceable.get(alreadyUsedBuffer);\n\t\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\t\treferenceable.set(item, ref);\n\t\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\titem = alreadyUsedBuffer;\n\t\t\t\t}\n\t\t\t\taddReferenceable(item);\n\n\t\t\t\tresult.push(item);\n\t\t\t} else if (item === ESCAPE) {\n\t\t\t\tresult.push(ESCAPE, ESCAPE_ESCAPE_VALUE);\n\t\t\t} else if (\n\t\t\t\ttypeof item === \"object\"\n\t\t\t\t// We don't have to check for null as ESCAPE is null and this has been checked before\n\t\t\t) {\n\t\t\t\t// check if we can emit a reference\n\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (cycleStack.has(item)) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`This is a circular references. To serialize circular references use 'setCircularReference' somewhere in the circle during serialize and deserialize.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst { request, name, serializer } =\n\t\t\t\t\tObjectMiddleware.getSerializerFor(item);\n\t\t\t\tconst key = `${request}/${name}`;\n\t\t\t\tconst lastIndex = objectTypeLookup.get(key);\n\n\t\t\t\tif (lastIndex === undefined) {\n\t\t\t\t\tobjectTypeLookup.set(key, currentPosTypeLookup++);\n\n\t\t\t\t\tresult.push(ESCAPE, request, name);\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(ESCAPE, currentPosTypeLookup - lastIndex);\n\t\t\t\t}\n\n\t\t\t\tcycleStack.add(item);\n\n\t\t\t\ttry {\n\t\t\t\t\tserializer.serialize(item, ctx);\n\t\t\t\t} finally {\n\t\t\t\t\tcycleStack.delete(item);\n\t\t\t\t}\n\n\t\t\t\tresult.push(ESCAPE, ESCAPE_END_OBJECT);\n\n\t\t\t\taddReferenceable(item);\n\t\t\t} else if (typeof item === \"string\") {\n\t\t\t\tif (item.length > 1) {\n\t\t\t\t\t// short strings are shorter when not emitting a reference (this saves 1 byte per empty string)\n\t\t\t\t\t// check if we can emit a reference\n\t\t\t\t\tconst ref = referenceable.get(item);\n\t\t\t\t\tif (ref !== undefined) {\n\t\t\t\t\t\tresult.push(ESCAPE, ref - currentPos);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\taddReferenceable(item);\n\t\t\t\t}\n\n\t\t\t\tif (item.length > 102400 && context.logger) {\n\t\t\t\t\tcontext.logger.warn(\n\t\t\t\t\t\t`Serializing big strings (${Math.round(\n\t\t\t\t\t\t\titem.length / 1024\n\t\t\t\t\t\t)}kiB) impacts deserialization performance (consider using Buffer instead and decode when needed)`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tresult.push(item);\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\tif (!SerializerMiddleware.isLazy(item))\n\t\t\t\t\tthrow new Error(\"Unexpected function \" + item);\n\t\t\t\t/** @type {SerializedType} */\n\t\t\t\tconst serializedData =\n\t\t\t\t\tSerializerMiddleware.getLazySerializedValue(item);\n\t\t\t\tif (serializedData !== undefined) {\n\t\t\t\t\tif (typeof serializedData === \"function\") {\n\t\t\t\t\t\tresult.push(serializedData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Not implemented\");\n\t\t\t\t\t}\n\t\t\t\t} else if (SerializerMiddleware.isLazy(item, this)) {\n\t\t\t\t\tthrow new Error(\"Not implemented\");\n\t\t\t\t} else {\n\t\t\t\t\tconst data = SerializerMiddleware.serializeLazy(item, data =>\n\t\t\t\t\t\tthis.serialize([data], context)\n\t\t\t\t\t);\n\t\t\t\t\tSerializerMiddleware.setLazySerializedValue(item, data);\n\t\t\t\t\tresult.push(data);\n\t\t\t\t}\n\t\t\t} else if (item === undefined) {\n\t\t\t\tresult.push(ESCAPE, ESCAPE_UNDEFINED);\n\t\t\t} else {\n\t\t\t\tresult.push(item);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\tfor (const item of data) {\n\t\t\t\tprocess(item);\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\tif (e === NOT_SERIALIZABLE) return null;\n\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\t// Get rid of these references to avoid leaking memory\n\t\t\t// This happens because the optimized code v8 generates\n\t\t\t// is optimized for our \"ctx.write\" method so it will reference\n\t\t\t// it from e. g. Dependency.prototype.serialize -(IC)-> ctx.write\n\t\t\tdata =\n\t\t\t\tresult =\n\t\t\t\treferenceable =\n\t\t\t\tbufferDedupeMap =\n\t\t\t\tobjectTypeLookup =\n\t\t\t\tctx =\n\t\t\t\t\tundefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {SerializedType} data data\n\t * @param {Object} context context object\n\t * @returns {DeserializedType|Promise<DeserializedType>} deserialized data\n\t */\n\tdeserialize(data, context) {\n\t\tlet currentDataPos = 0;\n\t\tconst read = () => {\n\t\t\tif (currentDataPos >= data.length)\n\t\t\t\tthrow new Error(\"Unexpected end of stream\");\n\n\t\t\treturn data[currentDataPos++];\n\t\t};\n\n\t\tif (read() !== CURRENT_VERSION)\n\t\t\tthrow new Error(\"Version mismatch, serializer changed\");\n\n\t\tlet currentPos = 0;\n\t\tlet referenceable = [];\n\t\tconst addReferenceable = item => {\n\t\t\treferenceable.push(item);\n\t\t\tcurrentPos++;\n\t\t};\n\t\tlet currentPosTypeLookup = 0;\n\t\tlet objectTypeLookup = [];\n\t\tlet result = [];\n\t\tlet ctx = {\n\t\t\tread() {\n\t\t\t\treturn decodeValue();\n\t\t\t},\n\t\t\tsetCircularReference(ref) {\n\t\t\t\taddReferenceable(ref);\n\t\t\t},\n\t\t\t...context\n\t\t};\n\t\tthis.extendContext(ctx);\n\t\tconst decodeValue = () => {\n\t\t\tconst item = read();\n\n\t\t\tif (item === ESCAPE) {\n\t\t\t\tconst nextItem = read();\n\n\t\t\t\tif (nextItem === ESCAPE_ESCAPE_VALUE) {\n\t\t\t\t\treturn ESCAPE;\n\t\t\t\t} else if (nextItem === ESCAPE_UNDEFINED) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t} else if (nextItem === ESCAPE_END_OBJECT) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unexpected end of object at position ${currentDataPos - 1}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tconst request = nextItem;\n\t\t\t\t\tlet serializer;\n\n\t\t\t\t\tif (typeof request === \"number\") {\n\t\t\t\t\t\tif (request < 0) {\n\t\t\t\t\t\t\t// relative reference\n\t\t\t\t\t\t\treturn referenceable[currentPos + request];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tserializer = objectTypeLookup[currentPosTypeLookup - request];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof request !== \"string\") {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unexpected type (${typeof request}) of request ` +\n\t\t\t\t\t\t\t\t\t`at position ${currentDataPos - 1}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst name = read();\n\n\t\t\t\t\t\tserializer = ObjectMiddleware._getDeserializerForWithoutError(\n\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (serializer === undefined) {\n\t\t\t\t\t\t\tif (request && !loadedRequests.has(request)) {\n\t\t\t\t\t\t\t\tlet loaded = false;\n\t\t\t\t\t\t\t\tfor (const [regExp, loader] of loaders) {\n\t\t\t\t\t\t\t\t\tif (regExp.test(request)) {\n\t\t\t\t\t\t\t\t\t\tif (loader(request)) {\n\t\t\t\t\t\t\t\t\t\t\tloaded = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!loaded) {\n\t\t\t\t\t\t\t\t\trequire(request);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tloadedRequests.add(request);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tserializer = ObjectMiddleware.getDeserializerFor(request, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobjectTypeLookup.push(serializer);\n\t\t\t\t\t\tcurrentPosTypeLookup++;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst item = serializer.deserialize(ctx);\n\t\t\t\t\t\tconst end1 = read();\n\n\t\t\t\t\t\tif (end1 !== ESCAPE) {\n\t\t\t\t\t\t\tthrow new Error(\"Expected end of object\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst end2 = read();\n\n\t\t\t\t\t\tif (end2 !== ESCAPE_END_OBJECT) {\n\t\t\t\t\t\t\tthrow new Error(\"Expected end of object\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\taddReferenceable(item);\n\n\t\t\t\t\t\treturn item;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t// As this is only for error handling, we omit creating a Map for\n\t\t\t\t\t\t// faster access to this information, as this would affect performance\n\t\t\t\t\t\t// in the good case\n\t\t\t\t\t\tlet serializerEntry;\n\t\t\t\t\t\tfor (const entry of serializers) {\n\t\t\t\t\t\t\tif (entry[1].serializer === serializer) {\n\t\t\t\t\t\t\t\tserializerEntry = entry;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst name = !serializerEntry\n\t\t\t\t\t\t\t? \"unknown\"\n\t\t\t\t\t\t\t: !serializerEntry[1].request\n\t\t\t\t\t\t\t? serializerEntry[0].name\n\t\t\t\t\t\t\t: serializerEntry[1].name\n\t\t\t\t\t\t\t? `${serializerEntry[1].request} ${serializerEntry[1].name}`\n\t\t\t\t\t\t\t: serializerEntry[1].request;\n\t\t\t\t\t\terr.message += `\\n(during deserialization of ${name})`;\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (typeof item === \"string\") {\n\t\t\t\tif (item.length > 1) {\n\t\t\t\t\taddReferenceable(item);\n\t\t\t\t}\n\n\t\t\t\treturn item;\n\t\t\t} else if (Buffer.isBuffer(item)) {\n\t\t\t\taddReferenceable(item);\n\n\t\t\t\treturn item;\n\t\t\t} else if (typeof item === \"function\") {\n\t\t\t\treturn SerializerMiddleware.deserializeLazy(\n\t\t\t\t\titem,\n\t\t\t\t\tdata => this.deserialize(data, context)[0]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\treturn item;\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\twhile (currentDataPos < data.length) {\n\t\t\t\tresult.push(decodeValue());\n\t\t\t}\n\t\t\treturn result;\n\t\t} finally {\n\t\t\t// Get rid of these references to avoid leaking memory\n\t\t\t// This happens because the optimized code v8 generates\n\t\t\t// is optimized for our \"ctx.read\" method so it will reference\n\t\t\t// it from e. g. Dependency.prototype.deserialize -(IC)-> ctx.read\n\t\t\tresult = referenceable = data = objectTypeLookup = ctx = undefined;\n\t\t}\n\t}\n}\n\nmodule.exports = ObjectMiddleware;\nmodule.exports.NOT_SERIALIZABLE = NOT_SERIALIZABLE;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}