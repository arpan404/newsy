{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst Entrypoint = require(\"./Entrypoint\");\n\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\n\nconst {\n  first\n} = require(\"./util/SetHelpers\");\n\nconst SortableSet = require(\"./util/SortableSet\");\n\nconst {\n  compareModulesById,\n  compareIterables,\n  compareModulesByIdentifier,\n  concatComparators,\n  compareSelect,\n  compareIds\n} = require(\"./util/comparators\");\n\nconst createHash = require(\"./util/createHash\");\n\nconst findGraphRoots = require(\"./util/findGraphRoots\");\n\nconst {\n  RuntimeSpecMap,\n  RuntimeSpecSet,\n  runtimeToString,\n  mergeRuntime,\n  forEachRuntime\n} = require(\"./util/runtime\");\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\n\n\nconst EMPTY_SET = new Set();\nconst ZERO_BIG_INT = BigInt(0);\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\n\nclass ModuleHashInfo {\n  constructor(hash, renderedHash) {\n    this.hash = hash;\n    this.renderedHash = renderedHash;\n  }\n\n}\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\n\n\nconst getArray = set => {\n  return Array.from(set);\n};\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\n\n\nconst getModuleRuntimes = chunks => {\n  const runtimes = new RuntimeSpecSet();\n\n  for (const chunk of chunks) {\n    runtimes.add(chunk.runtime);\n  }\n\n  return runtimes;\n};\n/**\n * @param {WeakMap<Module, Set<string>> | undefined} sourceTypesByModule sourceTypesByModule\n * @returns {function (SortableSet<Module>): Map<string, SortableSet<Module>>} modules by source type\n */\n\n\nconst modulesBySourceType = sourceTypesByModule => set => {\n  /** @type {Map<string, SortableSet<Module>>} */\n  const map = new Map();\n\n  for (const module of set) {\n    const sourceTypes = sourceTypesByModule && sourceTypesByModule.get(module) || module.getSourceTypes();\n\n    for (const sourceType of sourceTypes) {\n      let innerSet = map.get(sourceType);\n\n      if (innerSet === undefined) {\n        innerSet = new SortableSet();\n        map.set(sourceType, innerSet);\n      }\n\n      innerSet.add(module);\n    }\n  }\n\n  for (const [key, innerSet] of map) {\n    // When all modules have the source type, we reuse the original SortableSet\n    // to benefit from the shared cache (especially for sorting)\n    if (innerSet.size === set.size) {\n      map.set(key, set);\n    }\n  }\n\n  return map;\n};\n\nconst defaultModulesBySourceType = modulesBySourceType(undefined);\n/** @type {WeakMap<Function, any>} */\n\nconst createOrderedArrayFunctionMap = new WeakMap();\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\n\nconst createOrderedArrayFunction = comparator => {\n  /** @type {SetToArrayFunction<T>} */\n  let fn = createOrderedArrayFunctionMap.get(comparator);\n  if (fn !== undefined) return fn;\n\n  fn = set => {\n    set.sortWith(comparator);\n    return Array.from(set);\n  };\n\n  createOrderedArrayFunctionMap.set(comparator, fn);\n  return fn;\n};\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\n\n\nconst getModulesSize = modules => {\n  let size = 0;\n\n  for (const module of modules) {\n    for (const type of module.getSourceTypes()) {\n      size += module.size(type);\n    }\n  }\n\n  return size;\n};\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\n\n\nconst getModulesSizes = modules => {\n  let sizes = Object.create(null);\n\n  for (const module of modules) {\n    for (const type of module.getSourceTypes()) {\n      sizes[type] = (sizes[type] || 0) + module.size(type);\n    }\n  }\n\n  return sizes;\n};\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\n\n\nconst isAvailableChunk = (a, b) => {\n  const queue = new Set(b.groupsIterable);\n\n  for (const chunkGroup of queue) {\n    if (a.isInGroup(chunkGroup)) continue;\n    if (chunkGroup.isInitial()) return false;\n\n    for (const parent of chunkGroup.parentsIterable) {\n      queue.add(parent);\n    }\n  }\n\n  return true;\n};\n\nclass ChunkGraphModule {\n  constructor() {\n    /** @type {SortableSet<Chunk>} */\n    this.chunks = new SortableSet();\n    /** @type {Set<Chunk> | undefined} */\n\n    this.entryInChunks = undefined;\n    /** @type {Set<Chunk> | undefined} */\n\n    this.runtimeInChunks = undefined;\n    /** @type {RuntimeSpecMap<ModuleHashInfo>} */\n\n    this.hashes = undefined;\n    /** @type {string | number} */\n\n    this.id = null;\n    /** @type {RuntimeSpecMap<Set<string>> | undefined} */\n\n    this.runtimeRequirements = undefined;\n    /** @type {RuntimeSpecMap<string>} */\n\n    this.graphHashes = undefined;\n    /** @type {RuntimeSpecMap<string>} */\n\n    this.graphHashesWithConnections = undefined;\n  }\n\n}\n\nclass ChunkGraphChunk {\n  constructor() {\n    /** @type {SortableSet<Module>} */\n    this.modules = new SortableSet();\n    /** @type {WeakMap<Module, Set<string>> | undefined} */\n\n    this.sourceTypesByModule = undefined;\n    /** @type {Map<Module, Entrypoint>} */\n\n    this.entryModules = new Map();\n    /** @type {SortableSet<RuntimeModule>} */\n\n    this.runtimeModules = new SortableSet();\n    /** @type {Set<RuntimeModule> | undefined} */\n\n    this.fullHashModules = undefined;\n    /** @type {Set<RuntimeModule> | undefined} */\n\n    this.dependentHashModules = undefined;\n    /** @type {Set<string> | undefined} */\n\n    this.runtimeRequirements = undefined;\n    /** @type {Set<string>} */\n\n    this.runtimeRequirementsInTree = new Set();\n    this._modulesBySourceType = defaultModulesBySourceType;\n  }\n\n}\n\nclass ChunkGraph {\n  /**\n   * @param {ModuleGraph} moduleGraph the module graph\n   * @param {string | Hash} hashFunction the hash function to use\n   */\n  constructor(moduleGraph) {\n    let hashFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"md4\";\n\n    /** @private @type {WeakMap<Module, ChunkGraphModule>} */\n    this._modules = new WeakMap();\n    /** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n\n    this._chunks = new WeakMap();\n    /** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n\n    this._blockChunkGroups = new WeakMap();\n    /** @private @type {Map<string, string | number>} */\n\n    this._runtimeIds = new Map();\n    /** @type {ModuleGraph} */\n\n    this.moduleGraph = moduleGraph;\n    this._hashFunction = hashFunction;\n    this._getGraphRoots = this._getGraphRoots.bind(this);\n  }\n  /**\n   * @private\n   * @param {Module} module the module\n   * @returns {ChunkGraphModule} internal module\n   */\n\n\n  _getChunkGraphModule(module) {\n    let cgm = this._modules.get(module);\n\n    if (cgm === undefined) {\n      cgm = new ChunkGraphModule();\n\n      this._modules.set(module, cgm);\n    }\n\n    return cgm;\n  }\n  /**\n   * @private\n   * @param {Chunk} chunk the chunk\n   * @returns {ChunkGraphChunk} internal chunk\n   */\n\n\n  _getChunkGraphChunk(chunk) {\n    let cgc = this._chunks.get(chunk);\n\n    if (cgc === undefined) {\n      cgc = new ChunkGraphChunk();\n\n      this._chunks.set(chunk, cgc);\n    }\n\n    return cgc;\n  }\n  /**\n   * @param {SortableSet<Module>} set the sortable Set to get the roots of\n   * @returns {Module[]} the graph roots\n   */\n\n\n  _getGraphRoots(set) {\n    const {\n      moduleGraph\n    } = this;\n    return Array.from(findGraphRoots(set, module => {\n      /** @type {Set<Module>} */\n      const set = new Set();\n\n      const addDependencies = module => {\n        for (const connection of moduleGraph.getOutgoingConnections(module)) {\n          if (!connection.module) continue;\n          const activeState = connection.getActiveState(undefined);\n          if (activeState === false) continue;\n\n          if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n            addDependencies(connection.module);\n            continue;\n          }\n\n          set.add(connection.module);\n        }\n      };\n\n      addDependencies(module);\n      return set;\n    })).sort(compareModulesByIdentifier);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the module\n   * @returns {void}\n   */\n\n\n  connectChunkAndModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgm.chunks.add(chunk);\n    cgc.modules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Module} module the module\n   * @returns {void}\n   */\n\n\n  disconnectChunkAndModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgc.modules.delete(module); // No need to invalidate cgc._modulesBySourceType because we modified cgc.modules anyway\n\n    if (cgc.sourceTypesByModule) cgc.sourceTypesByModule.delete(module);\n    cgm.chunks.delete(chunk);\n  }\n  /**\n   * @param {Chunk} chunk the chunk which will be disconnected\n   * @returns {void}\n   */\n\n\n  disconnectChunk(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of cgc.modules) {\n      const cgm = this._getChunkGraphModule(module);\n\n      cgm.chunks.delete(chunk);\n    }\n\n    cgc.modules.clear();\n    chunk.disconnectFromGroups();\n    ChunkGraph.clearChunkGraphForChunk(chunk);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<Module>} modules the modules\n   * @returns {void}\n   */\n\n\n  attachModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of modules) {\n      cgc.modules.add(module);\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the runtime modules\n   * @returns {void}\n   */\n\n\n  attachRuntimeModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of modules) {\n      cgc.runtimeModules.add(module);\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n   * @returns {void}\n   */\n\n\n  attachFullHashModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\n    for (const module of modules) {\n      cgc.fullHashModules.add(module);\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n   * @returns {void}\n   */\n\n\n  attachDependentHashModules(chunk, modules) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n\n    for (const module of modules) {\n      cgc.dependentHashModules.add(module);\n    }\n  }\n  /**\n   * @param {Module} oldModule the replaced module\n   * @param {Module} newModule the replacing module\n   * @returns {void}\n   */\n\n\n  replaceModule(oldModule, newModule) {\n    const oldCgm = this._getChunkGraphModule(oldModule);\n\n    const newCgm = this._getChunkGraphModule(newModule);\n\n    for (const chunk of oldCgm.chunks) {\n      const cgc = this._getChunkGraphChunk(chunk);\n\n      cgc.modules.delete(oldModule);\n      cgc.modules.add(newModule);\n      newCgm.chunks.add(chunk);\n    }\n\n    oldCgm.chunks.clear();\n\n    if (oldCgm.entryInChunks !== undefined) {\n      if (newCgm.entryInChunks === undefined) {\n        newCgm.entryInChunks = new Set();\n      }\n\n      for (const chunk of oldCgm.entryInChunks) {\n        const cgc = this._getChunkGraphChunk(chunk);\n\n        const old = cgc.entryModules.get(oldModule);\n        /** @type {Map<Module, Entrypoint>} */\n\n        const newEntryModules = new Map();\n\n        for (const [m, cg] of cgc.entryModules) {\n          if (m === oldModule) {\n            newEntryModules.set(newModule, old);\n          } else {\n            newEntryModules.set(m, cg);\n          }\n        }\n\n        cgc.entryModules = newEntryModules;\n        newCgm.entryInChunks.add(chunk);\n      }\n\n      oldCgm.entryInChunks = undefined;\n    }\n\n    if (oldCgm.runtimeInChunks !== undefined) {\n      if (newCgm.runtimeInChunks === undefined) {\n        newCgm.runtimeInChunks = new Set();\n      }\n\n      for (const chunk of oldCgm.runtimeInChunks) {\n        const cgc = this._getChunkGraphChunk(chunk);\n\n        cgc.runtimeModules.delete(\n        /** @type {RuntimeModule} */\n        oldModule);\n        cgc.runtimeModules.add(\n        /** @type {RuntimeModule} */\n        newModule);\n        newCgm.runtimeInChunks.add(chunk);\n\n        if (cgc.fullHashModules !== undefined && cgc.fullHashModules.has(\n        /** @type {RuntimeModule} */\n        oldModule)) {\n          cgc.fullHashModules.delete(\n          /** @type {RuntimeModule} */\n          oldModule);\n          cgc.fullHashModules.add(\n          /** @type {RuntimeModule} */\n          newModule);\n        }\n\n        if (cgc.dependentHashModules !== undefined && cgc.dependentHashModules.has(\n        /** @type {RuntimeModule} */\n        oldModule)) {\n          cgc.dependentHashModules.delete(\n          /** @type {RuntimeModule} */\n          oldModule);\n          cgc.dependentHashModules.add(\n          /** @type {RuntimeModule} */\n          newModule);\n        }\n      }\n\n      oldCgm.runtimeInChunks = undefined;\n    }\n  }\n  /**\n   * @param {Module} module the checked module\n   * @param {Chunk} chunk the checked chunk\n   * @returns {boolean} true, if the chunk contains the module\n   */\n\n\n  isModuleInChunk(module, chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.has(module);\n  }\n  /**\n   * @param {Module} module the checked module\n   * @param {ChunkGroup} chunkGroup the checked chunk group\n   * @returns {boolean} true, if the chunk contains the module\n   */\n\n\n  isModuleInChunkGroup(module, chunkGroup) {\n    for (const chunk of chunkGroup.chunks) {\n      if (this.isModuleInChunk(module, chunk)) return true;\n    }\n\n    return false;\n  }\n  /**\n   * @param {Module} module the checked module\n   * @returns {boolean} true, if the module is entry of any chunk\n   */\n\n\n  isEntryModule(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.entryInChunks !== undefined;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n   */\n\n\n  getModuleChunksIterable(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n   * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n   */\n\n\n  getOrderedModuleChunksIterable(module, sortFn) {\n    const cgm = this._getChunkGraphModule(module);\n\n    cgm.chunks.sortWith(sortFn);\n    return cgm.chunks;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {Chunk[]} array of chunks (cached, do not modify)\n   */\n\n\n  getModuleChunks(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks.getFromCache(getArray);\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {number} the number of chunk which contain the module\n   */\n\n\n  getNumberOfModuleChunks(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks.size;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {RuntimeSpecSet} runtimes\n   */\n\n\n  getModuleRuntimes(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the number of modules which are contained in this chunk\n   */\n\n\n  getNumberOfChunkModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the number of full hash modules which are contained in this chunk\n   */\n\n\n  getNumberOfChunkFullHashModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Module>} return the modules for this chunk\n   */\n\n\n  getChunkModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} sourceType source type\n   * @returns {Iterable<Module> | undefined} return the modules for this chunk\n   */\n\n\n  getChunkModulesIterableBySourceType(chunk, sourceType) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const modulesWithSourceType = cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);\n    return modulesWithSourceType;\n  }\n  /**\n   * @param {Chunk} chunk chunk\n   * @param {Module} module chunk module\n   * @param {Set<string>} sourceTypes source types\n   */\n\n\n  setChunkModuleSourceTypes(chunk, module, sourceTypes) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.sourceTypesByModule === undefined) {\n      cgc.sourceTypesByModule = new WeakMap();\n    }\n\n    cgc.sourceTypesByModule.set(module, sourceTypes); // Update cgc._modulesBySourceType to invalidate the cache\n\n    cgc._modulesBySourceType = modulesBySourceType(cgc.sourceTypesByModule);\n  }\n  /**\n   * @param {Chunk} chunk chunk\n   * @param {Module} module chunk module\n   * @returns {Set<string>} source types\n   */\n\n\n  getChunkModuleSourceTypes(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.sourceTypesByModule === undefined) {\n      return module.getSourceTypes();\n    }\n\n    return cgc.sourceTypesByModule.get(module) || module.getSourceTypes();\n  }\n  /**\n   * @param {Module} module module\n   * @returns {Set<string>} source types\n   */\n\n\n  getModuleSourceTypes(module) {\n    return this._getOverwrittenModuleSourceTypes(module) || module.getSourceTypes();\n  }\n  /**\n   * @param {Module} module module\n   * @returns {Set<string> | undefined} source types\n   */\n\n\n  _getOverwrittenModuleSourceTypes(module) {\n    let newSet = false;\n    let sourceTypes;\n\n    for (const chunk of this.getModuleChunksIterable(module)) {\n      const cgc = this._getChunkGraphChunk(chunk);\n\n      if (cgc.sourceTypesByModule === undefined) return;\n      const st = cgc.sourceTypesByModule.get(module);\n      if (st === undefined) return;\n\n      if (!sourceTypes) {\n        sourceTypes = st;\n        continue;\n      } else if (!newSet) {\n        for (const type of st) {\n          if (!newSet) {\n            if (!sourceTypes.has(type)) {\n              newSet = true;\n              sourceTypes = new Set(sourceTypes);\n              sourceTypes.add(type);\n            }\n          } else {\n            sourceTypes.add(type);\n          }\n        }\n      } else {\n        for (const type of st) sourceTypes.add(type);\n      }\n    }\n\n    return sourceTypes;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Iterable<Module>} return the modules for this chunk\n   */\n\n\n  getOrderedChunkModulesIterable(chunk, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgc.modules.sortWith(comparator);\n    return cgc.modules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} sourceType source type\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Iterable<Module> | undefined} return the modules for this chunk\n   */\n\n\n  getOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const modulesWithSourceType = cgc.modules.getFromUnorderedCache(cgc._modulesBySourceType).get(sourceType);\n    if (modulesWithSourceType === undefined) return undefined;\n    modulesWithSourceType.sortWith(comparator);\n    return modulesWithSourceType;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n   */\n\n\n  getChunkModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(getArray);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {function(Module, Module): -1|0|1} comparator comparator function\n   * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n   */\n\n\n  getOrderedChunkModules(chunk, comparator) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const arrayFunction = createOrderedArrayFunction(comparator);\n    return cgc.modules.getFromUnorderedCache(arrayFunction);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @param {boolean} includeAllChunks all chunks or only async chunks\n   * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n   */\n\n\n  getChunkModuleIdMap(chunk, filterFn) {\n    let includeAllChunks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    /** @type {Record<string|number, (string|number)[]>} */\n    const chunkModuleIdMap = Object.create(null);\n\n    for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {\n      /** @type {(string|number)[]} */\n      let array;\n\n      for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) {\n        if (filterFn(module)) {\n          if (array === undefined) {\n            array = [];\n            chunkModuleIdMap[asyncChunk.id] = array;\n          }\n\n          const moduleId = this.getModuleId(module);\n          array.push(moduleId);\n        }\n      }\n    }\n\n    return chunkModuleIdMap;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @param {number} hashLength length of the hash\n   * @param {boolean} includeAllChunks all chunks or only async chunks\n   * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n   */\n\n\n  getChunkModuleRenderedHashMap(chunk, filterFn) {\n    let hashLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let includeAllChunks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    /** @type {Record<string|number, Record<string|number, string>>} */\n    const chunkModuleHashMap = Object.create(null);\n\n    for (const asyncChunk of includeAllChunks ? chunk.getAllReferencedChunks() : chunk.getAllAsyncChunks()) {\n      /** @type {Record<string|number, string>} */\n      let idToHashMap;\n\n      for (const module of this.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(this))) {\n        if (filterFn(module)) {\n          if (idToHashMap === undefined) {\n            idToHashMap = Object.create(null);\n            chunkModuleHashMap[asyncChunk.id] = idToHashMap;\n          }\n\n          const moduleId = this.getModuleId(module);\n          const hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\n          idToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n        }\n      }\n    }\n\n    return chunkModuleHashMap;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n   * @returns {Record<string|number, boolean>} chunk map\n   */\n\n\n  getChunkConditionMap(chunk, filterFn) {\n    const map = Object.create(null);\n\n    for (const c of chunk.getAllReferencedChunks()) {\n      map[c.id] = filterFn(c, this);\n    }\n\n    return map;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n   * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n   * @returns {boolean} return true if module exists in graph\n   */\n\n\n  hasModuleInGraph(chunk, filterFn, filterChunkFn) {\n    const queue = new Set(chunk.groupsIterable);\n    const chunksProcessed = new Set();\n\n    for (const chunkGroup of queue) {\n      for (const innerChunk of chunkGroup.chunks) {\n        if (!chunksProcessed.has(innerChunk)) {\n          chunksProcessed.add(innerChunk);\n\n          if (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n            for (const module of this.getChunkModulesIterable(innerChunk)) {\n              if (filterFn(module)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {Chunk} chunkA first chunk\n   * @param {Chunk} chunkB second chunk\n   * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n   */\n\n\n  compareChunks(chunkA, chunkB) {\n    const cgcA = this._getChunkGraphChunk(chunkA);\n\n    const cgcB = this._getChunkGraphChunk(chunkB);\n\n    if (cgcA.modules.size > cgcB.modules.size) return -1;\n    if (cgcA.modules.size < cgcB.modules.size) return 1;\n    cgcA.modules.sortWith(compareModulesByIdentifier);\n    cgcB.modules.sortWith(compareModulesByIdentifier);\n    return compareModuleIterables(cgcA.modules, cgcB.modules);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} total size of all modules in the chunk\n   */\n\n\n  getChunkModulesSize(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(getModulesSize);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n   */\n\n\n  getChunkModulesSizes(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(getModulesSizes);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Module[]} root modules of the chunks (ordered by identifier)\n   */\n\n\n  getChunkRootModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of the chunk\n   */\n\n\n  getChunkSize(chunk) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n    const chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n    return chunkOverhead + modulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1);\n  }\n  /**\n   * @param {Chunk} chunkA chunk\n   * @param {Chunk} chunkB chunk\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of the chunk or false if chunks can't be integrated\n   */\n\n\n  getIntegratedChunksSize(chunkA, chunkB) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    const cgcA = this._getChunkGraphChunk(chunkA);\n\n    const cgcB = this._getChunkGraphChunk(chunkB);\n\n    const allModules = new Set(cgcA.modules);\n\n    for (const m of cgcB.modules) allModules.add(m);\n\n    let modulesSize = getModulesSize(allModules);\n    const chunkOverhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n    const entryChunkMultiplicator = typeof options.entryChunkMultiplicator === \"number\" ? options.entryChunkMultiplicator : 10;\n    return chunkOverhead + modulesSize * (chunkA.canBeInitial() || chunkB.canBeInitial() ? entryChunkMultiplicator : 1);\n  }\n  /**\n   * @param {Chunk} chunkA chunk\n   * @param {Chunk} chunkB chunk\n   * @returns {boolean} true, if chunks could be integrated\n   */\n\n\n  canChunksBeIntegrated(chunkA, chunkB) {\n    if (chunkA.preventIntegration || chunkB.preventIntegration) {\n      return false;\n    }\n\n    const hasRuntimeA = chunkA.hasRuntime();\n    const hasRuntimeB = chunkB.hasRuntime();\n\n    if (hasRuntimeA !== hasRuntimeB) {\n      if (hasRuntimeA) {\n        return isAvailableChunk(chunkA, chunkB);\n      } else if (hasRuntimeB) {\n        return isAvailableChunk(chunkB, chunkA);\n      } else {\n        return false;\n      }\n    }\n\n    if (this.getNumberOfEntryModules(chunkA) > 0 || this.getNumberOfEntryModules(chunkB) > 0) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * @param {Chunk} chunkA the target chunk\n   * @param {Chunk} chunkB the chunk to integrate\n   * @returns {void}\n   */\n\n\n  integrateChunks(chunkA, chunkB) {\n    // Decide for one name (deterministic)\n    if (chunkA.name && chunkB.name) {\n      if (this.getNumberOfEntryModules(chunkA) > 0 === this.getNumberOfEntryModules(chunkB) > 0) {\n        // When both chunks have entry modules or none have one, use\n        // shortest name\n        if (chunkA.name.length !== chunkB.name.length) {\n          chunkA.name = chunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n        } else {\n          chunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n        }\n      } else if (this.getNumberOfEntryModules(chunkB) > 0) {\n        // Pick the name of the chunk with the entry module\n        chunkA.name = chunkB.name;\n      }\n    } else if (chunkB.name) {\n      chunkA.name = chunkB.name;\n    } // Merge id name hints\n\n\n    for (const hint of chunkB.idNameHints) {\n      chunkA.idNameHints.add(hint);\n    } // Merge runtime\n\n\n    chunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime); // getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n\n    for (const module of this.getChunkModules(chunkB)) {\n      this.disconnectChunkAndModule(chunkB, module);\n      this.connectChunkAndModule(chunkA, module);\n    }\n\n    for (const [module, chunkGroup] of Array.from(this.getChunkEntryModulesWithChunkGroupIterable(chunkB))) {\n      this.disconnectChunkAndEntryModule(chunkB, module);\n      this.connectChunkAndEntryModule(chunkA, module, chunkGroup);\n    }\n\n    for (const chunkGroup of chunkB.groupsIterable) {\n      chunkGroup.replaceChunk(chunkB, chunkA);\n      chunkA.addGroup(chunkGroup);\n      chunkB.removeGroup(chunkGroup);\n    }\n\n    ChunkGraph.clearChunkGraphForChunk(chunkB);\n  }\n  /**\n   * @param {Chunk} chunk the chunk to upgrade\n   * @returns {void}\n   */\n\n\n  upgradeDependentToFullHashModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.dependentHashModules === undefined) return;\n\n    if (cgc.fullHashModules === undefined) {\n      cgc.fullHashModules = cgc.dependentHashModules;\n    } else {\n      for (const m of cgc.dependentHashModules) {\n        cgc.fullHashModules.add(m);\n      }\n\n      cgc.dependentHashModules = undefined;\n    }\n  }\n  /**\n   * @param {Module} module the checked module\n   * @param {Chunk} chunk the checked chunk\n   * @returns {boolean} true, if the chunk contains the module as entry\n   */\n\n\n  isEntryModuleInChunk(module, chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules.has(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the entry module\n   * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n   * @returns {void}\n   */\n\n\n  connectChunkAndEntryModule(chunk, module, entrypoint) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgm.entryInChunks === undefined) {\n      cgm.entryInChunks = new Set();\n    }\n\n    cgm.entryInChunks.add(chunk);\n    cgc.entryModules.set(module, entrypoint);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the runtime module\n   * @returns {void}\n   */\n\n\n  connectChunkAndRuntimeModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgm.runtimeInChunks === undefined) {\n      cgm.runtimeInChunks = new Set();\n    }\n\n    cgm.runtimeInChunks.add(chunk);\n    cgc.runtimeModules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the module that require a full hash\n   * @returns {void}\n   */\n\n\n  addFullHashModuleToChunk(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n    cgc.fullHashModules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the module that require a full hash\n   * @returns {void}\n   */\n\n\n  addDependentHashModuleToChunk(chunk, module) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    if (cgc.dependentHashModules === undefined) cgc.dependentHashModules = new Set();\n    cgc.dependentHashModules.add(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {Module} module the entry module\n   * @returns {void}\n   */\n\n\n  disconnectChunkAndEntryModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgm.entryInChunks.delete(chunk);\n\n    if (cgm.entryInChunks.size === 0) {\n      cgm.entryInChunks = undefined;\n    }\n\n    cgc.entryModules.delete(module);\n  }\n  /**\n   * @param {Chunk} chunk the new chunk\n   * @param {RuntimeModule} module the runtime module\n   * @returns {void}\n   */\n\n\n  disconnectChunkAndRuntimeModule(chunk, module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    cgm.runtimeInChunks.delete(chunk);\n\n    if (cgm.runtimeInChunks.size === 0) {\n      cgm.runtimeInChunks = undefined;\n    }\n\n    cgc.runtimeModules.delete(module);\n  }\n  /**\n   * @param {Module} module the entry module, it will no longer be entry\n   * @returns {void}\n   */\n\n\n  disconnectEntryModule(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    for (const chunk of cgm.entryInChunks) {\n      const cgc = this._getChunkGraphChunk(chunk);\n\n      cgc.entryModules.delete(module);\n    }\n\n    cgm.entryInChunks = undefined;\n  }\n  /**\n   * @param {Chunk} chunk the chunk, for which all entries will be removed\n   * @returns {void}\n   */\n\n\n  disconnectEntries(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const module of cgc.entryModules.keys()) {\n      const cgm = this._getChunkGraphModule(module);\n\n      cgm.entryInChunks.delete(chunk);\n\n      if (cgm.entryInChunks.size === 0) {\n        cgm.entryInChunks = undefined;\n      }\n    }\n\n    cgc.entryModules.clear();\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the amount of entry modules in chunk\n   */\n\n\n  getNumberOfEntryModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {number} the amount of entry modules in chunk\n   */\n\n\n  getNumberOfRuntimeModules(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.runtimeModules.size;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Module>} iterable of modules (do not modify)\n   */\n\n\n  getChunkEntryModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules.keys();\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<Chunk>} iterable of chunks\n   */\n\n\n  getChunkEntryDependentChunksIterable(chunk) {\n    /** @type {Set<Chunk>} */\n    const set = new Set();\n\n    for (const chunkGroup of chunk.groupsIterable) {\n      if (chunkGroup instanceof Entrypoint) {\n        const entrypointChunk = chunkGroup.getEntrypointChunk();\n\n        const cgc = this._getChunkGraphChunk(entrypointChunk);\n\n        for (const chunkGroup of cgc.entryModules.values()) {\n          for (const c of chunkGroup.chunks) {\n            if (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n              set.add(c);\n            }\n          }\n        }\n      }\n    }\n\n    return set;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {boolean} true, when it has dependent chunks\n   */\n\n\n  hasChunkEntryDependentChunks(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    for (const chunkGroup of cgc.entryModules.values()) {\n      for (const c of chunkGroup.chunks) {\n        if (c !== chunk) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n   */\n\n\n  getChunkRuntimeModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.runtimeModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {RuntimeModule[]} array of modules in order of execution\n   */\n\n\n  getChunkRuntimeModulesInOrder(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const array = Array.from(cgc.runtimeModules);\n    array.sort(concatComparators(compareSelect(\n    /**\n     * @param {RuntimeModule} r runtime module\n     * @returns {number=} stage\n     */\n    r => r.stage, compareIds), compareModulesByIdentifier));\n    return array;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n   */\n\n\n  getChunkFullHashModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.fullHashModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n   */\n\n\n  getChunkFullHashModulesSet(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.fullHashModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n   */\n\n\n  getChunkDependentHashModulesIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.dependentHashModules;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n   */\n\n\n  getChunkEntryModulesWithChunkGroupIterable(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.entryModules;\n  }\n  /**\n   * @param {AsyncDependenciesBlock} depBlock the async block\n   * @returns {ChunkGroup} the chunk group\n   */\n\n\n  getBlockChunkGroup(depBlock) {\n    return this._blockChunkGroups.get(depBlock);\n  }\n  /**\n   * @param {AsyncDependenciesBlock} depBlock the async block\n   * @param {ChunkGroup} chunkGroup the chunk group\n   * @returns {void}\n   */\n\n\n  connectBlockAndChunkGroup(depBlock, chunkGroup) {\n    this._blockChunkGroups.set(depBlock, chunkGroup);\n\n    chunkGroup.addBlock(depBlock);\n  }\n  /**\n   * @param {ChunkGroup} chunkGroup the chunk group\n   * @returns {void}\n   */\n\n\n  disconnectChunkGroup(chunkGroup) {\n    for (const block of chunkGroup.blocksIterable) {\n      this._blockChunkGroups.delete(block);\n    } // TODO refactor by moving blocks list into ChunkGraph\n\n\n    chunkGroup._blocks.clear();\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {string | number} the id of the module\n   */\n\n\n  getModuleId(module) {\n    const cgm = this._getChunkGraphModule(module);\n\n    return cgm.id;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {string | number} id the id of the module\n   * @returns {void}\n   */\n\n\n  setModuleId(module, id) {\n    const cgm = this._getChunkGraphModule(module);\n\n    cgm.id = id;\n  }\n  /**\n   * @param {string} runtime runtime\n   * @returns {string | number} the id of the runtime\n   */\n\n\n  getRuntimeId(runtime) {\n    return this._runtimeIds.get(runtime);\n  }\n  /**\n   * @param {string} runtime runtime\n   * @param {string | number} id the id of the runtime\n   * @returns {void}\n   */\n\n\n  setRuntimeId(runtime, id) {\n    this._runtimeIds.set(runtime, id);\n  }\n  /**\n   * @template T\n   * @param {Module} module the module\n   * @param {RuntimeSpecMap<T>} hashes hashes data\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {T} hash\n   */\n\n\n  _getModuleHashInfo(module, hashes, runtime) {\n    if (!hashes) {\n      throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (hashes not set at all)`);\n    } else if (runtime === undefined) {\n      const hashInfoItems = new Set(hashes.values());\n\n      if (hashInfoItems.size !== 1) {\n        throw new Error(`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(hashes.keys(), r => runtimeToString(r)).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`);\n      }\n\n      return first(hashInfoItems);\n    } else {\n      const hashInfo = hashes.get(runtime);\n\n      if (!hashInfo) {\n        throw new Error(`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(runtime)} (available runtimes ${Array.from(hashes.keys(), runtimeToString).join(\", \")})`);\n      }\n\n      return hashInfo;\n    }\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {boolean} true, if the module has hashes for this runtime\n   */\n\n\n  hasModuleHashes(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const hashes = cgm.hashes;\n    return hashes && hashes.has(runtime);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n\n\n  getModuleHash(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const hashes = cgm.hashes;\n    return this._getModuleHashInfo(module, hashes, runtime).hash;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n\n\n  getRenderedModuleHash(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const hashes = cgm.hashes;\n    return this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {string} hash the full hash\n   * @param {string} renderedHash the shortened hash for rendering\n   * @returns {void}\n   */\n\n\n  setModuleHashes(module, runtime, hash, renderedHash) {\n    const cgm = this._getChunkGraphModule(module);\n\n    if (cgm.hashes === undefined) {\n      cgm.hashes = new RuntimeSpecMap();\n    }\n\n    cgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n   * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n   * @returns {void}\n   */\n\n\n  addModuleRuntimeRequirements(module, runtime, items) {\n    let transferOwnership = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    const cgm = this._getChunkGraphModule(module);\n\n    const runtimeRequirementsMap = cgm.runtimeRequirements;\n\n    if (runtimeRequirementsMap === undefined) {\n      const map = new RuntimeSpecMap(); // TODO avoid cloning item and track ownership instead\n\n      map.set(runtime, transferOwnership ? items : new Set(items));\n      cgm.runtimeRequirements = map;\n      return;\n    }\n\n    runtimeRequirementsMap.update(runtime, runtimeRequirements => {\n      if (runtimeRequirements === undefined) {\n        return transferOwnership ? items : new Set(items);\n      } else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n        for (const item of items) runtimeRequirements.add(item);\n\n        return runtimeRequirements;\n      } else {\n        for (const item of runtimeRequirements) items.add(item);\n\n        return items;\n      }\n    });\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n   * @returns {void}\n   */\n\n\n  addChunkRuntimeRequirements(chunk, items) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const runtimeRequirements = cgc.runtimeRequirements;\n\n    if (runtimeRequirements === undefined) {\n      cgc.runtimeRequirements = items;\n    } else if (runtimeRequirements.size >= items.size) {\n      for (const item of items) runtimeRequirements.add(item);\n    } else {\n      for (const item of runtimeRequirements) items.add(item);\n\n      cgc.runtimeRequirements = items;\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {Iterable<string>} items runtime requirements to be added\n   * @returns {void}\n   */\n\n\n  addTreeRuntimeRequirements(chunk, items) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const runtimeRequirements = cgc.runtimeRequirementsInTree;\n\n    for (const item of items) runtimeRequirements.add(item);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n\n\n  getModuleRuntimeRequirements(module, runtime) {\n    const cgm = this._getChunkGraphModule(module);\n\n    const runtimeRequirements = cgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n    return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n\n\n  getChunkRuntimeRequirements(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    const runtimeRequirements = cgc.runtimeRequirements;\n    return runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {boolean} withConnections include connections\n   * @returns {string} hash\n   */\n\n\n  getModuleGraphHash(module, runtime) {\n    let withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    const cgm = this._getChunkGraphModule(module);\n\n    return withConnections ? this._getModuleGraphHashWithConnections(cgm, module, runtime) : this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @param {boolean} withConnections include connections\n   * @returns {bigint} hash\n   */\n\n\n  getModuleGraphHashBigInt(module, runtime) {\n    let withConnections = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    const cgm = this._getChunkGraphModule(module);\n\n    return withConnections ? BigInt(`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`) : this._getModuleGraphHashBigInt(cgm, module, runtime);\n  }\n  /**\n   * @param {ChunkGraphModule} cgm the ChunkGraphModule\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {bigint} hash as big int\n   */\n\n\n  _getModuleGraphHashBigInt(cgm, module, runtime) {\n    if (cgm.graphHashes === undefined) {\n      cgm.graphHashes = new RuntimeSpecMap();\n    }\n\n    const graphHash = cgm.graphHashes.provide(runtime, () => {\n      const hash = createHash(this._hashFunction);\n      hash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\n\n      const sourceTypes = this._getOverwrittenModuleSourceTypes(module);\n\n      if (sourceTypes !== undefined) {\n        for (const type of sourceTypes) hash.update(type);\n      }\n\n      this.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n      return BigInt(`0x${\n      /** @type {string} */\n      hash.digest(\"hex\")}`);\n    });\n    return graphHash;\n  }\n  /**\n   * @param {ChunkGraphModule} cgm the ChunkGraphModule\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime the runtime\n   * @returns {string} hash\n   */\n\n\n  _getModuleGraphHashWithConnections(cgm, module, runtime) {\n    if (cgm.graphHashesWithConnections === undefined) {\n      cgm.graphHashesWithConnections = new RuntimeSpecMap();\n    }\n\n    const activeStateToString = state => {\n      if (state === false) return \"F\";\n      if (state === true) return \"T\";\n      if (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n      throw new Error(\"Not implemented active state\");\n    };\n\n    const strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n    return cgm.graphHashesWithConnections.provide(runtime, () => {\n      const graphHash = this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n\n      const connections = this.moduleGraph.getOutgoingConnections(module);\n      /** @type {Set<Module>} */\n\n      const activeNamespaceModules = new Set();\n      /** @type {Map<string, Module | Set<Module>>} */\n\n      const connectedModules = new Map();\n\n      const processConnection = (connection, stateInfo) => {\n        const module = connection.module;\n        stateInfo += module.getExportsType(this.moduleGraph, strict); // cspell:word Tnamespace\n\n        if (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);else {\n          const oldModule = connectedModules.get(stateInfo);\n\n          if (oldModule === undefined) {\n            connectedModules.set(stateInfo, module);\n          } else if (oldModule instanceof Set) {\n            oldModule.add(module);\n          } else if (oldModule !== module) {\n            connectedModules.set(stateInfo, new Set([oldModule, module]));\n          }\n        }\n      };\n\n      if (runtime === undefined || typeof runtime === \"string\") {\n        for (const connection of connections) {\n          const state = connection.getActiveState(runtime);\n          if (state === false) continue;\n          processConnection(connection, state === true ? \"T\" : \"O\");\n        }\n      } else {\n        // cspell:word Tnamespace\n        for (const connection of connections) {\n          const states = new Set();\n          let stateInfo = \"\";\n          forEachRuntime(runtime, runtime => {\n            const state = connection.getActiveState(runtime);\n            states.add(state);\n            stateInfo += activeStateToString(state) + runtime;\n          }, true);\n\n          if (states.size === 1) {\n            const state = first(states);\n            if (state === false) continue;\n            stateInfo = activeStateToString(state);\n          }\n\n          processConnection(connection, stateInfo);\n        }\n      } // cspell:word Tnamespace\n\n\n      if (activeNamespaceModules.size === 0 && connectedModules.size === 0) return graphHash;\n      const connectedModulesInOrder = connectedModules.size > 1 ? Array.from(connectedModules).sort((_ref, _ref2) => {\n        let [a] = _ref;\n        let [b] = _ref2;\n        return a < b ? -1 : 1;\n      }) : connectedModules;\n      const hash = createHash(this._hashFunction);\n\n      const addModuleToHash = module => {\n        hash.update(this._getModuleGraphHashBigInt(this._getChunkGraphModule(module), module, runtime).toString(16));\n      };\n\n      const addModulesToHash = modules => {\n        let xor = ZERO_BIG_INT;\n\n        for (const m of modules) {\n          xor = xor ^ this._getModuleGraphHashBigInt(this._getChunkGraphModule(m), m, runtime);\n        }\n\n        hash.update(xor.toString(16));\n      };\n\n      if (activeNamespaceModules.size === 1) addModuleToHash(activeNamespaceModules.values().next().value);else if (activeNamespaceModules.size > 1) addModulesToHash(activeNamespaceModules);\n\n      for (const [stateInfo, modules] of connectedModulesInOrder) {\n        hash.update(stateInfo);\n\n        if (modules instanceof Set) {\n          addModulesToHash(modules);\n        } else {\n          addModuleToHash(modules);\n        }\n      }\n\n      hash.update(graphHash);\n      return (\n        /** @type {string} */\n        hash.digest(\"hex\")\n      );\n    });\n  }\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n\n\n  getTreeRuntimeRequirements(chunk) {\n    const cgc = this._getChunkGraphChunk(chunk);\n\n    return cgc.runtimeRequirementsInTree;\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Module} module the module\n   * @param {string} deprecateMessage message for the deprecation message\n   * @param {string} deprecationCode code for the deprecation\n   * @returns {ChunkGraph} the chunk graph\n   */\n\n\n  static getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n    const fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n    if (fn) return fn(module);\n    const newFn = util.deprecate(\n    /**\n     * @param {Module} module the module\n     * @returns {ChunkGraph} the chunk graph\n     */\n    module => {\n      const chunkGraph = chunkGraphForModuleMap.get(module);\n      if (!chunkGraph) throw new Error(deprecateMessage + \": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\");\n      return chunkGraph;\n    }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n    deprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n    return newFn(module);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Module} module the module\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {void}\n   */\n\n\n  static setChunkGraphForModule(module, chunkGraph) {\n    chunkGraphForModuleMap.set(module, chunkGraph);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Module} module the module\n   * @returns {void}\n   */\n\n\n  static clearChunkGraphForModule(module) {\n    chunkGraphForModuleMap.delete(module);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {string} deprecateMessage message for the deprecation message\n   * @param {string} deprecationCode code for the deprecation\n   * @returns {ChunkGraph} the chunk graph\n   */\n\n\n  static getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n    const fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n    if (fn) return fn(chunk);\n    const newFn = util.deprecate(\n    /**\n     * @param {Chunk} chunk the chunk\n     * @returns {ChunkGraph} the chunk graph\n     */\n    chunk => {\n      const chunkGraph = chunkGraphForChunkMap.get(chunk);\n      if (!chunkGraph) throw new Error(deprecateMessage + \"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\");\n      return chunkGraph;\n    }, deprecateMessage + \": Use new ChunkGraph API\", deprecationCode);\n    deprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n    return newFn(chunk);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {void}\n   */\n\n\n  static setChunkGraphForChunk(chunk, chunkGraph) {\n    chunkGraphForChunkMap.set(chunk, chunkGraph);\n  } // TODO remove in webpack 6\n\n  /**\n   * @param {Chunk} chunk the chunk\n   * @returns {void}\n   */\n\n\n  static clearChunkGraphForChunk(chunk) {\n    chunkGraphForChunkMap.delete(chunk);\n  }\n\n} // TODO remove in webpack 6\n\n/** @type {WeakMap<Module, ChunkGraph>} */\n\n\nconst chunkGraphForModuleMap = new WeakMap(); // TODO remove in webpack 6\n\n/** @type {WeakMap<Chunk, ChunkGraph>} */\n\nconst chunkGraphForChunkMap = new WeakMap(); // TODO remove in webpack 6\n\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\n\nconst deprecateGetChunkGraphForModuleMap = new Map(); // TODO remove in webpack 6\n\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\n\nconst deprecateGetChunkGraphForChunkMap = new Map();\nmodule.exports = ChunkGraph;","map":{"version":3,"names":["util","require","Entrypoint","ModuleGraphConnection","first","SortableSet","compareModulesById","compareIterables","compareModulesByIdentifier","concatComparators","compareSelect","compareIds","createHash","findGraphRoots","RuntimeSpecMap","RuntimeSpecSet","runtimeToString","mergeRuntime","forEachRuntime","EMPTY_SET","Set","ZERO_BIG_INT","BigInt","compareModuleIterables","ModuleHashInfo","constructor","hash","renderedHash","getArray","set","Array","from","getModuleRuntimes","chunks","runtimes","chunk","add","runtime","modulesBySourceType","sourceTypesByModule","map","Map","module","sourceTypes","get","getSourceTypes","sourceType","innerSet","undefined","key","size","defaultModulesBySourceType","createOrderedArrayFunctionMap","WeakMap","createOrderedArrayFunction","comparator","fn","sortWith","getModulesSize","modules","type","getModulesSizes","sizes","Object","create","isAvailableChunk","a","b","queue","groupsIterable","chunkGroup","isInGroup","isInitial","parent","parentsIterable","ChunkGraphModule","entryInChunks","runtimeInChunks","hashes","id","runtimeRequirements","graphHashes","graphHashesWithConnections","ChunkGraphChunk","entryModules","runtimeModules","fullHashModules","dependentHashModules","runtimeRequirementsInTree","_modulesBySourceType","ChunkGraph","moduleGraph","hashFunction","_modules","_chunks","_blockChunkGroups","_runtimeIds","_hashFunction","_getGraphRoots","bind","_getChunkGraphModule","cgm","_getChunkGraphChunk","cgc","addDependencies","connection","getOutgoingConnections","activeState","getActiveState","TRANSITIVE_ONLY","sort","connectChunkAndModule","disconnectChunkAndModule","delete","disconnectChunk","clear","disconnectFromGroups","clearChunkGraphForChunk","attachModules","attachRuntimeModules","attachFullHashModules","attachDependentHashModules","replaceModule","oldModule","newModule","oldCgm","newCgm","old","newEntryModules","m","cg","has","isModuleInChunk","isModuleInChunkGroup","isEntryModule","getModuleChunksIterable","getOrderedModuleChunksIterable","sortFn","getModuleChunks","getFromCache","getNumberOfModuleChunks","getFromUnorderedCache","getNumberOfChunkModules","getNumberOfChunkFullHashModules","getChunkModulesIterable","getChunkModulesIterableBySourceType","modulesWithSourceType","setChunkModuleSourceTypes","getChunkModuleSourceTypes","getModuleSourceTypes","_getOverwrittenModuleSourceTypes","newSet","st","getOrderedChunkModulesIterable","getOrderedChunkModulesIterableBySourceType","getChunkModules","getOrderedChunkModules","arrayFunction","getChunkModuleIdMap","filterFn","includeAllChunks","chunkModuleIdMap","asyncChunk","getAllReferencedChunks","getAllAsyncChunks","array","moduleId","getModuleId","push","getChunkModuleRenderedHashMap","hashLength","chunkModuleHashMap","idToHashMap","getRenderedModuleHash","slice","getChunkConditionMap","c","hasModuleInGraph","filterChunkFn","chunksProcessed","innerChunk","child","childrenIterable","compareChunks","chunkA","chunkB","cgcA","cgcB","getChunkModulesSize","getChunkModulesSizes","getChunkRootModules","getChunkSize","options","modulesSize","chunkOverhead","entryChunkMultiplicator","canBeInitial","getIntegratedChunksSize","allModules","canChunksBeIntegrated","preventIntegration","hasRuntimeA","hasRuntime","hasRuntimeB","getNumberOfEntryModules","integrateChunks","name","length","hint","idNameHints","getChunkEntryModulesWithChunkGroupIterable","disconnectChunkAndEntryModule","connectChunkAndEntryModule","replaceChunk","addGroup","removeGroup","upgradeDependentToFullHashModules","isEntryModuleInChunk","entrypoint","connectChunkAndRuntimeModule","addFullHashModuleToChunk","addDependentHashModuleToChunk","disconnectChunkAndRuntimeModule","disconnectEntryModule","disconnectEntries","keys","getNumberOfRuntimeModules","getChunkEntryModulesIterable","getChunkEntryDependentChunksIterable","entrypointChunk","getEntrypointChunk","values","hasChunkEntryDependentChunks","getChunkRuntimeModulesIterable","getChunkRuntimeModulesInOrder","r","stage","getChunkFullHashModulesIterable","getChunkFullHashModulesSet","getChunkDependentHashModulesIterable","getBlockChunkGroup","depBlock","connectBlockAndChunkGroup","addBlock","disconnectChunkGroup","block","blocksIterable","_blocks","setModuleId","getRuntimeId","setRuntimeId","_getModuleHashInfo","Error","identifier","hashInfoItems","join","hashInfo","hasModuleHashes","getModuleHash","setModuleHashes","addModuleRuntimeRequirements","items","transferOwnership","runtimeRequirementsMap","update","item","addChunkRuntimeRequirements","addTreeRuntimeRequirements","getModuleRuntimeRequirements","getChunkRuntimeRequirements","getModuleGraphHash","withConnections","_getModuleGraphHashWithConnections","_getModuleGraphHashBigInt","toString","getModuleGraphHashBigInt","graphHash","provide","isAsync","getExportsInfo","updateHash","digest","activeStateToString","state","strict","buildMeta","strictHarmonyModule","connections","activeNamespaceModules","connectedModules","processConnection","stateInfo","getExportsType","states","connectedModulesInOrder","addModuleToHash","addModulesToHash","xor","next","value","getTreeRuntimeRequirements","getChunkGraphForModule","deprecateMessage","deprecationCode","deprecateGetChunkGraphForModuleMap","newFn","deprecate","chunkGraph","chunkGraphForModuleMap","setChunkGraphForModule","clearChunkGraphForModule","getChunkGraphForChunk","deprecateGetChunkGraphForChunkMap","chunkGraphForChunkMap","setChunkGraphForChunk","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/ChunkGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst util = require(\"util\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { first } = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst {\n\tcompareModulesById,\n\tcompareIterables,\n\tcompareModulesByIdentifier,\n\tconcatComparators,\n\tcompareSelect,\n\tcompareIds\n} = require(\"./util/comparators\");\nconst createHash = require(\"./util/createHash\");\nconst findGraphRoots = require(\"./util/findGraphRoots\");\nconst {\n\tRuntimeSpecMap,\n\tRuntimeSpecSet,\n\truntimeToString,\n\tmergeRuntime,\n\tforEachRuntime\n} = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @type {ReadonlySet<string>} */\nconst EMPTY_SET = new Set();\n\nconst ZERO_BIG_INT = BigInt(0);\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/** @typedef {(c: Chunk, chunkGraph: ChunkGraph) => boolean} ChunkFilterPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {[Module, Entrypoint | undefined]} EntryModuleWithChunkGroup */\n\n/**\n * @typedef {Object} ChunkSizeOptions\n * @property {number=} chunkOverhead constant overhead for a chunk\n * @property {number=} entryChunkMultiplicator multiplicator for initial chunks\n */\n\nclass ModuleHashInfo {\n\tconstructor(hash, renderedHash) {\n\t\tthis.hash = hash;\n\t\tthis.renderedHash = renderedHash;\n\t}\n}\n\n/** @template T @typedef {(set: SortableSet<T>) => T[]} SetToArrayFunction<T> */\n\n/**\n * @template T\n * @param {SortableSet<T>} set the set\n * @returns {T[]} set as array\n */\nconst getArray = set => {\n\treturn Array.from(set);\n};\n\n/**\n * @param {SortableSet<Chunk>} chunks the chunks\n * @returns {RuntimeSpecSet} runtimes\n */\nconst getModuleRuntimes = chunks => {\n\tconst runtimes = new RuntimeSpecSet();\n\tfor (const chunk of chunks) {\n\t\truntimes.add(chunk.runtime);\n\t}\n\treturn runtimes;\n};\n\n/**\n * @param {WeakMap<Module, Set<string>> | undefined} sourceTypesByModule sourceTypesByModule\n * @returns {function (SortableSet<Module>): Map<string, SortableSet<Module>>} modules by source type\n */\nconst modulesBySourceType = sourceTypesByModule => set => {\n\t/** @type {Map<string, SortableSet<Module>>} */\n\tconst map = new Map();\n\tfor (const module of set) {\n\t\tconst sourceTypes =\n\t\t\t(sourceTypesByModule && sourceTypesByModule.get(module)) ||\n\t\t\tmodule.getSourceTypes();\n\t\tfor (const sourceType of sourceTypes) {\n\t\t\tlet innerSet = map.get(sourceType);\n\t\t\tif (innerSet === undefined) {\n\t\t\t\tinnerSet = new SortableSet();\n\t\t\t\tmap.set(sourceType, innerSet);\n\t\t\t}\n\t\t\tinnerSet.add(module);\n\t\t}\n\t}\n\tfor (const [key, innerSet] of map) {\n\t\t// When all modules have the source type, we reuse the original SortableSet\n\t\t// to benefit from the shared cache (especially for sorting)\n\t\tif (innerSet.size === set.size) {\n\t\t\tmap.set(key, set);\n\t\t}\n\t}\n\treturn map;\n};\nconst defaultModulesBySourceType = modulesBySourceType(undefined);\n\n/** @type {WeakMap<Function, any>} */\nconst createOrderedArrayFunctionMap = new WeakMap();\n\n/**\n * @template T\n * @param {function(T, T): -1|0|1} comparator comparator function\n * @returns {SetToArrayFunction<T>} set as ordered array\n */\nconst createOrderedArrayFunction = comparator => {\n\t/** @type {SetToArrayFunction<T>} */\n\tlet fn = createOrderedArrayFunctionMap.get(comparator);\n\tif (fn !== undefined) return fn;\n\tfn = set => {\n\t\tset.sortWith(comparator);\n\t\treturn Array.from(set);\n\t};\n\tcreateOrderedArrayFunctionMap.set(comparator, fn);\n\treturn fn;\n};\n\n/**\n * @param {Iterable<Module>} modules the modules to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = modules => {\n\tlet size = 0;\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsize += module.size(type);\n\t\t}\n\t}\n\treturn size;\n};\n\n/**\n * @param {Iterable<Module>} modules the sortable Set to get the size of\n * @returns {Record<string, number>} the sizes of the modules\n */\nconst getModulesSizes = modules => {\n\tlet sizes = Object.create(null);\n\tfor (const module of modules) {\n\t\tfor (const type of module.getSourceTypes()) {\n\t\t\tsizes[type] = (sizes[type] || 0) + module.size(type);\n\t\t}\n\t}\n\treturn sizes;\n};\n\n/**\n * @param {Chunk} a chunk\n * @param {Chunk} b chunk\n * @returns {boolean} true, if a is always a parent of b\n */\nconst isAvailableChunk = (a, b) => {\n\tconst queue = new Set(b.groupsIterable);\n\tfor (const chunkGroup of queue) {\n\t\tif (a.isInGroup(chunkGroup)) continue;\n\t\tif (chunkGroup.isInitial()) return false;\n\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\tqueue.add(parent);\n\t\t}\n\t}\n\treturn true;\n};\n\nclass ChunkGraphModule {\n\tconstructor() {\n\t\t/** @type {SortableSet<Chunk>} */\n\t\tthis.chunks = new SortableSet();\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.entryInChunks = undefined;\n\t\t/** @type {Set<Chunk> | undefined} */\n\t\tthis.runtimeInChunks = undefined;\n\t\t/** @type {RuntimeSpecMap<ModuleHashInfo>} */\n\t\tthis.hashes = undefined;\n\t\t/** @type {string | number} */\n\t\tthis.id = null;\n\t\t/** @type {RuntimeSpecMap<Set<string>> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashes = undefined;\n\t\t/** @type {RuntimeSpecMap<string>} */\n\t\tthis.graphHashesWithConnections = undefined;\n\t}\n}\n\nclass ChunkGraphChunk {\n\tconstructor() {\n\t\t/** @type {SortableSet<Module>} */\n\t\tthis.modules = new SortableSet();\n\t\t/** @type {WeakMap<Module, Set<string>> | undefined} */\n\t\tthis.sourceTypesByModule = undefined;\n\t\t/** @type {Map<Module, Entrypoint>} */\n\t\tthis.entryModules = new Map();\n\t\t/** @type {SortableSet<RuntimeModule>} */\n\t\tthis.runtimeModules = new SortableSet();\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.fullHashModules = undefined;\n\t\t/** @type {Set<RuntimeModule> | undefined} */\n\t\tthis.dependentHashModules = undefined;\n\t\t/** @type {Set<string> | undefined} */\n\t\tthis.runtimeRequirements = undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.runtimeRequirementsInTree = new Set();\n\n\t\tthis._modulesBySourceType = defaultModulesBySourceType;\n\t}\n}\n\nclass ChunkGraph {\n\t/**\n\t * @param {ModuleGraph} moduleGraph the module graph\n\t * @param {string | Hash} hashFunction the hash function to use\n\t */\n\tconstructor(moduleGraph, hashFunction = \"md4\") {\n\t\t/** @private @type {WeakMap<Module, ChunkGraphModule>} */\n\t\tthis._modules = new WeakMap();\n\t\t/** @private @type {WeakMap<Chunk, ChunkGraphChunk>} */\n\t\tthis._chunks = new WeakMap();\n\t\t/** @private @type {WeakMap<AsyncDependenciesBlock, ChunkGroup>} */\n\t\tthis._blockChunkGroups = new WeakMap();\n\t\t/** @private @type {Map<string, string | number>} */\n\t\tthis._runtimeIds = new Map();\n\t\t/** @type {ModuleGraph} */\n\t\tthis.moduleGraph = moduleGraph;\n\n\t\tthis._hashFunction = hashFunction;\n\n\t\tthis._getGraphRoots = this._getGraphRoots.bind(this);\n\t}\n\n\t/**\n\t * @private\n\t * @param {Module} module the module\n\t * @returns {ChunkGraphModule} internal module\n\t */\n\t_getChunkGraphModule(module) {\n\t\tlet cgm = this._modules.get(module);\n\t\tif (cgm === undefined) {\n\t\t\tcgm = new ChunkGraphModule();\n\t\t\tthis._modules.set(module, cgm);\n\t\t}\n\t\treturn cgm;\n\t}\n\n\t/**\n\t * @private\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ChunkGraphChunk} internal chunk\n\t */\n\t_getChunkGraphChunk(chunk) {\n\t\tlet cgc = this._chunks.get(chunk);\n\t\tif (cgc === undefined) {\n\t\t\tcgc = new ChunkGraphChunk();\n\t\t\tthis._chunks.set(chunk, cgc);\n\t\t}\n\t\treturn cgc;\n\t}\n\n\t/**\n\t * @param {SortableSet<Module>} set the sortable Set to get the roots of\n\t * @returns {Module[]} the graph roots\n\t */\n\t_getGraphRoots(set) {\n\t\tconst { moduleGraph } = this;\n\t\treturn Array.from(\n\t\t\tfindGraphRoots(set, module => {\n\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\tconst set = new Set();\n\t\t\t\tconst addDependencies = module => {\n\t\t\t\t\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\n\t\t\t\t\t\tif (!connection.module) continue;\n\t\t\t\t\t\tconst activeState = connection.getActiveState(undefined);\n\t\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n\t\t\t\t\t\t\taddDependencies(connection.module);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset.add(connection.module);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\taddDependencies(module);\n\t\t\t\treturn set;\n\t\t\t})\n\t\t).sort(compareModulesByIdentifier);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.chunks.add(chunk);\n\t\tcgc.modules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.delete(module);\n\t\t// No need to invalidate cgc._modulesBySourceType because we modified cgc.modules anyway\n\t\tif (cgc.sourceTypesByModule) cgc.sourceTypesByModule.delete(module);\n\t\tcgm.chunks.delete(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk which will be disconnected\n\t * @returns {void}\n\t */\n\tdisconnectChunk(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.modules) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.chunks.delete(chunk);\n\t\t}\n\t\tcgc.modules.clear();\n\t\tchunk.disconnectFromGroups();\n\t\tChunkGraph.clearChunkGraphForChunk(chunk);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<Module>} modules the modules\n\t * @returns {void}\n\t */\n\tattachModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.modules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the runtime modules\n\t * @returns {void}\n\t */\n\tattachRuntimeModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of modules) {\n\t\t\tcgc.runtimeModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachFullHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.fullHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<RuntimeModule>} modules the modules that require a full hash\n\t * @returns {void}\n\t */\n\tattachDependentHashModules(chunk, modules) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tfor (const module of modules) {\n\t\t\tcgc.dependentHashModules.add(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} oldModule the replaced module\n\t * @param {Module} newModule the replacing module\n\t * @returns {void}\n\t */\n\treplaceModule(oldModule, newModule) {\n\t\tconst oldCgm = this._getChunkGraphModule(oldModule);\n\t\tconst newCgm = this._getChunkGraphModule(newModule);\n\n\t\tfor (const chunk of oldCgm.chunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.modules.delete(oldModule);\n\t\t\tcgc.modules.add(newModule);\n\t\t\tnewCgm.chunks.add(chunk);\n\t\t}\n\t\toldCgm.chunks.clear();\n\n\t\tif (oldCgm.entryInChunks !== undefined) {\n\t\t\tif (newCgm.entryInChunks === undefined) {\n\t\t\t\tnewCgm.entryInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.entryInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tconst old = cgc.entryModules.get(oldModule);\n\t\t\t\t/** @type {Map<Module, Entrypoint>} */\n\t\t\t\tconst newEntryModules = new Map();\n\t\t\t\tfor (const [m, cg] of cgc.entryModules) {\n\t\t\t\t\tif (m === oldModule) {\n\t\t\t\t\t\tnewEntryModules.set(newModule, old);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewEntryModules.set(m, cg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcgc.entryModules = newEntryModules;\n\t\t\t\tnewCgm.entryInChunks.add(chunk);\n\t\t\t}\n\t\t\toldCgm.entryInChunks = undefined;\n\t\t}\n\n\t\tif (oldCgm.runtimeInChunks !== undefined) {\n\t\t\tif (newCgm.runtimeInChunks === undefined) {\n\t\t\t\tnewCgm.runtimeInChunks = new Set();\n\t\t\t}\n\t\t\tfor (const chunk of oldCgm.runtimeInChunks) {\n\t\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\t\tcgc.runtimeModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\tcgc.runtimeModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\tnewCgm.runtimeInChunks.add(chunk);\n\t\t\t\tif (\n\t\t\t\t\tcgc.fullHashModules !== undefined &&\n\t\t\t\t\tcgc.fullHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.fullHashModules.delete(/** @type {RuntimeModule} */ (oldModule));\n\t\t\t\t\tcgc.fullHashModules.add(/** @type {RuntimeModule} */ (newModule));\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tcgc.dependentHashModules !== undefined &&\n\t\t\t\t\tcgc.dependentHashModules.has(/** @type {RuntimeModule} */ (oldModule))\n\t\t\t\t) {\n\t\t\t\t\tcgc.dependentHashModules.delete(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (oldModule)\n\t\t\t\t\t);\n\t\t\t\t\tcgc.dependentHashModules.add(\n\t\t\t\t\t\t/** @type {RuntimeModule} */ (newModule)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\toldCgm.runtimeInChunks = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.has(module);\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {ChunkGroup} chunkGroup the checked chunk group\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tisModuleInChunkGroup(module, chunkGroup) {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tif (this.isModuleInChunk(module, chunk)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @returns {boolean} true, if the module is entry of any chunk\n\t */\n\tisEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.entryInChunks !== undefined;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetModuleChunksIterable(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {function(Chunk, Chunk): -1|0|1} sortFn sort function\n\t * @returns {Iterable<Chunk>} iterable of chunks (do not modify)\n\t */\n\tgetOrderedModuleChunksIterable(module, sortFn) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.chunks.sortWith(sortFn);\n\t\treturn cgm.chunks;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {Chunk[]} array of chunks (cached, do not modify)\n\t */\n\tgetModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromCache(getArray);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {number} the number of chunk which contain the module\n\t */\n\tgetNumberOfModuleChunks(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.size;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {RuntimeSpecSet} runtimes\n\t */\n\tgetModuleRuntimes(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.chunks.getFromUnorderedCache(getModuleRuntimes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the number of full hash modules which are contained in this chunk\n\t */\n\tgetNumberOfChunkFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules === undefined ? 0 : cgc.fullHashModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetChunkModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetChunkModulesIterableBySourceType(chunk, sourceType) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(cgc._modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk chunk\n\t * @param {Module} module chunk module\n\t * @param {Set<string>} sourceTypes source types\n\t */\n\tsetChunkModuleSourceTypes(chunk, module, sourceTypes) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.sourceTypesByModule === undefined) {\n\t\t\tcgc.sourceTypesByModule = new WeakMap();\n\t\t}\n\t\tcgc.sourceTypesByModule.set(module, sourceTypes);\n\t\t// Update cgc._modulesBySourceType to invalidate the cache\n\t\tcgc._modulesBySourceType = modulesBySourceType(cgc.sourceTypesByModule);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk chunk\n\t * @param {Module} module chunk module\n\t * @returns {Set<string>} source types\n\t */\n\tgetChunkModuleSourceTypes(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.sourceTypesByModule === undefined) {\n\t\t\treturn module.getSourceTypes();\n\t\t}\n\t\treturn cgc.sourceTypesByModule.get(module) || module.getSourceTypes();\n\t}\n\n\t/**\n\t * @param {Module} module module\n\t * @returns {Set<string>} source types\n\t */\n\tgetModuleSourceTypes(module) {\n\t\treturn (\n\t\t\tthis._getOverwrittenModuleSourceTypes(module) || module.getSourceTypes()\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module module\n\t * @returns {Set<string> | undefined} source types\n\t */\n\t_getOverwrittenModuleSourceTypes(module) {\n\t\tlet newSet = false;\n\t\tlet sourceTypes;\n\t\tfor (const chunk of this.getModuleChunksIterable(module)) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tif (cgc.sourceTypesByModule === undefined) return;\n\t\t\tconst st = cgc.sourceTypesByModule.get(module);\n\t\t\tif (st === undefined) return;\n\t\t\tif (!sourceTypes) {\n\t\t\t\tsourceTypes = st;\n\t\t\t\tcontinue;\n\t\t\t} else if (!newSet) {\n\t\t\t\tfor (const type of st) {\n\t\t\t\t\tif (!newSet) {\n\t\t\t\t\t\tif (!sourceTypes.has(type)) {\n\t\t\t\t\t\t\tnewSet = true;\n\t\t\t\t\t\t\tsourceTypes = new Set(sourceTypes);\n\t\t\t\t\t\t\tsourceTypes.add(type);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsourceTypes.add(type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const type of st) sourceTypes.add(type);\n\t\t\t}\n\t\t}\n\n\t\treturn sourceTypes;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module>} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterable(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgc.modules.sortWith(comparator);\n\t\treturn cgc.modules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} sourceType source type\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Iterable<Module> | undefined} return the modules for this chunk\n\t */\n\tgetOrderedChunkModulesIterableBySourceType(chunk, sourceType, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesWithSourceType = cgc.modules\n\t\t\t.getFromUnorderedCache(cgc._modulesBySourceType)\n\t\t\t.get(sourceType);\n\t\tif (modulesWithSourceType === undefined) return undefined;\n\t\tmodulesWithSourceType.sortWith(comparator);\n\t\treturn modulesWithSourceType;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetChunkModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getArray);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {function(Module, Module): -1|0|1} comparator comparator function\n\t * @returns {Module[]} return the modules for this chunk (cached, do not modify)\n\t */\n\tgetOrderedChunkModules(chunk, comparator) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst arrayFunction = createOrderedArrayFunction(comparator);\n\t\treturn cgc.modules.getFromUnorderedCache(arrayFunction);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, (string|number)[]>} chunk to module ids object\n\t */\n\tgetChunkModuleIdMap(chunk, filterFn, includeAllChunks = false) {\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tarray.push(moduleId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleIdMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @param {number} hashLength length of the hash\n\t * @param {boolean} includeAllChunks all chunks or only async chunks\n\t * @returns {Record<string|number, Record<string|number, string>>} chunk to module id to module hash object\n\t */\n\tgetChunkModuleRenderedHashMap(\n\t\tchunk,\n\t\tfilterFn,\n\t\thashLength = 0,\n\t\tincludeAllChunks = false\n\t) {\n\t\t/** @type {Record<string|number, Record<string|number, string>>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const asyncChunk of includeAllChunks\n\t\t\t? chunk.getAllReferencedChunks()\n\t\t\t: chunk.getAllAsyncChunks()) {\n\t\t\t/** @type {Record<string|number, string>} */\n\t\t\tlet idToHashMap;\n\t\t\tfor (const module of this.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(this)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (idToHashMap === undefined) {\n\t\t\t\t\t\tidToHashMap = Object.create(null);\n\t\t\t\t\t\tchunkModuleHashMap[asyncChunk.id] = idToHashMap;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = this.getModuleId(module);\n\t\t\t\t\tconst hash = this.getRenderedModuleHash(module, asyncChunk.runtime);\n\t\t\t\t\tidToHashMap[moduleId] = hashLength ? hash.slice(0, hashLength) : hash;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunkModuleHashMap;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkFilterPredicate} filterFn function used to filter chunks\n\t * @returns {Record<string|number, boolean>} chunk map\n\t */\n\tgetChunkConditionMap(chunk, filterFn) {\n\t\tconst map = Object.create(null);\n\t\tfor (const c of chunk.getAllReferencedChunks()) {\n\t\t\tmap[c.id] = filterFn(c, this);\n\t\t}\n\t\treturn map;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(chunk, filterFn, filterChunkFn) {\n\t\tconst queue = new Set(chunk.groupsIterable);\n\t\tconst chunksProcessed = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const innerChunk of chunkGroup.chunks) {\n\t\t\t\tif (!chunksProcessed.has(innerChunk)) {\n\t\t\t\t\tchunksProcessed.add(innerChunk);\n\t\t\t\t\tif (!filterChunkFn || filterChunkFn(innerChunk, this)) {\n\t\t\t\t\t\tfor (const module of this.getChunkModulesIterable(innerChunk)) {\n\t\t\t\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA first chunk\n\t * @param {Chunk} chunkB second chunk\n\t * @returns {-1|0|1} this is a comparator function like sort and returns -1, 0, or 1 based on sort order\n\t */\n\tcompareChunks(chunkA, chunkB) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tif (cgcA.modules.size > cgcB.modules.size) return -1;\n\t\tif (cgcA.modules.size < cgcB.modules.size) return 1;\n\t\tcgcA.modules.sortWith(compareModulesByIdentifier);\n\t\tcgcB.modules.sortWith(compareModulesByIdentifier);\n\t\treturn compareModuleIterables(cgcA.modules, cgcB.modules);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} total size of all modules in the chunk\n\t */\n\tgetChunkModulesSize(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSize);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Record<string, number>} total sizes of all modules in the chunk by source type\n\t */\n\tgetChunkModulesSizes(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(getModulesSizes);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Module[]} root modules of the chunks (ordered by identifier)\n\t */\n\tgetChunkRootModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.modules.getFromUnorderedCache(this._getGraphRoots);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk\n\t */\n\tgetChunkSize(chunk, options = {}) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst modulesSize = cgc.modules.getFromUnorderedCache(getModulesSize);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize * (chunk.canBeInitial() ? entryChunkMultiplicator : 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk or false if chunks can't be integrated\n\t */\n\tgetIntegratedChunksSize(chunkA, chunkB, options = {}) {\n\t\tconst cgcA = this._getChunkGraphChunk(chunkA);\n\t\tconst cgcB = this._getChunkGraphChunk(chunkB);\n\t\tconst allModules = new Set(cgcA.modules);\n\t\tfor (const m of cgcB.modules) allModules.add(m);\n\t\tlet modulesSize = getModulesSize(allModules);\n\t\tconst chunkOverhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst entryChunkMultiplicator =\n\t\t\ttypeof options.entryChunkMultiplicator === \"number\"\n\t\t\t\t? options.entryChunkMultiplicator\n\t\t\t\t: 10;\n\t\treturn (\n\t\t\tchunkOverhead +\n\t\t\tmodulesSize *\n\t\t\t\t(chunkA.canBeInitial() || chunkB.canBeInitial()\n\t\t\t\t\t? entryChunkMultiplicator\n\t\t\t\t\t: 1)\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA chunk\n\t * @param {Chunk} chunkB chunk\n\t * @returns {boolean} true, if chunks could be integrated\n\t */\n\tcanChunksBeIntegrated(chunkA, chunkB) {\n\t\tif (chunkA.preventIntegration || chunkB.preventIntegration) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst hasRuntimeA = chunkA.hasRuntime();\n\t\tconst hasRuntimeB = chunkB.hasRuntime();\n\n\t\tif (hasRuntimeA !== hasRuntimeB) {\n\t\t\tif (hasRuntimeA) {\n\t\t\t\treturn isAvailableChunk(chunkA, chunkB);\n\t\t\t} else if (hasRuntimeB) {\n\t\t\t\treturn isAvailableChunk(chunkB, chunkA);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ||\n\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} chunkA the target chunk\n\t * @param {Chunk} chunkB the chunk to integrate\n\t * @returns {void}\n\t */\n\tintegrateChunks(chunkA, chunkB) {\n\t\t// Decide for one name (deterministic)\n\t\tif (chunkA.name && chunkB.name) {\n\t\t\tif (\n\t\t\t\tthis.getNumberOfEntryModules(chunkA) > 0 ===\n\t\t\t\tthis.getNumberOfEntryModules(chunkB) > 0\n\t\t\t) {\n\t\t\t\t// When both chunks have entry modules or none have one, use\n\t\t\t\t// shortest name\n\t\t\t\tif (chunkA.name.length !== chunkB.name.length) {\n\t\t\t\t\tchunkA.name =\n\t\t\t\t\t\tchunkA.name.length < chunkB.name.length ? chunkA.name : chunkB.name;\n\t\t\t\t} else {\n\t\t\t\t\tchunkA.name = chunkA.name < chunkB.name ? chunkA.name : chunkB.name;\n\t\t\t\t}\n\t\t\t} else if (this.getNumberOfEntryModules(chunkB) > 0) {\n\t\t\t\t// Pick the name of the chunk with the entry module\n\t\t\t\tchunkA.name = chunkB.name;\n\t\t\t}\n\t\t} else if (chunkB.name) {\n\t\t\tchunkA.name = chunkB.name;\n\t\t}\n\n\t\t// Merge id name hints\n\t\tfor (const hint of chunkB.idNameHints) {\n\t\t\tchunkA.idNameHints.add(hint);\n\t\t}\n\n\t\t// Merge runtime\n\t\tchunkA.runtime = mergeRuntime(chunkA.runtime, chunkB.runtime);\n\n\t\t// getChunkModules is used here to create a clone, because disconnectChunkAndModule modifies\n\t\tfor (const module of this.getChunkModules(chunkB)) {\n\t\t\tthis.disconnectChunkAndModule(chunkB, module);\n\t\t\tthis.connectChunkAndModule(chunkA, module);\n\t\t}\n\n\t\tfor (const [module, chunkGroup] of Array.from(\n\t\t\tthis.getChunkEntryModulesWithChunkGroupIterable(chunkB)\n\t\t)) {\n\t\t\tthis.disconnectChunkAndEntryModule(chunkB, module);\n\t\t\tthis.connectChunkAndEntryModule(chunkA, module, chunkGroup);\n\t\t}\n\n\t\tfor (const chunkGroup of chunkB.groupsIterable) {\n\t\t\tchunkGroup.replaceChunk(chunkB, chunkA);\n\t\t\tchunkA.addGroup(chunkGroup);\n\t\t\tchunkB.removeGroup(chunkGroup);\n\t\t}\n\t\tChunkGraph.clearChunkGraphForChunk(chunkB);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to upgrade\n\t * @returns {void}\n\t */\n\tupgradeDependentToFullHashModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined) return;\n\t\tif (cgc.fullHashModules === undefined) {\n\t\t\tcgc.fullHashModules = cgc.dependentHashModules;\n\t\t} else {\n\t\t\tfor (const m of cgc.dependentHashModules) {\n\t\t\t\tcgc.fullHashModules.add(m);\n\t\t\t}\n\t\t\tcgc.dependentHashModules = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the checked module\n\t * @param {Chunk} chunk the checked chunk\n\t * @returns {boolean} true, if the chunk contains the module as entry\n\t */\n\tisEntryModuleInChunk(module, chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.has(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @param {Entrypoint=} entrypoint the chunk group which must be loaded before the module is executed\n\t * @returns {void}\n\t */\n\tconnectChunkAndEntryModule(chunk, module, entrypoint) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.entryInChunks === undefined) {\n\t\t\tcgm.entryInChunks = new Set();\n\t\t}\n\t\tcgm.entryInChunks.add(chunk);\n\t\tcgc.entryModules.set(module, entrypoint);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgm.runtimeInChunks === undefined) {\n\t\t\tcgm.runtimeInChunks = new Set();\n\t\t}\n\t\tcgm.runtimeInChunks.add(chunk);\n\t\tcgc.runtimeModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddFullHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.fullHashModules === undefined) cgc.fullHashModules = new Set();\n\t\tcgc.fullHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the module that require a full hash\n\t * @returns {void}\n\t */\n\taddDependentHashModuleToChunk(chunk, module) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tif (cgc.dependentHashModules === undefined)\n\t\t\tcgc.dependentHashModules = new Set();\n\t\tcgc.dependentHashModules.add(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {Module} module the entry module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndEntryModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.entryInChunks.delete(chunk);\n\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\tcgm.entryInChunks = undefined;\n\t\t}\n\t\tcgc.entryModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the new chunk\n\t * @param {RuntimeModule} module the runtime module\n\t * @returns {void}\n\t */\n\tdisconnectChunkAndRuntimeModule(chunk, module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tcgm.runtimeInChunks.delete(chunk);\n\t\tif (cgm.runtimeInChunks.size === 0) {\n\t\t\tcgm.runtimeInChunks = undefined;\n\t\t}\n\t\tcgc.runtimeModules.delete(module);\n\t}\n\n\t/**\n\t * @param {Module} module the entry module, it will no longer be entry\n\t * @returns {void}\n\t */\n\tdisconnectEntryModule(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tfor (const chunk of cgm.entryInChunks) {\n\t\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\t\tcgc.entryModules.delete(module);\n\t\t}\n\t\tcgm.entryInChunks = undefined;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk, for which all entries will be removed\n\t * @returns {void}\n\t */\n\tdisconnectEntries(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const module of cgc.entryModules.keys()) {\n\t\t\tconst cgm = this._getChunkGraphModule(module);\n\t\t\tcgm.entryInChunks.delete(chunk);\n\t\t\tif (cgm.entryInChunks.size === 0) {\n\t\t\t\tcgm.entryInChunks = undefined;\n\t\t\t}\n\t\t}\n\t\tcgc.entryModules.clear();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfEntryModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {number} the amount of entry modules in chunk\n\t */\n\tgetNumberOfRuntimeModules(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules.size;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Module>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules.keys();\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<Chunk>} iterable of chunks\n\t */\n\tgetChunkEntryDependentChunksIterable(chunk) {\n\t\t/** @type {Set<Chunk>} */\n\t\tconst set = new Set();\n\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\tif (chunkGroup instanceof Entrypoint) {\n\t\t\t\tconst entrypointChunk = chunkGroup.getEntrypointChunk();\n\t\t\t\tconst cgc = this._getChunkGraphChunk(entrypointChunk);\n\t\t\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\t\t\tif (c !== chunk && c !== entrypointChunk && !c.hasRuntime()) {\n\t\t\t\t\t\t\tset.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn set;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {boolean} true, when it has dependent chunks\n\t */\n\thasChunkEntryDependentChunks(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tfor (const chunkGroup of cgc.entryModules.values()) {\n\t\t\tfor (const c of chunkGroup.chunks) {\n\t\t\t\tif (c !== chunk) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule>} iterable of modules (do not modify)\n\t */\n\tgetChunkRuntimeModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {RuntimeModule[]} array of modules in order of execution\n\t */\n\tgetChunkRuntimeModulesInOrder(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst array = Array.from(cgc.runtimeModules);\n\t\tarray.sort(\n\t\t\tconcatComparators(\n\t\t\t\tcompareSelect(\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {RuntimeModule} r runtime module\n\t\t\t\t\t * @returns {number=} stage\n\t\t\t\t\t */\n\t\t\t\t\tr => r.stage,\n\t\t\t\t\tcompareIds\n\t\t\t\t),\n\t\t\t\tcompareModulesByIdentifier\n\t\t\t)\n\t\t);\n\t\treturn array;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<RuntimeModule> | undefined} set of modules (do not modify)\n\t */\n\tgetChunkFullHashModulesSet(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.fullHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<RuntimeModule> | undefined} iterable of modules (do not modify)\n\t */\n\tgetChunkDependentHashModulesIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.dependentHashModules;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {Iterable<EntryModuleWithChunkGroup>} iterable of modules (do not modify)\n\t */\n\tgetChunkEntryModulesWithChunkGroupIterable(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.entryModules;\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @returns {ChunkGroup} the chunk group\n\t */\n\tgetBlockChunkGroup(depBlock) {\n\t\treturn this._blockChunkGroups.get(depBlock);\n\t}\n\n\t/**\n\t * @param {AsyncDependenciesBlock} depBlock the async block\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tconnectBlockAndChunkGroup(depBlock, chunkGroup) {\n\t\tthis._blockChunkGroups.set(depBlock, chunkGroup);\n\t\tchunkGroup.addBlock(depBlock);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunk group\n\t * @returns {void}\n\t */\n\tdisconnectChunkGroup(chunkGroup) {\n\t\tfor (const block of chunkGroup.blocksIterable) {\n\t\t\tthis._blockChunkGroups.delete(block);\n\t\t}\n\t\t// TODO refactor by moving blocks list into ChunkGraph\n\t\tchunkGroup._blocks.clear();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {string | number} the id of the module\n\t */\n\tgetModuleId(module) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn cgm.id;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {string | number} id the id of the module\n\t * @returns {void}\n\t */\n\tsetModuleId(module, id) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tcgm.id = id;\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @returns {string | number} the id of the runtime\n\t */\n\tgetRuntimeId(runtime) {\n\t\treturn this._runtimeIds.get(runtime);\n\t}\n\n\t/**\n\t * @param {string} runtime runtime\n\t * @param {string | number} id the id of the runtime\n\t * @returns {void}\n\t */\n\tsetRuntimeId(runtime, id) {\n\t\tthis._runtimeIds.set(runtime, id);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {Module} module the module\n\t * @param {RuntimeSpecMap<T>} hashes hashes data\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {T} hash\n\t */\n\t_getModuleHashInfo(module, hashes, runtime) {\n\t\tif (!hashes) {\n\t\t\tthrow new Error(\n\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\truntime\n\t\t\t\t)} (hashes not set at all)`\n\t\t\t);\n\t\t} else if (runtime === undefined) {\n\t\t\tconst hashInfoItems = new Set(hashes.values());\n\t\t\tif (hashInfoItems.size !== 1) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`No unique hash info entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t\t).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn first(hashInfoItems);\n\t\t} else {\n\t\t\tconst hashInfo = hashes.get(runtime);\n\t\t\tif (!hashInfo) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Module ${module.identifier()} has no hash info for runtime ${runtimeToString(\n\t\t\t\t\t\truntime\n\t\t\t\t\t)} (available runtimes ${Array.from(\n\t\t\t\t\t\thashes.keys(),\n\t\t\t\t\t\truntimeToString\n\t\t\t\t\t).join(\", \")})`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn hashInfo;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {boolean} true, if the module has hashes for this runtime\n\t */\n\thasModuleHashes(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn hashes && hashes.has(runtime);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).hash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\tgetRenderedModuleHash(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst hashes = cgm.hashes;\n\t\treturn this._getModuleHashInfo(module, hashes, runtime).renderedHash;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {string} hash the full hash\n\t * @param {string} renderedHash the shortened hash for rendering\n\t * @returns {void}\n\t */\n\tsetModuleHashes(module, runtime, hash, renderedHash) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tif (cgm.hashes === undefined) {\n\t\t\tcgm.hashes = new RuntimeSpecMap();\n\t\t}\n\t\tcgm.hashes.set(runtime, new ModuleHashInfo(hash, renderedHash));\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph when transferOwnership not false)\n\t * @param {boolean} transferOwnership true: transfer ownership of the items object, false: items is immutable and shared and won't be modified\n\t * @returns {void}\n\t */\n\taddModuleRuntimeRequirements(\n\t\tmodule,\n\t\truntime,\n\t\titems,\n\t\ttransferOwnership = true\n\t) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirementsMap = cgm.runtimeRequirements;\n\t\tif (runtimeRequirementsMap === undefined) {\n\t\t\tconst map = new RuntimeSpecMap();\n\t\t\t// TODO avoid cloning item and track ownership instead\n\t\t\tmap.set(runtime, transferOwnership ? items : new Set(items));\n\t\t\tcgm.runtimeRequirements = map;\n\t\t\treturn;\n\t\t}\n\t\truntimeRequirementsMap.update(runtime, runtimeRequirements => {\n\t\t\tif (runtimeRequirements === undefined) {\n\t\t\t\treturn transferOwnership ? items : new Set(items);\n\t\t\t} else if (!transferOwnership || runtimeRequirements.size >= items.size) {\n\t\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t\t\treturn runtimeRequirements;\n\t\t\t} else {\n\t\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\t\treturn items;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Set<string>} items runtime requirements to be added (ownership of this Set is given to ChunkGraph)\n\t * @returns {void}\n\t */\n\taddChunkRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\tif (runtimeRequirements === undefined) {\n\t\t\tcgc.runtimeRequirements = items;\n\t\t} else if (runtimeRequirements.size >= items.size) {\n\t\t\tfor (const item of items) runtimeRequirements.add(item);\n\t\t} else {\n\t\t\tfor (const item of runtimeRequirements) items.add(item);\n\t\t\tcgc.runtimeRequirements = items;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {Iterable<string>} items runtime requirements to be added\n\t * @returns {void}\n\t */\n\taddTreeRuntimeRequirements(chunk, items) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirementsInTree;\n\t\tfor (const item of items) runtimeRequirements.add(item);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetModuleRuntimeRequirements(module, runtime) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\tconst runtimeRequirements =\n\t\t\tcgm.runtimeRequirements && cgm.runtimeRequirements.get(runtime);\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetChunkRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\tconst runtimeRequirements = cgc.runtimeRequirements;\n\t\treturn runtimeRequirements === undefined ? EMPTY_SET : runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {string} hash\n\t */\n\tgetModuleGraphHash(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? this._getModuleGraphHashWithConnections(cgm, module, runtime)\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime).toString(16);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @param {boolean} withConnections include connections\n\t * @returns {bigint} hash\n\t */\n\tgetModuleGraphHashBigInt(module, runtime, withConnections = true) {\n\t\tconst cgm = this._getChunkGraphModule(module);\n\t\treturn withConnections\n\t\t\t? BigInt(\n\t\t\t\t\t`0x${this._getModuleGraphHashWithConnections(cgm, module, runtime)}`\n\t\t\t  )\n\t\t\t: this._getModuleGraphHashBigInt(cgm, module, runtime);\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {bigint} hash as big int\n\t */\n\t_getModuleGraphHashBigInt(cgm, module, runtime) {\n\t\tif (cgm.graphHashes === undefined) {\n\t\t\tcgm.graphHashes = new RuntimeSpecMap();\n\t\t}\n\t\tconst graphHash = cgm.graphHashes.provide(runtime, () => {\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\thash.update(`${cgm.id}${this.moduleGraph.isAsync(module)}`);\n\t\t\tconst sourceTypes = this._getOverwrittenModuleSourceTypes(module);\n\t\t\tif (sourceTypes !== undefined) {\n\t\t\t\tfor (const type of sourceTypes) hash.update(type);\n\t\t\t}\n\t\t\tthis.moduleGraph.getExportsInfo(module).updateHash(hash, runtime);\n\t\t\treturn BigInt(`0x${/** @type {string} */ (hash.digest(\"hex\"))}`);\n\t\t});\n\t\treturn graphHash;\n\t}\n\n\t/**\n\t * @param {ChunkGraphModule} cgm the ChunkGraphModule\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime the runtime\n\t * @returns {string} hash\n\t */\n\t_getModuleGraphHashWithConnections(cgm, module, runtime) {\n\t\tif (cgm.graphHashesWithConnections === undefined) {\n\t\t\tcgm.graphHashesWithConnections = new RuntimeSpecMap();\n\t\t}\n\t\tconst activeStateToString = state => {\n\t\t\tif (state === false) return \"F\";\n\t\t\tif (state === true) return \"T\";\n\t\t\tif (state === ModuleGraphConnection.TRANSITIVE_ONLY) return \"O\";\n\t\t\tthrow new Error(\"Not implemented active state\");\n\t\t};\n\t\tconst strict = module.buildMeta && module.buildMeta.strictHarmonyModule;\n\t\treturn cgm.graphHashesWithConnections.provide(runtime, () => {\n\t\t\tconst graphHash = this._getModuleGraphHashBigInt(\n\t\t\t\tcgm,\n\t\t\t\tmodule,\n\t\t\t\truntime\n\t\t\t).toString(16);\n\t\t\tconst connections = this.moduleGraph.getOutgoingConnections(module);\n\t\t\t/** @type {Set<Module>} */\n\t\t\tconst activeNamespaceModules = new Set();\n\t\t\t/** @type {Map<string, Module | Set<Module>>} */\n\t\t\tconst connectedModules = new Map();\n\t\t\tconst processConnection = (connection, stateInfo) => {\n\t\t\t\tconst module = connection.module;\n\t\t\t\tstateInfo += module.getExportsType(this.moduleGraph, strict);\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tif (stateInfo === \"Tnamespace\") activeNamespaceModules.add(module);\n\t\t\t\telse {\n\t\t\t\t\tconst oldModule = connectedModules.get(stateInfo);\n\t\t\t\t\tif (oldModule === undefined) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, module);\n\t\t\t\t\t} else if (oldModule instanceof Set) {\n\t\t\t\t\t\toldModule.add(module);\n\t\t\t\t\t} else if (oldModule !== module) {\n\t\t\t\t\t\tconnectedModules.set(stateInfo, new Set([oldModule, module]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (runtime === undefined || typeof runtime === \"string\") {\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\tprocessConnection(connection, state === true ? \"T\" : \"O\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// cspell:word Tnamespace\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst states = new Set();\n\t\t\t\t\tlet stateInfo = \"\";\n\t\t\t\t\tforEachRuntime(\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\truntime => {\n\t\t\t\t\t\t\tconst state = connection.getActiveState(runtime);\n\t\t\t\t\t\t\tstates.add(state);\n\t\t\t\t\t\t\tstateInfo += activeStateToString(state) + runtime;\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t\tif (states.size === 1) {\n\t\t\t\t\t\tconst state = first(states);\n\t\t\t\t\t\tif (state === false) continue;\n\t\t\t\t\t\tstateInfo = activeStateToString(state);\n\t\t\t\t\t}\n\t\t\t\t\tprocessConnection(connection, stateInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cspell:word Tnamespace\n\t\t\tif (activeNamespaceModules.size === 0 && connectedModules.size === 0)\n\t\t\t\treturn graphHash;\n\t\t\tconst connectedModulesInOrder =\n\t\t\t\tconnectedModules.size > 1\n\t\t\t\t\t? Array.from(connectedModules).sort(([a], [b]) => (a < b ? -1 : 1))\n\t\t\t\t\t: connectedModules;\n\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\tconst addModuleToHash = module => {\n\t\t\t\thash.update(\n\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\tthis._getChunkGraphModule(module),\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\truntime\n\t\t\t\t\t).toString(16)\n\t\t\t\t);\n\t\t\t};\n\t\t\tconst addModulesToHash = modules => {\n\t\t\t\tlet xor = ZERO_BIG_INT;\n\t\t\t\tfor (const m of modules) {\n\t\t\t\t\txor =\n\t\t\t\t\t\txor ^\n\t\t\t\t\t\tthis._getModuleGraphHashBigInt(\n\t\t\t\t\t\t\tthis._getChunkGraphModule(m),\n\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\thash.update(xor.toString(16));\n\t\t\t};\n\t\t\tif (activeNamespaceModules.size === 1)\n\t\t\t\taddModuleToHash(activeNamespaceModules.values().next().value);\n\t\t\telse if (activeNamespaceModules.size > 1)\n\t\t\t\taddModulesToHash(activeNamespaceModules);\n\t\t\tfor (const [stateInfo, modules] of connectedModulesInOrder) {\n\t\t\t\thash.update(stateInfo);\n\t\t\t\tif (modules instanceof Set) {\n\t\t\t\t\taddModulesToHash(modules);\n\t\t\t\t} else {\n\t\t\t\t\taddModuleToHash(modules);\n\t\t\t\t}\n\t\t\t}\n\t\t\thash.update(graphHash);\n\t\t\treturn /** @type {string} */ (hash.digest(\"hex\"));\n\t\t});\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetTreeRuntimeRequirements(chunk) {\n\t\tconst cgc = this._getChunkGraphChunk(chunk);\n\t\treturn cgc.runtimeRequirementsInTree;\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForModule(module, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForModuleMap.get(deprecateMessage);\n\t\tif (fn) return fn(module);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tmodule => {\n\t\t\t\tconst chunkGraph = chunkGraphForModuleMap.get(module);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\": There was no ChunkGraph assigned to the Module for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForModuleMap.set(deprecateMessage, newFn);\n\t\treturn newFn(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForModule(module, chunkGraph) {\n\t\tchunkGraphForModuleMap.set(module, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForModule(module) {\n\t\tchunkGraphForModuleMap.delete(module);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {string} deprecateMessage message for the deprecation message\n\t * @param {string} deprecationCode code for the deprecation\n\t * @returns {ChunkGraph} the chunk graph\n\t */\n\tstatic getChunkGraphForChunk(chunk, deprecateMessage, deprecationCode) {\n\t\tconst fn = deprecateGetChunkGraphForChunkMap.get(deprecateMessage);\n\t\tif (fn) return fn(chunk);\n\t\tconst newFn = util.deprecate(\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk the chunk\n\t\t\t * @returns {ChunkGraph} the chunk graph\n\t\t\t */\n\t\t\tchunk => {\n\t\t\t\tconst chunkGraph = chunkGraphForChunkMap.get(chunk);\n\t\t\t\tif (!chunkGraph)\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\tdeprecateMessage +\n\t\t\t\t\t\t\t\"There was no ChunkGraph assigned to the Chunk for backward-compat (Use the new API)\"\n\t\t\t\t\t);\n\t\t\t\treturn chunkGraph;\n\t\t\t},\n\t\t\tdeprecateMessage + \": Use new ChunkGraph API\",\n\t\t\tdeprecationCode\n\t\t);\n\t\tdeprecateGetChunkGraphForChunkMap.set(deprecateMessage, newFn);\n\t\treturn newFn(chunk);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tstatic setChunkGraphForChunk(chunk, chunkGraph) {\n\t\tchunkGraphForChunkMap.set(chunk, chunkGraph);\n\t}\n\n\t// TODO remove in webpack 6\n\t/**\n\t * @param {Chunk} chunk the chunk\n\t * @returns {void}\n\t */\n\tstatic clearChunkGraphForChunk(chunk) {\n\t\tchunkGraphForChunkMap.delete(chunk);\n\t}\n}\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Module, ChunkGraph>} */\nconst chunkGraphForModuleMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {WeakMap<Chunk, ChunkGraph>} */\nconst chunkGraphForChunkMap = new WeakMap();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (module: Module) => ChunkGraph>} */\nconst deprecateGetChunkGraphForModuleMap = new Map();\n\n// TODO remove in webpack 6\n/** @type {Map<string, (chunk: Chunk) => ChunkGraph>} */\nconst deprecateGetChunkGraphForChunkMap = new Map();\n\nmodule.exports = ChunkGraph;\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AACA,MAAMC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAA1B;;AACA,MAAME,qBAAqB,GAAGF,OAAO,CAAC,yBAAD,CAArC;;AACA,MAAM;EAAEG;AAAF,IAAYH,OAAO,CAAC,mBAAD,CAAzB;;AACA,MAAMI,WAAW,GAAGJ,OAAO,CAAC,oBAAD,CAA3B;;AACA,MAAM;EACLK,kBADK;EAELC,gBAFK;EAGLC,0BAHK;EAILC,iBAJK;EAKLC,aALK;EAMLC;AANK,IAOFV,OAAO,CAAC,oBAAD,CAPX;;AAQA,MAAMW,UAAU,GAAGX,OAAO,CAAC,mBAAD,CAA1B;;AACA,MAAMY,cAAc,GAAGZ,OAAO,CAAC,uBAAD,CAA9B;;AACA,MAAM;EACLa,cADK;EAELC,cAFK;EAGLC,eAHK;EAILC,YAJK;EAKLC;AALK,IAMFjB,OAAO,CAAC,gBAAD,CANX;AAQA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;;AACA,MAAMkB,SAAS,GAAG,IAAIC,GAAJ,EAAlB;AAEA,MAAMC,YAAY,GAAGC,MAAM,CAAC,CAAD,CAA3B;AAEA,MAAMC,sBAAsB,GAAGhB,gBAAgB,CAACC,0BAAD,CAA/C;AAEA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,MAAMgB,cAAN,CAAqB;EACpBC,WAAW,CAACC,IAAD,EAAOC,YAAP,EAAqB;IAC/B,KAAKD,IAAL,GAAYA,IAAZ;IACA,KAAKC,YAAL,GAAoBA,YAApB;EACA;;AAJmB;AAOrB;;AAEA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,QAAQ,GAAGC,GAAG,IAAI;EACvB,OAAOC,KAAK,CAACC,IAAN,CAAWF,GAAX,CAAP;AACA,CAFD;AAIA;AACA;AACA;AACA;;;AACA,MAAMG,iBAAiB,GAAGC,MAAM,IAAI;EACnC,MAAMC,QAAQ,GAAG,IAAInB,cAAJ,EAAjB;;EACA,KAAK,MAAMoB,KAAX,IAAoBF,MAApB,EAA4B;IAC3BC,QAAQ,CAACE,GAAT,CAAaD,KAAK,CAACE,OAAnB;EACA;;EACD,OAAOH,QAAP;AACA,CAND;AAQA;AACA;AACA;AACA;;;AACA,MAAMI,mBAAmB,GAAGC,mBAAmB,IAAIV,GAAG,IAAI;EACzD;EACA,MAAMW,GAAG,GAAG,IAAIC,GAAJ,EAAZ;;EACA,KAAK,MAAMC,MAAX,IAAqBb,GAArB,EAA0B;IACzB,MAAMc,WAAW,GACfJ,mBAAmB,IAAIA,mBAAmB,CAACK,GAApB,CAAwBF,MAAxB,CAAxB,IACAA,MAAM,CAACG,cAAP,EAFD;;IAGA,KAAK,MAAMC,UAAX,IAAyBH,WAAzB,EAAsC;MACrC,IAAII,QAAQ,GAAGP,GAAG,CAACI,GAAJ,CAAQE,UAAR,CAAf;;MACA,IAAIC,QAAQ,KAAKC,SAAjB,EAA4B;QAC3BD,QAAQ,GAAG,IAAI1C,WAAJ,EAAX;QACAmC,GAAG,CAACX,GAAJ,CAAQiB,UAAR,EAAoBC,QAApB;MACA;;MACDA,QAAQ,CAACX,GAAT,CAAaM,MAAb;IACA;EACD;;EACD,KAAK,MAAM,CAACO,GAAD,EAAMF,QAAN,CAAX,IAA8BP,GAA9B,EAAmC;IAClC;IACA;IACA,IAAIO,QAAQ,CAACG,IAAT,KAAkBrB,GAAG,CAACqB,IAA1B,EAAgC;MAC/BV,GAAG,CAACX,GAAJ,CAAQoB,GAAR,EAAapB,GAAb;IACA;EACD;;EACD,OAAOW,GAAP;AACA,CAxBD;;AAyBA,MAAMW,0BAA0B,GAAGb,mBAAmB,CAACU,SAAD,CAAtD;AAEA;;AACA,MAAMI,6BAA6B,GAAG,IAAIC,OAAJ,EAAtC;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,0BAA0B,GAAGC,UAAU,IAAI;EAChD;EACA,IAAIC,EAAE,GAAGJ,6BAA6B,CAACR,GAA9B,CAAkCW,UAAlC,CAAT;EACA,IAAIC,EAAE,KAAKR,SAAX,EAAsB,OAAOQ,EAAP;;EACtBA,EAAE,GAAG3B,GAAG,IAAI;IACXA,GAAG,CAAC4B,QAAJ,CAAaF,UAAb;IACA,OAAOzB,KAAK,CAACC,IAAN,CAAWF,GAAX,CAAP;EACA,CAHD;;EAIAuB,6BAA6B,CAACvB,GAA9B,CAAkC0B,UAAlC,EAA8CC,EAA9C;EACA,OAAOA,EAAP;AACA,CAVD;AAYA;AACA;AACA;AACA;;;AACA,MAAME,cAAc,GAAGC,OAAO,IAAI;EACjC,IAAIT,IAAI,GAAG,CAAX;;EACA,KAAK,MAAMR,MAAX,IAAqBiB,OAArB,EAA8B;IAC7B,KAAK,MAAMC,IAAX,IAAmBlB,MAAM,CAACG,cAAP,EAAnB,EAA4C;MAC3CK,IAAI,IAAIR,MAAM,CAACQ,IAAP,CAAYU,IAAZ,CAAR;IACA;EACD;;EACD,OAAOV,IAAP;AACA,CARD;AAUA;AACA;AACA;AACA;;;AACA,MAAMW,eAAe,GAAGF,OAAO,IAAI;EAClC,IAAIG,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAZ;;EACA,KAAK,MAAMtB,MAAX,IAAqBiB,OAArB,EAA8B;IAC7B,KAAK,MAAMC,IAAX,IAAmBlB,MAAM,CAACG,cAAP,EAAnB,EAA4C;MAC3CiB,KAAK,CAACF,IAAD,CAAL,GAAc,CAACE,KAAK,CAACF,IAAD,CAAL,IAAe,CAAhB,IAAqBlB,MAAM,CAACQ,IAAP,CAAYU,IAAZ,CAAnC;IACA;EACD;;EACD,OAAOE,KAAP;AACA,CARD;AAUA;AACA;AACA;AACA;AACA;;;AACA,MAAMG,gBAAgB,GAAG,CAACC,CAAD,EAAIC,CAAJ,KAAU;EAClC,MAAMC,KAAK,GAAG,IAAIhD,GAAJ,CAAQ+C,CAAC,CAACE,cAAV,CAAd;;EACA,KAAK,MAAMC,UAAX,IAAyBF,KAAzB,EAAgC;IAC/B,IAAIF,CAAC,CAACK,SAAF,CAAYD,UAAZ,CAAJ,EAA6B;IAC7B,IAAIA,UAAU,CAACE,SAAX,EAAJ,EAA4B,OAAO,KAAP;;IAC5B,KAAK,MAAMC,MAAX,IAAqBH,UAAU,CAACI,eAAhC,EAAiD;MAChDN,KAAK,CAAChC,GAAN,CAAUqC,MAAV;IACA;EACD;;EACD,OAAO,IAAP;AACA,CAVD;;AAYA,MAAME,gBAAN,CAAuB;EACtBlD,WAAW,GAAG;IACb;IACA,KAAKQ,MAAL,GAAc,IAAI5B,WAAJ,EAAd;IACA;;IACA,KAAKuE,aAAL,GAAqB5B,SAArB;IACA;;IACA,KAAK6B,eAAL,GAAuB7B,SAAvB;IACA;;IACA,KAAK8B,MAAL,GAAc9B,SAAd;IACA;;IACA,KAAK+B,EAAL,GAAU,IAAV;IACA;;IACA,KAAKC,mBAAL,GAA2BhC,SAA3B;IACA;;IACA,KAAKiC,WAAL,GAAmBjC,SAAnB;IACA;;IACA,KAAKkC,0BAAL,GAAkClC,SAAlC;EACA;;AAlBqB;;AAqBvB,MAAMmC,eAAN,CAAsB;EACrB1D,WAAW,GAAG;IACb;IACA,KAAKkC,OAAL,GAAe,IAAItD,WAAJ,EAAf;IACA;;IACA,KAAKkC,mBAAL,GAA2BS,SAA3B;IACA;;IACA,KAAKoC,YAAL,GAAoB,IAAI3C,GAAJ,EAApB;IACA;;IACA,KAAK4C,cAAL,GAAsB,IAAIhF,WAAJ,EAAtB;IACA;;IACA,KAAKiF,eAAL,GAAuBtC,SAAvB;IACA;;IACA,KAAKuC,oBAAL,GAA4BvC,SAA5B;IACA;;IACA,KAAKgC,mBAAL,GAA2BhC,SAA3B;IACA;;IACA,KAAKwC,yBAAL,GAAiC,IAAIpE,GAAJ,EAAjC;IAEA,KAAKqE,oBAAL,GAA4BtC,0BAA5B;EACA;;AApBoB;;AAuBtB,MAAMuC,UAAN,CAAiB;EAChB;AACD;AACA;AACA;EACCjE,WAAW,CAACkE,WAAD,EAAoC;IAAA,IAAtBC,YAAsB,uEAAP,KAAO;;IAC9C;IACA,KAAKC,QAAL,GAAgB,IAAIxC,OAAJ,EAAhB;IACA;;IACA,KAAKyC,OAAL,GAAe,IAAIzC,OAAJ,EAAf;IACA;;IACA,KAAK0C,iBAAL,GAAyB,IAAI1C,OAAJ,EAAzB;IACA;;IACA,KAAK2C,WAAL,GAAmB,IAAIvD,GAAJ,EAAnB;IACA;;IACA,KAAKkD,WAAL,GAAmBA,WAAnB;IAEA,KAAKM,aAAL,GAAqBL,YAArB;IAEA,KAAKM,cAAL,GAAsB,KAAKA,cAAL,CAAoBC,IAApB,CAAyB,IAAzB,CAAtB;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCC,oBAAoB,CAAC1D,MAAD,EAAS;IAC5B,IAAI2D,GAAG,GAAG,KAAKR,QAAL,CAAcjD,GAAd,CAAkBF,MAAlB,CAAV;;IACA,IAAI2D,GAAG,KAAKrD,SAAZ,EAAuB;MACtBqD,GAAG,GAAG,IAAI1B,gBAAJ,EAAN;;MACA,KAAKkB,QAAL,CAAchE,GAAd,CAAkBa,MAAlB,EAA0B2D,GAA1B;IACA;;IACD,OAAOA,GAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCC,mBAAmB,CAACnE,KAAD,EAAQ;IAC1B,IAAIoE,GAAG,GAAG,KAAKT,OAAL,CAAalD,GAAb,CAAiBT,KAAjB,CAAV;;IACA,IAAIoE,GAAG,KAAKvD,SAAZ,EAAuB;MACtBuD,GAAG,GAAG,IAAIpB,eAAJ,EAAN;;MACA,KAAKW,OAAL,CAAajE,GAAb,CAAiBM,KAAjB,EAAwBoE,GAAxB;IACA;;IACD,OAAOA,GAAP;EACA;EAED;AACD;AACA;AACA;;;EACCL,cAAc,CAACrE,GAAD,EAAM;IACnB,MAAM;MAAE8D;IAAF,IAAkB,IAAxB;IACA,OAAO7D,KAAK,CAACC,IAAN,CACNlB,cAAc,CAACgB,GAAD,EAAMa,MAAM,IAAI;MAC7B;MACA,MAAMb,GAAG,GAAG,IAAIT,GAAJ,EAAZ;;MACA,MAAMoF,eAAe,GAAG9D,MAAM,IAAI;QACjC,KAAK,MAAM+D,UAAX,IAAyBd,WAAW,CAACe,sBAAZ,CAAmChE,MAAnC,CAAzB,EAAqE;UACpE,IAAI,CAAC+D,UAAU,CAAC/D,MAAhB,EAAwB;UACxB,MAAMiE,WAAW,GAAGF,UAAU,CAACG,cAAX,CAA0B5D,SAA1B,CAApB;UACA,IAAI2D,WAAW,KAAK,KAApB,EAA2B;;UAC3B,IAAIA,WAAW,KAAKxG,qBAAqB,CAAC0G,eAA1C,EAA2D;YAC1DL,eAAe,CAACC,UAAU,CAAC/D,MAAZ,CAAf;YACA;UACA;;UACDb,GAAG,CAACO,GAAJ,CAAQqE,UAAU,CAAC/D,MAAnB;QACA;MACD,CAXD;;MAYA8D,eAAe,CAAC9D,MAAD,CAAf;MACA,OAAOb,GAAP;IACA,CAjBa,CADR,EAmBLiF,IAnBK,CAmBAtG,0BAnBA,CAAP;EAoBA;EAED;AACD;AACA;AACA;AACA;;;EACCuG,qBAAqB,CAAC5E,KAAD,EAAQO,MAAR,EAAgB;IACpC,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,MAAM6D,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACAkE,GAAG,CAACpE,MAAJ,CAAWG,GAAX,CAAeD,KAAf;IACAoE,GAAG,CAAC5C,OAAJ,CAAYvB,GAAZ,CAAgBM,MAAhB;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCsE,wBAAwB,CAAC7E,KAAD,EAAQO,MAAR,EAAgB;IACvC,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,MAAM6D,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACAoE,GAAG,CAAC5C,OAAJ,CAAYsD,MAAZ,CAAmBvE,MAAnB,EAHuC,CAIvC;;IACA,IAAI6D,GAAG,CAAChE,mBAAR,EAA6BgE,GAAG,CAAChE,mBAAJ,CAAwB0E,MAAxB,CAA+BvE,MAA/B;IAC7B2D,GAAG,CAACpE,MAAJ,CAAWgF,MAAX,CAAkB9E,KAAlB;EACA;EAED;AACD;AACA;AACA;;;EACC+E,eAAe,CAAC/E,KAAD,EAAQ;IACtB,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,KAAK,MAAMO,MAAX,IAAqB6D,GAAG,CAAC5C,OAAzB,EAAkC;MACjC,MAAM0C,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;MACA2D,GAAG,CAACpE,MAAJ,CAAWgF,MAAX,CAAkB9E,KAAlB;IACA;;IACDoE,GAAG,CAAC5C,OAAJ,CAAYwD,KAAZ;IACAhF,KAAK,CAACiF,oBAAN;IACA1B,UAAU,CAAC2B,uBAAX,CAAmClF,KAAnC;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCmF,aAAa,CAACnF,KAAD,EAAQwB,OAAR,EAAiB;IAC7B,MAAM4C,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,KAAK,MAAMO,MAAX,IAAqBiB,OAArB,EAA8B;MAC7B4C,GAAG,CAAC5C,OAAJ,CAAYvB,GAAZ,CAAgBM,MAAhB;IACA;EACD;EAED;AACD;AACA;AACA;AACA;;;EACC6E,oBAAoB,CAACpF,KAAD,EAAQwB,OAAR,EAAiB;IACpC,MAAM4C,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,KAAK,MAAMO,MAAX,IAAqBiB,OAArB,EAA8B;MAC7B4C,GAAG,CAAClB,cAAJ,CAAmBjD,GAAnB,CAAuBM,MAAvB;IACA;EACD;EAED;AACD;AACA;AACA;AACA;;;EACC8E,qBAAqB,CAACrF,KAAD,EAAQwB,OAAR,EAAiB;IACrC,MAAM4C,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,IAAIoE,GAAG,CAACjB,eAAJ,KAAwBtC,SAA5B,EAAuCuD,GAAG,CAACjB,eAAJ,GAAsB,IAAIlE,GAAJ,EAAtB;;IACvC,KAAK,MAAMsB,MAAX,IAAqBiB,OAArB,EAA8B;MAC7B4C,GAAG,CAACjB,eAAJ,CAAoBlD,GAApB,CAAwBM,MAAxB;IACA;EACD;EAED;AACD;AACA;AACA;AACA;;;EACC+E,0BAA0B,CAACtF,KAAD,EAAQwB,OAAR,EAAiB;IAC1C,MAAM4C,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,IAAIoE,GAAG,CAAChB,oBAAJ,KAA6BvC,SAAjC,EACCuD,GAAG,CAAChB,oBAAJ,GAA2B,IAAInE,GAAJ,EAA3B;;IACD,KAAK,MAAMsB,MAAX,IAAqBiB,OAArB,EAA8B;MAC7B4C,GAAG,CAAChB,oBAAJ,CAAyBnD,GAAzB,CAA6BM,MAA7B;IACA;EACD;EAED;AACD;AACA;AACA;AACA;;;EACCgF,aAAa,CAACC,SAAD,EAAYC,SAAZ,EAAuB;IACnC,MAAMC,MAAM,GAAG,KAAKzB,oBAAL,CAA0BuB,SAA1B,CAAf;;IACA,MAAMG,MAAM,GAAG,KAAK1B,oBAAL,CAA0BwB,SAA1B,CAAf;;IAEA,KAAK,MAAMzF,KAAX,IAAoB0F,MAAM,CAAC5F,MAA3B,EAAmC;MAClC,MAAMsE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;MACAoE,GAAG,CAAC5C,OAAJ,CAAYsD,MAAZ,CAAmBU,SAAnB;MACApB,GAAG,CAAC5C,OAAJ,CAAYvB,GAAZ,CAAgBwF,SAAhB;MACAE,MAAM,CAAC7F,MAAP,CAAcG,GAAd,CAAkBD,KAAlB;IACA;;IACD0F,MAAM,CAAC5F,MAAP,CAAckF,KAAd;;IAEA,IAAIU,MAAM,CAACjD,aAAP,KAAyB5B,SAA7B,EAAwC;MACvC,IAAI8E,MAAM,CAAClD,aAAP,KAAyB5B,SAA7B,EAAwC;QACvC8E,MAAM,CAAClD,aAAP,GAAuB,IAAIxD,GAAJ,EAAvB;MACA;;MACD,KAAK,MAAMe,KAAX,IAAoB0F,MAAM,CAACjD,aAA3B,EAA0C;QACzC,MAAM2B,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;QACA,MAAM4F,GAAG,GAAGxB,GAAG,CAACnB,YAAJ,CAAiBxC,GAAjB,CAAqB+E,SAArB,CAAZ;QACA;;QACA,MAAMK,eAAe,GAAG,IAAIvF,GAAJ,EAAxB;;QACA,KAAK,MAAM,CAACwF,CAAD,EAAIC,EAAJ,CAAX,IAAsB3B,GAAG,CAACnB,YAA1B,EAAwC;UACvC,IAAI6C,CAAC,KAAKN,SAAV,EAAqB;YACpBK,eAAe,CAACnG,GAAhB,CAAoB+F,SAApB,EAA+BG,GAA/B;UACA,CAFD,MAEO;YACNC,eAAe,CAACnG,GAAhB,CAAoBoG,CAApB,EAAuBC,EAAvB;UACA;QACD;;QACD3B,GAAG,CAACnB,YAAJ,GAAmB4C,eAAnB;QACAF,MAAM,CAAClD,aAAP,CAAqBxC,GAArB,CAAyBD,KAAzB;MACA;;MACD0F,MAAM,CAACjD,aAAP,GAAuB5B,SAAvB;IACA;;IAED,IAAI6E,MAAM,CAAChD,eAAP,KAA2B7B,SAA/B,EAA0C;MACzC,IAAI8E,MAAM,CAACjD,eAAP,KAA2B7B,SAA/B,EAA0C;QACzC8E,MAAM,CAACjD,eAAP,GAAyB,IAAIzD,GAAJ,EAAzB;MACA;;MACD,KAAK,MAAMe,KAAX,IAAoB0F,MAAM,CAAChD,eAA3B,EAA4C;QAC3C,MAAM0B,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;QACAoE,GAAG,CAAClB,cAAJ,CAAmB4B,MAAnB;QAA0B;QAA8BU,SAAxD;QACApB,GAAG,CAAClB,cAAJ,CAAmBjD,GAAnB;QAAuB;QAA8BwF,SAArD;QACAE,MAAM,CAACjD,eAAP,CAAuBzC,GAAvB,CAA2BD,KAA3B;;QACA,IACCoE,GAAG,CAACjB,eAAJ,KAAwBtC,SAAxB,IACAuD,GAAG,CAACjB,eAAJ,CAAoB6C,GAApB;QAAwB;QAA8BR,SAAtD,CAFD,EAGE;UACDpB,GAAG,CAACjB,eAAJ,CAAoB2B,MAApB;UAA2B;UAA8BU,SAAzD;UACApB,GAAG,CAACjB,eAAJ,CAAoBlD,GAApB;UAAwB;UAA8BwF,SAAtD;QACA;;QACD,IACCrB,GAAG,CAAChB,oBAAJ,KAA6BvC,SAA7B,IACAuD,GAAG,CAAChB,oBAAJ,CAAyB4C,GAAzB;QAA6B;QAA8BR,SAA3D,CAFD,EAGE;UACDpB,GAAG,CAAChB,oBAAJ,CAAyB0B,MAAzB;UACC;UAA8BU,SAD/B;UAGApB,GAAG,CAAChB,oBAAJ,CAAyBnD,GAAzB;UACC;UAA8BwF,SAD/B;QAGA;MACD;;MACDC,MAAM,CAAChD,eAAP,GAAyB7B,SAAzB;IACA;EACD;EAED;AACD;AACA;AACA;AACA;;;EACCoF,eAAe,CAAC1F,MAAD,EAASP,KAAT,EAAgB;IAC9B,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAAC5C,OAAJ,CAAYwE,GAAZ,CAAgBzF,MAAhB,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACC2F,oBAAoB,CAAC3F,MAAD,EAAS4B,UAAT,EAAqB;IACxC,KAAK,MAAMnC,KAAX,IAAoBmC,UAAU,CAACrC,MAA/B,EAAuC;MACtC,IAAI,KAAKmG,eAAL,CAAqB1F,MAArB,EAA6BP,KAA7B,CAAJ,EAAyC,OAAO,IAAP;IACzC;;IACD,OAAO,KAAP;EACA;EAED;AACD;AACA;AACA;;;EACCmG,aAAa,CAAC5F,MAAD,EAAS;IACrB,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,OAAO2D,GAAG,CAACzB,aAAJ,KAAsB5B,SAA7B;EACA;EAED;AACD;AACA;AACA;;;EACCuF,uBAAuB,CAAC7F,MAAD,EAAS;IAC/B,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,OAAO2D,GAAG,CAACpE,MAAX;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCuG,8BAA8B,CAAC9F,MAAD,EAAS+F,MAAT,EAAiB;IAC9C,MAAMpC,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA2D,GAAG,CAACpE,MAAJ,CAAWwB,QAAX,CAAoBgF,MAApB;IACA,OAAOpC,GAAG,CAACpE,MAAX;EACA;EAED;AACD;AACA;AACA;;;EACCyG,eAAe,CAAChG,MAAD,EAAS;IACvB,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,OAAO2D,GAAG,CAACpE,MAAJ,CAAW0G,YAAX,CAAwB/G,QAAxB,CAAP;EACA;EAED;AACD;AACA;AACA;;;EACCgH,uBAAuB,CAAClG,MAAD,EAAS;IAC/B,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,OAAO2D,GAAG,CAACpE,MAAJ,CAAWiB,IAAlB;EACA;EAED;AACD;AACA;AACA;;;EACClB,iBAAiB,CAACU,MAAD,EAAS;IACzB,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,OAAO2D,GAAG,CAACpE,MAAJ,CAAW4G,qBAAX,CAAiC7G,iBAAjC,CAAP;EACA;EAED;AACD;AACA;AACA;;;EACC8G,uBAAuB,CAAC3G,KAAD,EAAQ;IAC9B,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAAC5C,OAAJ,CAAYT,IAAnB;EACA;EAED;AACD;AACA;AACA;;;EACC6F,+BAA+B,CAAC5G,KAAD,EAAQ;IACtC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAACjB,eAAJ,KAAwBtC,SAAxB,GAAoC,CAApC,GAAwCuD,GAAG,CAACjB,eAAJ,CAAoBpC,IAAnE;EACA;EAED;AACD;AACA;AACA;;;EACC8F,uBAAuB,CAAC7G,KAAD,EAAQ;IAC9B,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAAC5C,OAAX;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCsF,mCAAmC,CAAC9G,KAAD,EAAQW,UAAR,EAAoB;IACtD,MAAMyD,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,MAAM+G,qBAAqB,GAAG3C,GAAG,CAAC5C,OAAJ,CAC5BkF,qBAD4B,CACNtC,GAAG,CAACd,oBADE,EAE5B7C,GAF4B,CAExBE,UAFwB,CAA9B;IAGA,OAAOoG,qBAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCC,yBAAyB,CAAChH,KAAD,EAAQO,MAAR,EAAgBC,WAAhB,EAA6B;IACrD,MAAM4D,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,IAAIoE,GAAG,CAAChE,mBAAJ,KAA4BS,SAAhC,EAA2C;MAC1CuD,GAAG,CAAChE,mBAAJ,GAA0B,IAAIc,OAAJ,EAA1B;IACA;;IACDkD,GAAG,CAAChE,mBAAJ,CAAwBV,GAAxB,CAA4Ba,MAA5B,EAAoCC,WAApC,EALqD,CAMrD;;IACA4D,GAAG,CAACd,oBAAJ,GAA2BnD,mBAAmB,CAACiE,GAAG,CAAChE,mBAAL,CAA9C;EACA;EAED;AACD;AACA;AACA;AACA;;;EACC6G,yBAAyB,CAACjH,KAAD,EAAQO,MAAR,EAAgB;IACxC,MAAM6D,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,IAAIoE,GAAG,CAAChE,mBAAJ,KAA4BS,SAAhC,EAA2C;MAC1C,OAAON,MAAM,CAACG,cAAP,EAAP;IACA;;IACD,OAAO0D,GAAG,CAAChE,mBAAJ,CAAwBK,GAAxB,CAA4BF,MAA5B,KAAuCA,MAAM,CAACG,cAAP,EAA9C;EACA;EAED;AACD;AACA;AACA;;;EACCwG,oBAAoB,CAAC3G,MAAD,EAAS;IAC5B,OACC,KAAK4G,gCAAL,CAAsC5G,MAAtC,KAAiDA,MAAM,CAACG,cAAP,EADlD;EAGA;EAED;AACD;AACA;AACA;;;EACCyG,gCAAgC,CAAC5G,MAAD,EAAS;IACxC,IAAI6G,MAAM,GAAG,KAAb;IACA,IAAI5G,WAAJ;;IACA,KAAK,MAAMR,KAAX,IAAoB,KAAKoG,uBAAL,CAA6B7F,MAA7B,CAApB,EAA0D;MACzD,MAAM6D,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;MACA,IAAIoE,GAAG,CAAChE,mBAAJ,KAA4BS,SAAhC,EAA2C;MAC3C,MAAMwG,EAAE,GAAGjD,GAAG,CAAChE,mBAAJ,CAAwBK,GAAxB,CAA4BF,MAA5B,CAAX;MACA,IAAI8G,EAAE,KAAKxG,SAAX,EAAsB;;MACtB,IAAI,CAACL,WAAL,EAAkB;QACjBA,WAAW,GAAG6G,EAAd;QACA;MACA,CAHD,MAGO,IAAI,CAACD,MAAL,EAAa;QACnB,KAAK,MAAM3F,IAAX,IAAmB4F,EAAnB,EAAuB;UACtB,IAAI,CAACD,MAAL,EAAa;YACZ,IAAI,CAAC5G,WAAW,CAACwF,GAAZ,CAAgBvE,IAAhB,CAAL,EAA4B;cAC3B2F,MAAM,GAAG,IAAT;cACA5G,WAAW,GAAG,IAAIvB,GAAJ,CAAQuB,WAAR,CAAd;cACAA,WAAW,CAACP,GAAZ,CAAgBwB,IAAhB;YACA;UACD,CAND,MAMO;YACNjB,WAAW,CAACP,GAAZ,CAAgBwB,IAAhB;UACA;QACD;MACD,CAZM,MAYA;QACN,KAAK,MAAMA,IAAX,IAAmB4F,EAAnB,EAAuB7G,WAAW,CAACP,GAAZ,CAAgBwB,IAAhB;MACvB;IACD;;IAED,OAAOjB,WAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACC8G,8BAA8B,CAACtH,KAAD,EAAQoB,UAAR,EAAoB;IACjD,MAAMgD,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACAoE,GAAG,CAAC5C,OAAJ,CAAYF,QAAZ,CAAqBF,UAArB;IACA,OAAOgD,GAAG,CAAC5C,OAAX;EACA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACC+F,0CAA0C,CAACvH,KAAD,EAAQW,UAAR,EAAoBS,UAApB,EAAgC;IACzE,MAAMgD,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,MAAM+G,qBAAqB,GAAG3C,GAAG,CAAC5C,OAAJ,CAC5BkF,qBAD4B,CACNtC,GAAG,CAACd,oBADE,EAE5B7C,GAF4B,CAExBE,UAFwB,CAA9B;IAGA,IAAIoG,qBAAqB,KAAKlG,SAA9B,EAAyC,OAAOA,SAAP;IACzCkG,qBAAqB,CAACzF,QAAtB,CAA+BF,UAA/B;IACA,OAAO2F,qBAAP;EACA;EAED;AACD;AACA;AACA;;;EACCS,eAAe,CAACxH,KAAD,EAAQ;IACtB,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAAC5C,OAAJ,CAAYkF,qBAAZ,CAAkCjH,QAAlC,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCgI,sBAAsB,CAACzH,KAAD,EAAQoB,UAAR,EAAoB;IACzC,MAAMgD,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,MAAM0H,aAAa,GAAGvG,0BAA0B,CAACC,UAAD,CAAhD;IACA,OAAOgD,GAAG,CAAC5C,OAAJ,CAAYkF,qBAAZ,CAAkCgB,aAAlC,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACCC,mBAAmB,CAAC3H,KAAD,EAAQ4H,QAAR,EAA4C;IAAA,IAA1BC,gBAA0B,uEAAP,KAAO;;IAC9D;IACA,MAAMC,gBAAgB,GAAGlG,MAAM,CAACC,MAAP,CAAc,IAAd,CAAzB;;IAEA,KAAK,MAAMkG,UAAX,IAAyBF,gBAAgB,GACtC7H,KAAK,CAACgI,sBAAN,EADsC,GAEtChI,KAAK,CAACiI,iBAAN,EAFH,EAE8B;MAC7B;MACA,IAAIC,KAAJ;;MACA,KAAK,MAAM3H,MAAX,IAAqB,KAAK+G,8BAAL,CACpBS,UADoB,EAEpB5J,kBAAkB,CAAC,IAAD,CAFE,CAArB,EAGG;QACF,IAAIyJ,QAAQ,CAACrH,MAAD,CAAZ,EAAsB;UACrB,IAAI2H,KAAK,KAAKrH,SAAd,EAAyB;YACxBqH,KAAK,GAAG,EAAR;YACAJ,gBAAgB,CAACC,UAAU,CAACnF,EAAZ,CAAhB,GAAkCsF,KAAlC;UACA;;UACD,MAAMC,QAAQ,GAAG,KAAKC,WAAL,CAAiB7H,MAAjB,CAAjB;UACA2H,KAAK,CAACG,IAAN,CAAWF,QAAX;QACA;MACD;IACD;;IAED,OAAOL,gBAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;;;EACCQ,6BAA6B,CAC5BtI,KAD4B,EAE5B4H,QAF4B,EAK3B;IAAA,IAFDW,UAEC,uEAFY,CAEZ;IAAA,IADDV,gBACC,uEADkB,KAClB;;IACD;IACA,MAAMW,kBAAkB,GAAG5G,MAAM,CAACC,MAAP,CAAc,IAAd,CAA3B;;IAEA,KAAK,MAAMkG,UAAX,IAAyBF,gBAAgB,GACtC7H,KAAK,CAACgI,sBAAN,EADsC,GAEtChI,KAAK,CAACiI,iBAAN,EAFH,EAE8B;MAC7B;MACA,IAAIQ,WAAJ;;MACA,KAAK,MAAMlI,MAAX,IAAqB,KAAK+G,8BAAL,CACpBS,UADoB,EAEpB5J,kBAAkB,CAAC,IAAD,CAFE,CAArB,EAGG;QACF,IAAIyJ,QAAQ,CAACrH,MAAD,CAAZ,EAAsB;UACrB,IAAIkI,WAAW,KAAK5H,SAApB,EAA+B;YAC9B4H,WAAW,GAAG7G,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;YACA2G,kBAAkB,CAACT,UAAU,CAACnF,EAAZ,CAAlB,GAAoC6F,WAApC;UACA;;UACD,MAAMN,QAAQ,GAAG,KAAKC,WAAL,CAAiB7H,MAAjB,CAAjB;UACA,MAAMhB,IAAI,GAAG,KAAKmJ,qBAAL,CAA2BnI,MAA3B,EAAmCwH,UAAU,CAAC7H,OAA9C,CAAb;UACAuI,WAAW,CAACN,QAAD,CAAX,GAAwBI,UAAU,GAAGhJ,IAAI,CAACoJ,KAAL,CAAW,CAAX,EAAcJ,UAAd,CAAH,GAA+BhJ,IAAjE;QACA;MACD;IACD;;IAED,OAAOiJ,kBAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCI,oBAAoB,CAAC5I,KAAD,EAAQ4H,QAAR,EAAkB;IACrC,MAAMvH,GAAG,GAAGuB,MAAM,CAACC,MAAP,CAAc,IAAd,CAAZ;;IACA,KAAK,MAAMgH,CAAX,IAAgB7I,KAAK,CAACgI,sBAAN,EAAhB,EAAgD;MAC/C3H,GAAG,CAACwI,CAAC,CAACjG,EAAH,CAAH,GAAYgF,QAAQ,CAACiB,CAAD,EAAI,IAAJ,CAApB;IACA;;IACD,OAAOxI,GAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACCyI,gBAAgB,CAAC9I,KAAD,EAAQ4H,QAAR,EAAkBmB,aAAlB,EAAiC;IAChD,MAAM9G,KAAK,GAAG,IAAIhD,GAAJ,CAAQe,KAAK,CAACkC,cAAd,CAAd;IACA,MAAM8G,eAAe,GAAG,IAAI/J,GAAJ,EAAxB;;IAEA,KAAK,MAAMkD,UAAX,IAAyBF,KAAzB,EAAgC;MAC/B,KAAK,MAAMgH,UAAX,IAAyB9G,UAAU,CAACrC,MAApC,EAA4C;QAC3C,IAAI,CAACkJ,eAAe,CAAChD,GAAhB,CAAoBiD,UAApB,CAAL,EAAsC;UACrCD,eAAe,CAAC/I,GAAhB,CAAoBgJ,UAApB;;UACA,IAAI,CAACF,aAAD,IAAkBA,aAAa,CAACE,UAAD,EAAa,IAAb,CAAnC,EAAuD;YACtD,KAAK,MAAM1I,MAAX,IAAqB,KAAKsG,uBAAL,CAA6BoC,UAA7B,CAArB,EAA+D;cAC9D,IAAIrB,QAAQ,CAACrH,MAAD,CAAZ,EAAsB;gBACrB,OAAO,IAAP;cACA;YACD;UACD;QACD;MACD;;MACD,KAAK,MAAM2I,KAAX,IAAoB/G,UAAU,CAACgH,gBAA/B,EAAiD;QAChDlH,KAAK,CAAChC,GAAN,CAAUiJ,KAAV;MACA;IACD;;IACD,OAAO,KAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCE,aAAa,CAACC,MAAD,EAASC,MAAT,EAAiB;IAC7B,MAAMC,IAAI,GAAG,KAAKpF,mBAAL,CAAyBkF,MAAzB,CAAb;;IACA,MAAMG,IAAI,GAAG,KAAKrF,mBAAL,CAAyBmF,MAAzB,CAAb;;IACA,IAAIC,IAAI,CAAC/H,OAAL,CAAaT,IAAb,GAAoByI,IAAI,CAAChI,OAAL,CAAaT,IAArC,EAA2C,OAAO,CAAC,CAAR;IAC3C,IAAIwI,IAAI,CAAC/H,OAAL,CAAaT,IAAb,GAAoByI,IAAI,CAAChI,OAAL,CAAaT,IAArC,EAA2C,OAAO,CAAP;IAC3CwI,IAAI,CAAC/H,OAAL,CAAaF,QAAb,CAAsBjD,0BAAtB;IACAmL,IAAI,CAAChI,OAAL,CAAaF,QAAb,CAAsBjD,0BAAtB;IACA,OAAOe,sBAAsB,CAACmK,IAAI,CAAC/H,OAAN,EAAegI,IAAI,CAAChI,OAApB,CAA7B;EACA;EAED;AACD;AACA;AACA;;;EACCiI,mBAAmB,CAACzJ,KAAD,EAAQ;IAC1B,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAAC5C,OAAJ,CAAYkF,qBAAZ,CAAkCnF,cAAlC,CAAP;EACA;EAED;AACD;AACA;AACA;;;EACCmI,oBAAoB,CAAC1J,KAAD,EAAQ;IAC3B,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAAC5C,OAAJ,CAAYkF,qBAAZ,CAAkChF,eAAlC,CAAP;EACA;EAED;AACD;AACA;AACA;;;EACCiI,mBAAmB,CAAC3J,KAAD,EAAQ;IAC1B,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAAC5C,OAAJ,CAAYkF,qBAAZ,CAAkC,KAAK3C,cAAvC,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACC6F,YAAY,CAAC5J,KAAD,EAAsB;IAAA,IAAd6J,OAAc,uEAAJ,EAAI;;IACjC,MAAMzF,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,MAAM8J,WAAW,GAAG1F,GAAG,CAAC5C,OAAJ,CAAYkF,qBAAZ,CAAkCnF,cAAlC,CAApB;IACA,MAAMwI,aAAa,GAClB,OAAOF,OAAO,CAACE,aAAf,KAAiC,QAAjC,GAA4CF,OAAO,CAACE,aAApD,GAAoE,KADrE;IAEA,MAAMC,uBAAuB,GAC5B,OAAOH,OAAO,CAACG,uBAAf,KAA2C,QAA3C,GACGH,OAAO,CAACG,uBADX,GAEG,EAHJ;IAIA,OACCD,aAAa,GACbD,WAAW,IAAI9J,KAAK,CAACiK,YAAN,KAAuBD,uBAAvB,GAAiD,CAArD,CAFZ;EAIA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACCE,uBAAuB,CAACb,MAAD,EAASC,MAAT,EAA+B;IAAA,IAAdO,OAAc,uEAAJ,EAAI;;IACrD,MAAMN,IAAI,GAAG,KAAKpF,mBAAL,CAAyBkF,MAAzB,CAAb;;IACA,MAAMG,IAAI,GAAG,KAAKrF,mBAAL,CAAyBmF,MAAzB,CAAb;;IACA,MAAMa,UAAU,GAAG,IAAIlL,GAAJ,CAAQsK,IAAI,CAAC/H,OAAb,CAAnB;;IACA,KAAK,MAAMsE,CAAX,IAAgB0D,IAAI,CAAChI,OAArB,EAA8B2I,UAAU,CAAClK,GAAX,CAAe6F,CAAf;;IAC9B,IAAIgE,WAAW,GAAGvI,cAAc,CAAC4I,UAAD,CAAhC;IACA,MAAMJ,aAAa,GAClB,OAAOF,OAAO,CAACE,aAAf,KAAiC,QAAjC,GAA4CF,OAAO,CAACE,aAApD,GAAoE,KADrE;IAEA,MAAMC,uBAAuB,GAC5B,OAAOH,OAAO,CAACG,uBAAf,KAA2C,QAA3C,GACGH,OAAO,CAACG,uBADX,GAEG,EAHJ;IAIA,OACCD,aAAa,GACbD,WAAW,IACTT,MAAM,CAACY,YAAP,MAAyBX,MAAM,CAACW,YAAP,EAAzB,GACED,uBADF,GAEE,CAHO,CAFZ;EAOA;EAED;AACD;AACA;AACA;AACA;;;EACCI,qBAAqB,CAACf,MAAD,EAASC,MAAT,EAAiB;IACrC,IAAID,MAAM,CAACgB,kBAAP,IAA6Bf,MAAM,CAACe,kBAAxC,EAA4D;MAC3D,OAAO,KAAP;IACA;;IAED,MAAMC,WAAW,GAAGjB,MAAM,CAACkB,UAAP,EAApB;IACA,MAAMC,WAAW,GAAGlB,MAAM,CAACiB,UAAP,EAApB;;IAEA,IAAID,WAAW,KAAKE,WAApB,EAAiC;MAChC,IAAIF,WAAJ,EAAiB;QAChB,OAAOxI,gBAAgB,CAACuH,MAAD,EAASC,MAAT,CAAvB;MACA,CAFD,MAEO,IAAIkB,WAAJ,EAAiB;QACvB,OAAO1I,gBAAgB,CAACwH,MAAD,EAASD,MAAT,CAAvB;MACA,CAFM,MAEA;QACN,OAAO,KAAP;MACA;IACD;;IAED,IACC,KAAKoB,uBAAL,CAA6BpB,MAA7B,IAAuC,CAAvC,IACA,KAAKoB,uBAAL,CAA6BnB,MAA7B,IAAuC,CAFxC,EAGE;MACD,OAAO,KAAP;IACA;;IAED,OAAO,IAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCoB,eAAe,CAACrB,MAAD,EAASC,MAAT,EAAiB;IAC/B;IACA,IAAID,MAAM,CAACsB,IAAP,IAAerB,MAAM,CAACqB,IAA1B,EAAgC;MAC/B,IACC,KAAKF,uBAAL,CAA6BpB,MAA7B,IAAuC,CAAvC,KACA,KAAKoB,uBAAL,CAA6BnB,MAA7B,IAAuC,CAFxC,EAGE;QACD;QACA;QACA,IAAID,MAAM,CAACsB,IAAP,CAAYC,MAAZ,KAAuBtB,MAAM,CAACqB,IAAP,CAAYC,MAAvC,EAA+C;UAC9CvB,MAAM,CAACsB,IAAP,GACCtB,MAAM,CAACsB,IAAP,CAAYC,MAAZ,GAAqBtB,MAAM,CAACqB,IAAP,CAAYC,MAAjC,GAA0CvB,MAAM,CAACsB,IAAjD,GAAwDrB,MAAM,CAACqB,IADhE;QAEA,CAHD,MAGO;UACNtB,MAAM,CAACsB,IAAP,GAActB,MAAM,CAACsB,IAAP,GAAcrB,MAAM,CAACqB,IAArB,GAA4BtB,MAAM,CAACsB,IAAnC,GAA0CrB,MAAM,CAACqB,IAA/D;QACA;MACD,CAZD,MAYO,IAAI,KAAKF,uBAAL,CAA6BnB,MAA7B,IAAuC,CAA3C,EAA8C;QACpD;QACAD,MAAM,CAACsB,IAAP,GAAcrB,MAAM,CAACqB,IAArB;MACA;IACD,CAjBD,MAiBO,IAAIrB,MAAM,CAACqB,IAAX,EAAiB;MACvBtB,MAAM,CAACsB,IAAP,GAAcrB,MAAM,CAACqB,IAArB;IACA,CArB8B,CAuB/B;;;IACA,KAAK,MAAME,IAAX,IAAmBvB,MAAM,CAACwB,WAA1B,EAAuC;MACtCzB,MAAM,CAACyB,WAAP,CAAmB7K,GAAnB,CAAuB4K,IAAvB;IACA,CA1B8B,CA4B/B;;;IACAxB,MAAM,CAACnJ,OAAP,GAAiBpB,YAAY,CAACuK,MAAM,CAACnJ,OAAR,EAAiBoJ,MAAM,CAACpJ,OAAxB,CAA7B,CA7B+B,CA+B/B;;IACA,KAAK,MAAMK,MAAX,IAAqB,KAAKiH,eAAL,CAAqB8B,MAArB,CAArB,EAAmD;MAClD,KAAKzE,wBAAL,CAA8ByE,MAA9B,EAAsC/I,MAAtC;MACA,KAAKqE,qBAAL,CAA2ByE,MAA3B,EAAmC9I,MAAnC;IACA;;IAED,KAAK,MAAM,CAACA,MAAD,EAAS4B,UAAT,CAAX,IAAmCxC,KAAK,CAACC,IAAN,CAClC,KAAKmL,0CAAL,CAAgDzB,MAAhD,CADkC,CAAnC,EAEG;MACF,KAAK0B,6BAAL,CAAmC1B,MAAnC,EAA2C/I,MAA3C;MACA,KAAK0K,0BAAL,CAAgC5B,MAAhC,EAAwC9I,MAAxC,EAAgD4B,UAAhD;IACA;;IAED,KAAK,MAAMA,UAAX,IAAyBmH,MAAM,CAACpH,cAAhC,EAAgD;MAC/CC,UAAU,CAAC+I,YAAX,CAAwB5B,MAAxB,EAAgCD,MAAhC;MACAA,MAAM,CAAC8B,QAAP,CAAgBhJ,UAAhB;MACAmH,MAAM,CAAC8B,WAAP,CAAmBjJ,UAAnB;IACA;;IACDoB,UAAU,CAAC2B,uBAAX,CAAmCoE,MAAnC;EACA;EAED;AACD;AACA;AACA;;;EACC+B,iCAAiC,CAACrL,KAAD,EAAQ;IACxC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,IAAIoE,GAAG,CAAChB,oBAAJ,KAA6BvC,SAAjC,EAA4C;;IAC5C,IAAIuD,GAAG,CAACjB,eAAJ,KAAwBtC,SAA5B,EAAuC;MACtCuD,GAAG,CAACjB,eAAJ,GAAsBiB,GAAG,CAAChB,oBAA1B;IACA,CAFD,MAEO;MACN,KAAK,MAAM0C,CAAX,IAAgB1B,GAAG,CAAChB,oBAApB,EAA0C;QACzCgB,GAAG,CAACjB,eAAJ,CAAoBlD,GAApB,CAAwB6F,CAAxB;MACA;;MACD1B,GAAG,CAAChB,oBAAJ,GAA2BvC,SAA3B;IACA;EACD;EAED;AACD;AACA;AACA;AACA;;;EACCyK,oBAAoB,CAAC/K,MAAD,EAASP,KAAT,EAAgB;IACnC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAACnB,YAAJ,CAAiB+C,GAAjB,CAAqBzF,MAArB,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACC0K,0BAA0B,CAACjL,KAAD,EAAQO,MAAR,EAAgBgL,UAAhB,EAA4B;IACrD,MAAMrH,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,MAAM6D,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,IAAIkE,GAAG,CAACzB,aAAJ,KAAsB5B,SAA1B,EAAqC;MACpCqD,GAAG,CAACzB,aAAJ,GAAoB,IAAIxD,GAAJ,EAApB;IACA;;IACDiF,GAAG,CAACzB,aAAJ,CAAkBxC,GAAlB,CAAsBD,KAAtB;IACAoE,GAAG,CAACnB,YAAJ,CAAiBvD,GAAjB,CAAqBa,MAArB,EAA6BgL,UAA7B;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCC,4BAA4B,CAACxL,KAAD,EAAQO,MAAR,EAAgB;IAC3C,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,MAAM6D,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,IAAIkE,GAAG,CAACxB,eAAJ,KAAwB7B,SAA5B,EAAuC;MACtCqD,GAAG,CAACxB,eAAJ,GAAsB,IAAIzD,GAAJ,EAAtB;IACA;;IACDiF,GAAG,CAACxB,eAAJ,CAAoBzC,GAApB,CAAwBD,KAAxB;IACAoE,GAAG,CAAClB,cAAJ,CAAmBjD,GAAnB,CAAuBM,MAAvB;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCkL,wBAAwB,CAACzL,KAAD,EAAQO,MAAR,EAAgB;IACvC,MAAM6D,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,IAAIoE,GAAG,CAACjB,eAAJ,KAAwBtC,SAA5B,EAAuCuD,GAAG,CAACjB,eAAJ,GAAsB,IAAIlE,GAAJ,EAAtB;IACvCmF,GAAG,CAACjB,eAAJ,CAAoBlD,GAApB,CAAwBM,MAAxB;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCmL,6BAA6B,CAAC1L,KAAD,EAAQO,MAAR,EAAgB;IAC5C,MAAM6D,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,IAAIoE,GAAG,CAAChB,oBAAJ,KAA6BvC,SAAjC,EACCuD,GAAG,CAAChB,oBAAJ,GAA2B,IAAInE,GAAJ,EAA3B;IACDmF,GAAG,CAAChB,oBAAJ,CAAyBnD,GAAzB,CAA6BM,MAA7B;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCyK,6BAA6B,CAAChL,KAAD,EAAQO,MAAR,EAAgB;IAC5C,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,MAAM6D,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACAkE,GAAG,CAACzB,aAAJ,CAAkBqC,MAAlB,CAAyB9E,KAAzB;;IACA,IAAIkE,GAAG,CAACzB,aAAJ,CAAkB1B,IAAlB,KAA2B,CAA/B,EAAkC;MACjCmD,GAAG,CAACzB,aAAJ,GAAoB5B,SAApB;IACA;;IACDuD,GAAG,CAACnB,YAAJ,CAAiB6B,MAAjB,CAAwBvE,MAAxB;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCoL,+BAA+B,CAAC3L,KAAD,EAAQO,MAAR,EAAgB;IAC9C,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,MAAM6D,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACAkE,GAAG,CAACxB,eAAJ,CAAoBoC,MAApB,CAA2B9E,KAA3B;;IACA,IAAIkE,GAAG,CAACxB,eAAJ,CAAoB3B,IAApB,KAA6B,CAAjC,EAAoC;MACnCmD,GAAG,CAACxB,eAAJ,GAAsB7B,SAAtB;IACA;;IACDuD,GAAG,CAAClB,cAAJ,CAAmB4B,MAAnB,CAA0BvE,MAA1B;EACA;EAED;AACD;AACA;AACA;;;EACCqL,qBAAqB,CAACrL,MAAD,EAAS;IAC7B,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,KAAK,MAAMP,KAAX,IAAoBkE,GAAG,CAACzB,aAAxB,EAAuC;MACtC,MAAM2B,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;MACAoE,GAAG,CAACnB,YAAJ,CAAiB6B,MAAjB,CAAwBvE,MAAxB;IACA;;IACD2D,GAAG,CAACzB,aAAJ,GAAoB5B,SAApB;EACA;EAED;AACD;AACA;AACA;;;EACCgL,iBAAiB,CAAC7L,KAAD,EAAQ;IACxB,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,KAAK,MAAMO,MAAX,IAAqB6D,GAAG,CAACnB,YAAJ,CAAiB6I,IAAjB,EAArB,EAA8C;MAC7C,MAAM5H,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;MACA2D,GAAG,CAACzB,aAAJ,CAAkBqC,MAAlB,CAAyB9E,KAAzB;;MACA,IAAIkE,GAAG,CAACzB,aAAJ,CAAkB1B,IAAlB,KAA2B,CAA/B,EAAkC;QACjCmD,GAAG,CAACzB,aAAJ,GAAoB5B,SAApB;MACA;IACD;;IACDuD,GAAG,CAACnB,YAAJ,CAAiB+B,KAAjB;EACA;EAED;AACD;AACA;AACA;;;EACCyF,uBAAuB,CAACzK,KAAD,EAAQ;IAC9B,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAACnB,YAAJ,CAAiBlC,IAAxB;EACA;EAED;AACD;AACA;AACA;;;EACCgL,yBAAyB,CAAC/L,KAAD,EAAQ;IAChC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAAClB,cAAJ,CAAmBnC,IAA1B;EACA;EAED;AACD;AACA;AACA;;;EACCiL,4BAA4B,CAAChM,KAAD,EAAQ;IACnC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAACnB,YAAJ,CAAiB6I,IAAjB,EAAP;EACA;EAED;AACD;AACA;AACA;;;EACCG,oCAAoC,CAACjM,KAAD,EAAQ;IAC3C;IACA,MAAMN,GAAG,GAAG,IAAIT,GAAJ,EAAZ;;IACA,KAAK,MAAMkD,UAAX,IAAyBnC,KAAK,CAACkC,cAA/B,EAA+C;MAC9C,IAAIC,UAAU,YAAYpE,UAA1B,EAAsC;QACrC,MAAMmO,eAAe,GAAG/J,UAAU,CAACgK,kBAAX,EAAxB;;QACA,MAAM/H,GAAG,GAAG,KAAKD,mBAAL,CAAyB+H,eAAzB,CAAZ;;QACA,KAAK,MAAM/J,UAAX,IAAyBiC,GAAG,CAACnB,YAAJ,CAAiBmJ,MAAjB,EAAzB,EAAoD;UACnD,KAAK,MAAMvD,CAAX,IAAgB1G,UAAU,CAACrC,MAA3B,EAAmC;YAClC,IAAI+I,CAAC,KAAK7I,KAAN,IAAe6I,CAAC,KAAKqD,eAArB,IAAwC,CAACrD,CAAC,CAAC0B,UAAF,EAA7C,EAA6D;cAC5D7K,GAAG,CAACO,GAAJ,CAAQ4I,CAAR;YACA;UACD;QACD;MACD;IACD;;IAED,OAAOnJ,GAAP;EACA;EAED;AACD;AACA;AACA;;;EACC2M,4BAA4B,CAACrM,KAAD,EAAQ;IACnC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,KAAK,MAAMmC,UAAX,IAAyBiC,GAAG,CAACnB,YAAJ,CAAiBmJ,MAAjB,EAAzB,EAAoD;MACnD,KAAK,MAAMvD,CAAX,IAAgB1G,UAAU,CAACrC,MAA3B,EAAmC;QAClC,IAAI+I,CAAC,KAAK7I,KAAV,EAAiB;UAChB,OAAO,IAAP;QACA;MACD;IACD;;IACD,OAAO,KAAP;EACA;EAED;AACD;AACA;AACA;;;EACCsM,8BAA8B,CAACtM,KAAD,EAAQ;IACrC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAAClB,cAAX;EACA;EAED;AACD;AACA;AACA;;;EACCqJ,6BAA6B,CAACvM,KAAD,EAAQ;IACpC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,MAAMkI,KAAK,GAAGvI,KAAK,CAACC,IAAN,CAAWwE,GAAG,CAAClB,cAAf,CAAd;IACAgF,KAAK,CAACvD,IAAN,CACCrG,iBAAiB,CAChBC,aAAa;IACZ;AACL;AACA;AACA;IACKiO,CAAC,IAAIA,CAAC,CAACC,KALK,EAMZjO,UANY,CADG,EAShBH,0BATgB,CADlB;IAaA,OAAO6J,KAAP;EACA;EAED;AACD;AACA;AACA;;;EACCwE,+BAA+B,CAAC1M,KAAD,EAAQ;IACtC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAACjB,eAAX;EACA;EAED;AACD;AACA;AACA;;;EACCwJ,0BAA0B,CAAC3M,KAAD,EAAQ;IACjC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAACjB,eAAX;EACA;EAED;AACD;AACA;AACA;;;EACCyJ,oCAAoC,CAAC5M,KAAD,EAAQ;IAC3C,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAAChB,oBAAX;EACA;EAED;AACD;AACA;AACA;;;EACC2H,0CAA0C,CAAC/K,KAAD,EAAQ;IACjD,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAACnB,YAAX;EACA;EAED;AACD;AACA;AACA;;;EACC4J,kBAAkB,CAACC,QAAD,EAAW;IAC5B,OAAO,KAAKlJ,iBAAL,CAAuBnD,GAAvB,CAA2BqM,QAA3B,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCC,yBAAyB,CAACD,QAAD,EAAW3K,UAAX,EAAuB;IAC/C,KAAKyB,iBAAL,CAAuBlE,GAAvB,CAA2BoN,QAA3B,EAAqC3K,UAArC;;IACAA,UAAU,CAAC6K,QAAX,CAAoBF,QAApB;EACA;EAED;AACD;AACA;AACA;;;EACCG,oBAAoB,CAAC9K,UAAD,EAAa;IAChC,KAAK,MAAM+K,KAAX,IAAoB/K,UAAU,CAACgL,cAA/B,EAA+C;MAC9C,KAAKvJ,iBAAL,CAAuBkB,MAAvB,CAA8BoI,KAA9B;IACA,CAH+B,CAIhC;;;IACA/K,UAAU,CAACiL,OAAX,CAAmBpI,KAAnB;EACA;EAED;AACD;AACA;AACA;;;EACCoD,WAAW,CAAC7H,MAAD,EAAS;IACnB,MAAM2D,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,OAAO2D,GAAG,CAACtB,EAAX;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCyK,WAAW,CAAC9M,MAAD,EAASqC,EAAT,EAAa;IACvB,MAAMsB,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA2D,GAAG,CAACtB,EAAJ,GAASA,EAAT;EACA;EAED;AACD;AACA;AACA;;;EACC0K,YAAY,CAACpN,OAAD,EAAU;IACrB,OAAO,KAAK2D,WAAL,CAAiBpD,GAAjB,CAAqBP,OAArB,CAAP;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCqN,YAAY,CAACrN,OAAD,EAAU0C,EAAV,EAAc;IACzB,KAAKiB,WAAL,CAAiBnE,GAAjB,CAAqBQ,OAArB,EAA8B0C,EAA9B;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;;;EACC4K,kBAAkB,CAACjN,MAAD,EAASoC,MAAT,EAAiBzC,OAAjB,EAA0B;IAC3C,IAAI,CAACyC,MAAL,EAAa;MACZ,MAAM,IAAI8K,KAAJ,CACJ,UAASlN,MAAM,CAACmN,UAAP,EAAoB,iCAAgC7O,eAAe,CAC5EqB,OAD4E,CAE3E,0BAHG,CAAN;IAKA,CAND,MAMO,IAAIA,OAAO,KAAKW,SAAhB,EAA2B;MACjC,MAAM8M,aAAa,GAAG,IAAI1O,GAAJ,CAAQ0D,MAAM,CAACyJ,MAAP,EAAR,CAAtB;;MACA,IAAIuB,aAAa,CAAC5M,IAAd,KAAuB,CAA3B,EAA8B;QAC7B,MAAM,IAAI0M,KAAJ,CACJ,yDAAwDlN,MAAM,CAACmN,UAAP,EAAoB,wBAAuB/N,KAAK,CAACC,IAAN,CACnG+C,MAAM,CAACmJ,IAAP,EADmG,EAEnGU,CAAC,IAAI3N,eAAe,CAAC2N,CAAD,CAF+E,EAGlGoB,IAHkG,CAG7F,IAH6F,CAGvF;AAClB,6GALU,CAAN;MAOA;;MACD,OAAO3P,KAAK,CAAC0P,aAAD,CAAZ;IACA,CAZM,MAYA;MACN,MAAME,QAAQ,GAAGlL,MAAM,CAAClC,GAAP,CAAWP,OAAX,CAAjB;;MACA,IAAI,CAAC2N,QAAL,EAAe;QACd,MAAM,IAAIJ,KAAJ,CACJ,UAASlN,MAAM,CAACmN,UAAP,EAAoB,iCAAgC7O,eAAe,CAC5EqB,OAD4E,CAE3E,wBAAuBP,KAAK,CAACC,IAAN,CACxB+C,MAAM,CAACmJ,IAAP,EADwB,EAExBjN,eAFwB,EAGvB+O,IAHuB,CAGlB,IAHkB,CAGZ,GANR,CAAN;MAQA;;MACD,OAAOC,QAAP;IACA;EACD;EAED;AACD;AACA;AACA;AACA;;;EACCC,eAAe,CAACvN,MAAD,EAASL,OAAT,EAAkB;IAChC,MAAMgE,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,MAAMoC,MAAM,GAAGuB,GAAG,CAACvB,MAAnB;IACA,OAAOA,MAAM,IAAIA,MAAM,CAACqD,GAAP,CAAW9F,OAAX,CAAjB;EACA;EAED;AACD;AACA;AACA;AACA;;;EACC6N,aAAa,CAACxN,MAAD,EAASL,OAAT,EAAkB;IAC9B,MAAMgE,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,MAAMoC,MAAM,GAAGuB,GAAG,CAACvB,MAAnB;IACA,OAAO,KAAK6K,kBAAL,CAAwBjN,MAAxB,EAAgCoC,MAAhC,EAAwCzC,OAAxC,EAAiDX,IAAxD;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCmJ,qBAAqB,CAACnI,MAAD,EAASL,OAAT,EAAkB;IACtC,MAAMgE,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,MAAMoC,MAAM,GAAGuB,GAAG,CAACvB,MAAnB;IACA,OAAO,KAAK6K,kBAAL,CAAwBjN,MAAxB,EAAgCoC,MAAhC,EAAwCzC,OAAxC,EAAiDV,YAAxD;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;;;EACCwO,eAAe,CAACzN,MAAD,EAASL,OAAT,EAAkBX,IAAlB,EAAwBC,YAAxB,EAAsC;IACpD,MAAM0E,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,IAAI2D,GAAG,CAACvB,MAAJ,KAAe9B,SAAnB,EAA8B;MAC7BqD,GAAG,CAACvB,MAAJ,GAAa,IAAIhE,cAAJ,EAAb;IACA;;IACDuF,GAAG,CAACvB,MAAJ,CAAWjD,GAAX,CAAeQ,OAAf,EAAwB,IAAIb,cAAJ,CAAmBE,IAAnB,EAAyBC,YAAzB,CAAxB;EACA;EAED;AACD;AACA;AACA;AACA;AACA;AACA;;;EACCyO,4BAA4B,CAC3B1N,MAD2B,EAE3BL,OAF2B,EAG3BgO,KAH2B,EAK1B;IAAA,IADDC,iBACC,uEADmB,IACnB;;IACD,MAAMjK,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,MAAM6N,sBAAsB,GAAGlK,GAAG,CAACrB,mBAAnC;;IACA,IAAIuL,sBAAsB,KAAKvN,SAA/B,EAA0C;MACzC,MAAMR,GAAG,GAAG,IAAI1B,cAAJ,EAAZ,CADyC,CAEzC;;MACA0B,GAAG,CAACX,GAAJ,CAAQQ,OAAR,EAAiBiO,iBAAiB,GAAGD,KAAH,GAAW,IAAIjP,GAAJ,CAAQiP,KAAR,CAA7C;MACAhK,GAAG,CAACrB,mBAAJ,GAA0BxC,GAA1B;MACA;IACA;;IACD+N,sBAAsB,CAACC,MAAvB,CAA8BnO,OAA9B,EAAuC2C,mBAAmB,IAAI;MAC7D,IAAIA,mBAAmB,KAAKhC,SAA5B,EAAuC;QACtC,OAAOsN,iBAAiB,GAAGD,KAAH,GAAW,IAAIjP,GAAJ,CAAQiP,KAAR,CAAnC;MACA,CAFD,MAEO,IAAI,CAACC,iBAAD,IAAsBtL,mBAAmB,CAAC9B,IAApB,IAA4BmN,KAAK,CAACnN,IAA5D,EAAkE;QACxE,KAAK,MAAMuN,IAAX,IAAmBJ,KAAnB,EAA0BrL,mBAAmB,CAAC5C,GAApB,CAAwBqO,IAAxB;;QAC1B,OAAOzL,mBAAP;MACA,CAHM,MAGA;QACN,KAAK,MAAMyL,IAAX,IAAmBzL,mBAAnB,EAAwCqL,KAAK,CAACjO,GAAN,CAAUqO,IAAV;;QACxC,OAAOJ,KAAP;MACA;IACD,CAVD;EAWA;EAED;AACD;AACA;AACA;AACA;;;EACCK,2BAA2B,CAACvO,KAAD,EAAQkO,KAAR,EAAe;IACzC,MAAM9J,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,MAAM6C,mBAAmB,GAAGuB,GAAG,CAACvB,mBAAhC;;IACA,IAAIA,mBAAmB,KAAKhC,SAA5B,EAAuC;MACtCuD,GAAG,CAACvB,mBAAJ,GAA0BqL,KAA1B;IACA,CAFD,MAEO,IAAIrL,mBAAmB,CAAC9B,IAApB,IAA4BmN,KAAK,CAACnN,IAAtC,EAA4C;MAClD,KAAK,MAAMuN,IAAX,IAAmBJ,KAAnB,EAA0BrL,mBAAmB,CAAC5C,GAApB,CAAwBqO,IAAxB;IAC1B,CAFM,MAEA;MACN,KAAK,MAAMA,IAAX,IAAmBzL,mBAAnB,EAAwCqL,KAAK,CAACjO,GAAN,CAAUqO,IAAV;;MACxClK,GAAG,CAACvB,mBAAJ,GAA0BqL,KAA1B;IACA;EACD;EAED;AACD;AACA;AACA;AACA;;;EACCM,0BAA0B,CAACxO,KAAD,EAAQkO,KAAR,EAAe;IACxC,MAAM9J,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,MAAM6C,mBAAmB,GAAGuB,GAAG,CAACf,yBAAhC;;IACA,KAAK,MAAMiL,IAAX,IAAmBJ,KAAnB,EAA0BrL,mBAAmB,CAAC5C,GAApB,CAAwBqO,IAAxB;EAC1B;EAED;AACD;AACA;AACA;AACA;;;EACCG,4BAA4B,CAAClO,MAAD,EAASL,OAAT,EAAkB;IAC7C,MAAMgE,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,MAAMsC,mBAAmB,GACxBqB,GAAG,CAACrB,mBAAJ,IAA2BqB,GAAG,CAACrB,mBAAJ,CAAwBpC,GAAxB,CAA4BP,OAA5B,CAD5B;IAEA,OAAO2C,mBAAmB,KAAKhC,SAAxB,GAAoC7B,SAApC,GAAgD6D,mBAAvD;EACA;EAED;AACD;AACA;AACA;;;EACC6L,2BAA2B,CAAC1O,KAAD,EAAQ;IAClC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,MAAM6C,mBAAmB,GAAGuB,GAAG,CAACvB,mBAAhC;IACA,OAAOA,mBAAmB,KAAKhC,SAAxB,GAAoC7B,SAApC,GAAgD6D,mBAAvD;EACA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACC8L,kBAAkB,CAACpO,MAAD,EAASL,OAAT,EAA0C;IAAA,IAAxB0O,eAAwB,uEAAN,IAAM;;IAC3D,MAAM1K,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,OAAOqO,eAAe,GACnB,KAAKC,kCAAL,CAAwC3K,GAAxC,EAA6C3D,MAA7C,EAAqDL,OAArD,CADmB,GAEnB,KAAK4O,yBAAL,CAA+B5K,GAA/B,EAAoC3D,MAApC,EAA4CL,OAA5C,EAAqD6O,QAArD,CAA8D,EAA9D,CAFH;EAGA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACCC,wBAAwB,CAACzO,MAAD,EAASL,OAAT,EAA0C;IAAA,IAAxB0O,eAAwB,uEAAN,IAAM;;IACjE,MAAM1K,GAAG,GAAG,KAAKD,oBAAL,CAA0B1D,MAA1B,CAAZ;;IACA,OAAOqO,eAAe,GACnBzP,MAAM,CACL,KAAI,KAAK0P,kCAAL,CAAwC3K,GAAxC,EAA6C3D,MAA7C,EAAqDL,OAArD,CAA8D,EAD7D,CADa,GAInB,KAAK4O,yBAAL,CAA+B5K,GAA/B,EAAoC3D,MAApC,EAA4CL,OAA5C,CAJH;EAKA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACC4O,yBAAyB,CAAC5K,GAAD,EAAM3D,MAAN,EAAcL,OAAd,EAAuB;IAC/C,IAAIgE,GAAG,CAACpB,WAAJ,KAAoBjC,SAAxB,EAAmC;MAClCqD,GAAG,CAACpB,WAAJ,GAAkB,IAAInE,cAAJ,EAAlB;IACA;;IACD,MAAMsQ,SAAS,GAAG/K,GAAG,CAACpB,WAAJ,CAAgBoM,OAAhB,CAAwBhP,OAAxB,EAAiC,MAAM;MACxD,MAAMX,IAAI,GAAGd,UAAU,CAAC,KAAKqF,aAAN,CAAvB;MACAvE,IAAI,CAAC8O,MAAL,CAAa,GAAEnK,GAAG,CAACtB,EAAG,GAAE,KAAKY,WAAL,CAAiB2L,OAAjB,CAAyB5O,MAAzB,CAAiC,EAAzD;;MACA,MAAMC,WAAW,GAAG,KAAK2G,gCAAL,CAAsC5G,MAAtC,CAApB;;MACA,IAAIC,WAAW,KAAKK,SAApB,EAA+B;QAC9B,KAAK,MAAMY,IAAX,IAAmBjB,WAAnB,EAAgCjB,IAAI,CAAC8O,MAAL,CAAY5M,IAAZ;MAChC;;MACD,KAAK+B,WAAL,CAAiB4L,cAAjB,CAAgC7O,MAAhC,EAAwC8O,UAAxC,CAAmD9P,IAAnD,EAAyDW,OAAzD;MACA,OAAOf,MAAM,CAAE;MAAI;MAAuBI,IAAI,CAAC+P,MAAL,CAAY,KAAZ,CAAoB,EAAjD,CAAb;IACA,CATiB,CAAlB;IAUA,OAAOL,SAAP;EACA;EAED;AACD;AACA;AACA;AACA;AACA;;;EACCJ,kCAAkC,CAAC3K,GAAD,EAAM3D,MAAN,EAAcL,OAAd,EAAuB;IACxD,IAAIgE,GAAG,CAACnB,0BAAJ,KAAmClC,SAAvC,EAAkD;MACjDqD,GAAG,CAACnB,0BAAJ,GAAiC,IAAIpE,cAAJ,EAAjC;IACA;;IACD,MAAM4Q,mBAAmB,GAAGC,KAAK,IAAI;MACpC,IAAIA,KAAK,KAAK,KAAd,EAAqB,OAAO,GAAP;MACrB,IAAIA,KAAK,KAAK,IAAd,EAAoB,OAAO,GAAP;MACpB,IAAIA,KAAK,KAAKxR,qBAAqB,CAAC0G,eAApC,EAAqD,OAAO,GAAP;MACrD,MAAM,IAAI+I,KAAJ,CAAU,8BAAV,CAAN;IACA,CALD;;IAMA,MAAMgC,MAAM,GAAGlP,MAAM,CAACmP,SAAP,IAAoBnP,MAAM,CAACmP,SAAP,CAAiBC,mBAApD;IACA,OAAOzL,GAAG,CAACnB,0BAAJ,CAA+BmM,OAA/B,CAAuChP,OAAvC,EAAgD,MAAM;MAC5D,MAAM+O,SAAS,GAAG,KAAKH,yBAAL,CACjB5K,GADiB,EAEjB3D,MAFiB,EAGjBL,OAHiB,EAIhB6O,QAJgB,CAIP,EAJO,CAAlB;;MAKA,MAAMa,WAAW,GAAG,KAAKpM,WAAL,CAAiBe,sBAAjB,CAAwChE,MAAxC,CAApB;MACA;;MACA,MAAMsP,sBAAsB,GAAG,IAAI5Q,GAAJ,EAA/B;MACA;;MACA,MAAM6Q,gBAAgB,GAAG,IAAIxP,GAAJ,EAAzB;;MACA,MAAMyP,iBAAiB,GAAG,CAACzL,UAAD,EAAa0L,SAAb,KAA2B;QACpD,MAAMzP,MAAM,GAAG+D,UAAU,CAAC/D,MAA1B;QACAyP,SAAS,IAAIzP,MAAM,CAAC0P,cAAP,CAAsB,KAAKzM,WAA3B,EAAwCiM,MAAxC,CAAb,CAFoD,CAGpD;;QACA,IAAIO,SAAS,KAAK,YAAlB,EAAgCH,sBAAsB,CAAC5P,GAAvB,CAA2BM,MAA3B,EAAhC,KACK;UACJ,MAAMiF,SAAS,GAAGsK,gBAAgB,CAACrP,GAAjB,CAAqBuP,SAArB,CAAlB;;UACA,IAAIxK,SAAS,KAAK3E,SAAlB,EAA6B;YAC5BiP,gBAAgB,CAACpQ,GAAjB,CAAqBsQ,SAArB,EAAgCzP,MAAhC;UACA,CAFD,MAEO,IAAIiF,SAAS,YAAYvG,GAAzB,EAA8B;YACpCuG,SAAS,CAACvF,GAAV,CAAcM,MAAd;UACA,CAFM,MAEA,IAAIiF,SAAS,KAAKjF,MAAlB,EAA0B;YAChCuP,gBAAgB,CAACpQ,GAAjB,CAAqBsQ,SAArB,EAAgC,IAAI/Q,GAAJ,CAAQ,CAACuG,SAAD,EAAYjF,MAAZ,CAAR,CAAhC;UACA;QACD;MACD,CAfD;;MAgBA,IAAIL,OAAO,KAAKW,SAAZ,IAAyB,OAAOX,OAAP,KAAmB,QAAhD,EAA0D;QACzD,KAAK,MAAMoE,UAAX,IAAyBsL,WAAzB,EAAsC;UACrC,MAAMJ,KAAK,GAAGlL,UAAU,CAACG,cAAX,CAA0BvE,OAA1B,CAAd;UACA,IAAIsP,KAAK,KAAK,KAAd,EAAqB;UACrBO,iBAAiB,CAACzL,UAAD,EAAakL,KAAK,KAAK,IAAV,GAAiB,GAAjB,GAAuB,GAApC,CAAjB;QACA;MACD,CAND,MAMO;QACN;QACA,KAAK,MAAMlL,UAAX,IAAyBsL,WAAzB,EAAsC;UACrC,MAAMM,MAAM,GAAG,IAAIjR,GAAJ,EAAf;UACA,IAAI+Q,SAAS,GAAG,EAAhB;UACAjR,cAAc,CACbmB,OADa,EAEbA,OAAO,IAAI;YACV,MAAMsP,KAAK,GAAGlL,UAAU,CAACG,cAAX,CAA0BvE,OAA1B,CAAd;YACAgQ,MAAM,CAACjQ,GAAP,CAAWuP,KAAX;YACAQ,SAAS,IAAIT,mBAAmB,CAACC,KAAD,CAAnB,GAA6BtP,OAA1C;UACA,CANY,EAOb,IAPa,CAAd;;UASA,IAAIgQ,MAAM,CAACnP,IAAP,KAAgB,CAApB,EAAuB;YACtB,MAAMyO,KAAK,GAAGvR,KAAK,CAACiS,MAAD,CAAnB;YACA,IAAIV,KAAK,KAAK,KAAd,EAAqB;YACrBQ,SAAS,GAAGT,mBAAmB,CAACC,KAAD,CAA/B;UACA;;UACDO,iBAAiB,CAACzL,UAAD,EAAa0L,SAAb,CAAjB;QACA;MACD,CAtD2D,CAuD5D;;;MACA,IAAIH,sBAAsB,CAAC9O,IAAvB,KAAgC,CAAhC,IAAqC+O,gBAAgB,CAAC/O,IAAjB,KAA0B,CAAnE,EACC,OAAOkO,SAAP;MACD,MAAMkB,uBAAuB,GAC5BL,gBAAgB,CAAC/O,IAAjB,GAAwB,CAAxB,GACGpB,KAAK,CAACC,IAAN,CAAWkQ,gBAAX,EAA6BnL,IAA7B,CAAkC;QAAA,IAAC,CAAC5C,CAAD,CAAD;QAAA,IAAM,CAACC,CAAD,CAAN;QAAA,OAAeD,CAAC,GAAGC,CAAJ,GAAQ,CAAC,CAAT,GAAa,CAA5B;MAAA,CAAlC,CADH,GAEG8N,gBAHJ;MAIA,MAAMvQ,IAAI,GAAGd,UAAU,CAAC,KAAKqF,aAAN,CAAvB;;MACA,MAAMsM,eAAe,GAAG7P,MAAM,IAAI;QACjChB,IAAI,CAAC8O,MAAL,CACC,KAAKS,yBAAL,CACC,KAAK7K,oBAAL,CAA0B1D,MAA1B,CADD,EAECA,MAFD,EAGCL,OAHD,EAIE6O,QAJF,CAIW,EAJX,CADD;MAOA,CARD;;MASA,MAAMsB,gBAAgB,GAAG7O,OAAO,IAAI;QACnC,IAAI8O,GAAG,GAAGpR,YAAV;;QACA,KAAK,MAAM4G,CAAX,IAAgBtE,OAAhB,EAAyB;UACxB8O,GAAG,GACFA,GAAG,GACH,KAAKxB,yBAAL,CACC,KAAK7K,oBAAL,CAA0B6B,CAA1B,CADD,EAECA,CAFD,EAGC5F,OAHD,CAFD;QAOA;;QACDX,IAAI,CAAC8O,MAAL,CAAYiC,GAAG,CAACvB,QAAJ,CAAa,EAAb,CAAZ;MACA,CAZD;;MAaA,IAAIc,sBAAsB,CAAC9O,IAAvB,KAAgC,CAApC,EACCqP,eAAe,CAACP,sBAAsB,CAACzD,MAAvB,GAAgCmE,IAAhC,GAAuCC,KAAxC,CAAf,CADD,KAEK,IAAIX,sBAAsB,CAAC9O,IAAvB,GAA8B,CAAlC,EACJsP,gBAAgB,CAACR,sBAAD,CAAhB;;MACD,KAAK,MAAM,CAACG,SAAD,EAAYxO,OAAZ,CAAX,IAAmC2O,uBAAnC,EAA4D;QAC3D5Q,IAAI,CAAC8O,MAAL,CAAY2B,SAAZ;;QACA,IAAIxO,OAAO,YAAYvC,GAAvB,EAA4B;UAC3BoR,gBAAgB,CAAC7O,OAAD,CAAhB;QACA,CAFD,MAEO;UACN4O,eAAe,CAAC5O,OAAD,CAAf;QACA;MACD;;MACDjC,IAAI,CAAC8O,MAAL,CAAYY,SAAZ;MACA;QAAO;QAAuB1P,IAAI,CAAC+P,MAAL,CAAY,KAAZ;MAA9B;IACA,CAnGM,CAAP;EAoGA;EAED;AACD;AACA;AACA;;;EACCmB,0BAA0B,CAACzQ,KAAD,EAAQ;IACjC,MAAMoE,GAAG,GAAG,KAAKD,mBAAL,CAAyBnE,KAAzB,CAAZ;;IACA,OAAOoE,GAAG,CAACf,yBAAX;EACA,CA57Ce,CA87ChB;;EACA;AACD;AACA;AACA;AACA;AACA;;;EAC8B,OAAtBqN,sBAAsB,CAACnQ,MAAD,EAASoQ,gBAAT,EAA2BC,eAA3B,EAA4C;IACxE,MAAMvP,EAAE,GAAGwP,kCAAkC,CAACpQ,GAAnC,CAAuCkQ,gBAAvC,CAAX;IACA,IAAItP,EAAJ,EAAQ,OAAOA,EAAE,CAACd,MAAD,CAAT;IACR,MAAMuQ,KAAK,GAAGjT,IAAI,CAACkT,SAAL;IACb;AACH;AACA;AACA;IACGxQ,MAAM,IAAI;MACT,MAAMyQ,UAAU,GAAGC,sBAAsB,CAACxQ,GAAvB,CAA2BF,MAA3B,CAAnB;MACA,IAAI,CAACyQ,UAAL,EACC,MAAM,IAAIvD,KAAJ,CACLkD,gBAAgB,GACf,wFAFI,CAAN;MAID,OAAOK,UAAP;IACA,CAbY,EAcbL,gBAAgB,GAAG,0BAdN,EAebC,eAfa,CAAd;IAiBAC,kCAAkC,CAACnR,GAAnC,CAAuCiR,gBAAvC,EAAyDG,KAAzD;IACA,OAAOA,KAAK,CAACvQ,MAAD,CAAZ;EACA,CA39Ce,CA69ChB;;EACA;AACD;AACA;AACA;AACA;;;EAC8B,OAAtB2Q,sBAAsB,CAAC3Q,MAAD,EAASyQ,UAAT,EAAqB;IACjDC,sBAAsB,CAACvR,GAAvB,CAA2Ba,MAA3B,EAAmCyQ,UAAnC;EACA,CAr+Ce,CAu+ChB;;EACA;AACD;AACA;AACA;;;EACgC,OAAxBG,wBAAwB,CAAC5Q,MAAD,EAAS;IACvC0Q,sBAAsB,CAACnM,MAAvB,CAA8BvE,MAA9B;EACA,CA9+Ce,CAg/ChB;;EACA;AACD;AACA;AACA;AACA;AACA;;;EAC6B,OAArB6Q,qBAAqB,CAACpR,KAAD,EAAQ2Q,gBAAR,EAA0BC,eAA1B,EAA2C;IACtE,MAAMvP,EAAE,GAAGgQ,iCAAiC,CAAC5Q,GAAlC,CAAsCkQ,gBAAtC,CAAX;IACA,IAAItP,EAAJ,EAAQ,OAAOA,EAAE,CAACrB,KAAD,CAAT;IACR,MAAM8Q,KAAK,GAAGjT,IAAI,CAACkT,SAAL;IACb;AACH;AACA;AACA;IACG/Q,KAAK,IAAI;MACR,MAAMgR,UAAU,GAAGM,qBAAqB,CAAC7Q,GAAtB,CAA0BT,KAA1B,CAAnB;MACA,IAAI,CAACgR,UAAL,EACC,MAAM,IAAIvD,KAAJ,CACLkD,gBAAgB,GACf,qFAFI,CAAN;MAID,OAAOK,UAAP;IACA,CAbY,EAcbL,gBAAgB,GAAG,0BAdN,EAebC,eAfa,CAAd;IAiBAS,iCAAiC,CAAC3R,GAAlC,CAAsCiR,gBAAtC,EAAwDG,KAAxD;IACA,OAAOA,KAAK,CAAC9Q,KAAD,CAAZ;EACA,CA7gDe,CA+gDhB;;EACA;AACD;AACA;AACA;AACA;;;EAC6B,OAArBuR,qBAAqB,CAACvR,KAAD,EAAQgR,UAAR,EAAoB;IAC/CM,qBAAqB,CAAC5R,GAAtB,CAA0BM,KAA1B,EAAiCgR,UAAjC;EACA,CAvhDe,CAyhDhB;;EACA;AACD;AACA;AACA;;;EAC+B,OAAvB9L,uBAAuB,CAAClF,KAAD,EAAQ;IACrCsR,qBAAqB,CAACxM,MAAtB,CAA6B9E,KAA7B;EACA;;AAhiDe,C,CAmiDjB;;AACA;;;AACA,MAAMiR,sBAAsB,GAAG,IAAI/P,OAAJ,EAA/B,C,CAEA;;AACA;;AACA,MAAMoQ,qBAAqB,GAAG,IAAIpQ,OAAJ,EAA9B,C,CAEA;;AACA;;AACA,MAAM2P,kCAAkC,GAAG,IAAIvQ,GAAJ,EAA3C,C,CAEA;;AACA;;AACA,MAAM+Q,iCAAiC,GAAG,IAAI/Q,GAAJ,EAA1C;AAEAC,MAAM,CAACiR,OAAP,GAAiBjO,UAAjB"},"metadata":{},"sourceType":"script"}