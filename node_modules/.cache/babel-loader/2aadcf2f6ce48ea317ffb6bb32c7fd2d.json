{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n\nconst ProgressPlugin = require(\"../ProgressPlugin\");\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nconst BUILD_DEPENDENCIES_KEY = Symbol();\n\nclass IdleFileCachePlugin {\n  /**\n   * @param {TODO} strategy cache strategy\n   * @param {number} idleTimeout timeout\n   * @param {number} idleTimeoutForInitialStore initial timeout\n   * @param {number} idleTimeoutAfterLargeChanges timeout after changes\n   */\n  constructor(strategy, idleTimeout, idleTimeoutForInitialStore, idleTimeoutAfterLargeChanges) {\n    this.strategy = strategy;\n    this.idleTimeout = idleTimeout;\n    this.idleTimeoutForInitialStore = idleTimeoutForInitialStore;\n    this.idleTimeoutAfterLargeChanges = idleTimeoutAfterLargeChanges;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    let strategy = this.strategy;\n    const idleTimeout = this.idleTimeout;\n    const idleTimeoutForInitialStore = Math.min(idleTimeout, this.idleTimeoutForInitialStore);\n    const idleTimeoutAfterLargeChanges = this.idleTimeoutAfterLargeChanges;\n    const resolvedPromise = Promise.resolve();\n    let timeSpendInBuild = 0;\n    let timeSpendInStore = 0;\n    let avgTimeSpendInStore = 0;\n    /** @type {Map<string | typeof BUILD_DEPENDENCIES_KEY, () => Promise>} */\n\n    const pendingIdleTasks = new Map();\n    compiler.cache.hooks.store.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, (identifier, etag, data) => {\n      pendingIdleTasks.set(identifier, () => strategy.store(identifier, etag, data));\n    });\n    compiler.cache.hooks.get.tapPromise({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, (identifier, etag, gotHandlers) => {\n      const restore = () => strategy.restore(identifier, etag).then(cacheEntry => {\n        if (cacheEntry === undefined) {\n          gotHandlers.push((result, callback) => {\n            if (result !== undefined) {\n              pendingIdleTasks.set(identifier, () => strategy.store(identifier, etag, result));\n            }\n\n            callback();\n          });\n        } else {\n          return cacheEntry;\n        }\n      });\n\n      const pendingTask = pendingIdleTasks.get(identifier);\n\n      if (pendingTask !== undefined) {\n        pendingIdleTasks.delete(identifier);\n        return pendingTask().then(restore);\n      }\n\n      return restore();\n    });\n    compiler.cache.hooks.storeBuildDependencies.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, dependencies => {\n      pendingIdleTasks.set(BUILD_DEPENDENCIES_KEY, () => strategy.storeBuildDependencies(dependencies));\n    });\n    compiler.cache.hooks.shutdown.tapPromise({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, () => {\n      if (idleTimer) {\n        clearTimeout(idleTimer);\n        idleTimer = undefined;\n      }\n\n      isIdle = false;\n      const reportProgress = ProgressPlugin.getReporter(compiler);\n      const jobs = Array.from(pendingIdleTasks.values());\n      if (reportProgress) reportProgress(0, \"process pending cache items\");\n      const promises = jobs.map(fn => fn());\n      pendingIdleTasks.clear();\n      promises.push(currentIdlePromise);\n      const promise = Promise.all(promises);\n      currentIdlePromise = promise.then(() => strategy.afterAllStored());\n\n      if (reportProgress) {\n        currentIdlePromise = currentIdlePromise.then(() => {\n          reportProgress(1, `stored`);\n        });\n      }\n\n      return currentIdlePromise.then(() => {\n        // Reset strategy\n        if (strategy.clear) strategy.clear();\n      });\n    });\n    /** @type {Promise<any>} */\n\n    let currentIdlePromise = resolvedPromise;\n    let isIdle = false;\n    let isInitialStore = true;\n\n    const processIdleTasks = () => {\n      if (isIdle) {\n        const startTime = Date.now();\n\n        if (pendingIdleTasks.size > 0) {\n          const promises = [currentIdlePromise];\n          const maxTime = startTime + 100;\n          let maxCount = 100;\n\n          for (const [filename, factory] of pendingIdleTasks) {\n            pendingIdleTasks.delete(filename);\n            promises.push(factory());\n            if (maxCount-- <= 0 || Date.now() > maxTime) break;\n          }\n\n          currentIdlePromise = Promise.all(promises);\n          currentIdlePromise.then(() => {\n            timeSpendInStore += Date.now() - startTime; // Allow to exit the process between\n\n            idleTimer = setTimeout(processIdleTasks, 0);\n            idleTimer.unref();\n          });\n          return;\n        }\n\n        currentIdlePromise = currentIdlePromise.then(async () => {\n          await strategy.afterAllStored();\n          timeSpendInStore += Date.now() - startTime;\n          avgTimeSpendInStore = Math.max(avgTimeSpendInStore, timeSpendInStore) * 0.9 + timeSpendInStore * 0.1;\n          timeSpendInStore = 0;\n          timeSpendInBuild = 0;\n        }).catch(err => {\n          const logger = compiler.getInfrastructureLogger(\"IdleFileCachePlugin\");\n          logger.warn(`Background tasks during idle failed: ${err.message}`);\n          logger.debug(err.stack);\n        });\n        isInitialStore = false;\n      }\n    };\n\n    let idleTimer = undefined;\n    compiler.cache.hooks.beginIdle.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, () => {\n      const isLargeChange = timeSpendInBuild > avgTimeSpendInStore * 2;\n\n      if (isInitialStore && idleTimeoutForInitialStore < idleTimeout) {\n        compiler.getInfrastructureLogger(\"IdleFileCachePlugin\").log(`Initial cache was generated and cache will be persisted in ${idleTimeoutForInitialStore / 1000}s.`);\n      } else if (isLargeChange && idleTimeoutAfterLargeChanges < idleTimeout) {\n        compiler.getInfrastructureLogger(\"IdleFileCachePlugin\").log(`Spend ${Math.round(timeSpendInBuild) / 1000}s in build and ${Math.round(avgTimeSpendInStore) / 1000}s in average in cache store. This is considered as large change and cache will be persisted in ${idleTimeoutAfterLargeChanges / 1000}s.`);\n      }\n\n      idleTimer = setTimeout(() => {\n        idleTimer = undefined;\n        isIdle = true;\n        resolvedPromise.then(processIdleTasks);\n      }, Math.min(isInitialStore ? idleTimeoutForInitialStore : Infinity, isLargeChange ? idleTimeoutAfterLargeChanges : Infinity, idleTimeout));\n      idleTimer.unref();\n    });\n    compiler.cache.hooks.endIdle.tap({\n      name: \"IdleFileCachePlugin\",\n      stage: Cache.STAGE_DISK\n    }, () => {\n      if (idleTimer) {\n        clearTimeout(idleTimer);\n        idleTimer = undefined;\n      }\n\n      isIdle = false;\n    });\n    compiler.hooks.done.tap(\"IdleFileCachePlugin\", stats => {\n      // 10% build overhead is ignored, as it's not cacheable\n      timeSpendInBuild *= 0.9;\n      timeSpendInBuild += stats.endTime - stats.startTime;\n    });\n  }\n\n}\n\nmodule.exports = IdleFileCachePlugin;","map":{"version":3,"names":["Cache","require","ProgressPlugin","BUILD_DEPENDENCIES_KEY","Symbol","IdleFileCachePlugin","constructor","strategy","idleTimeout","idleTimeoutForInitialStore","idleTimeoutAfterLargeChanges","apply","compiler","Math","min","resolvedPromise","Promise","resolve","timeSpendInBuild","timeSpendInStore","avgTimeSpendInStore","pendingIdleTasks","Map","cache","hooks","store","tap","name","stage","STAGE_DISK","identifier","etag","data","set","get","tapPromise","gotHandlers","restore","then","cacheEntry","undefined","push","result","callback","pendingTask","delete","storeBuildDependencies","dependencies","shutdown","idleTimer","clearTimeout","isIdle","reportProgress","getReporter","jobs","Array","from","values","promises","map","fn","clear","currentIdlePromise","promise","all","afterAllStored","isInitialStore","processIdleTasks","startTime","Date","now","size","maxTime","maxCount","filename","factory","setTimeout","unref","max","catch","err","logger","getInfrastructureLogger","warn","message","debug","stack","beginIdle","isLargeChange","log","round","Infinity","endIdle","done","stats","endTime","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/cache/IdleFileCachePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst BUILD_DEPENDENCIES_KEY = Symbol();\n\nclass IdleFileCachePlugin {\n\t/**\n\t * @param {TODO} strategy cache strategy\n\t * @param {number} idleTimeout timeout\n\t * @param {number} idleTimeoutForInitialStore initial timeout\n\t * @param {number} idleTimeoutAfterLargeChanges timeout after changes\n\t */\n\tconstructor(\n\t\tstrategy,\n\t\tidleTimeout,\n\t\tidleTimeoutForInitialStore,\n\t\tidleTimeoutAfterLargeChanges\n\t) {\n\t\tthis.strategy = strategy;\n\t\tthis.idleTimeout = idleTimeout;\n\t\tthis.idleTimeoutForInitialStore = idleTimeoutForInitialStore;\n\t\tthis.idleTimeoutAfterLargeChanges = idleTimeoutAfterLargeChanges;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tlet strategy = this.strategy;\n\t\tconst idleTimeout = this.idleTimeout;\n\t\tconst idleTimeoutForInitialStore = Math.min(\n\t\t\tidleTimeout,\n\t\t\tthis.idleTimeoutForInitialStore\n\t\t);\n\t\tconst idleTimeoutAfterLargeChanges = this.idleTimeoutAfterLargeChanges;\n\t\tconst resolvedPromise = Promise.resolve();\n\n\t\tlet timeSpendInBuild = 0;\n\t\tlet timeSpendInStore = 0;\n\t\tlet avgTimeSpendInStore = 0;\n\n\t\t/** @type {Map<string | typeof BUILD_DEPENDENCIES_KEY, () => Promise>} */\n\t\tconst pendingIdleTasks = new Map();\n\n\t\tcompiler.cache.hooks.store.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t(identifier, etag, data) => {\n\t\t\t\tpendingIdleTasks.set(identifier, () =>\n\t\t\t\t\tstrategy.store(identifier, etag, data)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.get.tapPromise(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t(identifier, etag, gotHandlers) => {\n\t\t\t\tconst restore = () =>\n\t\t\t\t\tstrategy.restore(identifier, etag).then(cacheEntry => {\n\t\t\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\t\t\tgotHandlers.push((result, callback) => {\n\t\t\t\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\t\t\t\tpendingIdleTasks.set(identifier, () =>\n\t\t\t\t\t\t\t\t\t\tstrategy.store(identifier, etag, result)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn cacheEntry;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\tconst pendingTask = pendingIdleTasks.get(identifier);\n\t\t\t\tif (pendingTask !== undefined) {\n\t\t\t\t\tpendingIdleTasks.delete(identifier);\n\t\t\t\t\treturn pendingTask().then(restore);\n\t\t\t\t}\n\t\t\t\treturn restore();\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.storeBuildDependencies.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\tdependencies => {\n\t\t\t\tpendingIdleTasks.set(BUILD_DEPENDENCIES_KEY, () =>\n\t\t\t\t\tstrategy.storeBuildDependencies(dependencies)\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.cache.hooks.shutdown.tapPromise(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tif (idleTimer) {\n\t\t\t\t\tclearTimeout(idleTimer);\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t}\n\t\t\t\tisIdle = false;\n\t\t\t\tconst reportProgress = ProgressPlugin.getReporter(compiler);\n\t\t\t\tconst jobs = Array.from(pendingIdleTasks.values());\n\t\t\t\tif (reportProgress) reportProgress(0, \"process pending cache items\");\n\t\t\t\tconst promises = jobs.map(fn => fn());\n\t\t\t\tpendingIdleTasks.clear();\n\t\t\t\tpromises.push(currentIdlePromise);\n\t\t\t\tconst promise = Promise.all(promises);\n\t\t\t\tcurrentIdlePromise = promise.then(() => strategy.afterAllStored());\n\t\t\t\tif (reportProgress) {\n\t\t\t\t\tcurrentIdlePromise = currentIdlePromise.then(() => {\n\t\t\t\t\t\treportProgress(1, `stored`);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn currentIdlePromise.then(() => {\n\t\t\t\t\t// Reset strategy\n\t\t\t\t\tif (strategy.clear) strategy.clear();\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\n\t\t/** @type {Promise<any>} */\n\t\tlet currentIdlePromise = resolvedPromise;\n\t\tlet isIdle = false;\n\t\tlet isInitialStore = true;\n\t\tconst processIdleTasks = () => {\n\t\t\tif (isIdle) {\n\t\t\t\tconst startTime = Date.now();\n\t\t\t\tif (pendingIdleTasks.size > 0) {\n\t\t\t\t\tconst promises = [currentIdlePromise];\n\t\t\t\t\tconst maxTime = startTime + 100;\n\t\t\t\t\tlet maxCount = 100;\n\t\t\t\t\tfor (const [filename, factory] of pendingIdleTasks) {\n\t\t\t\t\t\tpendingIdleTasks.delete(filename);\n\t\t\t\t\t\tpromises.push(factory());\n\t\t\t\t\t\tif (maxCount-- <= 0 || Date.now() > maxTime) break;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentIdlePromise = Promise.all(promises);\n\t\t\t\t\tcurrentIdlePromise.then(() => {\n\t\t\t\t\t\ttimeSpendInStore += Date.now() - startTime;\n\t\t\t\t\t\t// Allow to exit the process between\n\t\t\t\t\t\tidleTimer = setTimeout(processIdleTasks, 0);\n\t\t\t\t\t\tidleTimer.unref();\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentIdlePromise = currentIdlePromise\n\t\t\t\t\t.then(async () => {\n\t\t\t\t\t\tawait strategy.afterAllStored();\n\t\t\t\t\t\ttimeSpendInStore += Date.now() - startTime;\n\t\t\t\t\t\tavgTimeSpendInStore =\n\t\t\t\t\t\t\tMath.max(avgTimeSpendInStore, timeSpendInStore) * 0.9 +\n\t\t\t\t\t\t\ttimeSpendInStore * 0.1;\n\t\t\t\t\t\ttimeSpendInStore = 0;\n\t\t\t\t\t\ttimeSpendInBuild = 0;\n\t\t\t\t\t})\n\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\tconst logger = compiler.getInfrastructureLogger(\n\t\t\t\t\t\t\t\"IdleFileCachePlugin\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlogger.warn(`Background tasks during idle failed: ${err.message}`);\n\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t});\n\t\t\t\tisInitialStore = false;\n\t\t\t}\n\t\t};\n\t\tlet idleTimer = undefined;\n\t\tcompiler.cache.hooks.beginIdle.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tconst isLargeChange = timeSpendInBuild > avgTimeSpendInStore * 2;\n\t\t\t\tif (isInitialStore && idleTimeoutForInitialStore < idleTimeout) {\n\t\t\t\t\tcompiler\n\t\t\t\t\t\t.getInfrastructureLogger(\"IdleFileCachePlugin\")\n\t\t\t\t\t\t.log(\n\t\t\t\t\t\t\t`Initial cache was generated and cache will be persisted in ${\n\t\t\t\t\t\t\t\tidleTimeoutForInitialStore / 1000\n\t\t\t\t\t\t\t}s.`\n\t\t\t\t\t\t);\n\t\t\t\t} else if (\n\t\t\t\t\tisLargeChange &&\n\t\t\t\t\tidleTimeoutAfterLargeChanges < idleTimeout\n\t\t\t\t) {\n\t\t\t\t\tcompiler\n\t\t\t\t\t\t.getInfrastructureLogger(\"IdleFileCachePlugin\")\n\t\t\t\t\t\t.log(\n\t\t\t\t\t\t\t`Spend ${Math.round(timeSpendInBuild) / 1000}s in build and ${\n\t\t\t\t\t\t\t\tMath.round(avgTimeSpendInStore) / 1000\n\t\t\t\t\t\t\t}s in average in cache store. This is considered as large change and cache will be persisted in ${\n\t\t\t\t\t\t\t\tidleTimeoutAfterLargeChanges / 1000\n\t\t\t\t\t\t\t}s.`\n\t\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tidleTimer = setTimeout(() => {\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t\tisIdle = true;\n\t\t\t\t\tresolvedPromise.then(processIdleTasks);\n\t\t\t\t}, Math.min(isInitialStore ? idleTimeoutForInitialStore : Infinity, isLargeChange ? idleTimeoutAfterLargeChanges : Infinity, idleTimeout));\n\t\t\t\tidleTimer.unref();\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.endIdle.tap(\n\t\t\t{ name: \"IdleFileCachePlugin\", stage: Cache.STAGE_DISK },\n\t\t\t() => {\n\t\t\t\tif (idleTimer) {\n\t\t\t\t\tclearTimeout(idleTimer);\n\t\t\t\t\tidleTimer = undefined;\n\t\t\t\t}\n\t\t\t\tisIdle = false;\n\t\t\t}\n\t\t);\n\t\tcompiler.hooks.done.tap(\"IdleFileCachePlugin\", stats => {\n\t\t\t// 10% build overhead is ignored, as it's not cacheable\n\t\t\ttimeSpendInBuild *= 0.9;\n\t\t\ttimeSpendInBuild += stats.endTime - stats.startTime;\n\t\t});\n\t}\n}\n\nmodule.exports = IdleFileCachePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}