{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\n\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\n\nconst {\n  compareModulesByIdentifier,\n  compareChunks\n} = require(\"../util/comparators\");\n\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\n\nconst identifierUtils = require(\"../util/identifier\");\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"), () => require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\"), {\n  name: \"Aggressive Splitting Plugin\",\n  baseDataPath: \"options\"\n});\n\nconst moveModuleBetween = (chunkGraph, oldChunk, newChunk) => {\n  return module => {\n    chunkGraph.disconnectChunkAndModule(oldChunk, module);\n    chunkGraph.connectChunkAndModule(newChunk, module);\n  };\n};\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\n\n\nconst isNotAEntryModule = (chunkGraph, chunk) => {\n  return module => {\n    return !chunkGraph.isEntryModuleInChunk(module, chunk);\n  };\n};\n/** @type {WeakSet<Chunk>} */\n\n\nconst recordedChunks = new WeakSet();\n\nclass AggressiveSplittingPlugin {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    this.options = options;\n\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n  /**\n   * @param {Chunk} chunk the chunk to test\n   * @returns {boolean} true if the chunk was recorded\n   */\n\n\n  static wasChunkRecorded(chunk) {\n    return recordedChunks.has(chunk);\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", compilation => {\n      let needAdditionalSeal = false;\n      let newSplits;\n      let fromAggressiveSplittingSet;\n      let chunkSplitDataMap;\n      compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n        newSplits = [];\n        fromAggressiveSplittingSet = new Set();\n        chunkSplitDataMap = new Map();\n      });\n      compilation.hooks.optimizeChunks.tap({\n        name: \"AggressiveSplittingPlugin\",\n        stage: STAGE_ADVANCED\n      }, chunks => {\n        const chunkGraph = compilation.chunkGraph; // Precompute stuff\n\n        const nameToModuleMap = new Map();\n        const moduleToNameMap = new Map();\n        const makePathsRelative = identifierUtils.makePathsRelative.bindContextCache(compiler.context, compiler.root);\n\n        for (const m of compilation.modules) {\n          const name = makePathsRelative(m.identifier());\n          nameToModuleMap.set(name, m);\n          moduleToNameMap.set(m, name);\n        } // Check used chunk ids\n\n\n        const usedIds = new Set();\n\n        for (const chunk of chunks) {\n          usedIds.add(chunk.id);\n        }\n\n        const recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n        const usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n        const minSize = this.options.minSize;\n        const maxSize = this.options.maxSize;\n\n        const applySplit = splitData => {\n          // Cannot split if id is already taken\n          if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n            return false;\n          } // Get module objects from names\n\n\n          const selectedModules = splitData.modules.map(name => nameToModuleMap.get(name)); // Does the modules exist at all?\n\n          if (!selectedModules.every(Boolean)) return false; // Check if size matches (faster than waiting for hash)\n\n          let size = 0;\n\n          for (const m of selectedModules) size += m.size();\n\n          if (size !== splitData.size) return false; // get chunks with all modules\n\n          const selectedChunks = intersect(selectedModules.map(m => new Set(chunkGraph.getModuleChunksIterable(m)))); // No relevant chunks found\n\n          if (selectedChunks.size === 0) return false; // The found chunk is already the split or similar\n\n          if (selectedChunks.size === 1 && chunkGraph.getNumberOfChunkModules(Array.from(selectedChunks)[0]) === selectedModules.length) {\n            const chunk = Array.from(selectedChunks)[0];\n            if (fromAggressiveSplittingSet.has(chunk)) return false;\n            fromAggressiveSplittingSet.add(chunk);\n            chunkSplitDataMap.set(chunk, splitData);\n            return true;\n          } // split the chunk into two parts\n\n\n          const newChunk = compilation.addChunk();\n          newChunk.chunkReason = \"aggressive splitted\";\n\n          for (const chunk of selectedChunks) {\n            selectedModules.forEach(moveModuleBetween(chunkGraph, chunk, newChunk));\n            chunk.split(newChunk);\n            chunk.name = null;\n          }\n\n          fromAggressiveSplittingSet.add(newChunk);\n          chunkSplitDataMap.set(newChunk, splitData);\n\n          if (splitData.id !== null && splitData.id !== undefined) {\n            newChunk.id = splitData.id;\n            newChunk.ids = [splitData.id];\n          }\n\n          return true;\n        }; // try to restore to recorded splitting\n\n\n        let changed = false;\n\n        for (let j = 0; j < usedSplits.length; j++) {\n          const splitData = usedSplits[j];\n          if (applySplit(splitData)) changed = true;\n        } // for any chunk which isn't splitted yet, split it and create a new entry\n        // start with the biggest chunk\n\n\n        const cmpFn = compareChunks(chunkGraph);\n        const sortedChunks = Array.from(chunks).sort((a, b) => {\n          const diff1 = chunkGraph.getChunkModulesSize(b) - chunkGraph.getChunkModulesSize(a);\n          if (diff1) return diff1;\n          const diff2 = chunkGraph.getNumberOfChunkModules(a) - chunkGraph.getNumberOfChunkModules(b);\n          if (diff2) return diff2;\n          return cmpFn(a, b);\n        });\n\n        for (const chunk of sortedChunks) {\n          if (fromAggressiveSplittingSet.has(chunk)) continue;\n          const size = chunkGraph.getChunkModulesSize(chunk);\n\n          if (size > maxSize && chunkGraph.getNumberOfChunkModules(chunk) > 1) {\n            const modules = chunkGraph.getOrderedChunkModules(chunk, compareModulesByIdentifier).filter(isNotAEntryModule(chunkGraph, chunk));\n            const selectedModules = [];\n            let selectedModulesSize = 0;\n\n            for (let k = 0; k < modules.length; k++) {\n              const module = modules[k];\n              const newSize = selectedModulesSize + module.size();\n\n              if (newSize > maxSize && selectedModulesSize >= minSize) {\n                break;\n              }\n\n              selectedModulesSize = newSize;\n              selectedModules.push(module);\n            }\n\n            if (selectedModules.length === 0) continue;\n            const splitData = {\n              modules: selectedModules.map(m => moduleToNameMap.get(m)).sort(),\n              size: selectedModulesSize\n            };\n\n            if (applySplit(splitData)) {\n              newSplits = (newSplits || []).concat(splitData);\n              changed = true;\n            }\n          }\n        }\n\n        if (changed) return true;\n      });\n      compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", records => {\n        // 4. save made splittings to records\n        const allSplits = new Set();\n        const invalidSplits = new Set(); // Check if some splittings are invalid\n        // We remove invalid splittings and try again\n\n        for (const chunk of compilation.chunks) {\n          const splitData = chunkSplitDataMap.get(chunk);\n\n          if (splitData !== undefined) {\n            if (splitData.hash && chunk.hash !== splitData.hash) {\n              // Split was successful, but hash doesn't equal\n              // We can throw away the split since it's useless now\n              invalidSplits.add(splitData);\n            }\n          }\n        }\n\n        if (invalidSplits.size > 0) {\n          records.aggressiveSplits = records.aggressiveSplits.filter(splitData => !invalidSplits.has(splitData));\n          needAdditionalSeal = true;\n        } else {\n          // set hash and id values on all (new) splittings\n          for (const chunk of compilation.chunks) {\n            const splitData = chunkSplitDataMap.get(chunk);\n\n            if (splitData !== undefined) {\n              splitData.hash = chunk.hash;\n              splitData.id = chunk.id;\n              allSplits.add(splitData); // set flag for stats\n\n              recordedChunks.add(chunk);\n            }\n          } // Also add all unused historical splits (after the used ones)\n          // They can still be used in some future compilation\n\n\n          const recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n\n          if (recordedSplits) {\n            for (const splitData of recordedSplits) {\n              if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n            }\n          } // record all splits\n\n\n          records.aggressiveSplits = Array.from(allSplits);\n          needAdditionalSeal = false;\n        }\n      });\n      compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", () => {\n        if (needAdditionalSeal) {\n          needAdditionalSeal = false;\n          return true;\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = AggressiveSplittingPlugin;","map":{"version":3,"names":["STAGE_ADVANCED","require","intersect","compareModulesByIdentifier","compareChunks","createSchemaValidation","identifierUtils","validate","name","baseDataPath","moveModuleBetween","chunkGraph","oldChunk","newChunk","module","disconnectChunkAndModule","connectChunkAndModule","isNotAEntryModule","chunk","isEntryModuleInChunk","recordedChunks","WeakSet","AggressiveSplittingPlugin","constructor","options","minSize","maxSize","chunkOverhead","entryChunkMultiplicator","wasChunkRecorded","has","apply","compiler","hooks","thisCompilation","tap","compilation","needAdditionalSeal","newSplits","fromAggressiveSplittingSet","chunkSplitDataMap","optimize","Set","Map","optimizeChunks","stage","chunks","nameToModuleMap","moduleToNameMap","makePathsRelative","bindContextCache","context","root","m","modules","identifier","set","usedIds","add","id","recordedSplits","records","aggressiveSplits","usedSplits","concat","applySplit","splitData","undefined","selectedModules","map","get","every","Boolean","size","selectedChunks","getModuleChunksIterable","getNumberOfChunkModules","Array","from","length","addChunk","chunkReason","forEach","split","ids","changed","j","cmpFn","sortedChunks","sort","a","b","diff1","getChunkModulesSize","diff2","getOrderedChunkModules","filter","selectedModulesSize","k","newSize","push","recordHash","allSplits","invalidSplits","hash","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst { intersect } = require(\"../util/SetHelpers\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareChunks\n} = require(\"../util/comparators\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst identifierUtils = require(\"../util/identifier\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js\"),\n\t() =>\n\t\trequire(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\"),\n\t{\n\t\tname: \"Aggressive Splitting Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\nconst moveModuleBetween = (chunkGraph, oldChunk, newChunk) => {\n\treturn module => {\n\t\tchunkGraph.disconnectChunkAndModule(oldChunk, module);\n\t\tchunkGraph.connectChunkAndModule(newChunk, module);\n\t};\n};\n\n/**\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {Chunk} chunk the chunk\n * @returns {function(Module): boolean} filter for entry module\n */\nconst isNotAEntryModule = (chunkGraph, chunk) => {\n\treturn module => {\n\t\treturn !chunkGraph.isEntryModuleInChunk(module, chunk);\n\t};\n};\n\n/** @type {WeakSet<Chunk>} */\nconst recordedChunks = new WeakSet();\n\nclass AggressiveSplittingPlugin {\n\t/**\n\t * @param {AggressiveSplittingPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\tthis.options = options;\n\t\tif (typeof this.options.minSize !== \"number\") {\n\t\t\tthis.options.minSize = 30 * 1024;\n\t\t}\n\t\tif (typeof this.options.maxSize !== \"number\") {\n\t\t\tthis.options.maxSize = 50 * 1024;\n\t\t}\n\t\tif (typeof this.options.chunkOverhead !== \"number\") {\n\t\t\tthis.options.chunkOverhead = 0;\n\t\t}\n\t\tif (typeof this.options.entryChunkMultiplicator !== \"number\") {\n\t\t\tthis.options.entryChunkMultiplicator = 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} chunk the chunk to test\n\t * @returns {boolean} true if the chunk was recorded\n\t */\n\tstatic wasChunkRecorded(chunk) {\n\t\treturn recordedChunks.has(chunk);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tlet needAdditionalSeal = false;\n\t\t\t\tlet newSplits;\n\t\t\t\tlet fromAggressiveSplittingSet;\n\t\t\t\tlet chunkSplitDataMap;\n\t\t\t\tcompilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n\t\t\t\t\tnewSplits = [];\n\t\t\t\t\tfromAggressiveSplittingSet = new Set();\n\t\t\t\t\tchunkSplitDataMap = new Map();\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: \"AggressiveSplittingPlugin\",\n\t\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t\t},\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\t// Precompute stuff\n\t\t\t\t\t\tconst nameToModuleMap = new Map();\n\t\t\t\t\t\tconst moduleToNameMap = new Map();\n\t\t\t\t\t\tconst makePathsRelative =\n\t\t\t\t\t\t\tidentifierUtils.makePathsRelative.bindContextCache(\n\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\tcompiler.root\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tfor (const m of compilation.modules) {\n\t\t\t\t\t\t\tconst name = makePathsRelative(m.identifier());\n\t\t\t\t\t\t\tnameToModuleMap.set(name, m);\n\t\t\t\t\t\t\tmoduleToNameMap.set(m, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check used chunk ids\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t(compilation.records && compilation.records.aggressiveSplits) ||\n\t\t\t\t\t\t\t[];\n\t\t\t\t\t\tconst usedSplits = newSplits\n\t\t\t\t\t\t\t? recordedSplits.concat(newSplits)\n\t\t\t\t\t\t\t: recordedSplits;\n\n\t\t\t\t\t\tconst minSize = this.options.minSize;\n\t\t\t\t\t\tconst maxSize = this.options.maxSize;\n\n\t\t\t\t\t\tconst applySplit = splitData => {\n\t\t\t\t\t\t\t// Cannot split if id is already taken\n\t\t\t\t\t\t\tif (splitData.id !== undefined && usedIds.has(splitData.id)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get module objects from names\n\t\t\t\t\t\t\tconst selectedModules = splitData.modules.map(name =>\n\t\t\t\t\t\t\t\tnameToModuleMap.get(name)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Does the modules exist at all?\n\t\t\t\t\t\t\tif (!selectedModules.every(Boolean)) return false;\n\n\t\t\t\t\t\t\t// Check if size matches (faster than waiting for hash)\n\t\t\t\t\t\t\tlet size = 0;\n\t\t\t\t\t\t\tfor (const m of selectedModules) size += m.size();\n\t\t\t\t\t\t\tif (size !== splitData.size) return false;\n\n\t\t\t\t\t\t\t// get chunks with all modules\n\t\t\t\t\t\t\tconst selectedChunks = intersect(\n\t\t\t\t\t\t\t\tselectedModules.map(\n\t\t\t\t\t\t\t\t\tm => new Set(chunkGraph.getModuleChunksIterable(m))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// No relevant chunks found\n\t\t\t\t\t\t\tif (selectedChunks.size === 0) return false;\n\n\t\t\t\t\t\t\t// The found chunk is already the split or similar\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tselectedChunks.size === 1 &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(\n\t\t\t\t\t\t\t\t\tArray.from(selectedChunks)[0]\n\t\t\t\t\t\t\t\t) === selectedModules.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst chunk = Array.from(selectedChunks)[0];\n\t\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) return false;\n\t\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(chunk);\n\t\t\t\t\t\t\t\tchunkSplitDataMap.set(chunk, splitData);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split the chunk into two parts\n\t\t\t\t\t\t\tconst newChunk = compilation.addChunk();\n\t\t\t\t\t\t\tnewChunk.chunkReason = \"aggressive splitted\";\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tselectedModules.forEach(\n\t\t\t\t\t\t\t\t\tmoveModuleBetween(chunkGraph, chunk, newChunk)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t\t\tchunk.name = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(newChunk);\n\t\t\t\t\t\t\tchunkSplitDataMap.set(newChunk, splitData);\n\n\t\t\t\t\t\t\tif (splitData.id !== null && splitData.id !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk.id = splitData.id;\n\t\t\t\t\t\t\t\tnewChunk.ids = [splitData.id];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// try to restore to recorded splitting\n\t\t\t\t\t\tlet changed = false;\n\t\t\t\t\t\tfor (let j = 0; j < usedSplits.length; j++) {\n\t\t\t\t\t\t\tconst splitData = usedSplits[j];\n\t\t\t\t\t\t\tif (applySplit(splitData)) changed = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for any chunk which isn't splitted yet, split it and create a new entry\n\t\t\t\t\t\t// start with the biggest chunk\n\t\t\t\t\t\tconst cmpFn = compareChunks(chunkGraph);\n\t\t\t\t\t\tconst sortedChunks = Array.from(chunks).sort((a, b) => {\n\t\t\t\t\t\t\tconst diff1 =\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(b) -\n\t\t\t\t\t\t\t\tchunkGraph.getChunkModulesSize(a);\n\t\t\t\t\t\t\tif (diff1) return diff1;\n\t\t\t\t\t\t\tconst diff2 =\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(a) -\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(b);\n\t\t\t\t\t\t\tif (diff2) return diff2;\n\t\t\t\t\t\t\treturn cmpFn(a, b);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (const chunk of sortedChunks) {\n\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) continue;\n\t\t\t\t\t\t\tconst size = chunkGraph.getChunkModulesSize(chunk);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tsize > maxSize &&\n\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) > 1\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst modules = chunkGraph\n\t\t\t\t\t\t\t\t\t.getOrderedChunkModules(chunk, compareModulesByIdentifier)\n\t\t\t\t\t\t\t\t\t.filter(isNotAEntryModule(chunkGraph, chunk));\n\t\t\t\t\t\t\t\tconst selectedModules = [];\n\t\t\t\t\t\t\t\tlet selectedModulesSize = 0;\n\t\t\t\t\t\t\t\tfor (let k = 0; k < modules.length; k++) {\n\t\t\t\t\t\t\t\t\tconst module = modules[k];\n\t\t\t\t\t\t\t\t\tconst newSize = selectedModulesSize + module.size();\n\t\t\t\t\t\t\t\t\tif (newSize > maxSize && selectedModulesSize >= minSize) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tselectedModulesSize = newSize;\n\t\t\t\t\t\t\t\t\tselectedModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (selectedModules.length === 0) continue;\n\t\t\t\t\t\t\t\tconst splitData = {\n\t\t\t\t\t\t\t\t\tmodules: selectedModules\n\t\t\t\t\t\t\t\t\t\t.map(m => moduleToNameMap.get(m))\n\t\t\t\t\t\t\t\t\t\t.sort(),\n\t\t\t\t\t\t\t\t\tsize: selectedModulesSize\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (applySplit(splitData)) {\n\t\t\t\t\t\t\t\t\tnewSplits = (newSplits || []).concat(splitData);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (changed) return true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.recordHash.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\trecords => {\n\t\t\t\t\t\t// 4. save made splittings to records\n\t\t\t\t\t\tconst allSplits = new Set();\n\t\t\t\t\t\tconst invalidSplits = new Set();\n\n\t\t\t\t\t\t// Check if some splittings are invalid\n\t\t\t\t\t\t// We remove invalid splittings and try again\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\tif (splitData.hash && chunk.hash !== splitData.hash) {\n\t\t\t\t\t\t\t\t\t// Split was successful, but hash doesn't equal\n\t\t\t\t\t\t\t\t\t// We can throw away the split since it's useless now\n\t\t\t\t\t\t\t\t\tinvalidSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (invalidSplits.size > 0) {\n\t\t\t\t\t\t\trecords.aggressiveSplits = records.aggressiveSplits.filter(\n\t\t\t\t\t\t\t\tsplitData => !invalidSplits.has(splitData)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tneedAdditionalSeal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set hash and id values on all (new) splittings\n\t\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\t\tsplitData.hash = chunk.hash;\n\t\t\t\t\t\t\t\t\tsplitData.id = chunk.id;\n\t\t\t\t\t\t\t\t\tallSplits.add(splitData);\n\t\t\t\t\t\t\t\t\t// set flag for stats\n\t\t\t\t\t\t\t\t\trecordedChunks.add(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add all unused historical splits (after the used ones)\n\t\t\t\t\t\t\t// They can still be used in some future compilation\n\t\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t\tcompilation.records && compilation.records.aggressiveSplits;\n\t\t\t\t\t\t\tif (recordedSplits) {\n\t\t\t\t\t\t\t\tfor (const splitData of recordedSplits) {\n\t\t\t\t\t\t\t\t\tif (!invalidSplits.has(splitData)) allSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// record all splits\n\t\t\t\t\t\t\trecords.aggressiveSplits = Array.from(allSplits);\n\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.needAdditionalSeal.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\t() => {\n\t\t\t\t\t\tif (needAdditionalSeal) {\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = AggressiveSplittingPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}