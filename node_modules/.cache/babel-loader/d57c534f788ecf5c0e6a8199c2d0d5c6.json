{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass HookCodeFactory {\n  constructor(config) {\n    this.config = config;\n    this.options = undefined;\n    this._args = undefined;\n  }\n\n  create(options) {\n    this.init(options);\n    let fn;\n\n    switch (this.options.type) {\n      case \"sync\":\n        fn = new Function(this.args(), '\"use strict\";\\n' + this.header() + this.contentWithInterceptors({\n          onError: err => `throw ${err};\\n`,\n          onResult: result => `return ${result};\\n`,\n          resultReturns: true,\n          onDone: () => \"\",\n          rethrowIfPossible: true\n        }));\n        break;\n\n      case \"async\":\n        fn = new Function(this.args({\n          after: \"_callback\"\n        }), '\"use strict\";\\n' + this.header() + this.contentWithInterceptors({\n          onError: err => `_callback(${err});\\n`,\n          onResult: result => `_callback(null, ${result});\\n`,\n          onDone: () => \"_callback();\\n\"\n        }));\n        break;\n\n      case \"promise\":\n        let errorHelperUsed = false;\n        const content = this.contentWithInterceptors({\n          onError: err => {\n            errorHelperUsed = true;\n            return `_error(${err});\\n`;\n          },\n          onResult: result => `_resolve(${result});\\n`,\n          onDone: () => \"_resolve();\\n\"\n        });\n        let code = \"\";\n        code += '\"use strict\";\\n';\n        code += this.header();\n        code += \"return new Promise((function(_resolve, _reject) {\\n\";\n\n        if (errorHelperUsed) {\n          code += \"var _sync = true;\\n\";\n          code += \"function _error(_err) {\\n\";\n          code += \"if(_sync)\\n\";\n          code += \"_resolve(Promise.resolve().then((function() { throw _err; })));\\n\";\n          code += \"else\\n\";\n          code += \"_reject(_err);\\n\";\n          code += \"};\\n\";\n        }\n\n        code += content;\n\n        if (errorHelperUsed) {\n          code += \"_sync = false;\\n\";\n        }\n\n        code += \"}));\\n\";\n        fn = new Function(this.args(), code);\n        break;\n    }\n\n    this.deinit();\n    return fn;\n  }\n\n  setup(instance, options) {\n    instance._x = options.taps.map(t => t.fn);\n  }\n  /**\n   * @param {{ type: \"sync\" | \"promise\" | \"async\", taps: Array<Tap>, interceptors: Array<Interceptor> }} options\n   */\n\n\n  init(options) {\n    this.options = options;\n    this._args = options.args.slice();\n  }\n\n  deinit() {\n    this.options = undefined;\n    this._args = undefined;\n  }\n\n  contentWithInterceptors(options) {\n    if (this.options.interceptors.length > 0) {\n      const onError = options.onError;\n      const onResult = options.onResult;\n      const onDone = options.onDone;\n      let code = \"\";\n\n      for (let i = 0; i < this.options.interceptors.length; i++) {\n        const interceptor = this.options.interceptors[i];\n\n        if (interceptor.call) {\n          code += `${this.getInterceptor(i)}.call(${this.args({\n            before: interceptor.context ? \"_context\" : undefined\n          })});\\n`;\n        }\n      }\n\n      code += this.content(Object.assign(options, {\n        onError: onError && (err => {\n          let code = \"\";\n\n          for (let i = 0; i < this.options.interceptors.length; i++) {\n            const interceptor = this.options.interceptors[i];\n\n            if (interceptor.error) {\n              code += `${this.getInterceptor(i)}.error(${err});\\n`;\n            }\n          }\n\n          code += onError(err);\n          return code;\n        }),\n        onResult: onResult && (result => {\n          let code = \"\";\n\n          for (let i = 0; i < this.options.interceptors.length; i++) {\n            const interceptor = this.options.interceptors[i];\n\n            if (interceptor.result) {\n              code += `${this.getInterceptor(i)}.result(${result});\\n`;\n            }\n          }\n\n          code += onResult(result);\n          return code;\n        }),\n        onDone: onDone && (() => {\n          let code = \"\";\n\n          for (let i = 0; i < this.options.interceptors.length; i++) {\n            const interceptor = this.options.interceptors[i];\n\n            if (interceptor.done) {\n              code += `${this.getInterceptor(i)}.done();\\n`;\n            }\n          }\n\n          code += onDone();\n          return code;\n        })\n      }));\n      return code;\n    } else {\n      return this.content(options);\n    }\n  }\n\n  header() {\n    let code = \"\";\n\n    if (this.needContext()) {\n      code += \"var _context = {};\\n\";\n    } else {\n      code += \"var _context;\\n\";\n    }\n\n    code += \"var _x = this._x;\\n\";\n\n    if (this.options.interceptors.length > 0) {\n      code += \"var _taps = this.taps;\\n\";\n      code += \"var _interceptors = this.interceptors;\\n\";\n    }\n\n    return code;\n  }\n\n  needContext() {\n    for (const tap of this.options.taps) if (tap.context) return true;\n\n    return false;\n  }\n\n  callTap(tapIndex, _ref) {\n    let {\n      onError,\n      onResult,\n      onDone,\n      rethrowIfPossible\n    } = _ref;\n    let code = \"\";\n    let hasTapCached = false;\n\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n\n      if (interceptor.tap) {\n        if (!hasTapCached) {\n          code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\\n`;\n          hasTapCached = true;\n        }\n\n        code += `${this.getInterceptor(i)}.tap(${interceptor.context ? \"_context, \" : \"\"}_tap${tapIndex});\\n`;\n      }\n    }\n\n    code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\\n`;\n    const tap = this.options.taps[tapIndex];\n\n    switch (tap.type) {\n      case \"sync\":\n        if (!rethrowIfPossible) {\n          code += `var _hasError${tapIndex} = false;\\n`;\n          code += \"try {\\n\";\n        }\n\n        if (onResult) {\n          code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({\n            before: tap.context ? \"_context\" : undefined\n          })});\\n`;\n        } else {\n          code += `_fn${tapIndex}(${this.args({\n            before: tap.context ? \"_context\" : undefined\n          })});\\n`;\n        }\n\n        if (!rethrowIfPossible) {\n          code += \"} catch(_err) {\\n\";\n          code += `_hasError${tapIndex} = true;\\n`;\n          code += onError(\"_err\");\n          code += \"}\\n\";\n          code += `if(!_hasError${tapIndex}) {\\n`;\n        }\n\n        if (onResult) {\n          code += onResult(`_result${tapIndex}`);\n        }\n\n        if (onDone) {\n          code += onDone();\n        }\n\n        if (!rethrowIfPossible) {\n          code += \"}\\n\";\n        }\n\n        break;\n\n      case \"async\":\n        let cbCode = \"\";\n        if (onResult) cbCode += `(function(_err${tapIndex}, _result${tapIndex}) {\\n`;else cbCode += `(function(_err${tapIndex}) {\\n`;\n        cbCode += `if(_err${tapIndex}) {\\n`;\n        cbCode += onError(`_err${tapIndex}`);\n        cbCode += \"} else {\\n\";\n\n        if (onResult) {\n          cbCode += onResult(`_result${tapIndex}`);\n        }\n\n        if (onDone) {\n          cbCode += onDone();\n        }\n\n        cbCode += \"}\\n\";\n        cbCode += \"})\";\n        code += `_fn${tapIndex}(${this.args({\n          before: tap.context ? \"_context\" : undefined,\n          after: cbCode\n        })});\\n`;\n        break;\n\n      case \"promise\":\n        code += `var _hasResult${tapIndex} = false;\\n`;\n        code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({\n          before: tap.context ? \"_context\" : undefined\n        })});\\n`;\n        code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\\n`;\n        code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\\n`;\n        code += `_promise${tapIndex}.then((function(_result${tapIndex}) {\\n`;\n        code += `_hasResult${tapIndex} = true;\\n`;\n\n        if (onResult) {\n          code += onResult(`_result${tapIndex}`);\n        }\n\n        if (onDone) {\n          code += onDone();\n        }\n\n        code += `}), function(_err${tapIndex}) {\\n`;\n        code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\\n`;\n        code += onError(`_err${tapIndex}`);\n        code += \"});\\n\";\n        break;\n    }\n\n    return code;\n  }\n\n  callTapsSeries(_ref2) {\n    let {\n      onError,\n      onResult,\n      resultReturns,\n      onDone,\n      doneReturns,\n      rethrowIfPossible\n    } = _ref2;\n    if (this.options.taps.length === 0) return onDone();\n    const firstAsync = this.options.taps.findIndex(t => t.type !== \"sync\");\n    const somethingReturns = resultReturns || doneReturns;\n    let code = \"\";\n    let current = onDone;\n    let unrollCounter = 0;\n\n    for (let j = this.options.taps.length - 1; j >= 0; j--) {\n      const i = j;\n      const unroll = current !== onDone && (this.options.taps[i].type !== \"sync\" || unrollCounter++ > 20);\n\n      if (unroll) {\n        unrollCounter = 0;\n        code += `function _next${i}() {\\n`;\n        code += current();\n        code += `}\\n`;\n\n        current = () => `${somethingReturns ? \"return \" : \"\"}_next${i}();\\n`;\n      }\n\n      const done = current;\n\n      const doneBreak = skipDone => {\n        if (skipDone) return \"\";\n        return onDone();\n      };\n\n      const content = this.callTap(i, {\n        onError: error => onError(i, error, done, doneBreak),\n        onResult: onResult && (result => {\n          return onResult(i, result, done, doneBreak);\n        }),\n        onDone: !onResult && done,\n        rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)\n      });\n\n      current = () => content;\n    }\n\n    code += current();\n    return code;\n  }\n\n  callTapsLooping(_ref3) {\n    let {\n      onError,\n      onDone,\n      rethrowIfPossible\n    } = _ref3;\n    if (this.options.taps.length === 0) return onDone();\n    const syncOnly = this.options.taps.every(t => t.type === \"sync\");\n    let code = \"\";\n\n    if (!syncOnly) {\n      code += \"var _looper = (function() {\\n\";\n      code += \"var _loopAsync = false;\\n\";\n    }\n\n    code += \"var _loop;\\n\";\n    code += \"do {\\n\";\n    code += \"_loop = false;\\n\";\n\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n\n      if (interceptor.loop) {\n        code += `${this.getInterceptor(i)}.loop(${this.args({\n          before: interceptor.context ? \"_context\" : undefined\n        })});\\n`;\n      }\n    }\n\n    code += this.callTapsSeries({\n      onError,\n      onResult: (i, result, next, doneBreak) => {\n        let code = \"\";\n        code += `if(${result} !== undefined) {\\n`;\n        code += \"_loop = true;\\n\";\n        if (!syncOnly) code += \"if(_loopAsync) _looper();\\n\";\n        code += doneBreak(true);\n        code += `} else {\\n`;\n        code += next();\n        code += `}\\n`;\n        return code;\n      },\n      onDone: onDone && (() => {\n        let code = \"\";\n        code += \"if(!_loop) {\\n\";\n        code += onDone();\n        code += \"}\\n\";\n        return code;\n      }),\n      rethrowIfPossible: rethrowIfPossible && syncOnly\n    });\n    code += \"} while(_loop);\\n\";\n\n    if (!syncOnly) {\n      code += \"_loopAsync = true;\\n\";\n      code += \"});\\n\";\n      code += \"_looper();\\n\";\n    }\n\n    return code;\n  }\n\n  callTapsParallel(_ref4) {\n    let {\n      onError,\n      onResult,\n      onDone,\n      rethrowIfPossible,\n      onTap = (i, run) => run()\n    } = _ref4;\n\n    if (this.options.taps.length <= 1) {\n      return this.callTapsSeries({\n        onError,\n        onResult,\n        onDone,\n        rethrowIfPossible\n      });\n    }\n\n    let code = \"\";\n    code += \"do {\\n\";\n    code += `var _counter = ${this.options.taps.length};\\n`;\n\n    if (onDone) {\n      code += \"var _done = (function() {\\n\";\n      code += onDone();\n      code += \"});\\n\";\n    }\n\n    for (let i = 0; i < this.options.taps.length; i++) {\n      const done = () => {\n        if (onDone) return \"if(--_counter === 0) _done();\\n\";else return \"--_counter;\";\n      };\n\n      const doneBreak = skipDone => {\n        if (skipDone || !onDone) return \"_counter = 0;\\n\";else return \"_counter = 0;\\n_done();\\n\";\n      };\n\n      code += \"if(_counter <= 0) break;\\n\";\n      code += onTap(i, () => this.callTap(i, {\n        onError: error => {\n          let code = \"\";\n          code += \"if(_counter > 0) {\\n\";\n          code += onError(i, error, done, doneBreak);\n          code += \"}\\n\";\n          return code;\n        },\n        onResult: onResult && (result => {\n          let code = \"\";\n          code += \"if(_counter > 0) {\\n\";\n          code += onResult(i, result, done, doneBreak);\n          code += \"}\\n\";\n          return code;\n        }),\n        onDone: !onResult && (() => {\n          return done();\n        }),\n        rethrowIfPossible\n      }), done, doneBreak);\n    }\n\n    code += \"} while(false);\\n\";\n    return code;\n  }\n\n  args() {\n    let {\n      before,\n      after\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let allArgs = this._args;\n    if (before) allArgs = [before].concat(allArgs);\n    if (after) allArgs = allArgs.concat(after);\n\n    if (allArgs.length === 0) {\n      return \"\";\n    } else {\n      return allArgs.join(\", \");\n    }\n  }\n\n  getTapFn(idx) {\n    return `_x[${idx}]`;\n  }\n\n  getTap(idx) {\n    return `_taps[${idx}]`;\n  }\n\n  getInterceptor(idx) {\n    return `_interceptors[${idx}]`;\n  }\n\n}\n\nmodule.exports = HookCodeFactory;","map":{"version":3,"names":["HookCodeFactory","constructor","config","options","undefined","_args","create","init","fn","type","Function","args","header","contentWithInterceptors","onError","err","onResult","result","resultReturns","onDone","rethrowIfPossible","after","errorHelperUsed","content","code","deinit","setup","instance","_x","taps","map","t","slice","interceptors","length","i","interceptor","call","getInterceptor","before","context","Object","assign","error","done","needContext","tap","callTap","tapIndex","hasTapCached","getTap","getTapFn","cbCode","callTapsSeries","doneReturns","firstAsync","findIndex","somethingReturns","current","unrollCounter","j","unroll","doneBreak","skipDone","callTapsLooping","syncOnly","every","loop","next","callTapsParallel","onTap","run","allArgs","concat","join","idx","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/tapable/lib/HookCodeFactory.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass HookCodeFactory {\n\tconstructor(config) {\n\t\tthis.config = config;\n\t\tthis.options = undefined;\n\t\tthis._args = undefined;\n\t}\n\n\tcreate(options) {\n\t\tthis.init(options);\n\t\tlet fn;\n\t\tswitch (this.options.type) {\n\t\t\tcase \"sync\":\n\t\t\t\tfn = new Function(\n\t\t\t\t\tthis.args(),\n\t\t\t\t\t'\"use strict\";\\n' +\n\t\t\t\t\t\tthis.header() +\n\t\t\t\t\t\tthis.contentWithInterceptors({\n\t\t\t\t\t\t\tonError: err => `throw ${err};\\n`,\n\t\t\t\t\t\t\tonResult: result => `return ${result};\\n`,\n\t\t\t\t\t\t\tresultReturns: true,\n\t\t\t\t\t\t\tonDone: () => \"\",\n\t\t\t\t\t\t\trethrowIfPossible: true\n\t\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"async\":\n\t\t\t\tfn = new Function(\n\t\t\t\t\tthis.args({\n\t\t\t\t\t\tafter: \"_callback\"\n\t\t\t\t\t}),\n\t\t\t\t\t'\"use strict\";\\n' +\n\t\t\t\t\t\tthis.header() +\n\t\t\t\t\t\tthis.contentWithInterceptors({\n\t\t\t\t\t\t\tonError: err => `_callback(${err});\\n`,\n\t\t\t\t\t\t\tonResult: result => `_callback(null, ${result});\\n`,\n\t\t\t\t\t\t\tonDone: () => \"_callback();\\n\"\n\t\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"promise\":\n\t\t\t\tlet errorHelperUsed = false;\n\t\t\t\tconst content = this.contentWithInterceptors({\n\t\t\t\t\tonError: err => {\n\t\t\t\t\t\terrorHelperUsed = true;\n\t\t\t\t\t\treturn `_error(${err});\\n`;\n\t\t\t\t\t},\n\t\t\t\t\tonResult: result => `_resolve(${result});\\n`,\n\t\t\t\t\tonDone: () => \"_resolve();\\n\"\n\t\t\t\t});\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += '\"use strict\";\\n';\n\t\t\t\tcode += this.header();\n\t\t\t\tcode += \"return new Promise((function(_resolve, _reject) {\\n\";\n\t\t\t\tif (errorHelperUsed) {\n\t\t\t\t\tcode += \"var _sync = true;\\n\";\n\t\t\t\t\tcode += \"function _error(_err) {\\n\";\n\t\t\t\t\tcode += \"if(_sync)\\n\";\n\t\t\t\t\tcode +=\n\t\t\t\t\t\t\"_resolve(Promise.resolve().then((function() { throw _err; })));\\n\";\n\t\t\t\t\tcode += \"else\\n\";\n\t\t\t\t\tcode += \"_reject(_err);\\n\";\n\t\t\t\t\tcode += \"};\\n\";\n\t\t\t\t}\n\t\t\t\tcode += content;\n\t\t\t\tif (errorHelperUsed) {\n\t\t\t\t\tcode += \"_sync = false;\\n\";\n\t\t\t\t}\n\t\t\t\tcode += \"}));\\n\";\n\t\t\t\tfn = new Function(this.args(), code);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.deinit();\n\t\treturn fn;\n\t}\n\n\tsetup(instance, options) {\n\t\tinstance._x = options.taps.map(t => t.fn);\n\t}\n\n\t/**\n\t * @param {{ type: \"sync\" | \"promise\" | \"async\", taps: Array<Tap>, interceptors: Array<Interceptor> }} options\n\t */\n\tinit(options) {\n\t\tthis.options = options;\n\t\tthis._args = options.args.slice();\n\t}\n\n\tdeinit() {\n\t\tthis.options = undefined;\n\t\tthis._args = undefined;\n\t}\n\n\tcontentWithInterceptors(options) {\n\t\tif (this.options.interceptors.length > 0) {\n\t\t\tconst onError = options.onError;\n\t\t\tconst onResult = options.onResult;\n\t\t\tconst onDone = options.onDone;\n\t\t\tlet code = \"\";\n\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\tif (interceptor.call) {\n\t\t\t\t\tcode += `${this.getInterceptor(i)}.call(${this.args({\n\t\t\t\t\t\tbefore: interceptor.context ? \"_context\" : undefined\n\t\t\t\t\t})});\\n`;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode += this.content(\n\t\t\t\tObject.assign(options, {\n\t\t\t\t\tonError:\n\t\t\t\t\t\tonError &&\n\t\t\t\t\t\t(err => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\t\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\t\t\t\t\tif (interceptor.error) {\n\t\t\t\t\t\t\t\t\tcode += `${this.getInterceptor(i)}.error(${err});\\n`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcode += onError(err);\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t}),\n\t\t\t\t\tonResult:\n\t\t\t\t\t\tonResult &&\n\t\t\t\t\t\t(result => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\t\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\t\t\t\t\tif (interceptor.result) {\n\t\t\t\t\t\t\t\t\tcode += `${this.getInterceptor(i)}.result(${result});\\n`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcode += onResult(result);\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t}),\n\t\t\t\t\tonDone:\n\t\t\t\t\t\tonDone &&\n\t\t\t\t\t\t(() => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\t\t\t\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\t\t\t\t\t\tif (interceptor.done) {\n\t\t\t\t\t\t\t\t\tcode += `${this.getInterceptor(i)}.done();\\n`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcode += onDone();\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t);\n\t\t\treturn code;\n\t\t} else {\n\t\t\treturn this.content(options);\n\t\t}\n\t}\n\n\theader() {\n\t\tlet code = \"\";\n\t\tif (this.needContext()) {\n\t\t\tcode += \"var _context = {};\\n\";\n\t\t} else {\n\t\t\tcode += \"var _context;\\n\";\n\t\t}\n\t\tcode += \"var _x = this._x;\\n\";\n\t\tif (this.options.interceptors.length > 0) {\n\t\t\tcode += \"var _taps = this.taps;\\n\";\n\t\t\tcode += \"var _interceptors = this.interceptors;\\n\";\n\t\t}\n\t\treturn code;\n\t}\n\n\tneedContext() {\n\t\tfor (const tap of this.options.taps) if (tap.context) return true;\n\t\treturn false;\n\t}\n\n\tcallTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {\n\t\tlet code = \"\";\n\t\tlet hasTapCached = false;\n\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\tif (interceptor.tap) {\n\t\t\t\tif (!hasTapCached) {\n\t\t\t\t\tcode += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\\n`;\n\t\t\t\t\thasTapCached = true;\n\t\t\t\t}\n\t\t\t\tcode += `${this.getInterceptor(i)}.tap(${\n\t\t\t\t\tinterceptor.context ? \"_context, \" : \"\"\n\t\t\t\t}_tap${tapIndex});\\n`;\n\t\t\t}\n\t\t}\n\t\tcode += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\\n`;\n\t\tconst tap = this.options.taps[tapIndex];\n\t\tswitch (tap.type) {\n\t\t\tcase \"sync\":\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += `var _hasError${tapIndex} = false;\\n`;\n\t\t\t\t\tcode += \"try {\\n\";\n\t\t\t\t}\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += `var _result${tapIndex} = _fn${tapIndex}(${this.args({\n\t\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t\t})});\\n`;\n\t\t\t\t} else {\n\t\t\t\t\tcode += `_fn${tapIndex}(${this.args({\n\t\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t\t})});\\n`;\n\t\t\t\t}\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += \"} catch(_err) {\\n\";\n\t\t\t\t\tcode += `_hasError${tapIndex} = true;\\n`;\n\t\t\t\t\tcode += onError(\"_err\");\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\tcode += `if(!_hasError${tapIndex}) {\\n`;\n\t\t\t\t}\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcode += onDone();\n\t\t\t\t}\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"async\":\n\t\t\t\tlet cbCode = \"\";\n\t\t\t\tif (onResult)\n\t\t\t\t\tcbCode += `(function(_err${tapIndex}, _result${tapIndex}) {\\n`;\n\t\t\t\telse cbCode += `(function(_err${tapIndex}) {\\n`;\n\t\t\t\tcbCode += `if(_err${tapIndex}) {\\n`;\n\t\t\t\tcbCode += onError(`_err${tapIndex}`);\n\t\t\t\tcbCode += \"} else {\\n\";\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcbCode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcbCode += onDone();\n\t\t\t\t}\n\t\t\t\tcbCode += \"}\\n\";\n\t\t\t\tcbCode += \"})\";\n\t\t\t\tcode += `_fn${tapIndex}(${this.args({\n\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined,\n\t\t\t\t\tafter: cbCode\n\t\t\t\t})});\\n`;\n\t\t\t\tbreak;\n\t\t\tcase \"promise\":\n\t\t\t\tcode += `var _hasResult${tapIndex} = false;\\n`;\n\t\t\t\tcode += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({\n\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t})});\\n`;\n\t\t\t\tcode += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\\n`;\n\t\t\t\tcode += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\\n`;\n\t\t\t\tcode += `_promise${tapIndex}.then((function(_result${tapIndex}) {\\n`;\n\t\t\t\tcode += `_hasResult${tapIndex} = true;\\n`;\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcode += onDone();\n\t\t\t\t}\n\t\t\t\tcode += `}), function(_err${tapIndex}) {\\n`;\n\t\t\t\tcode += `if(_hasResult${tapIndex}) throw _err${tapIndex};\\n`;\n\t\t\t\tcode += onError(`_err${tapIndex}`);\n\t\t\t\tcode += \"});\\n\";\n\t\t\t\tbreak;\n\t\t}\n\t\treturn code;\n\t}\n\n\tcallTapsSeries({\n\t\tonError,\n\t\tonResult,\n\t\tresultReturns,\n\t\tonDone,\n\t\tdoneReturns,\n\t\trethrowIfPossible\n\t}) {\n\t\tif (this.options.taps.length === 0) return onDone();\n\t\tconst firstAsync = this.options.taps.findIndex(t => t.type !== \"sync\");\n\t\tconst somethingReturns = resultReturns || doneReturns;\n\t\tlet code = \"\";\n\t\tlet current = onDone;\n\t\tlet unrollCounter = 0;\n\t\tfor (let j = this.options.taps.length - 1; j >= 0; j--) {\n\t\t\tconst i = j;\n\t\t\tconst unroll =\n\t\t\t\tcurrent !== onDone &&\n\t\t\t\t(this.options.taps[i].type !== \"sync\" || unrollCounter++ > 20);\n\t\t\tif (unroll) {\n\t\t\t\tunrollCounter = 0;\n\t\t\t\tcode += `function _next${i}() {\\n`;\n\t\t\t\tcode += current();\n\t\t\t\tcode += `}\\n`;\n\t\t\t\tcurrent = () => `${somethingReturns ? \"return \" : \"\"}_next${i}();\\n`;\n\t\t\t}\n\t\t\tconst done = current;\n\t\t\tconst doneBreak = skipDone => {\n\t\t\t\tif (skipDone) return \"\";\n\t\t\t\treturn onDone();\n\t\t\t};\n\t\t\tconst content = this.callTap(i, {\n\t\t\t\tonError: error => onError(i, error, done, doneBreak),\n\t\t\t\tonResult:\n\t\t\t\t\tonResult &&\n\t\t\t\t\t(result => {\n\t\t\t\t\t\treturn onResult(i, result, done, doneBreak);\n\t\t\t\t\t}),\n\t\t\t\tonDone: !onResult && done,\n\t\t\t\trethrowIfPossible:\n\t\t\t\t\trethrowIfPossible && (firstAsync < 0 || i < firstAsync)\n\t\t\t});\n\t\t\tcurrent = () => content;\n\t\t}\n\t\tcode += current();\n\t\treturn code;\n\t}\n\n\tcallTapsLooping({ onError, onDone, rethrowIfPossible }) {\n\t\tif (this.options.taps.length === 0) return onDone();\n\t\tconst syncOnly = this.options.taps.every(t => t.type === \"sync\");\n\t\tlet code = \"\";\n\t\tif (!syncOnly) {\n\t\t\tcode += \"var _looper = (function() {\\n\";\n\t\t\tcode += \"var _loopAsync = false;\\n\";\n\t\t}\n\t\tcode += \"var _loop;\\n\";\n\t\tcode += \"do {\\n\";\n\t\tcode += \"_loop = false;\\n\";\n\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\tif (interceptor.loop) {\n\t\t\t\tcode += `${this.getInterceptor(i)}.loop(${this.args({\n\t\t\t\t\tbefore: interceptor.context ? \"_context\" : undefined\n\t\t\t\t})});\\n`;\n\t\t\t}\n\t\t}\n\t\tcode += this.callTapsSeries({\n\t\t\tonError,\n\t\t\tonResult: (i, result, next, doneBreak) => {\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += `if(${result} !== undefined) {\\n`;\n\t\t\t\tcode += \"_loop = true;\\n\";\n\t\t\t\tif (!syncOnly) code += \"if(_loopAsync) _looper();\\n\";\n\t\t\t\tcode += doneBreak(true);\n\t\t\t\tcode += `} else {\\n`;\n\t\t\t\tcode += next();\n\t\t\t\tcode += `}\\n`;\n\t\t\t\treturn code;\n\t\t\t},\n\t\t\tonDone:\n\t\t\t\tonDone &&\n\t\t\t\t(() => {\n\t\t\t\t\tlet code = \"\";\n\t\t\t\t\tcode += \"if(!_loop) {\\n\";\n\t\t\t\t\tcode += onDone();\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\treturn code;\n\t\t\t\t}),\n\t\t\trethrowIfPossible: rethrowIfPossible && syncOnly\n\t\t});\n\t\tcode += \"} while(_loop);\\n\";\n\t\tif (!syncOnly) {\n\t\t\tcode += \"_loopAsync = true;\\n\";\n\t\t\tcode += \"});\\n\";\n\t\t\tcode += \"_looper();\\n\";\n\t\t}\n\t\treturn code;\n\t}\n\n\tcallTapsParallel({\n\t\tonError,\n\t\tonResult,\n\t\tonDone,\n\t\trethrowIfPossible,\n\t\tonTap = (i, run) => run()\n\t}) {\n\t\tif (this.options.taps.length <= 1) {\n\t\t\treturn this.callTapsSeries({\n\t\t\t\tonError,\n\t\t\t\tonResult,\n\t\t\t\tonDone,\n\t\t\t\trethrowIfPossible\n\t\t\t});\n\t\t}\n\t\tlet code = \"\";\n\t\tcode += \"do {\\n\";\n\t\tcode += `var _counter = ${this.options.taps.length};\\n`;\n\t\tif (onDone) {\n\t\t\tcode += \"var _done = (function() {\\n\";\n\t\t\tcode += onDone();\n\t\t\tcode += \"});\\n\";\n\t\t}\n\t\tfor (let i = 0; i < this.options.taps.length; i++) {\n\t\t\tconst done = () => {\n\t\t\t\tif (onDone) return \"if(--_counter === 0) _done();\\n\";\n\t\t\t\telse return \"--_counter;\";\n\t\t\t};\n\t\t\tconst doneBreak = skipDone => {\n\t\t\t\tif (skipDone || !onDone) return \"_counter = 0;\\n\";\n\t\t\t\telse return \"_counter = 0;\\n_done();\\n\";\n\t\t\t};\n\t\t\tcode += \"if(_counter <= 0) break;\\n\";\n\t\t\tcode += onTap(\n\t\t\t\ti,\n\t\t\t\t() =>\n\t\t\t\t\tthis.callTap(i, {\n\t\t\t\t\t\tonError: error => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tcode += \"if(_counter > 0) {\\n\";\n\t\t\t\t\t\t\tcode += onError(i, error, done, doneBreak);\n\t\t\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonResult:\n\t\t\t\t\t\t\tonResult &&\n\t\t\t\t\t\t\t(result => {\n\t\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\t\tcode += \"if(_counter > 0) {\\n\";\n\t\t\t\t\t\t\t\tcode += onResult(i, result, done, doneBreak);\n\t\t\t\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\tonDone:\n\t\t\t\t\t\t\t!onResult &&\n\t\t\t\t\t\t\t(() => {\n\t\t\t\t\t\t\t\treturn done();\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\trethrowIfPossible\n\t\t\t\t\t}),\n\t\t\t\tdone,\n\t\t\t\tdoneBreak\n\t\t\t);\n\t\t}\n\t\tcode += \"} while(false);\\n\";\n\t\treturn code;\n\t}\n\n\targs({ before, after } = {}) {\n\t\tlet allArgs = this._args;\n\t\tif (before) allArgs = [before].concat(allArgs);\n\t\tif (after) allArgs = allArgs.concat(after);\n\t\tif (allArgs.length === 0) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn allArgs.join(\", \");\n\t\t}\n\t}\n\n\tgetTapFn(idx) {\n\t\treturn `_x[${idx}]`;\n\t}\n\n\tgetTap(idx) {\n\t\treturn `_taps[${idx}]`;\n\t}\n\n\tgetInterceptor(idx) {\n\t\treturn `_interceptors[${idx}]`;\n\t}\n}\n\nmodule.exports = HookCodeFactory;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,eAAN,CAAsB;EACrBC,WAAW,CAACC,MAAD,EAAS;IACnB,KAAKA,MAAL,GAAcA,MAAd;IACA,KAAKC,OAAL,GAAeC,SAAf;IACA,KAAKC,KAAL,GAAaD,SAAb;EACA;;EAEDE,MAAM,CAACH,OAAD,EAAU;IACf,KAAKI,IAAL,CAAUJ,OAAV;IACA,IAAIK,EAAJ;;IACA,QAAQ,KAAKL,OAAL,CAAaM,IAArB;MACC,KAAK,MAAL;QACCD,EAAE,GAAG,IAAIE,QAAJ,CACJ,KAAKC,IAAL,EADI,EAEJ,oBACC,KAAKC,MAAL,EADD,GAEC,KAAKC,uBAAL,CAA6B;UAC5BC,OAAO,EAAEC,GAAG,IAAK,SAAQA,GAAI,KADD;UAE5BC,QAAQ,EAAEC,MAAM,IAAK,UAASA,MAAO,KAFT;UAG5BC,aAAa,EAAE,IAHa;UAI5BC,MAAM,EAAE,MAAM,EAJc;UAK5BC,iBAAiB,EAAE;QALS,CAA7B,CAJG,CAAL;QAYA;;MACD,KAAK,OAAL;QACCZ,EAAE,GAAG,IAAIE,QAAJ,CACJ,KAAKC,IAAL,CAAU;UACTU,KAAK,EAAE;QADE,CAAV,CADI,EAIJ,oBACC,KAAKT,MAAL,EADD,GAEC,KAAKC,uBAAL,CAA6B;UAC5BC,OAAO,EAAEC,GAAG,IAAK,aAAYA,GAAI,MADL;UAE5BC,QAAQ,EAAEC,MAAM,IAAK,mBAAkBA,MAAO,MAFlB;UAG5BE,MAAM,EAAE,MAAM;QAHc,CAA7B,CANG,CAAL;QAYA;;MACD,KAAK,SAAL;QACC,IAAIG,eAAe,GAAG,KAAtB;QACA,MAAMC,OAAO,GAAG,KAAKV,uBAAL,CAA6B;UAC5CC,OAAO,EAAEC,GAAG,IAAI;YACfO,eAAe,GAAG,IAAlB;YACA,OAAQ,UAASP,GAAI,MAArB;UACA,CAJ2C;UAK5CC,QAAQ,EAAEC,MAAM,IAAK,YAAWA,MAAO,MALK;UAM5CE,MAAM,EAAE,MAAM;QAN8B,CAA7B,CAAhB;QAQA,IAAIK,IAAI,GAAG,EAAX;QACAA,IAAI,IAAI,iBAAR;QACAA,IAAI,IAAI,KAAKZ,MAAL,EAAR;QACAY,IAAI,IAAI,qDAAR;;QACA,IAAIF,eAAJ,EAAqB;UACpBE,IAAI,IAAI,qBAAR;UACAA,IAAI,IAAI,2BAAR;UACAA,IAAI,IAAI,aAAR;UACAA,IAAI,IACH,mEADD;UAEAA,IAAI,IAAI,QAAR;UACAA,IAAI,IAAI,kBAAR;UACAA,IAAI,IAAI,MAAR;QACA;;QACDA,IAAI,IAAID,OAAR;;QACA,IAAID,eAAJ,EAAqB;UACpBE,IAAI,IAAI,kBAAR;QACA;;QACDA,IAAI,IAAI,QAAR;QACAhB,EAAE,GAAG,IAAIE,QAAJ,CAAa,KAAKC,IAAL,EAAb,EAA0Ba,IAA1B,CAAL;QACA;IA3DF;;IA6DA,KAAKC,MAAL;IACA,OAAOjB,EAAP;EACA;;EAEDkB,KAAK,CAACC,QAAD,EAAWxB,OAAX,EAAoB;IACxBwB,QAAQ,CAACC,EAAT,GAAczB,OAAO,CAAC0B,IAAR,CAAaC,GAAb,CAAiBC,CAAC,IAAIA,CAAC,CAACvB,EAAxB,CAAd;EACA;EAED;AACD;AACA;;;EACCD,IAAI,CAACJ,OAAD,EAAU;IACb,KAAKA,OAAL,GAAeA,OAAf;IACA,KAAKE,KAAL,GAAaF,OAAO,CAACQ,IAAR,CAAaqB,KAAb,EAAb;EACA;;EAEDP,MAAM,GAAG;IACR,KAAKtB,OAAL,GAAeC,SAAf;IACA,KAAKC,KAAL,GAAaD,SAAb;EACA;;EAEDS,uBAAuB,CAACV,OAAD,EAAU;IAChC,IAAI,KAAKA,OAAL,CAAa8B,YAAb,CAA0BC,MAA1B,GAAmC,CAAvC,EAA0C;MACzC,MAAMpB,OAAO,GAAGX,OAAO,CAACW,OAAxB;MACA,MAAME,QAAQ,GAAGb,OAAO,CAACa,QAAzB;MACA,MAAMG,MAAM,GAAGhB,OAAO,CAACgB,MAAvB;MACA,IAAIK,IAAI,GAAG,EAAX;;MACA,KAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKhC,OAAL,CAAa8B,YAAb,CAA0BC,MAA9C,EAAsDC,CAAC,EAAvD,EAA2D;QAC1D,MAAMC,WAAW,GAAG,KAAKjC,OAAL,CAAa8B,YAAb,CAA0BE,CAA1B,CAApB;;QACA,IAAIC,WAAW,CAACC,IAAhB,EAAsB;UACrBb,IAAI,IAAK,GAAE,KAAKc,cAAL,CAAoBH,CAApB,CAAuB,SAAQ,KAAKxB,IAAL,CAAU;YACnD4B,MAAM,EAAEH,WAAW,CAACI,OAAZ,GAAsB,UAAtB,GAAmCpC;UADQ,CAAV,CAEvC,MAFH;QAGA;MACD;;MACDoB,IAAI,IAAI,KAAKD,OAAL,CACPkB,MAAM,CAACC,MAAP,CAAcvC,OAAd,EAAuB;QACtBW,OAAO,EACNA,OAAO,KACNC,GAAG,IAAI;UACP,IAAIS,IAAI,GAAG,EAAX;;UACA,KAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKhC,OAAL,CAAa8B,YAAb,CAA0BC,MAA9C,EAAsDC,CAAC,EAAvD,EAA2D;YAC1D,MAAMC,WAAW,GAAG,KAAKjC,OAAL,CAAa8B,YAAb,CAA0BE,CAA1B,CAApB;;YACA,IAAIC,WAAW,CAACO,KAAhB,EAAuB;cACtBnB,IAAI,IAAK,GAAE,KAAKc,cAAL,CAAoBH,CAApB,CAAuB,UAASpB,GAAI,MAA/C;YACA;UACD;;UACDS,IAAI,IAAIV,OAAO,CAACC,GAAD,CAAf;UACA,OAAOS,IAAP;QACA,CAXM,CAFc;QActBR,QAAQ,EACPA,QAAQ,KACPC,MAAM,IAAI;UACV,IAAIO,IAAI,GAAG,EAAX;;UACA,KAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKhC,OAAL,CAAa8B,YAAb,CAA0BC,MAA9C,EAAsDC,CAAC,EAAvD,EAA2D;YAC1D,MAAMC,WAAW,GAAG,KAAKjC,OAAL,CAAa8B,YAAb,CAA0BE,CAA1B,CAApB;;YACA,IAAIC,WAAW,CAACnB,MAAhB,EAAwB;cACvBO,IAAI,IAAK,GAAE,KAAKc,cAAL,CAAoBH,CAApB,CAAuB,WAAUlB,MAAO,MAAnD;YACA;UACD;;UACDO,IAAI,IAAIR,QAAQ,CAACC,MAAD,CAAhB;UACA,OAAOO,IAAP;QACA,CAXO,CAfa;QA2BtBL,MAAM,EACLA,MAAM,KACL,MAAM;UACN,IAAIK,IAAI,GAAG,EAAX;;UACA,KAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKhC,OAAL,CAAa8B,YAAb,CAA0BC,MAA9C,EAAsDC,CAAC,EAAvD,EAA2D;YAC1D,MAAMC,WAAW,GAAG,KAAKjC,OAAL,CAAa8B,YAAb,CAA0BE,CAA1B,CAApB;;YACA,IAAIC,WAAW,CAACQ,IAAhB,EAAsB;cACrBpB,IAAI,IAAK,GAAE,KAAKc,cAAL,CAAoBH,CAApB,CAAuB,YAAlC;YACA;UACD;;UACDX,IAAI,IAAIL,MAAM,EAAd;UACA,OAAOK,IAAP;QACA,CAXK;MA5Be,CAAvB,CADO,CAAR;MA2CA,OAAOA,IAAP;IACA,CAzDD,MAyDO;MACN,OAAO,KAAKD,OAAL,CAAapB,OAAb,CAAP;IACA;EACD;;EAEDS,MAAM,GAAG;IACR,IAAIY,IAAI,GAAG,EAAX;;IACA,IAAI,KAAKqB,WAAL,EAAJ,EAAwB;MACvBrB,IAAI,IAAI,sBAAR;IACA,CAFD,MAEO;MACNA,IAAI,IAAI,iBAAR;IACA;;IACDA,IAAI,IAAI,qBAAR;;IACA,IAAI,KAAKrB,OAAL,CAAa8B,YAAb,CAA0BC,MAA1B,GAAmC,CAAvC,EAA0C;MACzCV,IAAI,IAAI,0BAAR;MACAA,IAAI,IAAI,0CAAR;IACA;;IACD,OAAOA,IAAP;EACA;;EAEDqB,WAAW,GAAG;IACb,KAAK,MAAMC,GAAX,IAAkB,KAAK3C,OAAL,CAAa0B,IAA/B,EAAqC,IAAIiB,GAAG,CAACN,OAAR,EAAiB,OAAO,IAAP;;IACtD,OAAO,KAAP;EACA;;EAEDO,OAAO,CAACC,QAAD,QAA6D;IAAA,IAAlD;MAAElC,OAAF;MAAWE,QAAX;MAAqBG,MAArB;MAA6BC;IAA7B,CAAkD;IACnE,IAAII,IAAI,GAAG,EAAX;IACA,IAAIyB,YAAY,GAAG,KAAnB;;IACA,KAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKhC,OAAL,CAAa8B,YAAb,CAA0BC,MAA9C,EAAsDC,CAAC,EAAvD,EAA2D;MAC1D,MAAMC,WAAW,GAAG,KAAKjC,OAAL,CAAa8B,YAAb,CAA0BE,CAA1B,CAApB;;MACA,IAAIC,WAAW,CAACU,GAAhB,EAAqB;QACpB,IAAI,CAACG,YAAL,EAAmB;UAClBzB,IAAI,IAAK,WAAUwB,QAAS,MAAK,KAAKE,MAAL,CAAYF,QAAZ,CAAsB,KAAvD;UACAC,YAAY,GAAG,IAAf;QACA;;QACDzB,IAAI,IAAK,GAAE,KAAKc,cAAL,CAAoBH,CAApB,CAAuB,QACjCC,WAAW,CAACI,OAAZ,GAAsB,YAAtB,GAAqC,EACrC,OAAMQ,QAAS,MAFhB;MAGA;IACD;;IACDxB,IAAI,IAAK,UAASwB,QAAS,MAAK,KAAKG,QAAL,CAAcH,QAAd,CAAwB,KAAxD;IACA,MAAMF,GAAG,GAAG,KAAK3C,OAAL,CAAa0B,IAAb,CAAkBmB,QAAlB,CAAZ;;IACA,QAAQF,GAAG,CAACrC,IAAZ;MACC,KAAK,MAAL;QACC,IAAI,CAACW,iBAAL,EAAwB;UACvBI,IAAI,IAAK,gBAAewB,QAAS,aAAjC;UACAxB,IAAI,IAAI,SAAR;QACA;;QACD,IAAIR,QAAJ,EAAc;UACbQ,IAAI,IAAK,cAAawB,QAAS,SAAQA,QAAS,IAAG,KAAKrC,IAAL,CAAU;YAC5D4B,MAAM,EAAEO,GAAG,CAACN,OAAJ,GAAc,UAAd,GAA2BpC;UADyB,CAAV,CAEhD,MAFH;QAGA,CAJD,MAIO;UACNoB,IAAI,IAAK,MAAKwB,QAAS,IAAG,KAAKrC,IAAL,CAAU;YACnC4B,MAAM,EAAEO,GAAG,CAACN,OAAJ,GAAc,UAAd,GAA2BpC;UADA,CAAV,CAEvB,MAFH;QAGA;;QACD,IAAI,CAACgB,iBAAL,EAAwB;UACvBI,IAAI,IAAI,mBAAR;UACAA,IAAI,IAAK,YAAWwB,QAAS,YAA7B;UACAxB,IAAI,IAAIV,OAAO,CAAC,MAAD,CAAf;UACAU,IAAI,IAAI,KAAR;UACAA,IAAI,IAAK,gBAAewB,QAAS,OAAjC;QACA;;QACD,IAAIhC,QAAJ,EAAc;UACbQ,IAAI,IAAIR,QAAQ,CAAE,UAASgC,QAAS,EAApB,CAAhB;QACA;;QACD,IAAI7B,MAAJ,EAAY;UACXK,IAAI,IAAIL,MAAM,EAAd;QACA;;QACD,IAAI,CAACC,iBAAL,EAAwB;UACvBI,IAAI,IAAI,KAAR;QACA;;QACD;;MACD,KAAK,OAAL;QACC,IAAI4B,MAAM,GAAG,EAAb;QACA,IAAIpC,QAAJ,EACCoC,MAAM,IAAK,iBAAgBJ,QAAS,YAAWA,QAAS,OAAxD,CADD,KAEKI,MAAM,IAAK,iBAAgBJ,QAAS,OAApC;QACLI,MAAM,IAAK,UAASJ,QAAS,OAA7B;QACAI,MAAM,IAAItC,OAAO,CAAE,OAAMkC,QAAS,EAAjB,CAAjB;QACAI,MAAM,IAAI,YAAV;;QACA,IAAIpC,QAAJ,EAAc;UACboC,MAAM,IAAIpC,QAAQ,CAAE,UAASgC,QAAS,EAApB,CAAlB;QACA;;QACD,IAAI7B,MAAJ,EAAY;UACXiC,MAAM,IAAIjC,MAAM,EAAhB;QACA;;QACDiC,MAAM,IAAI,KAAV;QACAA,MAAM,IAAI,IAAV;QACA5B,IAAI,IAAK,MAAKwB,QAAS,IAAG,KAAKrC,IAAL,CAAU;UACnC4B,MAAM,EAAEO,GAAG,CAACN,OAAJ,GAAc,UAAd,GAA2BpC,SADA;UAEnCiB,KAAK,EAAE+B;QAF4B,CAAV,CAGvB,MAHH;QAIA;;MACD,KAAK,SAAL;QACC5B,IAAI,IAAK,iBAAgBwB,QAAS,aAAlC;QACAxB,IAAI,IAAK,eAAcwB,QAAS,SAAQA,QAAS,IAAG,KAAKrC,IAAL,CAAU;UAC7D4B,MAAM,EAAEO,GAAG,CAACN,OAAJ,GAAc,UAAd,GAA2BpC;QAD0B,CAAV,CAEjD,MAFH;QAGAoB,IAAI,IAAK,gBAAewB,QAAS,gBAAeA,QAAS,UAAzD;QACAxB,IAAI,IAAK,6FAA4FwB,QAAS,YAA9G;QACAxB,IAAI,IAAK,WAAUwB,QAAS,0BAAyBA,QAAS,OAA9D;QACAxB,IAAI,IAAK,aAAYwB,QAAS,YAA9B;;QACA,IAAIhC,QAAJ,EAAc;UACbQ,IAAI,IAAIR,QAAQ,CAAE,UAASgC,QAAS,EAApB,CAAhB;QACA;;QACD,IAAI7B,MAAJ,EAAY;UACXK,IAAI,IAAIL,MAAM,EAAd;QACA;;QACDK,IAAI,IAAK,oBAAmBwB,QAAS,OAArC;QACAxB,IAAI,IAAK,gBAAewB,QAAS,eAAcA,QAAS,KAAxD;QACAxB,IAAI,IAAIV,OAAO,CAAE,OAAMkC,QAAS,EAAjB,CAAf;QACAxB,IAAI,IAAI,OAAR;QACA;IAxEF;;IA0EA,OAAOA,IAAP;EACA;;EAED6B,cAAc,QAOX;IAAA,IAPY;MACdvC,OADc;MAEdE,QAFc;MAGdE,aAHc;MAIdC,MAJc;MAKdmC,WALc;MAMdlC;IANc,CAOZ;IACF,IAAI,KAAKjB,OAAL,CAAa0B,IAAb,CAAkBK,MAAlB,KAA6B,CAAjC,EAAoC,OAAOf,MAAM,EAAb;IACpC,MAAMoC,UAAU,GAAG,KAAKpD,OAAL,CAAa0B,IAAb,CAAkB2B,SAAlB,CAA4BzB,CAAC,IAAIA,CAAC,CAACtB,IAAF,KAAW,MAA5C,CAAnB;IACA,MAAMgD,gBAAgB,GAAGvC,aAAa,IAAIoC,WAA1C;IACA,IAAI9B,IAAI,GAAG,EAAX;IACA,IAAIkC,OAAO,GAAGvC,MAAd;IACA,IAAIwC,aAAa,GAAG,CAApB;;IACA,KAAK,IAAIC,CAAC,GAAG,KAAKzD,OAAL,CAAa0B,IAAb,CAAkBK,MAAlB,GAA2B,CAAxC,EAA2C0B,CAAC,IAAI,CAAhD,EAAmDA,CAAC,EAApD,EAAwD;MACvD,MAAMzB,CAAC,GAAGyB,CAAV;MACA,MAAMC,MAAM,GACXH,OAAO,KAAKvC,MAAZ,KACC,KAAKhB,OAAL,CAAa0B,IAAb,CAAkBM,CAAlB,EAAqB1B,IAArB,KAA8B,MAA9B,IAAwCkD,aAAa,KAAK,EAD3D,CADD;;MAGA,IAAIE,MAAJ,EAAY;QACXF,aAAa,GAAG,CAAhB;QACAnC,IAAI,IAAK,iBAAgBW,CAAE,QAA3B;QACAX,IAAI,IAAIkC,OAAO,EAAf;QACAlC,IAAI,IAAK,KAAT;;QACAkC,OAAO,GAAG,MAAO,GAAED,gBAAgB,GAAG,SAAH,GAAe,EAAG,QAAOtB,CAAE,OAA9D;MACA;;MACD,MAAMS,IAAI,GAAGc,OAAb;;MACA,MAAMI,SAAS,GAAGC,QAAQ,IAAI;QAC7B,IAAIA,QAAJ,EAAc,OAAO,EAAP;QACd,OAAO5C,MAAM,EAAb;MACA,CAHD;;MAIA,MAAMI,OAAO,GAAG,KAAKwB,OAAL,CAAaZ,CAAb,EAAgB;QAC/BrB,OAAO,EAAE6B,KAAK,IAAI7B,OAAO,CAACqB,CAAD,EAAIQ,KAAJ,EAAWC,IAAX,EAAiBkB,SAAjB,CADM;QAE/B9C,QAAQ,EACPA,QAAQ,KACPC,MAAM,IAAI;UACV,OAAOD,QAAQ,CAACmB,CAAD,EAAIlB,MAAJ,EAAY2B,IAAZ,EAAkBkB,SAAlB,CAAf;QACA,CAHO,CAHsB;QAO/B3C,MAAM,EAAE,CAACH,QAAD,IAAa4B,IAPU;QAQ/BxB,iBAAiB,EAChBA,iBAAiB,KAAKmC,UAAU,GAAG,CAAb,IAAkBpB,CAAC,GAAGoB,UAA3B;MATa,CAAhB,CAAhB;;MAWAG,OAAO,GAAG,MAAMnC,OAAhB;IACA;;IACDC,IAAI,IAAIkC,OAAO,EAAf;IACA,OAAOlC,IAAP;EACA;;EAEDwC,eAAe,QAAyC;IAAA,IAAxC;MAAElD,OAAF;MAAWK,MAAX;MAAmBC;IAAnB,CAAwC;IACvD,IAAI,KAAKjB,OAAL,CAAa0B,IAAb,CAAkBK,MAAlB,KAA6B,CAAjC,EAAoC,OAAOf,MAAM,EAAb;IACpC,MAAM8C,QAAQ,GAAG,KAAK9D,OAAL,CAAa0B,IAAb,CAAkBqC,KAAlB,CAAwBnC,CAAC,IAAIA,CAAC,CAACtB,IAAF,KAAW,MAAxC,CAAjB;IACA,IAAIe,IAAI,GAAG,EAAX;;IACA,IAAI,CAACyC,QAAL,EAAe;MACdzC,IAAI,IAAI,+BAAR;MACAA,IAAI,IAAI,2BAAR;IACA;;IACDA,IAAI,IAAI,cAAR;IACAA,IAAI,IAAI,QAAR;IACAA,IAAI,IAAI,kBAAR;;IACA,KAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKhC,OAAL,CAAa8B,YAAb,CAA0BC,MAA9C,EAAsDC,CAAC,EAAvD,EAA2D;MAC1D,MAAMC,WAAW,GAAG,KAAKjC,OAAL,CAAa8B,YAAb,CAA0BE,CAA1B,CAApB;;MACA,IAAIC,WAAW,CAAC+B,IAAhB,EAAsB;QACrB3C,IAAI,IAAK,GAAE,KAAKc,cAAL,CAAoBH,CAApB,CAAuB,SAAQ,KAAKxB,IAAL,CAAU;UACnD4B,MAAM,EAAEH,WAAW,CAACI,OAAZ,GAAsB,UAAtB,GAAmCpC;QADQ,CAAV,CAEvC,MAFH;MAGA;IACD;;IACDoB,IAAI,IAAI,KAAK6B,cAAL,CAAoB;MAC3BvC,OAD2B;MAE3BE,QAAQ,EAAE,CAACmB,CAAD,EAAIlB,MAAJ,EAAYmD,IAAZ,EAAkBN,SAAlB,KAAgC;QACzC,IAAItC,IAAI,GAAG,EAAX;QACAA,IAAI,IAAK,MAAKP,MAAO,qBAArB;QACAO,IAAI,IAAI,iBAAR;QACA,IAAI,CAACyC,QAAL,EAAezC,IAAI,IAAI,6BAAR;QACfA,IAAI,IAAIsC,SAAS,CAAC,IAAD,CAAjB;QACAtC,IAAI,IAAK,YAAT;QACAA,IAAI,IAAI4C,IAAI,EAAZ;QACA5C,IAAI,IAAK,KAAT;QACA,OAAOA,IAAP;MACA,CAZ0B;MAa3BL,MAAM,EACLA,MAAM,KACL,MAAM;QACN,IAAIK,IAAI,GAAG,EAAX;QACAA,IAAI,IAAI,gBAAR;QACAA,IAAI,IAAIL,MAAM,EAAd;QACAK,IAAI,IAAI,KAAR;QACA,OAAOA,IAAP;MACA,CAPK,CAdoB;MAsB3BJ,iBAAiB,EAAEA,iBAAiB,IAAI6C;IAtBb,CAApB,CAAR;IAwBAzC,IAAI,IAAI,mBAAR;;IACA,IAAI,CAACyC,QAAL,EAAe;MACdzC,IAAI,IAAI,sBAAR;MACAA,IAAI,IAAI,OAAR;MACAA,IAAI,IAAI,cAAR;IACA;;IACD,OAAOA,IAAP;EACA;;EAED6C,gBAAgB,QAMb;IAAA,IANc;MAChBvD,OADgB;MAEhBE,QAFgB;MAGhBG,MAHgB;MAIhBC,iBAJgB;MAKhBkD,KAAK,GAAG,CAACnC,CAAD,EAAIoC,GAAJ,KAAYA,GAAG;IALP,CAMd;;IACF,IAAI,KAAKpE,OAAL,CAAa0B,IAAb,CAAkBK,MAAlB,IAA4B,CAAhC,EAAmC;MAClC,OAAO,KAAKmB,cAAL,CAAoB;QAC1BvC,OAD0B;QAE1BE,QAF0B;QAG1BG,MAH0B;QAI1BC;MAJ0B,CAApB,CAAP;IAMA;;IACD,IAAII,IAAI,GAAG,EAAX;IACAA,IAAI,IAAI,QAAR;IACAA,IAAI,IAAK,kBAAiB,KAAKrB,OAAL,CAAa0B,IAAb,CAAkBK,MAAO,KAAnD;;IACA,IAAIf,MAAJ,EAAY;MACXK,IAAI,IAAI,6BAAR;MACAA,IAAI,IAAIL,MAAM,EAAd;MACAK,IAAI,IAAI,OAAR;IACA;;IACD,KAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKhC,OAAL,CAAa0B,IAAb,CAAkBK,MAAtC,EAA8CC,CAAC,EAA/C,EAAmD;MAClD,MAAMS,IAAI,GAAG,MAAM;QAClB,IAAIzB,MAAJ,EAAY,OAAO,iCAAP,CAAZ,KACK,OAAO,aAAP;MACL,CAHD;;MAIA,MAAM2C,SAAS,GAAGC,QAAQ,IAAI;QAC7B,IAAIA,QAAQ,IAAI,CAAC5C,MAAjB,EAAyB,OAAO,iBAAP,CAAzB,KACK,OAAO,2BAAP;MACL,CAHD;;MAIAK,IAAI,IAAI,4BAAR;MACAA,IAAI,IAAI8C,KAAK,CACZnC,CADY,EAEZ,MACC,KAAKY,OAAL,CAAaZ,CAAb,EAAgB;QACfrB,OAAO,EAAE6B,KAAK,IAAI;UACjB,IAAInB,IAAI,GAAG,EAAX;UACAA,IAAI,IAAI,sBAAR;UACAA,IAAI,IAAIV,OAAO,CAACqB,CAAD,EAAIQ,KAAJ,EAAWC,IAAX,EAAiBkB,SAAjB,CAAf;UACAtC,IAAI,IAAI,KAAR;UACA,OAAOA,IAAP;QACA,CAPc;QAQfR,QAAQ,EACPA,QAAQ,KACPC,MAAM,IAAI;UACV,IAAIO,IAAI,GAAG,EAAX;UACAA,IAAI,IAAI,sBAAR;UACAA,IAAI,IAAIR,QAAQ,CAACmB,CAAD,EAAIlB,MAAJ,EAAY2B,IAAZ,EAAkBkB,SAAlB,CAAhB;UACAtC,IAAI,IAAI,KAAR;UACA,OAAOA,IAAP;QACA,CAPO,CATM;QAiBfL,MAAM,EACL,CAACH,QAAD,KACC,MAAM;UACN,OAAO4B,IAAI,EAAX;QACA,CAHD,CAlBc;QAsBfxB;MAtBe,CAAhB,CAHW,EA2BZwB,IA3BY,EA4BZkB,SA5BY,CAAb;IA8BA;;IACDtC,IAAI,IAAI,mBAAR;IACA,OAAOA,IAAP;EACA;;EAEDb,IAAI,GAAyB;IAAA,IAAxB;MAAE4B,MAAF;MAAUlB;IAAV,CAAwB,uEAAJ,EAAI;IAC5B,IAAImD,OAAO,GAAG,KAAKnE,KAAnB;IACA,IAAIkC,MAAJ,EAAYiC,OAAO,GAAG,CAACjC,MAAD,EAASkC,MAAT,CAAgBD,OAAhB,CAAV;IACZ,IAAInD,KAAJ,EAAWmD,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAepD,KAAf,CAAV;;IACX,IAAImD,OAAO,CAACtC,MAAR,KAAmB,CAAvB,EAA0B;MACzB,OAAO,EAAP;IACA,CAFD,MAEO;MACN,OAAOsC,OAAO,CAACE,IAAR,CAAa,IAAb,CAAP;IACA;EACD;;EAEDvB,QAAQ,CAACwB,GAAD,EAAM;IACb,OAAQ,MAAKA,GAAI,GAAjB;EACA;;EAEDzB,MAAM,CAACyB,GAAD,EAAM;IACX,OAAQ,SAAQA,GAAI,GAApB;EACA;;EAEDrC,cAAc,CAACqC,GAAD,EAAM;IACnB,OAAQ,iBAAgBA,GAAI,GAA5B;EACA;;AA1coB;;AA6ctBC,MAAM,CAACC,OAAP,GAAiB7E,eAAjB"},"metadata":{},"sourceType":"script"}