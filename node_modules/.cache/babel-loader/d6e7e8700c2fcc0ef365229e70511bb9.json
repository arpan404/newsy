{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\n\nconst RuntimeModule = require(\"../RuntimeModule\");\n\nconst Template = require(\"../Template\");\n\nconst {\n  first\n} = require(\"../util/SetHelpers\");\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n\n/** @typedef {function(PathData, AssetInfo=): string} FilenameFunction */\n\n\nclass GetChunkFilenameRuntimeModule extends RuntimeModule {\n  /**\n   * @param {string} contentType the contentType to use the content hash for\n   * @param {string} name kind of filename\n   * @param {string} global function name to be assigned\n   * @param {function(Chunk): string | FilenameFunction} getFilenameForChunk functor to get the filename or function\n   * @param {boolean} allChunks when false, only async chunks are included\n   */\n  constructor(contentType, name, global, getFilenameForChunk, allChunks) {\n    super(`get ${name} chunk filename`);\n    this.contentType = contentType;\n    this.global = global;\n    this.getFilenameForChunk = getFilenameForChunk;\n    this.allChunks = allChunks;\n    this.dependentHash = true;\n  }\n  /**\n   * @returns {string} runtime code\n   */\n\n\n  generate() {\n    const {\n      global,\n      chunk,\n      chunkGraph,\n      contentType,\n      getFilenameForChunk,\n      allChunks,\n      compilation\n    } = this;\n    const {\n      runtimeTemplate\n    } = compilation;\n    /** @type {Map<string | FilenameFunction, Set<Chunk>>} */\n\n    const chunkFilenames = new Map();\n    let maxChunks = 0;\n    /** @type {string} */\n\n    let dynamicFilename;\n    /**\n     * @param {Chunk} c the chunk\n     * @returns {void}\n     */\n\n    const addChunk = c => {\n      const chunkFilename = getFilenameForChunk(c);\n\n      if (chunkFilename) {\n        let set = chunkFilenames.get(chunkFilename);\n\n        if (set === undefined) {\n          chunkFilenames.set(chunkFilename, set = new Set());\n        }\n\n        set.add(c);\n\n        if (typeof chunkFilename === \"string\") {\n          if (set.size < maxChunks) return;\n\n          if (set.size === maxChunks) {\n            if (chunkFilename.length < dynamicFilename.length) return;\n\n            if (chunkFilename.length === dynamicFilename.length) {\n              if (chunkFilename < dynamicFilename) return;\n            }\n          }\n\n          maxChunks = set.size;\n          dynamicFilename = chunkFilename;\n        }\n      }\n    };\n    /** @type {string[]} */\n\n\n    const includedChunksMessages = [];\n\n    if (allChunks) {\n      includedChunksMessages.push(\"all chunks\");\n\n      for (const c of chunk.getAllReferencedChunks()) {\n        addChunk(c);\n      }\n    } else {\n      includedChunksMessages.push(\"async chunks\");\n\n      for (const c of chunk.getAllAsyncChunks()) {\n        addChunk(c);\n      }\n\n      const includeEntries = chunkGraph.getTreeRuntimeRequirements(chunk).has(RuntimeGlobals.ensureChunkIncludeEntries);\n\n      if (includeEntries) {\n        includedChunksMessages.push(\"sibling chunks for the entrypoint\");\n\n        for (const c of chunkGraph.getChunkEntryDependentChunksIterable(chunk)) {\n          addChunk(c);\n        }\n      }\n    }\n\n    for (const entrypoint of chunk.getAllReferencedAsyncEntrypoints()) {\n      addChunk(entrypoint.chunks[entrypoint.chunks.length - 1]);\n    }\n    /** @type {Map<string, Set<string | number>>} */\n\n\n    const staticUrls = new Map();\n    /** @type {Set<Chunk>} */\n\n    const dynamicUrlChunks = new Set();\n    /**\n     * @param {Chunk} c the chunk\n     * @param {string | FilenameFunction} chunkFilename the filename template for the chunk\n     * @returns {void}\n     */\n\n    const addStaticUrl = (c, chunkFilename) => {\n      /**\n       * @param {string | number} value a value\n       * @returns {string} string to put in quotes\n       */\n      const unquotedStringify = value => {\n        const str = `${value}`;\n\n        if (str.length >= 5 && str === `${c.id}`) {\n          // This is shorter and generates the same result\n          return '\" + chunkId + \"';\n        }\n\n        const s = JSON.stringify(str);\n        return s.slice(1, s.length - 1);\n      };\n\n      const unquotedStringifyWithLength = value => length => unquotedStringify(`${value}`.slice(0, length));\n\n      const chunkFilenameValue = typeof chunkFilename === \"function\" ? JSON.stringify(chunkFilename({\n        chunk: c,\n        contentHashType: contentType\n      })) : JSON.stringify(chunkFilename);\n      const staticChunkFilename = compilation.getPath(chunkFilenameValue, {\n        hash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n        hashWithLength: length => `\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n        chunk: {\n          id: unquotedStringify(c.id),\n          hash: unquotedStringify(c.renderedHash),\n          hashWithLength: unquotedStringifyWithLength(c.renderedHash),\n          name: unquotedStringify(c.name || c.id),\n          contentHash: {\n            [contentType]: unquotedStringify(c.contentHash[contentType])\n          },\n          contentHashWithLength: {\n            [contentType]: unquotedStringifyWithLength(c.contentHash[contentType])\n          }\n        },\n        contentHashType: contentType\n      });\n      let set = staticUrls.get(staticChunkFilename);\n\n      if (set === undefined) {\n        staticUrls.set(staticChunkFilename, set = new Set());\n      }\n\n      set.add(c.id);\n    };\n\n    for (const [filename, chunks] of chunkFilenames) {\n      if (filename !== dynamicFilename) {\n        for (const c of chunks) addStaticUrl(c, filename);\n      } else {\n        for (const c of chunks) dynamicUrlChunks.add(c);\n      }\n    }\n    /**\n     * @param {function(Chunk): string | number} fn function from chunk to value\n     * @returns {string} code with static mapping of results of fn\n     */\n\n\n    const createMap = fn => {\n      const obj = {};\n      let useId = false;\n      let lastKey;\n      let entries = 0;\n\n      for (const c of dynamicUrlChunks) {\n        const value = fn(c);\n\n        if (value === c.id) {\n          useId = true;\n        } else {\n          obj[c.id] = value;\n          lastKey = c.id;\n          entries++;\n        }\n      }\n\n      if (entries === 0) return \"chunkId\";\n\n      if (entries === 1) {\n        return useId ? `(chunkId === ${JSON.stringify(lastKey)} ? ${JSON.stringify(obj[lastKey])} : chunkId)` : JSON.stringify(obj[lastKey]);\n      }\n\n      return useId ? `(${JSON.stringify(obj)}[chunkId] || chunkId)` : `${JSON.stringify(obj)}[chunkId]`;\n    };\n    /**\n     * @param {function(Chunk): string | number} fn function from chunk to value\n     * @returns {string} code with static mapping of results of fn for including in quoted string\n     */\n\n\n    const mapExpr = fn => {\n      return `\" + ${createMap(fn)} + \"`;\n    };\n    /**\n     * @param {function(Chunk): string | number} fn function from chunk to value\n     * @returns {function(number): string} function which generates code with static mapping of results of fn for including in quoted string for specific length\n     */\n\n\n    const mapExprWithLength = fn => length => {\n      return `\" + ${createMap(c => `${fn(c)}`.slice(0, length))} + \"`;\n    };\n\n    const url = dynamicFilename && compilation.getPath(JSON.stringify(dynamicFilename), {\n      hash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n      hashWithLength: length => `\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n      chunk: {\n        id: `\" + chunkId + \"`,\n        hash: mapExpr(c => c.renderedHash),\n        hashWithLength: mapExprWithLength(c => c.renderedHash),\n        name: mapExpr(c => c.name || c.id),\n        contentHash: {\n          [contentType]: mapExpr(c => c.contentHash[contentType])\n        },\n        contentHashWithLength: {\n          [contentType]: mapExprWithLength(c => c.contentHash[contentType])\n        }\n      },\n      contentHashType: contentType\n    });\n    return Template.asString([`// This function allow to reference ${includedChunksMessages.join(\" and \")}`, `${global} = ${runtimeTemplate.basicFunction(\"chunkId\", staticUrls.size > 0 ? [\"// return url for filenames not based on template\", // it minimizes to `x===1?\"...\":x===2?\"...\":\"...\"`\n    Template.asString(Array.from(staticUrls, _ref => {\n      let [url, ids] = _ref;\n      const condition = ids.size === 1 ? `chunkId === ${JSON.stringify(first(ids))}` : `{${Array.from(ids, id => `${JSON.stringify(id)}:1`).join(\",\")}}[chunkId]`;\n      return `if (${condition}) return ${url};`;\n    })), \"// return url for filenames based on template\", `return ${url};`] : [\"// return url for filenames based on template\", `return ${url};`])};`]);\n  }\n\n}\n\nmodule.exports = GetChunkFilenameRuntimeModule;","map":{"version":3,"names":["RuntimeGlobals","require","RuntimeModule","Template","first","GetChunkFilenameRuntimeModule","constructor","contentType","name","global","getFilenameForChunk","allChunks","dependentHash","generate","chunk","chunkGraph","compilation","runtimeTemplate","chunkFilenames","Map","maxChunks","dynamicFilename","addChunk","c","chunkFilename","set","get","undefined","Set","add","size","length","includedChunksMessages","push","getAllReferencedChunks","getAllAsyncChunks","includeEntries","getTreeRuntimeRequirements","has","ensureChunkIncludeEntries","getChunkEntryDependentChunksIterable","entrypoint","getAllReferencedAsyncEntrypoints","chunks","staticUrls","dynamicUrlChunks","addStaticUrl","unquotedStringify","value","str","id","s","JSON","stringify","slice","unquotedStringifyWithLength","chunkFilenameValue","contentHashType","staticChunkFilename","getPath","hash","getFullHash","hashWithLength","renderedHash","contentHash","contentHashWithLength","filename","createMap","fn","obj","useId","lastKey","entries","mapExpr","mapExprWithLength","url","asString","join","basicFunction","Array","from","ids","condition","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/runtime/GetChunkFilenameRuntimeModule.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst RuntimeModule = require(\"../RuntimeModule\");\nconst Template = require(\"../Template\");\nconst { first } = require(\"../util/SetHelpers\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n\n/** @typedef {function(PathData, AssetInfo=): string} FilenameFunction */\n\nclass GetChunkFilenameRuntimeModule extends RuntimeModule {\n\t/**\n\t * @param {string} contentType the contentType to use the content hash for\n\t * @param {string} name kind of filename\n\t * @param {string} global function name to be assigned\n\t * @param {function(Chunk): string | FilenameFunction} getFilenameForChunk functor to get the filename or function\n\t * @param {boolean} allChunks when false, only async chunks are included\n\t */\n\tconstructor(contentType, name, global, getFilenameForChunk, allChunks) {\n\t\tsuper(`get ${name} chunk filename`);\n\t\tthis.contentType = contentType;\n\t\tthis.global = global;\n\t\tthis.getFilenameForChunk = getFilenameForChunk;\n\t\tthis.allChunks = allChunks;\n\t\tthis.dependentHash = true;\n\t}\n\n\t/**\n\t * @returns {string} runtime code\n\t */\n\tgenerate() {\n\t\tconst {\n\t\t\tglobal,\n\t\t\tchunk,\n\t\t\tchunkGraph,\n\t\t\tcontentType,\n\t\t\tgetFilenameForChunk,\n\t\t\tallChunks,\n\t\t\tcompilation\n\t\t} = this;\n\t\tconst { runtimeTemplate } = compilation;\n\n\t\t/** @type {Map<string | FilenameFunction, Set<Chunk>>} */\n\t\tconst chunkFilenames = new Map();\n\t\tlet maxChunks = 0;\n\t\t/** @type {string} */\n\t\tlet dynamicFilename;\n\n\t\t/**\n\t\t * @param {Chunk} c the chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addChunk = c => {\n\t\t\tconst chunkFilename = getFilenameForChunk(c);\n\t\t\tif (chunkFilename) {\n\t\t\t\tlet set = chunkFilenames.get(chunkFilename);\n\t\t\t\tif (set === undefined) {\n\t\t\t\t\tchunkFilenames.set(chunkFilename, (set = new Set()));\n\t\t\t\t}\n\t\t\t\tset.add(c);\n\t\t\t\tif (typeof chunkFilename === \"string\") {\n\t\t\t\t\tif (set.size < maxChunks) return;\n\t\t\t\t\tif (set.size === maxChunks) {\n\t\t\t\t\t\tif (chunkFilename.length < dynamicFilename.length) return;\n\t\t\t\t\t\tif (chunkFilename.length === dynamicFilename.length) {\n\t\t\t\t\t\t\tif (chunkFilename < dynamicFilename) return;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmaxChunks = set.size;\n\t\t\t\t\tdynamicFilename = chunkFilename;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/** @type {string[]} */\n\t\tconst includedChunksMessages = [];\n\t\tif (allChunks) {\n\t\t\tincludedChunksMessages.push(\"all chunks\");\n\t\t\tfor (const c of chunk.getAllReferencedChunks()) {\n\t\t\t\taddChunk(c);\n\t\t\t}\n\t\t} else {\n\t\t\tincludedChunksMessages.push(\"async chunks\");\n\t\t\tfor (const c of chunk.getAllAsyncChunks()) {\n\t\t\t\taddChunk(c);\n\t\t\t}\n\t\t\tconst includeEntries = chunkGraph\n\t\t\t\t.getTreeRuntimeRequirements(chunk)\n\t\t\t\t.has(RuntimeGlobals.ensureChunkIncludeEntries);\n\t\t\tif (includeEntries) {\n\t\t\t\tincludedChunksMessages.push(\"sibling chunks for the entrypoint\");\n\t\t\t\tfor (const c of chunkGraph.getChunkEntryDependentChunksIterable(\n\t\t\t\t\tchunk\n\t\t\t\t)) {\n\t\t\t\t\taddChunk(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const entrypoint of chunk.getAllReferencedAsyncEntrypoints()) {\n\t\t\taddChunk(entrypoint.chunks[entrypoint.chunks.length - 1]);\n\t\t}\n\n\t\t/** @type {Map<string, Set<string | number>>} */\n\t\tconst staticUrls = new Map();\n\t\t/** @type {Set<Chunk>} */\n\t\tconst dynamicUrlChunks = new Set();\n\n\t\t/**\n\t\t * @param {Chunk} c the chunk\n\t\t * @param {string | FilenameFunction} chunkFilename the filename template for the chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addStaticUrl = (c, chunkFilename) => {\n\t\t\t/**\n\t\t\t * @param {string | number} value a value\n\t\t\t * @returns {string} string to put in quotes\n\t\t\t */\n\t\t\tconst unquotedStringify = value => {\n\t\t\t\tconst str = `${value}`;\n\t\t\t\tif (str.length >= 5 && str === `${c.id}`) {\n\t\t\t\t\t// This is shorter and generates the same result\n\t\t\t\t\treturn '\" + chunkId + \"';\n\t\t\t\t}\n\t\t\t\tconst s = JSON.stringify(str);\n\t\t\t\treturn s.slice(1, s.length - 1);\n\t\t\t};\n\t\t\tconst unquotedStringifyWithLength = value => length =>\n\t\t\t\tunquotedStringify(`${value}`.slice(0, length));\n\t\t\tconst chunkFilenameValue =\n\t\t\t\ttypeof chunkFilename === \"function\"\n\t\t\t\t\t? JSON.stringify(\n\t\t\t\t\t\t\tchunkFilename({\n\t\t\t\t\t\t\t\tchunk: c,\n\t\t\t\t\t\t\t\tcontentHashType: contentType\n\t\t\t\t\t\t\t})\n\t\t\t\t\t  )\n\t\t\t\t\t: JSON.stringify(chunkFilename);\n\t\t\tconst staticChunkFilename = compilation.getPath(chunkFilenameValue, {\n\t\t\t\thash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n\t\t\t\thashWithLength: length =>\n\t\t\t\t\t`\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n\t\t\t\tchunk: {\n\t\t\t\t\tid: unquotedStringify(c.id),\n\t\t\t\t\thash: unquotedStringify(c.renderedHash),\n\t\t\t\t\thashWithLength: unquotedStringifyWithLength(c.renderedHash),\n\t\t\t\t\tname: unquotedStringify(c.name || c.id),\n\t\t\t\t\tcontentHash: {\n\t\t\t\t\t\t[contentType]: unquotedStringify(c.contentHash[contentType])\n\t\t\t\t\t},\n\t\t\t\t\tcontentHashWithLength: {\n\t\t\t\t\t\t[contentType]: unquotedStringifyWithLength(\n\t\t\t\t\t\t\tc.contentHash[contentType]\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontentHashType: contentType\n\t\t\t});\n\t\t\tlet set = staticUrls.get(staticChunkFilename);\n\t\t\tif (set === undefined) {\n\t\t\t\tstaticUrls.set(staticChunkFilename, (set = new Set()));\n\t\t\t}\n\t\t\tset.add(c.id);\n\t\t};\n\n\t\tfor (const [filename, chunks] of chunkFilenames) {\n\t\t\tif (filename !== dynamicFilename) {\n\t\t\t\tfor (const c of chunks) addStaticUrl(c, filename);\n\t\t\t} else {\n\t\t\t\tfor (const c of chunks) dynamicUrlChunks.add(c);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {string} code with static mapping of results of fn\n\t\t */\n\t\tconst createMap = fn => {\n\t\t\tconst obj = {};\n\t\t\tlet useId = false;\n\t\t\tlet lastKey;\n\t\t\tlet entries = 0;\n\t\t\tfor (const c of dynamicUrlChunks) {\n\t\t\t\tconst value = fn(c);\n\t\t\t\tif (value === c.id) {\n\t\t\t\t\tuseId = true;\n\t\t\t\t} else {\n\t\t\t\t\tobj[c.id] = value;\n\t\t\t\t\tlastKey = c.id;\n\t\t\t\t\tentries++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (entries === 0) return \"chunkId\";\n\t\t\tif (entries === 1) {\n\t\t\t\treturn useId\n\t\t\t\t\t? `(chunkId === ${JSON.stringify(lastKey)} ? ${JSON.stringify(\n\t\t\t\t\t\t\tobj[lastKey]\n\t\t\t\t\t  )} : chunkId)`\n\t\t\t\t\t: JSON.stringify(obj[lastKey]);\n\t\t\t}\n\t\t\treturn useId\n\t\t\t\t? `(${JSON.stringify(obj)}[chunkId] || chunkId)`\n\t\t\t\t: `${JSON.stringify(obj)}[chunkId]`;\n\t\t};\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {string} code with static mapping of results of fn for including in quoted string\n\t\t */\n\t\tconst mapExpr = fn => {\n\t\t\treturn `\" + ${createMap(fn)} + \"`;\n\t\t};\n\n\t\t/**\n\t\t * @param {function(Chunk): string | number} fn function from chunk to value\n\t\t * @returns {function(number): string} function which generates code with static mapping of results of fn for including in quoted string for specific length\n\t\t */\n\t\tconst mapExprWithLength = fn => length => {\n\t\t\treturn `\" + ${createMap(c => `${fn(c)}`.slice(0, length))} + \"`;\n\t\t};\n\n\t\tconst url =\n\t\t\tdynamicFilename &&\n\t\t\tcompilation.getPath(JSON.stringify(dynamicFilename), {\n\t\t\t\thash: `\" + ${RuntimeGlobals.getFullHash}() + \"`,\n\t\t\t\thashWithLength: length =>\n\t\t\t\t\t`\" + ${RuntimeGlobals.getFullHash}().slice(0, ${length}) + \"`,\n\t\t\t\tchunk: {\n\t\t\t\t\tid: `\" + chunkId + \"`,\n\t\t\t\t\thash: mapExpr(c => c.renderedHash),\n\t\t\t\t\thashWithLength: mapExprWithLength(c => c.renderedHash),\n\t\t\t\t\tname: mapExpr(c => c.name || c.id),\n\t\t\t\t\tcontentHash: {\n\t\t\t\t\t\t[contentType]: mapExpr(c => c.contentHash[contentType])\n\t\t\t\t\t},\n\t\t\t\t\tcontentHashWithLength: {\n\t\t\t\t\t\t[contentType]: mapExprWithLength(c => c.contentHash[contentType])\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcontentHashType: contentType\n\t\t\t});\n\n\t\treturn Template.asString([\n\t\t\t`// This function allow to reference ${includedChunksMessages.join(\n\t\t\t\t\" and \"\n\t\t\t)}`,\n\t\t\t`${global} = ${runtimeTemplate.basicFunction(\n\t\t\t\t\"chunkId\",\n\n\t\t\t\tstaticUrls.size > 0\n\t\t\t\t\t? [\n\t\t\t\t\t\t\t\"// return url for filenames not based on template\",\n\t\t\t\t\t\t\t// it minimizes to `x===1?\"...\":x===2?\"...\":\"...\"`\n\t\t\t\t\t\t\tTemplate.asString(\n\t\t\t\t\t\t\t\tArray.from(staticUrls, ([url, ids]) => {\n\t\t\t\t\t\t\t\t\tconst condition =\n\t\t\t\t\t\t\t\t\t\tids.size === 1\n\t\t\t\t\t\t\t\t\t\t\t? `chunkId === ${JSON.stringify(first(ids))}`\n\t\t\t\t\t\t\t\t\t\t\t: `{${Array.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\tids,\n\t\t\t\t\t\t\t\t\t\t\t\t\tid => `${JSON.stringify(id)}:1`\n\t\t\t\t\t\t\t\t\t\t\t  ).join(\",\")}}[chunkId]`;\n\t\t\t\t\t\t\t\t\treturn `if (${condition}) return ${url};`;\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\"// return url for filenames based on template\",\n\t\t\t\t\t\t\t`return ${url};`\n\t\t\t\t\t  ]\n\t\t\t\t\t: [\"// return url for filenames based on template\", `return ${url};`]\n\t\t\t)};`\n\t\t]);\n\t}\n}\n\nmodule.exports = GetChunkFilenameRuntimeModule;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}