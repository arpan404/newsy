{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Chunk = require(\"../Chunk\");\n\nconst {\n  STAGE_ADVANCED\n} = require(\"../OptimizationStages\");\n\nconst WebpackError = require(\"../WebpackError\");\n\nconst {\n  requestToId\n} = require(\"../ids/IdHelpers\");\n\nconst {\n  isSubset\n} = require(\"../util/SetHelpers\");\n\nconst SortableSet = require(\"../util/SortableSet\");\n\nconst {\n  compareModulesByIdentifier,\n  compareIterables\n} = require(\"../util/comparators\");\n\nconst createHash = require(\"../util/createHash\");\n\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\n\nconst {\n  makePathsRelative\n} = require(\"../util/identifier\");\n\nconst memoize = require(\"../util/memoize\");\n\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\n\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {Record<string, number>} SplitChunksSizes */\n\n/**\n * @callback ChunkFilterFunction\n * @param {Chunk} chunk\n * @returns {boolean}\n */\n\n/**\n * @callback CombineSizeFunction\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\n/**\n * @typedef {Object} CacheGroupSource\n * @property {string=} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {boolean=} enforce\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean=} reuseExistingChunk\n * @property {boolean=} usedExports\n */\n\n/**\n * @typedef {Object} CacheGroup\n * @property {string} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean} reuseExistingChunk\n * @property {boolean} usedExports\n * @property {boolean} _validateSize\n * @property {boolean} _validateRemainingSize\n * @property {SplitChunksSizes} _minSizeForMaxSize\n * @property {boolean} _conditionalEnforce\n */\n\n/**\n * @typedef {Object} FallbackCacheGroup\n * @property {ChunkFilterFunction} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {string} automaticNameDelimiter\n */\n\n/**\n * @typedef {Object} CacheGroupsContext\n * @property {ModuleGraph} moduleGraph\n * @property {ChunkGraph} chunkGraph\n */\n\n/**\n * @callback GetCacheGroups\n * @param {Module} module\n * @param {CacheGroupsContext} context\n * @returns {CacheGroupSource[]}\n */\n\n/**\n * @callback GetName\n * @param {Module=} module\n * @param {Chunk[]=} chunks\n * @param {string=} key\n * @returns {string=}\n */\n\n/**\n * @typedef {Object} SplitChunksOptions\n * @property {ChunkFilterFunction} chunksFilter\n * @property {string[]} defaultSizeTypes\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxInitialSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {number} minChunks\n * @property {number} maxAsyncRequests\n * @property {number} maxInitialRequests\n * @property {boolean} hidePathInfo\n * @property {string | function(PathData, AssetInfo=): string} filename\n * @property {string} automaticNameDelimiter\n * @property {GetCacheGroups} getCacheGroups\n * @property {GetName} getName\n * @property {boolean} usedExports\n * @property {FallbackCacheGroup} fallbackCacheGroup\n */\n\n/**\n * @typedef {Object} ChunksInfoItem\n * @property {SortableSet<Module>} modules\n * @property {CacheGroup} cacheGroup\n * @property {number} cacheGroupIndex\n * @property {string} name\n * @property {Record<string, number>} sizes\n * @property {Set<Chunk>} chunks\n * @property {Set<Chunk>} reuseableChunks\n * @property {Set<bigint | Chunk>} chunksKeys\n */\n\n\nconst defaultGetName =\n/** @type {GetName} */\n() => {};\n\nconst deterministicGroupingForModules =\n/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n/** @type {WeakMap<Module, string>} */\n\nconst getKeyCache = new WeakMap();\n/**\n * @param {string} name a filename to hash\n * @param {OutputOptions} outputOptions hash function used\n * @returns {string} hashed filename\n */\n\nconst hashFilename = (name, outputOptions) => {\n  const digest =\n  /** @type {string} */\n  createHash(outputOptions.hashFunction).update(name).digest(outputOptions.hashDigest);\n  return digest.slice(0, 8);\n};\n/**\n * @param {Chunk} chunk the chunk\n * @returns {number} the number of requests\n */\n\n\nconst getRequests = chunk => {\n  let requests = 0;\n\n  for (const chunkGroup of chunk.groupsIterable) {\n    requests = Math.max(requests, chunkGroup.chunks.length);\n  }\n\n  return requests;\n};\n\nconst mapObject = (obj, fn) => {\n  const newObj = Object.create(null);\n\n  for (const key of Object.keys(obj)) {\n    newObj[key] = fn(obj[key], key);\n  }\n\n  return newObj;\n};\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\n\n\nconst isOverlap = (a, b) => {\n  for (const item of a) {\n    if (b.has(item)) return true;\n  }\n\n  return false;\n};\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n/**\n * @param {ChunksInfoItem} a item\n * @param {ChunksInfoItem} b item\n * @returns {number} compare result\n */\n\nconst compareEntries = (a, b) => {\n  // 1. by priority\n  const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority; // 2. by number of chunks\n\n  const diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount; // 3. by size reduction\n\n  const aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\n  const bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\n  const diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce; // 4. by cache group index\n\n  const indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n  if (indexDiff) return indexDiff; // 5. by number of modules (to be able to compare by identifier)\n\n  const modulesA = a.modules;\n  const modulesB = b.modules;\n  const diff = modulesA.size - modulesB.size;\n  if (diff) return diff; // 6. by module identifiers\n\n  modulesA.sort();\n  modulesB.sort();\n  return compareModuleIterables(modulesA, modulesB);\n};\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\n\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\n\nconst ALL_CHUNK_FILTER = chunk => true;\n/**\n * @param {OptimizationSplitChunksSizes} value the sizes\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {SplitChunksSizes} normalized representation\n */\n\n\nconst normalizeSizes = (value, defaultSizeTypes) => {\n  if (typeof value === \"number\") {\n    /** @type {Record<string, number>} */\n    const o = {};\n\n    for (const sizeType of defaultSizeTypes) o[sizeType] = value;\n\n    return o;\n  } else if (typeof value === \"object\" && value !== null) {\n    return { ...value\n    };\n  } else {\n    return {};\n  }\n};\n/**\n * @param {...SplitChunksSizes} sizes the sizes\n * @returns {SplitChunksSizes} the merged sizes\n */\n\n\nconst mergeSizes = function () {\n  /** @type {SplitChunksSizes} */\n  let merged = {};\n\n  for (let i = arguments.length - 1; i >= 0; i--) {\n    merged = Object.assign(merged, i < 0 || arguments.length <= i ? undefined : arguments[i]);\n  }\n\n  return merged;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {boolean} true, if there are sizes > 0\n */\n\n\nconst hasNonZeroSizes = sizes => {\n  for (const key of Object.keys(sizes)) {\n    if (sizes[key] > 0) return true;\n  }\n\n  return false;\n};\n/**\n * @param {SplitChunksSizes} a first sizes\n * @param {SplitChunksSizes} b second sizes\n * @param {CombineSizeFunction} combine a function to combine sizes\n * @returns {SplitChunksSizes} the combine sizes\n */\n\n\nconst combineSizes = (a, b, combine) => {\n  const aKeys = new Set(Object.keys(a));\n  const bKeys = new Set(Object.keys(b));\n  /** @type {SplitChunksSizes} */\n\n  const result = {};\n\n  for (const key of aKeys) {\n    if (bKeys.has(key)) {\n      result[key] = combine(a[key], b[key]);\n    } else {\n      result[key] = a[key];\n    }\n  }\n\n  for (const key of bKeys) {\n    if (!aKeys.has(key)) {\n      result[key] = b[key];\n    }\n  }\n\n  return result;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\n */\n\n\nconst checkMinSize = (sizes, minSize) => {\n  for (const key of Object.keys(minSize)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size < minSize[key]) return false;\n  }\n\n  return true;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSizeReduction the min sizes\n * @param {number} chunkCount number of chunks\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\n */\n\n\nconst checkMinSizeReduction = (sizes, minSizeReduction, chunkCount) => {\n  for (const key of Object.keys(minSizeReduction)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n    if (size * chunkCount < minSizeReduction[key]) return false;\n  }\n\n  return true;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {undefined | string[]} list of size types that are below min size\n */\n\n\nconst getViolatingMinSizes = (sizes, minSize) => {\n  let list;\n\n  for (const key of Object.keys(minSize)) {\n    const size = sizes[key];\n    if (size === undefined || size === 0) continue;\n\n    if (size < minSize[key]) {\n      if (list === undefined) list = [key];else list.push(key);\n    }\n  }\n\n  return list;\n};\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {number} the total size\n */\n\n\nconst totalSize = sizes => {\n  let size = 0;\n\n  for (const key of Object.keys(sizes)) {\n    size += sizes[key];\n  }\n\n  return size;\n};\n/**\n * @param {false|string|Function} name the chunk name\n * @returns {GetName} a function to get the name of the chunk\n */\n\n\nconst normalizeName = name => {\n  if (typeof name === \"string\") {\n    return () => name;\n  }\n\n  if (typeof name === \"function\") {\n    return (\n      /** @type {GetName} */\n      name\n    );\n  }\n};\n/**\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\n * @returns {ChunkFilterFunction} the chunk filter function\n */\n\n\nconst normalizeChunksFilter = chunks => {\n  if (chunks === \"initial\") {\n    return INITIAL_CHUNK_FILTER;\n  }\n\n  if (chunks === \"async\") {\n    return ASYNC_CHUNK_FILTER;\n  }\n\n  if (chunks === \"all\") {\n    return ALL_CHUNK_FILTER;\n  }\n\n  if (typeof chunks === \"function\") {\n    return chunks;\n  }\n};\n/**\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {GetCacheGroups} a function to get the cache groups\n */\n\n\nconst normalizeCacheGroups = (cacheGroups, defaultSizeTypes) => {\n  if (typeof cacheGroups === \"function\") {\n    return cacheGroups;\n  }\n\n  if (typeof cacheGroups === \"object\" && cacheGroups !== null) {\n    /** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\n    const handlers = [];\n\n    for (const key of Object.keys(cacheGroups)) {\n      const option = cacheGroups[key];\n\n      if (option === false) {\n        continue;\n      }\n\n      if (typeof option === \"string\" || option instanceof RegExp) {\n        const source = createCacheGroupSource({}, key, defaultSizeTypes);\n        handlers.push((module, context, results) => {\n          if (checkTest(option, module, context)) {\n            results.push(source);\n          }\n        });\n      } else if (typeof option === \"function\") {\n        const cache = new WeakMap();\n        handlers.push((module, context, results) => {\n          const result = option(module);\n\n          if (result) {\n            const groups = Array.isArray(result) ? result : [result];\n\n            for (const group of groups) {\n              const cachedSource = cache.get(group);\n\n              if (cachedSource !== undefined) {\n                results.push(cachedSource);\n              } else {\n                const source = createCacheGroupSource(group, key, defaultSizeTypes);\n                cache.set(group, source);\n                results.push(source);\n              }\n            }\n          }\n        });\n      } else {\n        const source = createCacheGroupSource(option, key, defaultSizeTypes);\n        handlers.push((module, context, results) => {\n          if (checkTest(option.test, module, context) && checkModuleType(option.type, module) && checkModuleLayer(option.layer, module)) {\n            results.push(source);\n          }\n        });\n      }\n    }\n    /**\n     * @param {Module} module the current module\n     * @param {CacheGroupsContext} context the current context\n     * @returns {CacheGroupSource[]} the matching cache groups\n     */\n\n\n    const fn = (module, context) => {\n      /** @type {CacheGroupSource[]} */\n      let results = [];\n\n      for (const fn of handlers) {\n        fn(module, context, results);\n      }\n\n      return results;\n    };\n\n    return fn;\n  }\n\n  return () => null;\n};\n/**\n * @param {undefined|boolean|string|RegExp|Function} test test option\n * @param {Module} module the module\n * @param {CacheGroupsContext} context context object\n * @returns {boolean} true, if the module should be selected\n */\n\n\nconst checkTest = (test, module, context) => {\n  if (test === undefined) return true;\n\n  if (typeof test === \"function\") {\n    return test(module, context);\n  }\n\n  if (typeof test === \"boolean\") return test;\n\n  if (typeof test === \"string\") {\n    const name = module.nameForCondition();\n    return name && name.startsWith(test);\n  }\n\n  if (test instanceof RegExp) {\n    const name = module.nameForCondition();\n    return name && test.test(name);\n  }\n\n  return false;\n};\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\n\n\nconst checkModuleType = (test, module) => {\n  if (test === undefined) return true;\n\n  if (typeof test === \"function\") {\n    return test(module.type);\n  }\n\n  if (typeof test === \"string\") {\n    const type = module.type;\n    return test === type;\n  }\n\n  if (test instanceof RegExp) {\n    const type = module.type;\n    return test.test(type);\n  }\n\n  return false;\n};\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\n\n\nconst checkModuleLayer = (test, module) => {\n  if (test === undefined) return true;\n\n  if (typeof test === \"function\") {\n    return test(module.layer);\n  }\n\n  if (typeof test === \"string\") {\n    const layer = module.layer;\n    return test === \"\" ? !layer : layer && layer.startsWith(test);\n  }\n\n  if (test instanceof RegExp) {\n    const layer = module.layer;\n    return test.test(layer);\n  }\n\n  return false;\n};\n/**\n * @param {OptimizationSplitChunksCacheGroup} options the group options\n * @param {string} key key of cache group\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {CacheGroupSource} the normalized cached group\n */\n\n\nconst createCacheGroupSource = (options, key, defaultSizeTypes) => {\n  const minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n  const minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n  const maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n  return {\n    key,\n    priority: options.priority,\n    getName: normalizeName(options.name),\n    chunksFilter: normalizeChunksFilter(options.chunks),\n    enforce: options.enforce,\n    minSize,\n    minSizeReduction,\n    minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n    enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n    maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n    maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n    minChunks: options.minChunks,\n    maxAsyncRequests: options.maxAsyncRequests,\n    maxInitialRequests: options.maxInitialRequests,\n    filename: options.filename,\n    idHint: options.idHint,\n    automaticNameDelimiter: options.automaticNameDelimiter,\n    reuseExistingChunk: options.reuseExistingChunk,\n    usedExports: options.usedExports\n  };\n};\n\nmodule.exports = class SplitChunksPlugin {\n  /**\n   * @param {OptimizationSplitChunksOptions=} options plugin options\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const defaultSizeTypes = options.defaultSizeTypes || [\"javascript\", \"unknown\"];\n    const fallbackCacheGroup = options.fallbackCacheGroup || {};\n    const minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n    const minSizeReduction = normalizeSizes(options.minSizeReduction, defaultSizeTypes);\n    const maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n    /** @type {SplitChunksOptions} */\n\n    this.options = {\n      chunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\n      defaultSizeTypes,\n      minSize,\n      minSizeReduction,\n      minRemainingSize: mergeSizes(normalizeSizes(options.minRemainingSize, defaultSizeTypes), minSize),\n      enforceSizeThreshold: normalizeSizes(options.enforceSizeThreshold, defaultSizeTypes),\n      maxAsyncSize: mergeSizes(normalizeSizes(options.maxAsyncSize, defaultSizeTypes), maxSize),\n      maxInitialSize: mergeSizes(normalizeSizes(options.maxInitialSize, defaultSizeTypes), maxSize),\n      minChunks: options.minChunks || 1,\n      maxAsyncRequests: options.maxAsyncRequests || 1,\n      maxInitialRequests: options.maxInitialRequests || 1,\n      hidePathInfo: options.hidePathInfo || false,\n      filename: options.filename || undefined,\n      getCacheGroups: normalizeCacheGroups(options.cacheGroups, defaultSizeTypes),\n      getName: options.name ? normalizeName(options.name) : defaultGetName,\n      automaticNameDelimiter: options.automaticNameDelimiter,\n      usedExports: options.usedExports,\n      fallbackCacheGroup: {\n        chunksFilter: normalizeChunksFilter(fallbackCacheGroup.chunks || options.chunks || \"all\"),\n        minSize: mergeSizes(normalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes), minSize),\n        maxAsyncSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxAsyncSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        maxInitialSize: mergeSizes(normalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes), normalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes), normalizeSizes(options.maxInitialSize, defaultSizeTypes), normalizeSizes(options.maxSize, defaultSizeTypes)),\n        automaticNameDelimiter: fallbackCacheGroup.automaticNameDelimiter || options.automaticNameDelimiter || \"~\"\n      }\n    };\n    /** @type {WeakMap<CacheGroupSource, CacheGroup>} */\n\n    this._cacheGroupCache = new WeakMap();\n  }\n  /**\n   * @param {CacheGroupSource} cacheGroupSource source\n   * @returns {CacheGroup} the cache group (cached)\n   */\n\n\n  _getCacheGroup(cacheGroupSource) {\n    const cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\n\n    if (cacheEntry !== undefined) return cacheEntry;\n    const minSize = mergeSizes(cacheGroupSource.minSize, cacheGroupSource.enforce ? undefined : this.options.minSize);\n    const minSizeReduction = mergeSizes(cacheGroupSource.minSizeReduction, cacheGroupSource.enforce ? undefined : this.options.minSizeReduction);\n    const minRemainingSize = mergeSizes(cacheGroupSource.minRemainingSize, cacheGroupSource.enforce ? undefined : this.options.minRemainingSize);\n    const enforceSizeThreshold = mergeSizes(cacheGroupSource.enforceSizeThreshold, cacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold);\n    const cacheGroup = {\n      key: cacheGroupSource.key,\n      priority: cacheGroupSource.priority || 0,\n      chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n      minSize,\n      minSizeReduction,\n      minRemainingSize,\n      enforceSizeThreshold,\n      maxAsyncSize: mergeSizes(cacheGroupSource.maxAsyncSize, cacheGroupSource.enforce ? undefined : this.options.maxAsyncSize),\n      maxInitialSize: mergeSizes(cacheGroupSource.maxInitialSize, cacheGroupSource.enforce ? undefined : this.options.maxInitialSize),\n      minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,\n      maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : this.options.maxAsyncRequests,\n      maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : this.options.maxInitialRequests,\n      getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : this.options.getName,\n      usedExports: cacheGroupSource.usedExports !== undefined ? cacheGroupSource.usedExports : this.options.usedExports,\n      filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : this.options.filename,\n      automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,\n      idHint: cacheGroupSource.idHint !== undefined ? cacheGroupSource.idHint : cacheGroupSource.key,\n      reuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\n      _validateSize: hasNonZeroSizes(minSize),\n      _validateRemainingSize: hasNonZeroSizes(minRemainingSize),\n      _minSizeForMaxSize: mergeSizes(cacheGroupSource.minSize, this.options.minSize),\n      _conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\n    };\n\n    this._cacheGroupCache.set(cacheGroupSource, cacheGroup);\n\n    return cacheGroup;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const cachedMakePathsRelative = makePathsRelative.bindContextCache(compiler.context, compiler.root);\n    compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n      const logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\n      let alreadyOptimized = false;\n      compilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n        alreadyOptimized = false;\n      });\n      compilation.hooks.optimizeChunks.tap({\n        name: \"SplitChunksPlugin\",\n        stage: STAGE_ADVANCED\n      }, chunks => {\n        if (alreadyOptimized) return;\n        alreadyOptimized = true;\n        logger.time(\"prepare\");\n        const chunkGraph = compilation.chunkGraph;\n        const moduleGraph = compilation.moduleGraph; // Give each selected chunk an index (to create strings from chunks)\n\n        /** @type {Map<Chunk, bigint>} */\n\n        const chunkIndexMap = new Map();\n        const ZERO = BigInt(\"0\");\n        const ONE = BigInt(\"1\");\n        const START = ONE << BigInt(\"31\");\n        let index = START;\n\n        for (const chunk of chunks) {\n          chunkIndexMap.set(chunk, index | BigInt(Math.random() * 0x7fffffff | 0));\n          index = index << ONE;\n        }\n        /**\n         * @param {Iterable<Chunk>} chunks list of chunks\n         * @returns {bigint | Chunk} key of the chunks\n         */\n\n\n        const getKey = chunks => {\n          const iterator = chunks[Symbol.iterator]();\n          let result = iterator.next();\n          if (result.done) return ZERO;\n          const first = result.value;\n          result = iterator.next();\n          if (result.done) return first;\n          let key = chunkIndexMap.get(first) | chunkIndexMap.get(result.value);\n\n          while (!(result = iterator.next()).done) {\n            const raw = chunkIndexMap.get(result.value);\n            key = key ^ raw;\n          }\n\n          return key;\n        };\n\n        const keyToString = key => {\n          if (typeof key === \"bigint\") return key.toString(16);\n          return chunkIndexMap.get(key).toString(16);\n        };\n\n        const getChunkSetsInGraph = memoize(() => {\n          /** @type {Map<bigint, Set<Chunk>>} */\n          const chunkSetsInGraph = new Map();\n          /** @type {Set<Chunk>} */\n\n          const singleChunkSets = new Set();\n\n          for (const module of compilation.modules) {\n            const chunks = chunkGraph.getModuleChunksIterable(module);\n            const chunksKey = getKey(chunks);\n\n            if (typeof chunksKey === \"bigint\") {\n              if (!chunkSetsInGraph.has(chunksKey)) {\n                chunkSetsInGraph.set(chunksKey, new Set(chunks));\n              }\n            } else {\n              singleChunkSets.add(chunksKey);\n            }\n          }\n\n          return {\n            chunkSetsInGraph,\n            singleChunkSets\n          };\n        });\n        /**\n         * @param {Module} module the module\n         * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\n         */\n\n        const groupChunksByExports = module => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          const groupedByUsedExports = new Map();\n\n          for (const chunk of chunkGraph.getModuleChunksIterable(module)) {\n            const key = exportsInfo.getUsageKey(chunk.runtime);\n            const list = groupedByUsedExports.get(key);\n\n            if (list !== undefined) {\n              list.push(chunk);\n            } else {\n              groupedByUsedExports.set(key, [chunk]);\n            }\n          }\n\n          return groupedByUsedExports.values();\n        };\n        /** @type {Map<Module, Iterable<Chunk[]>>} */\n\n\n        const groupedByExportsMap = new Map();\n        const getExportsChunkSetsInGraph = memoize(() => {\n          /** @type {Map<bigint, Set<Chunk>>} */\n          const chunkSetsInGraph = new Map();\n          /** @type {Set<Chunk>} */\n\n          const singleChunkSets = new Set();\n\n          for (const module of compilation.modules) {\n            const groupedChunks = Array.from(groupChunksByExports(module));\n            groupedByExportsMap.set(module, groupedChunks);\n\n            for (const chunks of groupedChunks) {\n              if (chunks.length === 1) {\n                singleChunkSets.add(chunks[0]);\n              } else {\n                const chunksKey =\n                /** @type {bigint} */\n                getKey(chunks);\n\n                if (!chunkSetsInGraph.has(chunksKey)) {\n                  chunkSetsInGraph.set(chunksKey, new Set(chunks));\n                }\n              }\n            }\n          }\n\n          return {\n            chunkSetsInGraph,\n            singleChunkSets\n          };\n        }); // group these set of chunks by count\n        // to allow to check less sets via isSubset\n        // (only smaller sets can be subset)\n\n        const groupChunkSetsByCount = chunkSets => {\n          /** @type {Map<number, Array<Set<Chunk>>>} */\n          const chunkSetsByCount = new Map();\n\n          for (const chunksSet of chunkSets) {\n            const count = chunksSet.size;\n            let array = chunkSetsByCount.get(count);\n\n            if (array === undefined) {\n              array = [];\n              chunkSetsByCount.set(count, array);\n            }\n\n            array.push(chunksSet);\n          }\n\n          return chunkSetsByCount;\n        };\n\n        const getChunkSetsByCount = memoize(() => groupChunkSetsByCount(getChunkSetsInGraph().chunkSetsInGraph.values()));\n        const getExportsChunkSetsByCount = memoize(() => groupChunkSetsByCount(getExportsChunkSetsInGraph().chunkSetsInGraph.values())); // Create a list of possible combinations\n\n        const createGetCombinations = (chunkSets, singleChunkSets, chunkSetsByCount) => {\n          /** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\n          const combinationsCache = new Map();\n          return key => {\n            const cacheEntry = combinationsCache.get(key);\n            if (cacheEntry !== undefined) return cacheEntry;\n\n            if (key instanceof Chunk) {\n              const result = [key];\n              combinationsCache.set(key, result);\n              return result;\n            }\n\n            const chunksSet = chunkSets.get(key);\n            /** @type {(Set<Chunk> | Chunk)[]} */\n\n            const array = [chunksSet];\n\n            for (const [count, setArray] of chunkSetsByCount) {\n              // \"equal\" is not needed because they would have been merge in the first step\n              if (count < chunksSet.size) {\n                for (const set of setArray) {\n                  if (isSubset(chunksSet, set)) {\n                    array.push(set);\n                  }\n                }\n              }\n            }\n\n            for (const chunk of singleChunkSets) {\n              if (chunksSet.has(chunk)) {\n                array.push(chunk);\n              }\n            }\n\n            combinationsCache.set(key, array);\n            return array;\n          };\n        };\n\n        const getCombinationsFactory = memoize(() => {\n          const {\n            chunkSetsInGraph,\n            singleChunkSets\n          } = getChunkSetsInGraph();\n          return createGetCombinations(chunkSetsInGraph, singleChunkSets, getChunkSetsByCount());\n        });\n\n        const getCombinations = key => getCombinationsFactory()(key);\n\n        const getExportsCombinationsFactory = memoize(() => {\n          const {\n            chunkSetsInGraph,\n            singleChunkSets\n          } = getExportsChunkSetsInGraph();\n          return createGetCombinations(chunkSetsInGraph, singleChunkSets, getExportsChunkSetsByCount());\n        });\n\n        const getExportsCombinations = key => getExportsCombinationsFactory()(key);\n        /**\n         * @typedef {Object} SelectedChunksResult\n         * @property {Chunk[]} chunks the list of chunks\n         * @property {bigint | Chunk} key a key of the list\n         */\n\n        /** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\n\n        const selectedChunksCacheByChunksSet = new WeakMap();\n        /**\n         * get list and key by applying the filter function to the list\n         * It is cached for performance reasons\n         * @param {Set<Chunk> | Chunk} chunks list of chunks\n         * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n         * @returns {SelectedChunksResult} list and key\n         */\n\n        const getSelectedChunks = (chunks, chunkFilter) => {\n          let entry = selectedChunksCacheByChunksSet.get(chunks);\n\n          if (entry === undefined) {\n            entry = new WeakMap();\n            selectedChunksCacheByChunksSet.set(chunks, entry);\n          }\n          /** @type {SelectedChunksResult} */\n\n\n          let entry2 = entry.get(chunkFilter);\n\n          if (entry2 === undefined) {\n            /** @type {Chunk[]} */\n            const selectedChunks = [];\n\n            if (chunks instanceof Chunk) {\n              if (chunkFilter(chunks)) selectedChunks.push(chunks);\n            } else {\n              for (const chunk of chunks) {\n                if (chunkFilter(chunk)) selectedChunks.push(chunk);\n              }\n            }\n\n            entry2 = {\n              chunks: selectedChunks,\n              key: getKey(selectedChunks)\n            };\n            entry.set(chunkFilter, entry2);\n          }\n\n          return entry2;\n        };\n        /** @type {Map<string, boolean>} */\n\n\n        const alreadyValidatedParents = new Map();\n        /** @type {Set<string>} */\n\n        const alreadyReportedErrors = new Set(); // Map a list of chunks to a list of modules\n        // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\n        /** @type {Map<string, ChunksInfoItem>} */\n\n        const chunksInfoMap = new Map();\n        /**\n         * @param {CacheGroup} cacheGroup the current cache group\n         * @param {number} cacheGroupIndex the index of the cache group of ordering\n         * @param {Chunk[]} selectedChunks chunks selected for this module\n         * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\n         * @param {Module} module the current module\n         * @returns {void}\n         */\n\n        const addModuleToChunksInfoMap = (cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) => {\n          // Break if minimum number of chunks is not reached\n          if (selectedChunks.length < cacheGroup.minChunks) return; // Determine name for split chunk\n\n          const name = cacheGroup.getName(module, selectedChunks, cacheGroup.key); // Check if the name is ok\n\n          const existingChunk = compilation.namedChunks.get(name);\n\n          if (existingChunk) {\n            const parentValidationKey = `${name}|${typeof selectedChunksKey === \"bigint\" ? selectedChunksKey : selectedChunksKey.debugId}`;\n            const valid = alreadyValidatedParents.get(parentValidationKey);\n            if (valid === false) return;\n\n            if (valid === undefined) {\n              // Module can only be moved into the existing chunk if the existing chunk\n              // is a parent of all selected chunks\n              let isInAllParents = true;\n              /** @type {Set<ChunkGroup>} */\n\n              const queue = new Set();\n\n              for (const chunk of selectedChunks) {\n                for (const group of chunk.groupsIterable) {\n                  queue.add(group);\n                }\n              }\n\n              for (const group of queue) {\n                if (existingChunk.isInGroup(group)) continue;\n                let hasParent = false;\n\n                for (const parent of group.parentsIterable) {\n                  hasParent = true;\n                  queue.add(parent);\n                }\n\n                if (!hasParent) {\n                  isInAllParents = false;\n                }\n              }\n\n              const valid = isInAllParents;\n              alreadyValidatedParents.set(parentValidationKey, valid);\n\n              if (!valid) {\n                if (!alreadyReportedErrors.has(name)) {\n                  alreadyReportedErrors.add(name);\n                  compilation.errors.push(new WebpackError(\"SplitChunksPlugin\\n\" + `Cache group \"${cacheGroup.key}\" conflicts with existing chunk.\\n` + `Both have the same name \"${name}\" and existing chunk is not a parent of the selected modules.\\n` + \"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" + 'HINT: You can omit \"name\" to automatically create a name.\\n' + \"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" + \"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" + \"Remove this entrypoint and add modules to cache group's 'test' instead. \" + \"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" + \"See migration guide of more info.\"));\n                }\n\n                return;\n              }\n            }\n          } // Create key for maps\n          // When it has a name we use the name as key\n          // Otherwise we create the key from chunks and cache group key\n          // This automatically merges equal names\n\n\n          const key = cacheGroup.key + (name ? ` name:${name}` : ` chunks:${keyToString(selectedChunksKey)}`); // Add module to maps\n\n          let info = chunksInfoMap.get(key);\n\n          if (info === undefined) {\n            chunksInfoMap.set(key, info = {\n              modules: new SortableSet(undefined, compareModulesByIdentifier),\n              cacheGroup,\n              cacheGroupIndex,\n              name,\n              sizes: {},\n              chunks: new Set(),\n              reuseableChunks: new Set(),\n              chunksKeys: new Set()\n            });\n          }\n\n          const oldSize = info.modules.size;\n          info.modules.add(module);\n\n          if (info.modules.size !== oldSize) {\n            for (const type of module.getSourceTypes()) {\n              info.sizes[type] = (info.sizes[type] || 0) + module.size(type);\n            }\n          }\n\n          const oldChunksKeysSize = info.chunksKeys.size;\n          info.chunksKeys.add(selectedChunksKey);\n\n          if (oldChunksKeysSize !== info.chunksKeys.size) {\n            for (const chunk of selectedChunks) {\n              info.chunks.add(chunk);\n            }\n          }\n        };\n\n        const context = {\n          moduleGraph,\n          chunkGraph\n        };\n        logger.timeEnd(\"prepare\");\n        logger.time(\"modules\"); // Walk through all modules\n\n        for (const module of compilation.modules) {\n          // Get cache group\n          let cacheGroups = this.options.getCacheGroups(module, context);\n\n          if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n            continue;\n          } // Prepare some values (usedExports = false)\n\n\n          const getCombs = memoize(() => {\n            const chunks = chunkGraph.getModuleChunksIterable(module);\n            const chunksKey = getKey(chunks);\n            return getCombinations(chunksKey);\n          }); // Prepare some values (usedExports = true)\n\n          const getCombsByUsedExports = memoize(() => {\n            // fill the groupedByExportsMap\n            getExportsChunkSetsInGraph();\n            /** @type {Set<Set<Chunk> | Chunk>} */\n\n            const set = new Set();\n            const groupedByUsedExports = groupedByExportsMap.get(module);\n\n            for (const chunks of groupedByUsedExports) {\n              const chunksKey = getKey(chunks);\n\n              for (const comb of getExportsCombinations(chunksKey)) set.add(comb);\n            }\n\n            return set;\n          });\n          let cacheGroupIndex = 0;\n\n          for (const cacheGroupSource of cacheGroups) {\n            const cacheGroup = this._getCacheGroup(cacheGroupSource);\n\n            const combs = cacheGroup.usedExports ? getCombsByUsedExports() : getCombs(); // For all combination of chunk selection\n\n            for (const chunkCombination of combs) {\n              // Break if minimum number of chunks is not reached\n              const count = chunkCombination instanceof Chunk ? 1 : chunkCombination.size;\n              if (count < cacheGroup.minChunks) continue; // Select chunks by configuration\n\n              const {\n                chunks: selectedChunks,\n                key: selectedChunksKey\n              } = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n              addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module);\n            }\n\n            cacheGroupIndex++;\n          }\n        }\n\n        logger.timeEnd(\"modules\");\n        logger.time(\"queue\");\n        /**\n         * @param {ChunksInfoItem} info entry\n         * @param {string[]} sourceTypes source types to be removed\n         */\n\n        const removeModulesWithSourceType = (info, sourceTypes) => {\n          for (const module of info.modules) {\n            const types = module.getSourceTypes();\n\n            if (sourceTypes.some(type => types.has(type))) {\n              info.modules.delete(module);\n\n              for (const type of types) {\n                info.sizes[type] -= module.size(type);\n              }\n            }\n          }\n        };\n        /**\n         * @param {ChunksInfoItem} info entry\n         * @returns {boolean} true, if entry become empty\n         */\n\n\n        const removeMinSizeViolatingModules = info => {\n          if (!info.cacheGroup._validateSize) return false;\n          const violatingSizes = getViolatingMinSizes(info.sizes, info.cacheGroup.minSize);\n          if (violatingSizes === undefined) return false;\n          removeModulesWithSourceType(info, violatingSizes);\n          return info.modules.size === 0;\n        }; // Filter items were size < minSize\n\n\n        for (const [key, info] of chunksInfoMap) {\n          if (removeMinSizeViolatingModules(info)) {\n            chunksInfoMap.delete(key);\n          } else if (!checkMinSizeReduction(info.sizes, info.cacheGroup.minSizeReduction, info.chunks.size)) {\n            chunksInfoMap.delete(key);\n          }\n        }\n        /**\n         * @typedef {Object} MaxSizeQueueItem\n         * @property {SplitChunksSizes} minSize\n         * @property {SplitChunksSizes} maxAsyncSize\n         * @property {SplitChunksSizes} maxInitialSize\n         * @property {string} automaticNameDelimiter\n         * @property {string[]} keys\n         */\n\n        /** @type {Map<Chunk, MaxSizeQueueItem>} */\n\n\n        const maxSizeQueueMap = new Map();\n\n        while (chunksInfoMap.size > 0) {\n          // Find best matching entry\n          let bestEntryKey;\n          let bestEntry;\n\n          for (const pair of chunksInfoMap) {\n            const key = pair[0];\n            const info = pair[1];\n\n            if (bestEntry === undefined || compareEntries(bestEntry, info) < 0) {\n              bestEntry = info;\n              bestEntryKey = key;\n            }\n          }\n\n          const item = bestEntry;\n          chunksInfoMap.delete(bestEntryKey);\n          let chunkName = item.name; // Variable for the new chunk (lazy created)\n\n          /** @type {Chunk} */\n\n          let newChunk; // When no chunk name, check if we can reuse a chunk instead of creating a new one\n\n          let isExistingChunk = false;\n          let isReusedWithAllModules = false;\n\n          if (chunkName) {\n            const chunkByName = compilation.namedChunks.get(chunkName);\n\n            if (chunkByName !== undefined) {\n              newChunk = chunkByName;\n              const oldSize = item.chunks.size;\n              item.chunks.delete(newChunk);\n              isExistingChunk = item.chunks.size !== oldSize;\n            }\n          } else if (item.cacheGroup.reuseExistingChunk) {\n            outer: for (const chunk of item.chunks) {\n              if (chunkGraph.getNumberOfChunkModules(chunk) !== item.modules.size) {\n                continue;\n              }\n\n              if (item.chunks.size > 1 && chunkGraph.getNumberOfEntryModules(chunk) > 0) {\n                continue;\n              }\n\n              for (const module of item.modules) {\n                if (!chunkGraph.isModuleInChunk(module, chunk)) {\n                  continue outer;\n                }\n              }\n\n              if (!newChunk || !newChunk.name) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length < newChunk.name.length) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) {\n                newChunk = chunk;\n              }\n            }\n\n            if (newChunk) {\n              item.chunks.delete(newChunk);\n              chunkName = undefined;\n              isExistingChunk = true;\n              isReusedWithAllModules = true;\n            }\n          }\n\n          const enforced = item.cacheGroup._conditionalEnforce && checkMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\n          const usedChunks = new Set(item.chunks); // Check if maxRequests condition can be fulfilled\n\n          if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {\n            for (const chunk of usedChunks) {\n              // respect max requests\n              const maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n\n              if (isFinite(maxRequests) && getRequests(chunk) >= maxRequests) {\n                usedChunks.delete(chunk);\n              }\n            }\n          }\n\n          outer: for (const chunk of usedChunks) {\n            for (const module of item.modules) {\n              if (chunkGraph.isModuleInChunk(module, chunk)) continue outer;\n            }\n\n            usedChunks.delete(chunk);\n          } // Were some (invalid) chunks removed from usedChunks?\n          // => readd all modules to the queue, as things could have been changed\n\n\n          if (usedChunks.size < item.chunks.size) {\n            if (isExistingChunk) usedChunks.add(newChunk);\n\n            if (usedChunks.size >= item.cacheGroup.minChunks) {\n              const chunksArr = Array.from(usedChunks);\n\n              for (const module of item.modules) {\n                addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), module);\n              }\n            }\n\n            continue;\n          } // Validate minRemainingSize constraint when a single chunk is left over\n\n\n          if (!enforced && item.cacheGroup._validateRemainingSize && usedChunks.size === 1) {\n            const [chunk] = usedChunks;\n            let chunkSizes = Object.create(null);\n\n            for (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n              if (!item.modules.has(module)) {\n                for (const type of module.getSourceTypes()) {\n                  chunkSizes[type] = (chunkSizes[type] || 0) + module.size(type);\n                }\n              }\n            }\n\n            const violatingSizes = getViolatingMinSizes(chunkSizes, item.cacheGroup.minRemainingSize);\n\n            if (violatingSizes !== undefined) {\n              const oldModulesSize = item.modules.size;\n              removeModulesWithSourceType(item, violatingSizes);\n\n              if (item.modules.size > 0 && item.modules.size !== oldModulesSize) {\n                // queue this item again to be processed again\n                // without violating modules\n                chunksInfoMap.set(bestEntryKey, item);\n              }\n\n              continue;\n            }\n          } // Create the new chunk if not reusing one\n\n\n          if (newChunk === undefined) {\n            newChunk = compilation.addChunk(chunkName);\n          } // Walk through all chunks\n\n\n          for (const chunk of usedChunks) {\n            // Add graph connections for splitted chunk\n            chunk.split(newChunk);\n          } // Add a note to the chunk\n\n\n          newChunk.chunkReason = (newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") + (isReusedWithAllModules ? \"reused as split chunk\" : \"split chunk\");\n\n          if (item.cacheGroup.key) {\n            newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n          }\n\n          if (chunkName) {\n            newChunk.chunkReason += ` (name: ${chunkName})`;\n          }\n\n          if (item.cacheGroup.filename) {\n            newChunk.filenameTemplate = item.cacheGroup.filename;\n          }\n\n          if (item.cacheGroup.idHint) {\n            newChunk.idNameHints.add(item.cacheGroup.idHint);\n          }\n\n          if (!isReusedWithAllModules) {\n            // Add all modules to the new chunk\n            for (const module of item.modules) {\n              if (!module.chunkCondition(newChunk, compilation)) continue; // Add module to new chunk\n\n              chunkGraph.connectChunkAndModule(newChunk, module); // Remove module from used chunks\n\n              for (const chunk of usedChunks) {\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            }\n          } else {\n            // Remove all modules from used chunks\n            for (const module of item.modules) {\n              for (const chunk of usedChunks) {\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            }\n          }\n\n          if (Object.keys(item.cacheGroup.maxAsyncSize).length > 0 || Object.keys(item.cacheGroup.maxInitialSize).length > 0) {\n            const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n            maxSizeQueueMap.set(newChunk, {\n              minSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.minSize, item.cacheGroup._minSizeForMaxSize, Math.max) : item.cacheGroup.minSize,\n              maxAsyncSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxAsyncSize, item.cacheGroup.maxAsyncSize, Math.min) : item.cacheGroup.maxAsyncSize,\n              maxInitialSize: oldMaxSizeSettings ? combineSizes(oldMaxSizeSettings.maxInitialSize, item.cacheGroup.maxInitialSize, Math.min) : item.cacheGroup.maxInitialSize,\n              automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n              keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n            });\n          } // remove all modules from other entries and update size\n\n\n          for (const [key, info] of chunksInfoMap) {\n            if (isOverlap(info.chunks, usedChunks)) {\n              // update modules and total size\n              // may remove it from the map when < minSize\n              let updated = false;\n\n              for (const module of item.modules) {\n                if (info.modules.has(module)) {\n                  // remove module\n                  info.modules.delete(module); // update size\n\n                  for (const key of module.getSourceTypes()) {\n                    info.sizes[key] -= module.size(key);\n                  }\n\n                  updated = true;\n                }\n              }\n\n              if (updated) {\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n\n                if (removeMinSizeViolatingModules(info) || !checkMinSizeReduction(info.sizes, info.cacheGroup.minSizeReduction, info.chunks.size)) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n              }\n            }\n          }\n        }\n\n        logger.timeEnd(\"queue\");\n        logger.time(\"maxSize\");\n        /** @type {Set<string>} */\n\n        const incorrectMinMaxSizeSet = new Set();\n        const {\n          outputOptions\n        } = compilation; // Make sure that maxSize is fulfilled\n\n        const {\n          fallbackCacheGroup\n        } = this.options;\n\n        for (const chunk of Array.from(compilation.chunks)) {\n          const chunkConfig = maxSizeQueueMap.get(chunk);\n          const {\n            minSize,\n            maxAsyncSize,\n            maxInitialSize,\n            automaticNameDelimiter\n          } = chunkConfig || fallbackCacheGroup;\n          if (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk)) continue;\n          /** @type {SplitChunksSizes} */\n\n          let maxSize;\n\n          if (chunk.isOnlyInitial()) {\n            maxSize = maxInitialSize;\n          } else if (chunk.canBeInitial()) {\n            maxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\n          } else {\n            maxSize = maxAsyncSize;\n          }\n\n          if (Object.keys(maxSize).length === 0) {\n            continue;\n          }\n\n          for (const key of Object.keys(maxSize)) {\n            const maxSizeValue = maxSize[key];\n            const minSizeValue = minSize[key];\n\n            if (typeof minSizeValue === \"number\" && minSizeValue > maxSizeValue) {\n              const keys = chunkConfig && chunkConfig.keys;\n              const warningKey = `${keys && keys.join()} ${minSizeValue} ${maxSizeValue}`;\n\n              if (!incorrectMinMaxSizeSet.has(warningKey)) {\n                incorrectMinMaxSizeSet.add(warningKey);\n                compilation.warnings.push(new MinMaxSizeWarning(keys, minSizeValue, maxSizeValue));\n              }\n            }\n          }\n\n          const results = deterministicGroupingForModules({\n            minSize,\n            maxSize: mapObject(maxSize, (value, key) => {\n              const minSizeValue = minSize[key];\n              return typeof minSizeValue === \"number\" ? Math.max(value, minSizeValue) : value;\n            }),\n            items: chunkGraph.getChunkModulesIterable(chunk),\n\n            getKey(module) {\n              const cache = getKeyCache.get(module);\n              if (cache !== undefined) return cache;\n              const ident = cachedMakePathsRelative(module.identifier());\n              const nameForCondition = module.nameForCondition && module.nameForCondition();\n              const name = nameForCondition ? cachedMakePathsRelative(nameForCondition) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n              const fullKey = name + automaticNameDelimiter + hashFilename(ident, outputOptions);\n              const key = requestToId(fullKey);\n              getKeyCache.set(module, key);\n              return key;\n            },\n\n            getSize(module) {\n              const size = Object.create(null);\n\n              for (const key of module.getSourceTypes()) {\n                size[key] = module.size(key);\n              }\n\n              return size;\n            }\n\n          });\n\n          if (results.length <= 1) {\n            continue;\n          }\n\n          for (let i = 0; i < results.length; i++) {\n            const group = results[i];\n            const key = this.options.hidePathInfo ? hashFilename(group.key, outputOptions) : group.key;\n            let name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n\n            if (name && name.length > 100) {\n              name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name, outputOptions);\n            }\n\n            if (i !== results.length - 1) {\n              const newPart = compilation.addChunk(name);\n              chunk.split(newPart);\n              newPart.chunkReason = chunk.chunkReason; // Add all modules to the new chunk\n\n              for (const module of group.items) {\n                if (!module.chunkCondition(newPart, compilation)) {\n                  continue;\n                } // Add module to new chunk\n\n\n                chunkGraph.connectChunkAndModule(newPart, module); // Remove module from used chunks\n\n                chunkGraph.disconnectChunkAndModule(chunk, module);\n              }\n            } else {\n              // change the chunk to be a part\n              chunk.name = name;\n            }\n          }\n        }\n\n        logger.timeEnd(\"maxSize\");\n      });\n    });\n  }\n\n};","map":{"version":3,"names":["Chunk","require","STAGE_ADVANCED","WebpackError","requestToId","isSubset","SortableSet","compareModulesByIdentifier","compareIterables","createHash","deterministicGrouping","makePathsRelative","memoize","MinMaxSizeWarning","defaultGetName","deterministicGroupingForModules","getKeyCache","WeakMap","hashFilename","name","outputOptions","digest","hashFunction","update","hashDigest","slice","getRequests","chunk","requests","chunkGroup","groupsIterable","Math","max","chunks","length","mapObject","obj","fn","newObj","Object","create","key","keys","isOverlap","a","b","item","has","compareModuleIterables","compareEntries","diffPriority","cacheGroup","priority","diffCount","size","aSizeReduce","totalSize","sizes","bSizeReduce","diffSizeReduce","indexDiff","cacheGroupIndex","modulesA","modules","modulesB","diff","sort","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","normalizeSizes","value","defaultSizeTypes","o","sizeType","mergeSizes","merged","i","assign","hasNonZeroSizes","combineSizes","combine","aKeys","Set","bKeys","result","checkMinSize","minSize","undefined","checkMinSizeReduction","minSizeReduction","chunkCount","getViolatingMinSizes","list","push","normalizeName","normalizeChunksFilter","normalizeCacheGroups","cacheGroups","handlers","option","RegExp","source","createCacheGroupSource","module","context","results","checkTest","cache","groups","Array","isArray","group","cachedSource","get","set","test","checkModuleType","type","checkModuleLayer","layer","nameForCondition","startsWith","options","maxSize","getName","chunksFilter","enforce","minRemainingSize","enforceSizeThreshold","maxAsyncSize","maxInitialSize","minChunks","maxAsyncRequests","maxInitialRequests","filename","idHint","automaticNameDelimiter","reuseExistingChunk","usedExports","exports","SplitChunksPlugin","constructor","fallbackCacheGroup","hidePathInfo","getCacheGroups","_cacheGroupCache","_getCacheGroup","cacheGroupSource","cacheEntry","Infinity","_validateSize","_validateRemainingSize","_minSizeForMaxSize","_conditionalEnforce","apply","compiler","cachedMakePathsRelative","bindContextCache","root","hooks","thisCompilation","tap","compilation","logger","getLogger","alreadyOptimized","unseal","optimizeChunks","stage","time","chunkGraph","moduleGraph","chunkIndexMap","Map","ZERO","BigInt","ONE","START","index","random","getKey","iterator","Symbol","next","done","first","raw","keyToString","toString","getChunkSetsInGraph","chunkSetsInGraph","singleChunkSets","getModuleChunksIterable","chunksKey","add","groupChunksByExports","exportsInfo","getExportsInfo","groupedByUsedExports","getUsageKey","runtime","values","groupedByExportsMap","getExportsChunkSetsInGraph","groupedChunks","from","groupChunkSetsByCount","chunkSets","chunkSetsByCount","chunksSet","count","array","getChunkSetsByCount","getExportsChunkSetsByCount","createGetCombinations","combinationsCache","setArray","getCombinationsFactory","getCombinations","getExportsCombinationsFactory","getExportsCombinations","selectedChunksCacheByChunksSet","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","alreadyValidatedParents","alreadyReportedErrors","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","existingChunk","namedChunks","parentValidationKey","debugId","valid","isInAllParents","queue","isInGroup","hasParent","parent","parentsIterable","errors","info","reuseableChunks","chunksKeys","oldSize","getSourceTypes","oldChunksKeysSize","timeEnd","getCombs","getCombsByUsedExports","comb","combs","chunkCombination","removeModulesWithSourceType","sourceTypes","types","some","delete","removeMinSizeViolatingModules","violatingSizes","maxSizeQueueMap","bestEntryKey","bestEntry","pair","chunkName","newChunk","isExistingChunk","isReusedWithAllModules","chunkByName","outer","getNumberOfChunkModules","getNumberOfEntryModules","isModuleInChunk","enforced","usedChunks","Number","isFinite","maxRequests","isOnlyInitial","min","chunksArr","chunkSizes","getChunkModulesIterable","oldModulesSize","addChunk","split","chunkReason","filenameTemplate","idNameHints","chunkCondition","connectChunkAndModule","disconnectChunkAndModule","oldMaxSizeSettings","concat","updated","incorrectMinMaxSizeSet","chunkConfig","maxSizeValue","minSizeValue","warningKey","join","warnings","items","ident","identifier","replace","fullKey","getSize","newPart"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Chunk = require(\"../Chunk\");\nconst { STAGE_ADVANCED } = require(\"../OptimizationStages\");\nconst WebpackError = require(\"../WebpackError\");\nconst { requestToId } = require(\"../ids/IdHelpers\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareIterables\n} = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst memoize = require(\"../util/memoize\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksCacheGroup} OptimizationSplitChunksCacheGroup */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksGetCacheGroups} OptimizationSplitChunksGetCacheGroups */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksOptions} OptimizationSplitChunksOptions */\n/** @typedef {import(\"../../declarations/WebpackOptions\").OptimizationSplitChunksSizes} OptimizationSplitChunksSizes */\n/** @typedef {import(\"../../declarations/WebpackOptions\").Output} OutputOptions */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compilation\").PathData} PathData */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {Record<string, number>} SplitChunksSizes */\n\n/**\n * @callback ChunkFilterFunction\n * @param {Chunk} chunk\n * @returns {boolean}\n */\n\n/**\n * @callback CombineSizeFunction\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\n/**\n * @typedef {Object} CacheGroupSource\n * @property {string=} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {boolean=} enforce\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean=} reuseExistingChunk\n * @property {boolean=} usedExports\n */\n\n/**\n * @typedef {Object} CacheGroup\n * @property {string} key\n * @property {number=} priority\n * @property {GetName=} getName\n * @property {ChunkFilterFunction=} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {number=} minChunks\n * @property {number=} maxAsyncRequests\n * @property {number=} maxInitialRequests\n * @property {(string | function(PathData, AssetInfo=): string)=} filename\n * @property {string=} idHint\n * @property {string} automaticNameDelimiter\n * @property {boolean} reuseExistingChunk\n * @property {boolean} usedExports\n * @property {boolean} _validateSize\n * @property {boolean} _validateRemainingSize\n * @property {SplitChunksSizes} _minSizeForMaxSize\n * @property {boolean} _conditionalEnforce\n */\n\n/**\n * @typedef {Object} FallbackCacheGroup\n * @property {ChunkFilterFunction} chunksFilter\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {SplitChunksSizes} maxInitialSize\n * @property {string} automaticNameDelimiter\n */\n\n/**\n * @typedef {Object} CacheGroupsContext\n * @property {ModuleGraph} moduleGraph\n * @property {ChunkGraph} chunkGraph\n */\n\n/**\n * @callback GetCacheGroups\n * @param {Module} module\n * @param {CacheGroupsContext} context\n * @returns {CacheGroupSource[]}\n */\n\n/**\n * @callback GetName\n * @param {Module=} module\n * @param {Chunk[]=} chunks\n * @param {string=} key\n * @returns {string=}\n */\n\n/**\n * @typedef {Object} SplitChunksOptions\n * @property {ChunkFilterFunction} chunksFilter\n * @property {string[]} defaultSizeTypes\n * @property {SplitChunksSizes} minSize\n * @property {SplitChunksSizes} minSizeReduction\n * @property {SplitChunksSizes} minRemainingSize\n * @property {SplitChunksSizes} enforceSizeThreshold\n * @property {SplitChunksSizes} maxInitialSize\n * @property {SplitChunksSizes} maxAsyncSize\n * @property {number} minChunks\n * @property {number} maxAsyncRequests\n * @property {number} maxInitialRequests\n * @property {boolean} hidePathInfo\n * @property {string | function(PathData, AssetInfo=): string} filename\n * @property {string} automaticNameDelimiter\n * @property {GetCacheGroups} getCacheGroups\n * @property {GetName} getName\n * @property {boolean} usedExports\n * @property {FallbackCacheGroup} fallbackCacheGroup\n */\n\n/**\n * @typedef {Object} ChunksInfoItem\n * @property {SortableSet<Module>} modules\n * @property {CacheGroup} cacheGroup\n * @property {number} cacheGroupIndex\n * @property {string} name\n * @property {Record<string, number>} sizes\n * @property {Set<Chunk>} chunks\n * @property {Set<Chunk>} reuseableChunks\n * @property {Set<bigint | Chunk>} chunksKeys\n */\n\nconst defaultGetName = /** @type {GetName} */ (() => {});\n\nconst deterministicGroupingForModules =\n\t/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (\n\t\tdeterministicGrouping\n\t);\n\n/** @type {WeakMap<Module, string>} */\nconst getKeyCache = new WeakMap();\n\n/**\n * @param {string} name a filename to hash\n * @param {OutputOptions} outputOptions hash function used\n * @returns {string} hashed filename\n */\nconst hashFilename = (name, outputOptions) => {\n\tconst digest = /** @type {string} */ (\n\t\tcreateHash(outputOptions.hashFunction)\n\t\t\t.update(name)\n\t\t\t.digest(outputOptions.hashDigest)\n\t);\n\treturn digest.slice(0, 8);\n};\n\n/**\n * @param {Chunk} chunk the chunk\n * @returns {number} the number of requests\n */\nconst getRequests = chunk => {\n\tlet requests = 0;\n\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\n\t}\n\treturn requests;\n};\n\nconst mapObject = (obj, fn) => {\n\tconst newObj = Object.create(null);\n\tfor (const key of Object.keys(obj)) {\n\t\tnewObj[key] = fn(obj[key], key);\n\t}\n\treturn newObj;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n\tfor (const item of a) {\n\t\tif (b.has(item)) return true;\n\t}\n\treturn false;\n};\n\nconst compareModuleIterables = compareIterables(compareModulesByIdentifier);\n\n/**\n * @param {ChunksInfoItem} a item\n * @param {ChunksInfoItem} b item\n * @returns {number} compare result\n */\nconst compareEntries = (a, b) => {\n\t// 1. by priority\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n\tif (diffPriority) return diffPriority;\n\t// 2. by number of chunks\n\tconst diffCount = a.chunks.size - b.chunks.size;\n\tif (diffCount) return diffCount;\n\t// 3. by size reduction\n\tconst aSizeReduce = totalSize(a.sizes) * (a.chunks.size - 1);\n\tconst bSizeReduce = totalSize(b.sizes) * (b.chunks.size - 1);\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\n\tif (diffSizeReduce) return diffSizeReduce;\n\t// 4. by cache group index\n\tconst indexDiff = b.cacheGroupIndex - a.cacheGroupIndex;\n\tif (indexDiff) return indexDiff;\n\t// 5. by number of modules (to be able to compare by identifier)\n\tconst modulesA = a.modules;\n\tconst modulesB = b.modules;\n\tconst diff = modulesA.size - modulesB.size;\n\tif (diff) return diff;\n\t// 6. by module identifiers\n\tmodulesA.sort();\n\tmodulesB.sort();\n\treturn compareModuleIterables(modulesA, modulesB);\n};\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\n/**\n * @param {OptimizationSplitChunksSizes} value the sizes\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {SplitChunksSizes} normalized representation\n */\nconst normalizeSizes = (value, defaultSizeTypes) => {\n\tif (typeof value === \"number\") {\n\t\t/** @type {Record<string, number>} */\n\t\tconst o = {};\n\t\tfor (const sizeType of defaultSizeTypes) o[sizeType] = value;\n\t\treturn o;\n\t} else if (typeof value === \"object\" && value !== null) {\n\t\treturn { ...value };\n\t} else {\n\t\treturn {};\n\t}\n};\n\n/**\n * @param {...SplitChunksSizes} sizes the sizes\n * @returns {SplitChunksSizes} the merged sizes\n */\nconst mergeSizes = (...sizes) => {\n\t/** @type {SplitChunksSizes} */\n\tlet merged = {};\n\tfor (let i = sizes.length - 1; i >= 0; i--) {\n\t\tmerged = Object.assign(merged, sizes[i]);\n\t}\n\treturn merged;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {boolean} true, if there are sizes > 0\n */\nconst hasNonZeroSizes = sizes => {\n\tfor (const key of Object.keys(sizes)) {\n\t\tif (sizes[key] > 0) return true;\n\t}\n\treturn false;\n};\n\n/**\n * @param {SplitChunksSizes} a first sizes\n * @param {SplitChunksSizes} b second sizes\n * @param {CombineSizeFunction} combine a function to combine sizes\n * @returns {SplitChunksSizes} the combine sizes\n */\nconst combineSizes = (a, b, combine) => {\n\tconst aKeys = new Set(Object.keys(a));\n\tconst bKeys = new Set(Object.keys(b));\n\t/** @type {SplitChunksSizes} */\n\tconst result = {};\n\tfor (const key of aKeys) {\n\t\tif (bKeys.has(key)) {\n\t\t\tresult[key] = combine(a[key], b[key]);\n\t\t} else {\n\t\t\tresult[key] = a[key];\n\t\t}\n\t}\n\tfor (const key of bKeys) {\n\t\tif (!aKeys.has(key)) {\n\t\t\tresult[key] = b[key];\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSize`\n */\nconst checkMinSize = (sizes, minSize) => {\n\tfor (const key of Object.keys(minSize)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size < minSize[key]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSizeReduction the min sizes\n * @param {number} chunkCount number of chunks\n * @returns {boolean} true if there are sizes and all existing sizes are at least `minSizeReduction`\n */\nconst checkMinSizeReduction = (sizes, minSizeReduction, chunkCount) => {\n\tfor (const key of Object.keys(minSizeReduction)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size * chunkCount < minSizeReduction[key]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @param {SplitChunksSizes} minSize the min sizes\n * @returns {undefined | string[]} list of size types that are below min size\n */\nconst getViolatingMinSizes = (sizes, minSize) => {\n\tlet list;\n\tfor (const key of Object.keys(minSize)) {\n\t\tconst size = sizes[key];\n\t\tif (size === undefined || size === 0) continue;\n\t\tif (size < minSize[key]) {\n\t\t\tif (list === undefined) list = [key];\n\t\t\telse list.push(key);\n\t\t}\n\t}\n\treturn list;\n};\n\n/**\n * @param {SplitChunksSizes} sizes the sizes\n * @returns {number} the total size\n */\nconst totalSize = sizes => {\n\tlet size = 0;\n\tfor (const key of Object.keys(sizes)) {\n\t\tsize += sizes[key];\n\t}\n\treturn size;\n};\n\n/**\n * @param {false|string|Function} name the chunk name\n * @returns {GetName} a function to get the name of the chunk\n */\nconst normalizeName = name => {\n\tif (typeof name === \"string\") {\n\t\treturn () => name;\n\t}\n\tif (typeof name === \"function\") {\n\t\treturn /** @type {GetName} */ (name);\n\t}\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup[\"chunks\"]} chunks the chunk filter option\n * @returns {ChunkFilterFunction} the chunk filter function\n */\nconst normalizeChunksFilter = chunks => {\n\tif (chunks === \"initial\") {\n\t\treturn INITIAL_CHUNK_FILTER;\n\t}\n\tif (chunks === \"async\") {\n\t\treturn ASYNC_CHUNK_FILTER;\n\t}\n\tif (chunks === \"all\") {\n\t\treturn ALL_CHUNK_FILTER;\n\t}\n\tif (typeof chunks === \"function\") {\n\t\treturn chunks;\n\t}\n};\n\n/**\n * @param {GetCacheGroups | Record<string, false|string|RegExp|OptimizationSplitChunksGetCacheGroups|OptimizationSplitChunksCacheGroup>} cacheGroups the cache group options\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {GetCacheGroups} a function to get the cache groups\n */\nconst normalizeCacheGroups = (cacheGroups, defaultSizeTypes) => {\n\tif (typeof cacheGroups === \"function\") {\n\t\treturn cacheGroups;\n\t}\n\tif (typeof cacheGroups === \"object\" && cacheGroups !== null) {\n\t\t/** @type {(function(Module, CacheGroupsContext, CacheGroupSource[]): void)[]} */\n\t\tconst handlers = [];\n\t\tfor (const key of Object.keys(cacheGroups)) {\n\t\t\tconst option = cacheGroups[key];\n\t\t\tif (option === false) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (typeof option === \"string\" || option instanceof RegExp) {\n\t\t\t\tconst source = createCacheGroupSource({}, key, defaultSizeTypes);\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tif (checkTest(option, module, context)) {\n\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else if (typeof option === \"function\") {\n\t\t\t\tconst cache = new WeakMap();\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tconst result = option(module);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tconst groups = Array.isArray(result) ? result : [result];\n\t\t\t\t\t\tfor (const group of groups) {\n\t\t\t\t\t\t\tconst cachedSource = cache.get(group);\n\t\t\t\t\t\t\tif (cachedSource !== undefined) {\n\t\t\t\t\t\t\t\tresults.push(cachedSource);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst source = createCacheGroupSource(\n\t\t\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\tdefaultSizeTypes\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tcache.set(group, source);\n\t\t\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst source = createCacheGroupSource(option, key, defaultSizeTypes);\n\t\t\t\thandlers.push((module, context, results) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcheckTest(option.test, module, context) &&\n\t\t\t\t\t\tcheckModuleType(option.type, module) &&\n\t\t\t\t\t\tcheckModuleLayer(option.layer, module)\n\t\t\t\t\t) {\n\t\t\t\t\t\tresults.push(source);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * @param {Module} module the current module\n\t\t * @param {CacheGroupsContext} context the current context\n\t\t * @returns {CacheGroupSource[]} the matching cache groups\n\t\t */\n\t\tconst fn = (module, context) => {\n\t\t\t/** @type {CacheGroupSource[]} */\n\t\t\tlet results = [];\n\t\t\tfor (const fn of handlers) {\n\t\t\t\tfn(module, context, results);\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\t\treturn fn;\n\t}\n\treturn () => null;\n};\n\n/**\n * @param {undefined|boolean|string|RegExp|Function} test test option\n * @param {Module} module the module\n * @param {CacheGroupsContext} context context object\n * @returns {boolean} true, if the module should be selected\n */\nconst checkTest = (test, module, context) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module, context);\n\t}\n\tif (typeof test === \"boolean\") return test;\n\tif (typeof test === \"string\") {\n\t\tconst name = module.nameForCondition();\n\t\treturn name && name.startsWith(test);\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst name = module.nameForCondition();\n\t\treturn name && test.test(name);\n\t}\n\treturn false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleType = (test, module) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module.type);\n\t}\n\tif (typeof test === \"string\") {\n\t\tconst type = module.type;\n\t\treturn test === type;\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst type = module.type;\n\t\treturn test.test(type);\n\t}\n\treturn false;\n};\n\n/**\n * @param {undefined|string|RegExp|Function} test type option\n * @param {Module} module the module\n * @returns {boolean} true, if the module should be selected\n */\nconst checkModuleLayer = (test, module) => {\n\tif (test === undefined) return true;\n\tif (typeof test === \"function\") {\n\t\treturn test(module.layer);\n\t}\n\tif (typeof test === \"string\") {\n\t\tconst layer = module.layer;\n\t\treturn test === \"\" ? !layer : layer && layer.startsWith(test);\n\t}\n\tif (test instanceof RegExp) {\n\t\tconst layer = module.layer;\n\t\treturn test.test(layer);\n\t}\n\treturn false;\n};\n\n/**\n * @param {OptimizationSplitChunksCacheGroup} options the group options\n * @param {string} key key of cache group\n * @param {string[]} defaultSizeTypes the default size types\n * @returns {CacheGroupSource} the normalized cached group\n */\nconst createCacheGroupSource = (options, key, defaultSizeTypes) => {\n\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n\tconst minSizeReduction = normalizeSizes(\n\t\toptions.minSizeReduction,\n\t\tdefaultSizeTypes\n\t);\n\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\treturn {\n\t\tkey,\n\t\tpriority: options.priority,\n\t\tgetName: normalizeName(options.name),\n\t\tchunksFilter: normalizeChunksFilter(options.chunks),\n\t\tenforce: options.enforce,\n\t\tminSize,\n\t\tminSizeReduction,\n\t\tminRemainingSize: mergeSizes(\n\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\n\t\t\tminSize\n\t\t),\n\t\tenforceSizeThreshold: normalizeSizes(\n\t\t\toptions.enforceSizeThreshold,\n\t\t\tdefaultSizeTypes\n\t\t),\n\t\tmaxAsyncSize: mergeSizes(\n\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\tmaxSize\n\t\t),\n\t\tmaxInitialSize: mergeSizes(\n\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\tmaxSize\n\t\t),\n\t\tminChunks: options.minChunks,\n\t\tmaxAsyncRequests: options.maxAsyncRequests,\n\t\tmaxInitialRequests: options.maxInitialRequests,\n\t\tfilename: options.filename,\n\t\tidHint: options.idHint,\n\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\treuseExistingChunk: options.reuseExistingChunk,\n\t\tusedExports: options.usedExports\n\t};\n};\n\nmodule.exports = class SplitChunksPlugin {\n\t/**\n\t * @param {OptimizationSplitChunksOptions=} options plugin options\n\t */\n\tconstructor(options = {}) {\n\t\tconst defaultSizeTypes = options.defaultSizeTypes || [\n\t\t\t\"javascript\",\n\t\t\t\"unknown\"\n\t\t];\n\t\tconst fallbackCacheGroup = options.fallbackCacheGroup || {};\n\t\tconst minSize = normalizeSizes(options.minSize, defaultSizeTypes);\n\t\tconst minSizeReduction = normalizeSizes(\n\t\t\toptions.minSizeReduction,\n\t\t\tdefaultSizeTypes\n\t\t);\n\t\tconst maxSize = normalizeSizes(options.maxSize, defaultSizeTypes);\n\n\t\t/** @type {SplitChunksOptions} */\n\t\tthis.options = {\n\t\t\tchunksFilter: normalizeChunksFilter(options.chunks || \"all\"),\n\t\t\tdefaultSizeTypes,\n\t\t\tminSize,\n\t\t\tminSizeReduction,\n\t\t\tminRemainingSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.minRemainingSize, defaultSizeTypes),\n\t\t\t\tminSize\n\t\t\t),\n\t\t\tenforceSizeThreshold: normalizeSizes(\n\t\t\t\toptions.enforceSizeThreshold,\n\t\t\t\tdefaultSizeTypes\n\t\t\t),\n\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\t\tmaxSize\n\t\t\t),\n\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\t\tmaxSize\n\t\t\t),\n\t\t\tminChunks: options.minChunks || 1,\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\n\t\t\thidePathInfo: options.hidePathInfo || false,\n\t\t\tfilename: options.filename || undefined,\n\t\t\tgetCacheGroups: normalizeCacheGroups(\n\t\t\t\toptions.cacheGroups,\n\t\t\t\tdefaultSizeTypes\n\t\t\t),\n\t\t\tgetName: options.name ? normalizeName(options.name) : defaultGetName,\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\tusedExports: options.usedExports,\n\t\t\tfallbackCacheGroup: {\n\t\t\t\tchunksFilter: normalizeChunksFilter(\n\t\t\t\t\tfallbackCacheGroup.chunks || options.chunks || \"all\"\n\t\t\t\t),\n\t\t\t\tminSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.minSize, defaultSizeTypes),\n\t\t\t\t\tminSize\n\t\t\t\t),\n\t\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxAsyncSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxAsyncSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\n\t\t\t\t),\n\t\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxInitialSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(fallbackCacheGroup.maxSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxInitialSize, defaultSizeTypes),\n\t\t\t\t\tnormalizeSizes(options.maxSize, defaultSizeTypes)\n\t\t\t\t),\n\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\tfallbackCacheGroup.automaticNameDelimiter ||\n\t\t\t\t\toptions.automaticNameDelimiter ||\n\t\t\t\t\t\"~\"\n\t\t\t}\n\t\t};\n\n\t\t/** @type {WeakMap<CacheGroupSource, CacheGroup>} */\n\t\tthis._cacheGroupCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {CacheGroupSource} cacheGroupSource source\n\t * @returns {CacheGroup} the cache group (cached)\n\t */\n\t_getCacheGroup(cacheGroupSource) {\n\t\tconst cacheEntry = this._cacheGroupCache.get(cacheGroupSource);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst minSize = mergeSizes(\n\t\t\tcacheGroupSource.minSize,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSize\n\t\t);\n\t\tconst minSizeReduction = mergeSizes(\n\t\t\tcacheGroupSource.minSizeReduction,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minSizeReduction\n\t\t);\n\t\tconst minRemainingSize = mergeSizes(\n\t\t\tcacheGroupSource.minRemainingSize,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.minRemainingSize\n\t\t);\n\t\tconst enforceSizeThreshold = mergeSizes(\n\t\t\tcacheGroupSource.enforceSizeThreshold,\n\t\t\tcacheGroupSource.enforce ? undefined : this.options.enforceSizeThreshold\n\t\t);\n\t\tconst cacheGroup = {\n\t\t\tkey: cacheGroupSource.key,\n\t\t\tpriority: cacheGroupSource.priority || 0,\n\t\t\tchunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n\t\t\tminSize,\n\t\t\tminSizeReduction,\n\t\t\tminRemainingSize,\n\t\t\tenforceSizeThreshold,\n\t\t\tmaxAsyncSize: mergeSizes(\n\t\t\t\tcacheGroupSource.maxAsyncSize,\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxAsyncSize\n\t\t\t),\n\t\t\tmaxInitialSize: mergeSizes(\n\t\t\t\tcacheGroupSource.maxInitialSize,\n\t\t\t\tcacheGroupSource.enforce ? undefined : this.options.maxInitialSize\n\t\t\t),\n\t\t\tminChunks:\n\t\t\t\tcacheGroupSource.minChunks !== undefined\n\t\t\t\t\t? cacheGroupSource.minChunks\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? 1\n\t\t\t\t\t: this.options.minChunks,\n\t\t\tmaxAsyncRequests:\n\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\n\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? Infinity\n\t\t\t\t\t: this.options.maxAsyncRequests,\n\t\t\tmaxInitialRequests:\n\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\n\t\t\t\t\t? cacheGroupSource.maxInitialRequests\n\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t? Infinity\n\t\t\t\t\t: this.options.maxInitialRequests,\n\t\t\tgetName:\n\t\t\t\tcacheGroupSource.getName !== undefined\n\t\t\t\t\t? cacheGroupSource.getName\n\t\t\t\t\t: this.options.getName,\n\t\t\tusedExports:\n\t\t\t\tcacheGroupSource.usedExports !== undefined\n\t\t\t\t\t? cacheGroupSource.usedExports\n\t\t\t\t\t: this.options.usedExports,\n\t\t\tfilename:\n\t\t\t\tcacheGroupSource.filename !== undefined\n\t\t\t\t\t? cacheGroupSource.filename\n\t\t\t\t\t: this.options.filename,\n\t\t\tautomaticNameDelimiter:\n\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\n\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\n\t\t\t\t\t: this.options.automaticNameDelimiter,\n\t\t\tidHint:\n\t\t\t\tcacheGroupSource.idHint !== undefined\n\t\t\t\t\t? cacheGroupSource.idHint\n\t\t\t\t\t: cacheGroupSource.key,\n\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk || false,\n\t\t\t_validateSize: hasNonZeroSizes(minSize),\n\t\t\t_validateRemainingSize: hasNonZeroSizes(minRemainingSize),\n\t\t\t_minSizeForMaxSize: mergeSizes(\n\t\t\t\tcacheGroupSource.minSize,\n\t\t\t\tthis.options.minSize\n\t\t\t),\n\t\t\t_conditionalEnforce: hasNonZeroSizes(enforceSizeThreshold)\n\t\t};\n\t\tthis._cacheGroupCache.set(cacheGroupSource, cacheGroup);\n\t\treturn cacheGroup;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cachedMakePathsRelative = makePathsRelative.bindContextCache(\n\t\t\tcompiler.context,\n\t\t\tcompiler.root\n\t\t);\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n\t\t\tconst logger = compilation.getLogger(\"webpack.SplitChunksPlugin\");\n\t\t\tlet alreadyOptimized = false;\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n\t\t\t\talreadyOptimized = false;\n\t\t\t});\n\t\t\tcompilation.hooks.optimizeChunks.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"SplitChunksPlugin\",\n\t\t\t\t\tstage: STAGE_ADVANCED\n\t\t\t\t},\n\t\t\t\tchunks => {\n\t\t\t\t\tif (alreadyOptimized) return;\n\t\t\t\t\talreadyOptimized = true;\n\t\t\t\t\tlogger.time(\"prepare\");\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\n\t\t\t\t\t/** @type {Map<Chunk, bigint>} */\n\t\t\t\t\tconst chunkIndexMap = new Map();\n\t\t\t\t\tconst ZERO = BigInt(\"0\");\n\t\t\t\t\tconst ONE = BigInt(\"1\");\n\t\t\t\t\tconst START = ONE << BigInt(\"31\");\n\t\t\t\t\tlet index = START;\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tchunkIndexMap.set(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tindex | BigInt((Math.random() * 0x7fffffff) | 0)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tindex = index << ONE;\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Iterable<Chunk>} chunks list of chunks\n\t\t\t\t\t * @returns {bigint | Chunk} key of the chunks\n\t\t\t\t\t */\n\t\t\t\t\tconst getKey = chunks => {\n\t\t\t\t\t\tconst iterator = chunks[Symbol.iterator]();\n\t\t\t\t\t\tlet result = iterator.next();\n\t\t\t\t\t\tif (result.done) return ZERO;\n\t\t\t\t\t\tconst first = result.value;\n\t\t\t\t\t\tresult = iterator.next();\n\t\t\t\t\t\tif (result.done) return first;\n\t\t\t\t\t\tlet key =\n\t\t\t\t\t\t\tchunkIndexMap.get(first) | chunkIndexMap.get(result.value);\n\t\t\t\t\t\twhile (!(result = iterator.next()).done) {\n\t\t\t\t\t\t\tconst raw = chunkIndexMap.get(result.value);\n\t\t\t\t\t\t\tkey = key ^ raw;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn key;\n\t\t\t\t\t};\n\t\t\t\t\tconst keyToString = key => {\n\t\t\t\t\t\tif (typeof key === \"bigint\") return key.toString(16);\n\t\t\t\t\t\treturn chunkIndexMap.get(key).toString(16);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getChunkSetsInGraph = memoize(() => {\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\t\tconst singleChunkSets = new Set();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\tif (typeof chunksKey === \"bigint\") {\n\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsingleChunkSets.add(chunksKey);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\n\t\t\t\t\t});\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Module} module the module\n\t\t\t\t\t * @returns {Iterable<Chunk[]>} groups of chunks with equal exports\n\t\t\t\t\t */\n\t\t\t\t\tconst groupChunksByExports = module => {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tconst groupedByUsedExports = new Map();\n\t\t\t\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(module)) {\n\t\t\t\t\t\t\tconst key = exportsInfo.getUsageKey(chunk.runtime);\n\t\t\t\t\t\t\tconst list = groupedByUsedExports.get(key);\n\t\t\t\t\t\t\tif (list !== undefined) {\n\t\t\t\t\t\t\t\tlist.push(chunk);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgroupedByUsedExports.set(key, [chunk]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn groupedByUsedExports.values();\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {Map<Module, Iterable<Chunk[]>>} */\n\t\t\t\t\tconst groupedByExportsMap = new Map();\n\n\t\t\t\t\tconst getExportsChunkSetsInGraph = memoize(() => {\n\t\t\t\t\t\t/** @type {Map<bigint, Set<Chunk>>} */\n\t\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\t\tconst singleChunkSets = new Set();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst groupedChunks = Array.from(groupChunksByExports(module));\n\t\t\t\t\t\t\tgroupedByExportsMap.set(module, groupedChunks);\n\t\t\t\t\t\t\tfor (const chunks of groupedChunks) {\n\t\t\t\t\t\t\t\tif (chunks.length === 1) {\n\t\t\t\t\t\t\t\t\tsingleChunkSets.add(chunks[0]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst chunksKey = /** @type {bigint} */ (getKey(chunks));\n\t\t\t\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(chunks));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn { chunkSetsInGraph, singleChunkSets };\n\t\t\t\t\t});\n\n\t\t\t\t\t// group these set of chunks by count\n\t\t\t\t\t// to allow to check less sets via isSubset\n\t\t\t\t\t// (only smaller sets can be subset)\n\t\t\t\t\tconst groupChunkSetsByCount = chunkSets => {\n\t\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\n\t\t\t\t\t\tconst chunkSetsByCount = new Map();\n\t\t\t\t\t\tfor (const chunksSet of chunkSets) {\n\t\t\t\t\t\t\tconst count = chunksSet.size;\n\t\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\n\t\t\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tarray.push(chunksSet);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn chunkSetsByCount;\n\t\t\t\t\t};\n\t\t\t\t\tconst getChunkSetsByCount = memoize(() =>\n\t\t\t\t\t\tgroupChunkSetsByCount(\n\t\t\t\t\t\t\tgetChunkSetsInGraph().chunkSetsInGraph.values()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tconst getExportsChunkSetsByCount = memoize(() =>\n\t\t\t\t\t\tgroupChunkSetsByCount(\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph().chunkSetsInGraph.values()\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t// Create a list of possible combinations\n\t\t\t\t\tconst createGetCombinations = (\n\t\t\t\t\t\tchunkSets,\n\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\tchunkSetsByCount\n\t\t\t\t\t) => {\n\t\t\t\t\t\t/** @type {Map<bigint | Chunk, (Set<Chunk> | Chunk)[]>} */\n\t\t\t\t\t\tconst combinationsCache = new Map();\n\n\t\t\t\t\t\treturn key => {\n\t\t\t\t\t\t\tconst cacheEntry = combinationsCache.get(key);\n\t\t\t\t\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\t\t\t\t\tif (key instanceof Chunk) {\n\t\t\t\t\t\t\t\tconst result = [key];\n\t\t\t\t\t\t\t\tcombinationsCache.set(key, result);\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst chunksSet = chunkSets.get(key);\n\t\t\t\t\t\t\t/** @type {(Set<Chunk> | Chunk)[]} */\n\t\t\t\t\t\t\tconst array = [chunksSet];\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const chunk of singleChunkSets) {\n\t\t\t\t\t\t\t\tif (chunksSet.has(chunk)) {\n\t\t\t\t\t\t\t\t\tarray.push(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcombinationsCache.set(key, array);\n\t\t\t\t\t\t\treturn array;\n\t\t\t\t\t\t};\n\t\t\t\t\t};\n\n\t\t\t\t\tconst getCombinationsFactory = memoize(() => {\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } = getChunkSetsInGraph();\n\t\t\t\t\t\treturn createGetCombinations(\n\t\t\t\t\t\t\tchunkSetsInGraph,\n\t\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\t\tgetChunkSetsByCount()\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tconst getCombinations = key => getCombinationsFactory()(key);\n\n\t\t\t\t\tconst getExportsCombinationsFactory = memoize(() => {\n\t\t\t\t\t\tconst { chunkSetsInGraph, singleChunkSets } =\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\n\t\t\t\t\t\treturn createGetCombinations(\n\t\t\t\t\t\t\tchunkSetsInGraph,\n\t\t\t\t\t\t\tsingleChunkSets,\n\t\t\t\t\t\t\tgetExportsChunkSetsByCount()\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tconst getExportsCombinations = key =>\n\t\t\t\t\t\tgetExportsCombinationsFactory()(key);\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\n\t\t\t\t\t * @property {bigint | Chunk} key a key of the list\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk> | Chunk, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * get list and key by applying the filter function to the list\n\t\t\t\t\t * It is cached for performance reasons\n\t\t\t\t\t * @param {Set<Chunk> | Chunk} chunks list of chunks\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\n\t\t\t\t\t */\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\n\t\t\t\t\t\tif (entry === undefined) {\n\t\t\t\t\t\t\tentry = new WeakMap();\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\n\t\t\t\t\t\tif (entry2 === undefined) {\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\t\t\tconst selectedChunks = [];\n\t\t\t\t\t\t\tif (chunks instanceof Chunk) {\n\t\t\t\t\t\t\t\tif (chunkFilter(chunks)) selectedChunks.push(chunks);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry2 = {\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn entry2;\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {Map<string, boolean>} */\n\t\t\t\t\tconst alreadyValidatedParents = new Map();\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst alreadyReportedErrors = new Set();\n\n\t\t\t\t\t// Map a list of chunks to a list of modules\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\n\t\t\t\t\tconst chunksInfoMap = new Map();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {CacheGroup} cacheGroup the current cache group\n\t\t\t\t\t * @param {number} cacheGroupIndex the index of the cache group of ordering\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\n\t\t\t\t\t * @param {bigint | Chunk} selectedChunksKey a key of selectedChunks\n\t\t\t\t\t * @param {Module} module the current module\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\n\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\tmodule\n\t\t\t\t\t) => {\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\n\t\t\t\t\t\t// Determine name for split chunk\n\t\t\t\t\t\tconst name = cacheGroup.getName(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\tcacheGroup.key\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Check if the name is ok\n\t\t\t\t\t\tconst existingChunk = compilation.namedChunks.get(name);\n\t\t\t\t\t\tif (existingChunk) {\n\t\t\t\t\t\t\tconst parentValidationKey = `${name}|${\n\t\t\t\t\t\t\t\ttypeof selectedChunksKey === \"bigint\"\n\t\t\t\t\t\t\t\t\t? selectedChunksKey\n\t\t\t\t\t\t\t\t\t: selectedChunksKey.debugId\n\t\t\t\t\t\t\t}`;\n\t\t\t\t\t\t\tconst valid = alreadyValidatedParents.get(parentValidationKey);\n\t\t\t\t\t\t\tif (valid === false) return;\n\t\t\t\t\t\t\tif (valid === undefined) {\n\t\t\t\t\t\t\t\t// Module can only be moved into the existing chunk if the existing chunk\n\t\t\t\t\t\t\t\t// is a parent of all selected chunks\n\t\t\t\t\t\t\t\tlet isInAllParents = true;\n\t\t\t\t\t\t\t\t/** @type {Set<ChunkGroup>} */\n\t\t\t\t\t\t\t\tconst queue = new Set();\n\t\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\t\tfor (const group of chunk.groupsIterable) {\n\t\t\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\t\tif (existingChunk.isInGroup(group)) continue;\n\t\t\t\t\t\t\t\t\tlet hasParent = false;\n\t\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\t\thasParent = true;\n\t\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!hasParent) {\n\t\t\t\t\t\t\t\t\t\tisInAllParents = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst valid = isInAllParents;\n\t\t\t\t\t\t\t\talreadyValidatedParents.set(parentValidationKey, valid);\n\t\t\t\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\t\t\t\tif (!alreadyReportedErrors.has(name)) {\n\t\t\t\t\t\t\t\t\t\talreadyReportedErrors.add(name);\n\t\t\t\t\t\t\t\t\t\tcompilation.errors.push(\n\t\t\t\t\t\t\t\t\t\t\tnew WebpackError(\n\t\t\t\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Cache group \"${cacheGroup.key}\" conflicts with existing chunk.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Both have the same name \"${name}\" and existing chunk is not a parent of the selected modules.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Use a different name for the cache group or make sure that the existing chunk is a parent (e. g. via dependOn).\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t'HINT: You can omit \"name\" to automatically create a name.\\n' +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"BREAKING CHANGE: webpack < 5 used to allow to use an entrypoint as splitChunk. \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"This is no longer allowed when the entrypoint is not a parent of the selected modules.\\n\" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Remove this entrypoint and add modules to cache group's 'test' instead. \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"If you need modules to be evaluated on startup, add them to the existing entrypoints (make them arrays). \" +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"See migration guide of more info.\"\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Create key for maps\n\t\t\t\t\t\t// When it has a name we use the name as key\n\t\t\t\t\t\t// Otherwise we create the key from chunks and cache group key\n\t\t\t\t\t\t// This automatically merges equal names\n\t\t\t\t\t\tconst key =\n\t\t\t\t\t\t\tcacheGroup.key +\n\t\t\t\t\t\t\t(name\n\t\t\t\t\t\t\t\t? ` name:${name}`\n\t\t\t\t\t\t\t\t: ` chunks:${keyToString(selectedChunksKey)}`);\n\t\t\t\t\t\t// Add module to maps\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\n\t\t\t\t\t\tif (info === undefined) {\n\t\t\t\t\t\t\tchunksInfoMap.set(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(\n\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\tcompareModulesByIdentifier\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\tsizes: {},\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst oldSize = info.modules.size;\n\t\t\t\t\t\tinfo.modules.add(module);\n\t\t\t\t\t\tif (info.modules.size !== oldSize) {\n\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\tinfo.sizes[type] = (info.sizes[type] || 0) + module.size(type);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst oldChunksKeysSize = info.chunksKeys.size;\n\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\n\t\t\t\t\t\tif (oldChunksKeysSize !== info.chunksKeys.size) {\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tconst context = {\n\t\t\t\t\t\tmoduleGraph,\n\t\t\t\t\t\tchunkGraph\n\t\t\t\t\t};\n\n\t\t\t\t\tlogger.timeEnd(\"prepare\");\n\n\t\t\t\t\tlogger.time(\"modules\");\n\n\t\t\t\t\t// Walk through all modules\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t// Get cache group\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module, context);\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prepare some values (usedExports = false)\n\t\t\t\t\t\tconst getCombs = memoize(() => {\n\t\t\t\t\t\t\tconst chunks = chunkGraph.getModuleChunksIterable(module);\n\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\treturn getCombinations(chunksKey);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Prepare some values (usedExports = true)\n\t\t\t\t\t\tconst getCombsByUsedExports = memoize(() => {\n\t\t\t\t\t\t\t// fill the groupedByExportsMap\n\t\t\t\t\t\t\tgetExportsChunkSetsInGraph();\n\t\t\t\t\t\t\t/** @type {Set<Set<Chunk> | Chunk>} */\n\t\t\t\t\t\t\tconst set = new Set();\n\t\t\t\t\t\t\tconst groupedByUsedExports = groupedByExportsMap.get(module);\n\t\t\t\t\t\t\tfor (const chunks of groupedByUsedExports) {\n\t\t\t\t\t\t\t\tconst chunksKey = getKey(chunks);\n\t\t\t\t\t\t\t\tfor (const comb of getExportsCombinations(chunksKey))\n\t\t\t\t\t\t\t\t\tset.add(comb);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn set;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tlet cacheGroupIndex = 0;\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\n\t\t\t\t\t\t\tconst cacheGroup = this._getCacheGroup(cacheGroupSource);\n\n\t\t\t\t\t\t\tconst combs = cacheGroup.usedExports\n\t\t\t\t\t\t\t\t? getCombsByUsedExports()\n\t\t\t\t\t\t\t\t: getCombs();\n\t\t\t\t\t\t\t// For all combination of chunk selection\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\t\t\tconst count =\n\t\t\t\t\t\t\t\t\tchunkCombination instanceof Chunk ? 1 : chunkCombination.size;\n\t\t\t\t\t\t\t\tif (count < cacheGroup.minChunks) continue;\n\t\t\t\t\t\t\t\t// Select chunks by configuration\n\t\t\t\t\t\t\t\tconst { chunks: selectedChunks, key: selectedChunksKey } =\n\t\t\t\t\t\t\t\t\tgetSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcacheGroupIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.timeEnd(\"modules\");\n\n\t\t\t\t\tlogger.time(\"queue\");\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\n\t\t\t\t\t * @param {string[]} sourceTypes source types to be removed\n\t\t\t\t\t */\n\t\t\t\t\tconst removeModulesWithSourceType = (info, sourceTypes) => {\n\t\t\t\t\t\tfor (const module of info.modules) {\n\t\t\t\t\t\t\tconst types = module.getSourceTypes();\n\t\t\t\t\t\t\tif (sourceTypes.some(type => types.has(type))) {\n\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\tfor (const type of types) {\n\t\t\t\t\t\t\t\t\tinfo.sizes[type] -= module.size(type);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {ChunksInfoItem} info entry\n\t\t\t\t\t * @returns {boolean} true, if entry become empty\n\t\t\t\t\t */\n\t\t\t\t\tconst removeMinSizeViolatingModules = info => {\n\t\t\t\t\t\tif (!info.cacheGroup._validateSize) return false;\n\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\n\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\tinfo.cacheGroup.minSize\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (violatingSizes === undefined) return false;\n\t\t\t\t\t\tremoveModulesWithSourceType(info, violatingSizes);\n\t\t\t\t\t\treturn info.modules.size === 0;\n\t\t\t\t\t};\n\n\t\t\t\t\t// Filter items were size < minSize\n\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\tif (removeMinSizeViolatingModules(info)) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t!checkMinSizeReduction(\n\t\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\n\t\t\t\t\t\t\t\tinfo.chunks.size\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} MaxSizeQueueItem\n\t\t\t\t\t * @property {SplitChunksSizes} minSize\n\t\t\t\t\t * @property {SplitChunksSizes} maxAsyncSize\n\t\t\t\t\t * @property {SplitChunksSizes} maxInitialSize\n\t\t\t\t\t * @property {string} automaticNameDelimiter\n\t\t\t\t\t * @property {string[]} keys\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {Map<Chunk, MaxSizeQueueItem>} */\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\n\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\n\t\t\t\t\t\t// Find best matching entry\n\t\t\t\t\t\tlet bestEntryKey;\n\t\t\t\t\t\tlet bestEntry;\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\t\tconst key = pair[0];\n\t\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tbestEntry === undefined ||\n\t\t\t\t\t\t\t\tcompareEntries(bestEntry, info) < 0\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst item = bestEntry;\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\n\n\t\t\t\t\t\tlet chunkName = item.name;\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\n\t\t\t\t\t\t/** @type {Chunk} */\n\t\t\t\t\t\tlet newChunk;\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\n\t\t\t\t\t\tlet isExistingChunk = false;\n\t\t\t\t\t\tlet isReusedWithAllModules = false;\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tconst chunkByName = compilation.namedChunks.get(chunkName);\n\t\t\t\t\t\t\tif (chunkByName !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk = chunkByName;\n\t\t\t\t\t\t\t\tconst oldSize = item.chunks.size;\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\n\t\t\t\t\t\t\t\tisExistingChunk = item.chunks.size !== oldSize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (item.cacheGroup.reuseExistingChunk) {\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfChunkModules(chunk) !==\n\t\t\t\t\t\t\t\t\titem.modules.size\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\titem.chunks.size > 1 &&\n\t\t\t\t\t\t\t\t\tchunkGraph.getNumberOfEntryModules(chunk) > 0\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (!chunkGraph.isModuleInChunk(module, chunk)) {\n\t\t\t\t\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (newChunk) {\n\t\t\t\t\t\t\t\titem.chunks.delete(newChunk);\n\t\t\t\t\t\t\t\tchunkName = undefined;\n\t\t\t\t\t\t\t\tisExistingChunk = true;\n\t\t\t\t\t\t\t\tisReusedWithAllModules = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst enforced =\n\t\t\t\t\t\t\titem.cacheGroup._conditionalEnforce &&\n\t\t\t\t\t\t\tcheckMinSize(item.sizes, item.cacheGroup.enforceSizeThreshold);\n\n\t\t\t\t\t\tconst usedChunks = new Set(item.chunks);\n\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\t(Number.isFinite(item.cacheGroup.maxInitialRequests) ||\n\t\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t// respect max requests\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\n\t\t\t\t\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tisFinite(maxRequests) &&\n\t\t\t\t\t\t\t\t\tgetRequests(chunk) >= maxRequests\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\touter: for (const chunk of usedChunks) {\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (chunkGraph.isModuleInChunk(module, chunk)) continue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Were some (invalid) chunks removed from usedChunks?\n\t\t\t\t\t\t// => readd all modules to the queue, as things could have been changed\n\t\t\t\t\t\tif (usedChunks.size < item.chunks.size) {\n\t\t\t\t\t\t\tif (isExistingChunk) usedChunks.add(newChunk);\n\t\t\t\t\t\t\tif (usedChunks.size >= item.cacheGroup.minChunks) {\n\t\t\t\t\t\t\t\tconst chunksArr = Array.from(usedChunks);\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\n\t\t\t\t\t\t\t\t\t\titem.cacheGroupIndex,\n\t\t\t\t\t\t\t\t\t\tchunksArr,\n\t\t\t\t\t\t\t\t\t\tgetKey(usedChunks),\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Validate minRemainingSize constraint when a single chunk is left over\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\titem.cacheGroup._validateRemainingSize &&\n\t\t\t\t\t\t\tusedChunks.size === 1\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst [chunk] = usedChunks;\n\t\t\t\t\t\t\tlet chunkSizes = Object.create(null);\n\t\t\t\t\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\t\t\t\t\tif (!item.modules.has(module)) {\n\t\t\t\t\t\t\t\t\tfor (const type of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\t\tchunkSizes[type] =\n\t\t\t\t\t\t\t\t\t\t\t(chunkSizes[type] || 0) + module.size(type);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst violatingSizes = getViolatingMinSizes(\n\t\t\t\t\t\t\t\tchunkSizes,\n\t\t\t\t\t\t\t\titem.cacheGroup.minRemainingSize\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (violatingSizes !== undefined) {\n\t\t\t\t\t\t\t\tconst oldModulesSize = item.modules.size;\n\t\t\t\t\t\t\t\tremoveModulesWithSourceType(item, violatingSizes);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\titem.modules.size > 0 &&\n\t\t\t\t\t\t\t\t\titem.modules.size !== oldModulesSize\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t// queue this item again to be processed again\n\t\t\t\t\t\t\t\t\t// without violating modules\n\t\t\t\t\t\t\t\t\tchunksInfoMap.set(bestEntryKey, item);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the new chunk if not reusing one\n\t\t\t\t\t\tif (newChunk === undefined) {\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Walk through all chunks\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\n\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add a note to the chunk\n\t\t\t\t\t\tnewChunk.chunkReason =\n\t\t\t\t\t\t\t(newChunk.chunkReason ? newChunk.chunkReason + \", \" : \"\") +\n\t\t\t\t\t\t\t(isReusedWithAllModules\n\t\t\t\t\t\t\t\t? \"reused as split chunk\"\n\t\t\t\t\t\t\t\t: \"split chunk\");\n\t\t\t\t\t\tif (item.cacheGroup.key) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.idHint) {\n\t\t\t\t\t\t\tnewChunk.idNameHints.add(item.cacheGroup.idHint);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isReusedWithAllModules) {\n\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk, compilation)) continue;\n\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newChunk, module);\n\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove all modules from used chunks\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxAsyncSize).length > 0 ||\n\t\t\t\t\t\t\tObject.keys(item.cacheGroup.maxInitialSize).length > 0\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\n\t\t\t\t\t\t\t\tminSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.minSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup._minSizeForMaxSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.max\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.minSize,\n\t\t\t\t\t\t\t\tmaxAsyncSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxAsyncSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.min\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncSize,\n\t\t\t\t\t\t\t\tmaxInitialSize: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? combineSizes(\n\t\t\t\t\t\t\t\t\t\t\toldMaxSizeSettings.maxInitialSize,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialSize,\n\t\t\t\t\t\t\t\t\t\t\tMath.min\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxInitialSize,\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove all modules from other entries and update size\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, usedChunks)) {\n\t\t\t\t\t\t\t\t// update modules and total size\n\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\n\t\t\t\t\t\t\t\tlet updated = false;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (info.modules.has(module)) {\n\t\t\t\t\t\t\t\t\t\t// remove module\n\t\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t\t\t// update size\n\t\t\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes[key] -= module.size(key);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (updated) {\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tremoveMinSizeViolatingModules(info) ||\n\t\t\t\t\t\t\t\t\t\t!checkMinSizeReduction(\n\t\t\t\t\t\t\t\t\t\t\tinfo.sizes,\n\t\t\t\t\t\t\t\t\t\t\tinfo.cacheGroup.minSizeReduction,\n\t\t\t\t\t\t\t\t\t\t\tinfo.chunks.size\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlogger.timeEnd(\"queue\");\n\n\t\t\t\t\tlogger.time(\"maxSize\");\n\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\n\n\t\t\t\t\tconst { outputOptions } = compilation;\n\n\t\t\t\t\t// Make sure that maxSize is fulfilled\n\t\t\t\t\tconst { fallbackCacheGroup } = this.options;\n\t\t\t\t\tfor (const chunk of Array.from(compilation.chunks)) {\n\t\t\t\t\t\tconst chunkConfig = maxSizeQueueMap.get(chunk);\n\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\tmaxAsyncSize,\n\t\t\t\t\t\t\tmaxInitialSize,\n\t\t\t\t\t\t\tautomaticNameDelimiter\n\t\t\t\t\t\t} = chunkConfig || fallbackCacheGroup;\n\t\t\t\t\t\tif (!chunkConfig && !fallbackCacheGroup.chunksFilter(chunk))\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t/** @type {SplitChunksSizes} */\n\t\t\t\t\t\tlet maxSize;\n\t\t\t\t\t\tif (chunk.isOnlyInitial()) {\n\t\t\t\t\t\t\tmaxSize = maxInitialSize;\n\t\t\t\t\t\t} else if (chunk.canBeInitial()) {\n\t\t\t\t\t\t\tmaxSize = combineSizes(maxAsyncSize, maxInitialSize, Math.min);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmaxSize = maxAsyncSize;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (Object.keys(maxSize).length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const key of Object.keys(maxSize)) {\n\t\t\t\t\t\t\tconst maxSizeValue = maxSize[key];\n\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttypeof minSizeValue === \"number\" &&\n\t\t\t\t\t\t\t\tminSizeValue > maxSizeValue\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst keys = chunkConfig && chunkConfig.keys;\n\t\t\t\t\t\t\t\tconst warningKey = `${\n\t\t\t\t\t\t\t\t\tkeys && keys.join()\n\t\t\t\t\t\t\t\t} ${minSizeValue} ${maxSizeValue}`;\n\t\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\n\t\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\n\t\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSizeValue, maxSizeValue)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\tmaxSize: mapObject(maxSize, (value, key) => {\n\t\t\t\t\t\t\t\tconst minSizeValue = minSize[key];\n\t\t\t\t\t\t\t\treturn typeof minSizeValue === \"number\"\n\t\t\t\t\t\t\t\t\t? Math.max(value, minSizeValue)\n\t\t\t\t\t\t\t\t\t: value;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\titems: chunkGraph.getChunkModulesIterable(chunk),\n\t\t\t\t\t\t\tgetKey(module) {\n\t\t\t\t\t\t\t\tconst cache = getKeyCache.get(module);\n\t\t\t\t\t\t\t\tif (cache !== undefined) return cache;\n\t\t\t\t\t\t\t\tconst ident = cachedMakePathsRelative(module.identifier());\n\t\t\t\t\t\t\t\tconst nameForCondition =\n\t\t\t\t\t\t\t\t\tmodule.nameForCondition && module.nameForCondition();\n\t\t\t\t\t\t\t\tconst name = nameForCondition\n\t\t\t\t\t\t\t\t\t? cachedMakePathsRelative(nameForCondition)\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n\t\t\t\t\t\t\t\tconst fullKey =\n\t\t\t\t\t\t\t\t\tname +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(ident, outputOptions);\n\t\t\t\t\t\t\t\tconst key = requestToId(fullKey);\n\t\t\t\t\t\t\t\tgetKeyCache.set(module, key);\n\t\t\t\t\t\t\t\treturn key;\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetSize(module) {\n\t\t\t\t\t\t\t\tconst size = Object.create(null);\n\t\t\t\t\t\t\t\tfor (const key of module.getSourceTypes()) {\n\t\t\t\t\t\t\t\t\tsize[key] = module.size(key);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn size;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (results.length <= 1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\tconst group = results[i];\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\n\t\t\t\t\t\t\t\t? hashFilename(group.key, outputOptions)\n\t\t\t\t\t\t\t\t: group.key;\n\t\t\t\t\t\t\tlet name = chunk.name\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (name && name.length > 100) {\n\t\t\t\t\t\t\t\tname =\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(name, outputOptions);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\n\t\t\t\t\t\t\t\tconst newPart = compilation.addChunk(name);\n\t\t\t\t\t\t\t\tchunk.split(newPart);\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart, compilation)) {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\t\tchunkGraph.connectChunkAndModule(newPart, module);\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// change the chunk to be a part\n\t\t\t\t\t\t\t\tchunk.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"maxSize\");\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAArB;;AACA,MAAM;EAAEC;AAAF,IAAqBD,OAAO,CAAC,uBAAD,CAAlC;;AACA,MAAME,YAAY,GAAGF,OAAO,CAAC,iBAAD,CAA5B;;AACA,MAAM;EAAEG;AAAF,IAAkBH,OAAO,CAAC,kBAAD,CAA/B;;AACA,MAAM;EAAEI;AAAF,IAAeJ,OAAO,CAAC,oBAAD,CAA5B;;AACA,MAAMK,WAAW,GAAGL,OAAO,CAAC,qBAAD,CAA3B;;AACA,MAAM;EACLM,0BADK;EAELC;AAFK,IAGFP,OAAO,CAAC,qBAAD,CAHX;;AAIA,MAAMQ,UAAU,GAAGR,OAAO,CAAC,oBAAD,CAA1B;;AACA,MAAMS,qBAAqB,GAAGT,OAAO,CAAC,+BAAD,CAArC;;AACA,MAAM;EAAEU;AAAF,IAAwBV,OAAO,CAAC,oBAAD,CAArC;;AACA,MAAMW,OAAO,GAAGX,OAAO,CAAC,iBAAD,CAAvB;;AACA,MAAMY,iBAAiB,GAAGZ,OAAO,CAAC,qBAAD,CAAjC;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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"},"metadata":{},"sourceType":"script"}