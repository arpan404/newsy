{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst FileSystemInfo = require(\"../FileSystemInfo\");\n\nconst ProgressPlugin = require(\"../ProgressPlugin\");\n\nconst {\n  formatSize\n} = require(\"../SizeFormatHelpers\");\n\nconst SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\n\nconst LazySet = require(\"../util/LazySet\");\n\nconst makeSerializable = require(\"../util/makeSerializable\");\n\nconst memoize = require(\"../util/memoize\");\n\nconst {\n  createFileSerializer,\n  NOT_SERIALIZABLE\n} = require(\"../util/serialization\");\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\n\n/** @typedef {import(\"../Cache\").Etag} Etag */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\n\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n\nclass PackContainer {\n  /**\n   * @param {Object} data stored data\n   * @param {string} version version identifier\n   * @param {Snapshot} buildSnapshot snapshot of all build dependencies\n   * @param {Set<string>} buildDependencies list of all unresolved build dependencies captured\n   * @param {Map<string, string | false>} resolveResults result of the resolved build dependencies\n   * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\n   */\n  constructor(data, version, buildSnapshot, buildDependencies, resolveResults, resolveBuildDependenciesSnapshot) {\n    this.data = data;\n    this.version = version;\n    this.buildSnapshot = buildSnapshot;\n    this.buildDependencies = buildDependencies;\n    this.resolveResults = resolveResults;\n    this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n  }\n\n  serialize(_ref) {\n    let {\n      write,\n      writeLazy\n    } = _ref;\n    write(this.version);\n    write(this.buildSnapshot);\n    write(this.buildDependencies);\n    write(this.resolveResults);\n    write(this.resolveBuildDependenciesSnapshot);\n    writeLazy(this.data);\n  }\n\n  deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    this.version = read();\n    this.buildSnapshot = read();\n    this.buildDependencies = read();\n    this.resolveResults = read();\n    this.resolveBuildDependenciesSnapshot = read();\n    this.data = read();\n  }\n\n}\n\nmakeSerializable(PackContainer, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContainer\");\nconst MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\n\nconst CONTENT_COUNT_TO_MERGE = 10;\nconst MIN_ITEMS_IN_FRESH_PACK = 100;\nconst MAX_ITEMS_IN_FRESH_PACK = 50000;\nconst MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\n\nclass PackItemInfo {\n  /**\n   * @param {string} identifier identifier of item\n   * @param {string | null} etag etag of item\n   * @param {any} value fresh value of item\n   */\n  constructor(identifier, etag, value) {\n    this.identifier = identifier;\n    this.etag = etag;\n    this.location = -1;\n    this.lastAccess = Date.now();\n    this.freshValue = value;\n  }\n\n}\n\nclass Pack {\n  constructor(logger, maxAge) {\n    /** @type {Map<string, PackItemInfo>} */\n    this.itemInfo = new Map();\n    /** @type {string[]} */\n\n    this.requests = [];\n    this.requestsTimeout = undefined;\n    /** @type {Map<string, PackItemInfo>} */\n\n    this.freshContent = new Map();\n    /** @type {(undefined | PackContent)[]} */\n\n    this.content = [];\n    this.invalid = false;\n    this.logger = logger;\n    this.maxAge = maxAge;\n  }\n\n  _addRequest(identifier) {\n    this.requests.push(identifier);\n\n    if (this.requestsTimeout === undefined) {\n      this.requestsTimeout = setTimeout(() => {\n        this.requests.push(undefined);\n        this.requestsTimeout = undefined;\n      }, MAX_TIME_IN_FRESH_PACK);\n      if (this.requestsTimeout.unref) this.requestsTimeout.unref();\n    }\n  }\n\n  stopCapturingRequests() {\n    if (this.requestsTimeout !== undefined) {\n      clearTimeout(this.requestsTimeout);\n      this.requestsTimeout = undefined;\n    }\n  }\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {string | null} etag etag of the resource\n   * @returns {any} cached content\n   */\n\n\n  get(identifier, etag) {\n    const info = this.itemInfo.get(identifier);\n\n    this._addRequest(identifier);\n\n    if (info === undefined) {\n      return undefined;\n    }\n\n    if (info.etag !== etag) return null;\n    info.lastAccess = Date.now();\n    const loc = info.location;\n\n    if (loc === -1) {\n      return info.freshValue;\n    } else {\n      if (!this.content[loc]) {\n        return undefined;\n      }\n\n      return this.content[loc].get(identifier);\n    }\n  }\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {string | null} etag etag of the resource\n   * @param {any} data cached content\n   * @returns {void}\n   */\n\n\n  set(identifier, etag, data) {\n    if (!this.invalid) {\n      this.invalid = true;\n      this.logger.log(`Pack got invalid because of write to: ${identifier}`);\n    }\n\n    const info = this.itemInfo.get(identifier);\n\n    if (info === undefined) {\n      const newInfo = new PackItemInfo(identifier, etag, data);\n      this.itemInfo.set(identifier, newInfo);\n\n      this._addRequest(identifier);\n\n      this.freshContent.set(identifier, newInfo);\n    } else {\n      const loc = info.location;\n\n      if (loc >= 0) {\n        this._addRequest(identifier);\n\n        this.freshContent.set(identifier, info);\n        const content = this.content[loc];\n        content.delete(identifier);\n\n        if (content.items.size === 0) {\n          this.content[loc] = undefined;\n          this.logger.debug(\"Pack %d got empty and is removed\", loc);\n        }\n      }\n\n      info.freshValue = data;\n      info.lastAccess = Date.now();\n      info.etag = etag;\n      info.location = -1;\n    }\n  }\n\n  getContentStats() {\n    let count = 0;\n    let size = 0;\n\n    for (const content of this.content) {\n      if (content !== undefined) {\n        count++;\n        const s = content.getSize();\n\n        if (s > 0) {\n          size += s;\n        }\n      }\n    }\n\n    return {\n      count,\n      size\n    };\n  }\n  /**\n   * @returns {number} new location of data entries\n   */\n\n\n  _findLocation() {\n    let i;\n\n    for (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\n\n    return i;\n  }\n\n  _gcAndUpdateLocation(items, usedItems, newLoc) {\n    let count = 0;\n    let lastGC;\n    const now = Date.now();\n\n    for (const identifier of items) {\n      const info = this.itemInfo.get(identifier);\n\n      if (now - info.lastAccess > this.maxAge) {\n        this.itemInfo.delete(identifier);\n        items.delete(identifier);\n        usedItems.delete(identifier);\n        count++;\n        lastGC = identifier;\n      } else {\n        info.location = newLoc;\n      }\n    }\n\n    if (count > 0) {\n      this.logger.log(\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\", count, newLoc, items.size, lastGC);\n    }\n  }\n\n  _persistFreshContent() {\n    const itemsCount = this.freshContent.size;\n\n    if (itemsCount > 0) {\n      const packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\n      const itemsPerPack = Math.ceil(itemsCount / packCount);\n      const packs = [];\n      let i = 0;\n      let ignoreNextTimeTick = false;\n\n      const createNextPack = () => {\n        const loc = this._findLocation();\n\n        this.content[loc] = null; // reserve\n\n        const pack = {\n          /** @type {Set<string>} */\n          items: new Set(),\n\n          /** @type {Map<string, any>} */\n          map: new Map(),\n          loc\n        };\n        packs.push(pack);\n        return pack;\n      };\n\n      let pack = createNextPack();\n      if (this.requestsTimeout !== undefined) clearTimeout(this.requestsTimeout);\n\n      for (const identifier of this.requests) {\n        if (identifier === undefined) {\n          if (ignoreNextTimeTick) {\n            ignoreNextTimeTick = false;\n          } else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\n            i = 0;\n            pack = createNextPack();\n          }\n\n          continue;\n        }\n\n        const info = this.freshContent.get(identifier);\n        if (info === undefined) continue;\n        pack.items.add(identifier);\n        pack.map.set(identifier, info.freshValue);\n        info.location = pack.loc;\n        info.freshValue = undefined;\n        this.freshContent.delete(identifier);\n\n        if (++i > itemsPerPack) {\n          i = 0;\n          pack = createNextPack();\n          ignoreNextTimeTick = true;\n        }\n      }\n\n      this.requests.length = 0;\n\n      for (const pack of packs) {\n        this.content[pack.loc] = new PackContent(pack.items, new Set(pack.items), new PackContentItems(pack.map));\n      }\n\n      this.logger.log(`${itemsCount} fresh items in cache put into pack ${packs.length > 1 ? packs.map(pack => `${pack.loc} (${pack.items.size} items)`).join(\", \") : packs[0].loc}`);\n    }\n  }\n  /**\n   * Merges small content files to a single content file\n   */\n\n\n  _optimizeSmallContent() {\n    // 1. Find all small content files\n    // Treat unused content files separately to avoid\n    // a merge-split cycle\n\n    /** @type {number[]} */\n    const smallUsedContents = [];\n    /** @type {number} */\n\n    let smallUsedContentSize = 0;\n    /** @type {number[]} */\n\n    const smallUnusedContents = [];\n    /** @type {number} */\n\n    let smallUnusedContentSize = 0;\n\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content === undefined) continue;\n      if (content.outdated) continue;\n      const size = content.getSize();\n      if (size < 0 || size > MIN_CONTENT_SIZE) continue;\n\n      if (content.used.size > 0) {\n        smallUsedContents.push(i);\n        smallUsedContentSize += size;\n      } else {\n        smallUnusedContents.push(i);\n        smallUnusedContentSize += size;\n      }\n    } // 2. Check if minimum number is reached\n\n\n    let mergedIndices;\n\n    if (smallUsedContents.length >= CONTENT_COUNT_TO_MERGE || smallUsedContentSize > MIN_CONTENT_SIZE) {\n      mergedIndices = smallUsedContents;\n    } else if (smallUnusedContents.length >= CONTENT_COUNT_TO_MERGE || smallUnusedContentSize > MIN_CONTENT_SIZE) {\n      mergedIndices = smallUnusedContents;\n    } else return;\n\n    const mergedContent = []; // 3. Remove old content entries\n\n    for (const i of mergedIndices) {\n      mergedContent.push(this.content[i]);\n      this.content[i] = undefined;\n    } // 4. Determine merged items\n\n    /** @type {Set<string>} */\n\n\n    const mergedItems = new Set();\n    /** @type {Set<string>} */\n\n    const mergedUsedItems = new Set();\n    /** @type {(function(Map<string, any>): Promise)[]} */\n\n    const addToMergedMap = [];\n\n    for (const content of mergedContent) {\n      for (const identifier of content.items) {\n        mergedItems.add(identifier);\n      }\n\n      for (const identifier of content.used) {\n        mergedUsedItems.add(identifier);\n      }\n\n      addToMergedMap.push(async map => {\n        // unpack existing content\n        // after that values are accessible in .content\n        await content.unpack(\"it should be merged with other small pack contents\");\n\n        for (const [identifier, value] of content.content) {\n          map.set(identifier, value);\n        }\n      });\n    } // 5. GC and update location of merged items\n\n\n    const newLoc = this._findLocation();\n\n    this._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc); // 6. If not empty, store content somewhere\n\n\n    if (mergedItems.size > 0) {\n      this.content[newLoc] = new PackContent(mergedItems, mergedUsedItems, memoize(async () => {\n        /** @type {Map<string, any>} */\n        const map = new Map();\n        await Promise.all(addToMergedMap.map(fn => fn(map)));\n        return new PackContentItems(map);\n      }));\n      this.logger.log(\"Merged %d small files with %d cache items into pack %d\", mergedContent.length, mergedItems.size, newLoc);\n    }\n  }\n  /**\n   * Split large content files with used and unused items\n   * into two parts to separate used from unused items\n   */\n\n\n  _optimizeUnusedContent() {\n    // 1. Find a large content file with used and unused items\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n      if (content === undefined) continue;\n      const size = content.getSize();\n      if (size < MIN_CONTENT_SIZE) continue;\n      const used = content.used.size;\n      const total = content.items.size;\n\n      if (used > 0 && used < total) {\n        // 2. Remove this content\n        this.content[i] = undefined; // 3. Determine items for the used content file\n\n        const usedItems = new Set(content.used);\n\n        const newLoc = this._findLocation();\n\n        this._gcAndUpdateLocation(usedItems, usedItems, newLoc); // 4. Create content file for used items\n\n\n        if (usedItems.size > 0) {\n          this.content[newLoc] = new PackContent(usedItems, new Set(usedItems), async () => {\n            await content.unpack(\"it should be splitted into used and unused items\");\n            const map = new Map();\n\n            for (const identifier of usedItems) {\n              map.set(identifier, content.content.get(identifier));\n            }\n\n            return new PackContentItems(map);\n          });\n        } // 5. Determine items for the unused content file\n\n\n        const unusedItems = new Set(content.items);\n        const usedOfUnusedItems = new Set();\n\n        for (const identifier of usedItems) {\n          unusedItems.delete(identifier);\n        }\n\n        const newUnusedLoc = this._findLocation();\n\n        this._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc); // 6. Create content file for unused items\n\n\n        if (unusedItems.size > 0) {\n          this.content[newUnusedLoc] = new PackContent(unusedItems, usedOfUnusedItems, async () => {\n            await content.unpack(\"it should be splitted into used and unused items\");\n            const map = new Map();\n\n            for (const identifier of unusedItems) {\n              map.set(identifier, content.content.get(identifier));\n            }\n\n            return new PackContentItems(map);\n          });\n        }\n\n        this.logger.log(\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\", i, newLoc, usedItems.size, newUnusedLoc, unusedItems.size); // optimizing only one of them is good enough and\n        // reduces the amount of serialization needed\n\n        return;\n      }\n    }\n  }\n  /**\n   * Find the content with the oldest item and run GC on that.\n   * Only runs for one content to avoid large invalidation.\n   */\n\n\n  _gcOldestContent() {\n    /** @type {PackItemInfo} */\n    let oldest = undefined;\n\n    for (const info of this.itemInfo.values()) {\n      if (oldest === undefined || info.lastAccess < oldest.lastAccess) {\n        oldest = info;\n      }\n    }\n\n    if (Date.now() - oldest.lastAccess > this.maxAge) {\n      const loc = oldest.location;\n      if (loc < 0) return;\n      const content = this.content[loc];\n      const items = new Set(content.items);\n      const usedItems = new Set(content.used);\n\n      this._gcAndUpdateLocation(items, usedItems, loc);\n\n      this.content[loc] = items.size > 0 ? new PackContent(items, usedItems, async () => {\n        await content.unpack(\"it contains old items that should be garbage collected\");\n        const map = new Map();\n\n        for (const identifier of items) {\n          map.set(identifier, content.content.get(identifier));\n        }\n\n        return new PackContentItems(map);\n      }) : undefined;\n    }\n  }\n\n  serialize(_ref3) {\n    let {\n      write,\n      writeSeparate\n    } = _ref3;\n\n    this._persistFreshContent();\n\n    this._optimizeSmallContent();\n\n    this._optimizeUnusedContent();\n\n    this._gcOldestContent();\n\n    for (const identifier of this.itemInfo.keys()) {\n      write(identifier);\n    }\n\n    write(null); // null as marker of the end of keys\n\n    for (const info of this.itemInfo.values()) {\n      write(info.etag);\n    }\n\n    for (const info of this.itemInfo.values()) {\n      write(info.lastAccess);\n    }\n\n    for (let i = 0; i < this.content.length; i++) {\n      const content = this.content[i];\n\n      if (content !== undefined) {\n        write(content.items);\n        content.writeLazy(lazy => writeSeparate(lazy, {\n          name: `${i}`\n        }));\n      } else {\n        write(undefined); // undefined marks an empty content slot\n      }\n    }\n\n    write(null); // null as marker of the end of items\n  }\n\n  deserialize(_ref4) {\n    let {\n      read,\n      logger\n    } = _ref4;\n    this.logger = logger;\n    {\n      const items = [];\n      let item = read();\n\n      while (item !== null) {\n        items.push(item);\n        item = read();\n      }\n\n      this.itemInfo.clear();\n      const infoItems = items.map(identifier => {\n        const info = new PackItemInfo(identifier, undefined, undefined);\n        this.itemInfo.set(identifier, info);\n        return info;\n      });\n\n      for (const info of infoItems) {\n        info.etag = read();\n      }\n\n      for (const info of infoItems) {\n        info.lastAccess = read();\n      }\n    }\n    this.content.length = 0;\n    let items = read();\n\n    while (items !== null) {\n      if (items === undefined) {\n        this.content.push(items);\n      } else {\n        const idx = this.content.length;\n        const lazy = read();\n        this.content.push(new PackContent(items, new Set(), lazy, logger, `${this.content.length}`));\n\n        for (const identifier of items) {\n          this.itemInfo.get(identifier).location = idx;\n        }\n      }\n\n      items = read();\n    }\n  }\n\n}\n\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\n\nclass PackContentItems {\n  /**\n   * @param {Map<string, any>} map items\n   */\n  constructor(map) {\n    this.map = map;\n  }\n\n  serialize(_ref5) {\n    let {\n      write,\n      snapshot,\n      rollback,\n      logger,\n      profile\n    } = _ref5;\n\n    if (profile) {\n      write(false);\n\n      for (const [key, value] of this.map) {\n        const s = snapshot();\n\n        try {\n          write(key);\n          const start = process.hrtime();\n          write(value);\n          const durationHr = process.hrtime(start);\n          const duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\n          if (duration > 1) {\n            if (duration > 500) logger.error(`Serialization of '${key}': ${duration} ms`);else if (duration > 50) logger.warn(`Serialization of '${key}': ${duration} ms`);else if (duration > 10) logger.info(`Serialization of '${key}': ${duration} ms`);else if (duration > 5) logger.log(`Serialization of '${key}': ${duration} ms`);else logger.debug(`Serialization of '${key}': ${duration} ms`);\n          }\n        } catch (e) {\n          rollback(s);\n          if (e === NOT_SERIALIZABLE) continue;\n          const msg = \"Skipped not serializable cache item\";\n\n          if (e.message.includes(\"ModuleBuildError\")) {\n            logger.log(`${msg} (in build error): ${e.message}`);\n            logger.debug(`${msg} '${key}' (in build error): ${e.stack}`);\n          } else {\n            logger.warn(`${msg}: ${e.message}`);\n            logger.debug(`${msg} '${key}': ${e.stack}`);\n          }\n        }\n      }\n\n      write(null);\n      return;\n    } // Try to serialize all at once\n\n\n    const s = snapshot();\n\n    try {\n      write(true);\n      write(this.map);\n    } catch (e) {\n      rollback(s); // Try to serialize each item on it's own\n\n      write(false);\n\n      for (const [key, value] of this.map) {\n        const s = snapshot();\n\n        try {\n          write(key);\n          write(value);\n        } catch (e) {\n          rollback(s);\n          if (e === NOT_SERIALIZABLE) continue;\n          logger.warn(`Skipped not serializable cache item '${key}': ${e.message}`);\n          logger.debug(e.stack);\n        }\n      }\n\n      write(null);\n    }\n  }\n\n  deserialize(_ref6) {\n    let {\n      read,\n      logger,\n      profile\n    } = _ref6;\n\n    if (read()) {\n      this.map = read();\n    } else if (profile) {\n      const map = new Map();\n      let key = read();\n\n      while (key !== null) {\n        const start = process.hrtime();\n        const value = read();\n        const durationHr = process.hrtime(start);\n        const duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\n        if (duration > 1) {\n          if (duration > 100) logger.error(`Deserialization of '${key}': ${duration} ms`);else if (duration > 20) logger.warn(`Deserialization of '${key}': ${duration} ms`);else if (duration > 5) logger.info(`Deserialization of '${key}': ${duration} ms`);else if (duration > 2) logger.log(`Deserialization of '${key}': ${duration} ms`);else logger.debug(`Deserialization of '${key}': ${duration} ms`);\n        }\n\n        map.set(key, value);\n        key = read();\n      }\n\n      this.map = map;\n    } else {\n      const map = new Map();\n      let key = read();\n\n      while (key !== null) {\n        map.set(key, read());\n        key = read();\n      }\n\n      this.map = map;\n    }\n  }\n\n}\n\nmakeSerializable(PackContentItems, \"webpack/lib/cache/PackFileCacheStrategy\", \"PackContentItems\");\n\nclass PackContent {\n  /*\n  \tThis class can be in these states:\n  \t   |   this.lazy    | this.content | this.outdated | state\n  \tA1 |   undefined    |     Map      |     false     | fresh content\n  \tA2 |   undefined    |     Map      |     true      | (will not happen)\n  \tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\n  \tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\n  \tC1 | lazy* () => {} |     Map      |     false     | deserialized\n  \tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\n  \t\tthis.used is a subset of this.items.\n  \tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\n  \tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\n  \tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\n  \tWhen this.lazy and this.content is set, they contain the same data.\n  \tthis.get must only be called with a valid item from this.items.\n  \tIn state C this.lazy is unMemoized\n  */\n\n  /**\n   * @param {Set<string>} items keys\n   * @param {Set<string>} usedItems used keys\n   * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\n   * @param {Logger=} logger logger for logging\n   * @param {string=} lazyName name of dataOrFn for logging\n   */\n  constructor(items, usedItems, dataOrFn, logger, lazyName) {\n    this.items = items;\n    /** @type {function(): Promise<PackContentItems> | PackContentItems} */\n\n    this.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\n    /** @type {Map<string, any>} */\n\n    this.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\n    this.outdated = false;\n    this.used = usedItems;\n    this.logger = logger;\n    this.lazyName = lazyName;\n  }\n\n  get(identifier) {\n    this.used.add(identifier);\n\n    if (this.content) {\n      return this.content.get(identifier);\n    } // We are in state B\n\n\n    const {\n      lazyName\n    } = this;\n    let timeMessage;\n\n    if (lazyName) {\n      // only log once\n      this.lazyName = undefined;\n      timeMessage = `restore cache content ${lazyName} (${formatSize(this.getSize())})`;\n      this.logger.log(`starting to restore cache content ${lazyName} (${formatSize(this.getSize())}) because of request to: ${identifier}`);\n      this.logger.time(timeMessage);\n    }\n\n    const value = this.lazy();\n\n    if (\"then\" in value) {\n      return value.then(data => {\n        const map = data.map;\n\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        } // Move to state C\n\n\n        this.content = map;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n        return map.get(identifier);\n      });\n    } else {\n      const map = value.map;\n\n      if (timeMessage) {\n        this.logger.timeEnd(timeMessage);\n      } // Move to state C\n\n\n      this.content = map;\n      this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n      return map.get(identifier);\n    }\n  }\n  /**\n   * @param {string} reason explanation why unpack is necessary\n   * @returns {void | Promise} maybe a promise if lazy\n   */\n\n\n  unpack(reason) {\n    if (this.content) return; // Move from state B to C\n\n    if (this.lazy) {\n      const {\n        lazyName\n      } = this;\n      let timeMessage;\n\n      if (lazyName) {\n        // only log once\n        this.lazyName = undefined;\n        timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`;\n        this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because ${reason}`);\n        this.logger.time(timeMessage);\n      }\n\n      const value = this.lazy();\n\n      if (\"then\" in value) {\n        return value.then(data => {\n          if (timeMessage) {\n            this.logger.timeEnd(timeMessage);\n          }\n\n          this.content = data.map;\n        });\n      } else {\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n\n        this.content = value.map;\n      }\n    }\n  }\n  /**\n   * @returns {number} size of the content or -1 if not known\n   */\n\n\n  getSize() {\n    if (!this.lazy) return -1;\n    const options =\n    /** @type {any} */\n    this.lazy.options;\n    if (!options) return -1;\n    const size = options.size;\n    if (typeof size !== \"number\") return -1;\n    return size;\n  }\n\n  delete(identifier) {\n    this.items.delete(identifier);\n    this.used.delete(identifier);\n    this.outdated = true;\n  }\n  /**\n   * @template T\n   * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\n   * @returns {void}\n   */\n\n\n  writeLazy(write) {\n    if (!this.outdated && this.lazy) {\n      // State B1 or C1\n      // this.lazy is still the valid deserialized version\n      write(this.lazy);\n      return;\n    }\n\n    if (!this.outdated && this.content) {\n      // State A1\n      const map = new Map(this.content); // Move to state C1\n\n      this.lazy = SerializerMiddleware.unMemoizeLazy(write(() => new PackContentItems(map)));\n      return;\n    }\n\n    if (this.content) {\n      // State A2 or C2\n\n      /** @type {Map<string, any>} */\n      const map = new Map();\n\n      for (const item of this.items) {\n        map.set(item, this.content.get(item));\n      } // Move to state C1\n\n\n      this.outdated = false;\n      this.content = map;\n      this.lazy = SerializerMiddleware.unMemoizeLazy(write(() => new PackContentItems(map)));\n      return;\n    } // State B2\n\n\n    const {\n      lazyName\n    } = this;\n    let timeMessage;\n\n    if (lazyName) {\n      // only log once\n      this.lazyName = undefined;\n      timeMessage = `unpack cache content ${lazyName} (${formatSize(this.getSize())})`;\n      this.logger.log(`starting to unpack cache content ${lazyName} (${formatSize(this.getSize())}) because it's outdated and need to be serialized`);\n      this.logger.time(timeMessage);\n    }\n\n    const value = this.lazy();\n    this.outdated = false;\n\n    if (\"then\" in value) {\n      // Move to state B1\n      this.lazy = write(() => value.then(data => {\n        if (timeMessage) {\n          this.logger.timeEnd(timeMessage);\n        }\n\n        const oldMap = data.map;\n        /** @type {Map<string, any>} */\n\n        const map = new Map();\n\n        for (const item of this.items) {\n          map.set(item, oldMap.get(item));\n        } // Move to state C1 (or maybe C2)\n\n\n        this.content = map;\n        this.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n        return new PackContentItems(map);\n      }));\n    } else {\n      // Move to state C1\n      if (timeMessage) {\n        this.logger.timeEnd(timeMessage);\n      }\n\n      const oldMap = value.map;\n      /** @type {Map<string, any>} */\n\n      const map = new Map();\n\n      for (const item of this.items) {\n        map.set(item, oldMap.get(item));\n      }\n\n      this.content = map;\n      this.lazy = write(() => new PackContentItems(map));\n    }\n  }\n\n}\n\nconst allowCollectingMemory = buf => {\n  const wasted = buf.buffer.byteLength - buf.byteLength;\n\n  if (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\n    return Buffer.from(buf);\n  }\n\n  return buf;\n};\n\nclass PackFileCacheStrategy {\n  /**\n   * @param {Object} options options\n   * @param {Compiler} options.compiler the compiler\n   * @param {IntermediateFileSystem} options.fs the filesystem\n   * @param {string} options.context the context directory\n   * @param {string} options.cacheLocation the location of the cache data\n   * @param {string} options.version version identifier\n   * @param {Logger} options.logger a logger\n   * @param {SnapshotOptions} options.snapshot options regarding snapshotting\n   * @param {number} options.maxAge max age of cache items\n   * @param {boolean} options.profile track and log detailed timing information for individual cache items\n   * @param {boolean} options.allowCollectingMemory allow to collect unused memory created during deserialization\n   * @param {false | \"gzip\" | \"brotli\"} options.compression compression used\n   */\n  constructor(_ref7) {\n    let {\n      compiler,\n      fs,\n      context,\n      cacheLocation,\n      version,\n      logger,\n      snapshot,\n      maxAge,\n      profile,\n      allowCollectingMemory,\n      compression\n    } = _ref7;\n    this.fileSerializer = createFileSerializer(fs, compiler.options.output.hashFunction);\n    this.fileSystemInfo = new FileSystemInfo(fs, {\n      managedPaths: snapshot.managedPaths,\n      immutablePaths: snapshot.immutablePaths,\n      logger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\n      hashFunction: compiler.options.output.hashFunction\n    });\n    this.compiler = compiler;\n    this.context = context;\n    this.cacheLocation = cacheLocation;\n    this.version = version;\n    this.logger = logger;\n    this.maxAge = maxAge;\n    this.profile = profile;\n    this.allowCollectingMemory = allowCollectingMemory;\n    this.compression = compression;\n    this._extension = compression === \"brotli\" ? \".pack.br\" : compression === \"gzip\" ? \".pack.gz\" : \".pack\";\n    this.snapshot = snapshot;\n    /** @type {Set<string>} */\n\n    this.buildDependencies = new Set();\n    /** @type {LazySet<string>} */\n\n    this.newBuildDependencies = new LazySet();\n    /** @type {Snapshot} */\n\n    this.resolveBuildDependenciesSnapshot = undefined;\n    /** @type {Map<string, string | false>} */\n\n    this.resolveResults = undefined;\n    /** @type {Snapshot} */\n\n    this.buildSnapshot = undefined;\n    /** @type {Promise<Pack>} */\n\n    this.packPromise = this._openPack();\n    this.storePromise = Promise.resolve();\n  }\n\n  _getPack() {\n    if (this.packPromise === undefined) {\n      this.packPromise = this.storePromise.then(() => this._openPack());\n    }\n\n    return this.packPromise;\n  }\n  /**\n   * @returns {Promise<Pack>} the pack\n   */\n\n\n  _openPack() {\n    const {\n      logger,\n      profile,\n      cacheLocation,\n      version\n    } = this;\n    /** @type {Snapshot} */\n\n    let buildSnapshot;\n    /** @type {Set<string>} */\n\n    let buildDependencies;\n    /** @type {Set<string>} */\n\n    let newBuildDependencies;\n    /** @type {Snapshot} */\n\n    let resolveBuildDependenciesSnapshot;\n    /** @type {Map<string, string | false>} */\n\n    let resolveResults;\n    logger.time(\"restore cache container\");\n    return this.fileSerializer.deserialize(null, {\n      filename: `${cacheLocation}/index${this._extension}`,\n      extension: `${this._extension}`,\n      logger,\n      profile,\n      retainedBuffer: this.allowCollectingMemory ? allowCollectingMemory : undefined\n    }).catch(err => {\n      if (err.code !== \"ENOENT\") {\n        logger.warn(`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`);\n        logger.debug(err.stack);\n      } else {\n        logger.debug(`No pack exists at ${cacheLocation}${this._extension}: ${err}`);\n      }\n\n      return undefined;\n    }).then(packContainer => {\n      logger.timeEnd(\"restore cache container\");\n      if (!packContainer) return undefined;\n\n      if (!(packContainer instanceof PackContainer)) {\n        logger.warn(`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`, packContainer);\n        return undefined;\n      }\n\n      if (packContainer.version !== version) {\n        logger.log(`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`);\n        return undefined;\n      }\n\n      logger.time(\"check build dependencies\");\n      return Promise.all([new Promise((resolve, reject) => {\n        this.fileSystemInfo.checkSnapshotValid(packContainer.buildSnapshot, (err, valid) => {\n          if (err) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`);\n            logger.debug(err.stack);\n            return resolve(false);\n          }\n\n          if (!valid) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`);\n            return resolve(false);\n          }\n\n          buildSnapshot = packContainer.buildSnapshot;\n          return resolve(true);\n        });\n      }), new Promise((resolve, reject) => {\n        this.fileSystemInfo.checkSnapshotValid(packContainer.resolveBuildDependenciesSnapshot, (err, valid) => {\n          if (err) {\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`);\n            logger.debug(err.stack);\n            return resolve(false);\n          }\n\n          if (valid) {\n            resolveBuildDependenciesSnapshot = packContainer.resolveBuildDependenciesSnapshot;\n            buildDependencies = packContainer.buildDependencies;\n            resolveResults = packContainer.resolveResults;\n            return resolve(true);\n          }\n\n          logger.log(\"resolving of build dependencies is invalid, will re-resolve build dependencies\");\n          this.fileSystemInfo.checkResolveResultsValid(packContainer.resolveResults, (err, valid) => {\n            if (err) {\n              logger.log(`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`);\n              logger.debug(err.stack);\n              return resolve(false);\n            }\n\n            if (valid) {\n              newBuildDependencies = packContainer.buildDependencies;\n              resolveResults = packContainer.resolveResults;\n              return resolve(true);\n            }\n\n            logger.log(`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`);\n            return resolve(false);\n          });\n        });\n      })]).catch(err => {\n        logger.timeEnd(\"check build dependencies\");\n        throw err;\n      }).then(_ref8 => {\n        let [buildSnapshotValid, resolveValid] = _ref8;\n        logger.timeEnd(\"check build dependencies\");\n\n        if (buildSnapshotValid && resolveValid) {\n          logger.time(\"restore cache content metadata\");\n          const d = packContainer.data();\n          logger.timeEnd(\"restore cache content metadata\");\n          return d;\n        }\n\n        return undefined;\n      });\n    }).then(pack => {\n      if (pack) {\n        pack.maxAge = this.maxAge;\n        this.buildSnapshot = buildSnapshot;\n        if (buildDependencies) this.buildDependencies = buildDependencies;\n        if (newBuildDependencies) this.newBuildDependencies.addAll(newBuildDependencies);\n        this.resolveResults = resolveResults;\n        this.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n        return pack;\n      }\n\n      return new Pack(logger, this.maxAge);\n    }).catch(err => {\n      this.logger.warn(`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`);\n      this.logger.debug(err.stack);\n      return new Pack(logger, this.maxAge);\n    });\n  }\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {Etag | null} etag etag of the resource\n   * @param {any} data cached content\n   * @returns {Promise<void>} promise\n   */\n\n\n  store(identifier, etag, data) {\n    return this._getPack().then(pack => {\n      pack.set(identifier, etag === null ? null : etag.toString(), data);\n    });\n  }\n  /**\n   * @param {string} identifier unique name for the resource\n   * @param {Etag | null} etag etag of the resource\n   * @returns {Promise<any>} promise to the cached content\n   */\n\n\n  restore(identifier, etag) {\n    return this._getPack().then(pack => pack.get(identifier, etag === null ? null : etag.toString())).catch(err => {\n      if (err && err.code !== \"ENOENT\") {\n        this.logger.warn(`Restoring failed for ${identifier} from pack: ${err}`);\n        this.logger.debug(err.stack);\n      }\n    });\n  }\n\n  storeBuildDependencies(dependencies) {\n    this.newBuildDependencies.addAll(dependencies);\n  }\n\n  afterAllStored() {\n    const packPromise = this.packPromise;\n    if (packPromise === undefined) return Promise.resolve();\n    const reportProgress = ProgressPlugin.getReporter(this.compiler);\n    return this.storePromise = packPromise.then(pack => {\n      pack.stopCapturingRequests();\n      if (!pack.invalid) return;\n      this.packPromise = undefined;\n      this.logger.log(`Storing pack...`);\n      let promise;\n      const newBuildDependencies = new Set();\n\n      for (const dep of this.newBuildDependencies) {\n        if (!this.buildDependencies.has(dep)) {\n          newBuildDependencies.add(dep);\n        }\n      }\n\n      if (newBuildDependencies.size > 0 || !this.buildSnapshot) {\n        if (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\n        this.logger.debug(`Capturing build dependencies... (${Array.from(newBuildDependencies).join(\", \")})`);\n        promise = new Promise((resolve, reject) => {\n          this.logger.time(\"resolve build dependencies\");\n          this.fileSystemInfo.resolveBuildDependencies(this.context, newBuildDependencies, (err, result) => {\n            this.logger.timeEnd(\"resolve build dependencies\");\n            if (err) return reject(err);\n            this.logger.time(\"snapshot build dependencies\");\n            const {\n              files,\n              directories,\n              missing,\n              resolveResults,\n              resolveDependencies\n            } = result;\n\n            if (this.resolveResults) {\n              for (const [key, value] of resolveResults) {\n                this.resolveResults.set(key, value);\n              }\n            } else {\n              this.resolveResults = resolveResults;\n            }\n\n            if (reportProgress) {\n              reportProgress(0.6, \"snapshot build dependencies\", \"resolving\");\n            }\n\n            this.fileSystemInfo.createSnapshot(undefined, resolveDependencies.files, resolveDependencies.directories, resolveDependencies.missing, this.snapshot.resolveBuildDependencies, (err, snapshot) => {\n              if (err) {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                return reject(err);\n              }\n\n              if (!snapshot) {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                return reject(new Error(\"Unable to snapshot resolve dependencies\"));\n              }\n\n              if (this.resolveBuildDependenciesSnapshot) {\n                this.resolveBuildDependenciesSnapshot = this.fileSystemInfo.mergeSnapshots(this.resolveBuildDependenciesSnapshot, snapshot);\n              } else {\n                this.resolveBuildDependenciesSnapshot = snapshot;\n              }\n\n              if (reportProgress) {\n                reportProgress(0.7, \"snapshot build dependencies\", \"modules\");\n              }\n\n              this.fileSystemInfo.createSnapshot(undefined, files, directories, missing, this.snapshot.buildDependencies, (err, snapshot) => {\n                this.logger.timeEnd(\"snapshot build dependencies\");\n                if (err) return reject(err);\n\n                if (!snapshot) {\n                  return reject(new Error(\"Unable to snapshot build dependencies\"));\n                }\n\n                this.logger.debug(\"Captured build dependencies\");\n\n                if (this.buildSnapshot) {\n                  this.buildSnapshot = this.fileSystemInfo.mergeSnapshots(this.buildSnapshot, snapshot);\n                } else {\n                  this.buildSnapshot = snapshot;\n                }\n\n                resolve();\n              });\n            });\n          });\n        });\n      } else {\n        promise = Promise.resolve();\n      }\n\n      return promise.then(() => {\n        if (reportProgress) reportProgress(0.8, \"serialize pack\");\n        this.logger.time(`store pack`);\n        const updatedBuildDependencies = new Set(this.buildDependencies);\n\n        for (const dep of newBuildDependencies) {\n          updatedBuildDependencies.add(dep);\n        }\n\n        const content = new PackContainer(pack, this.version, this.buildSnapshot, updatedBuildDependencies, this.resolveResults, this.resolveBuildDependenciesSnapshot);\n        return this.fileSerializer.serialize(content, {\n          filename: `${this.cacheLocation}/index${this._extension}`,\n          extension: `${this._extension}`,\n          logger: this.logger,\n          profile: this.profile\n        }).then(() => {\n          for (const dep of newBuildDependencies) {\n            this.buildDependencies.add(dep);\n          }\n\n          this.newBuildDependencies.clear();\n          this.logger.timeEnd(`store pack`);\n          const stats = pack.getContentStats();\n          this.logger.log(\"Stored pack (%d items, %d files, %d MiB)\", pack.itemInfo.size, stats.count, Math.round(stats.size / 1024 / 1024));\n        }).catch(err => {\n          this.logger.timeEnd(`store pack`);\n          this.logger.warn(`Caching failed for pack: ${err}`);\n          this.logger.debug(err.stack);\n        });\n      });\n    }).catch(err => {\n      this.logger.warn(`Caching failed for pack: ${err}`);\n      this.logger.debug(err.stack);\n    });\n  }\n\n  clear() {\n    this.fileSystemInfo.clear();\n    this.buildDependencies.clear();\n    this.newBuildDependencies.clear();\n    this.resolveBuildDependenciesSnapshot = undefined;\n    this.resolveResults = undefined;\n    this.buildSnapshot = undefined;\n    this.packPromise = undefined;\n  }\n\n}\n\nmodule.exports = PackFileCacheStrategy;","map":{"version":3,"names":["FileSystemInfo","require","ProgressPlugin","formatSize","SerializerMiddleware","LazySet","makeSerializable","memoize","createFileSerializer","NOT_SERIALIZABLE","PackContainer","constructor","data","version","buildSnapshot","buildDependencies","resolveResults","resolveBuildDependenciesSnapshot","serialize","write","writeLazy","deserialize","read","MIN_CONTENT_SIZE","CONTENT_COUNT_TO_MERGE","MIN_ITEMS_IN_FRESH_PACK","MAX_ITEMS_IN_FRESH_PACK","MAX_TIME_IN_FRESH_PACK","PackItemInfo","identifier","etag","value","location","lastAccess","Date","now","freshValue","Pack","logger","maxAge","itemInfo","Map","requests","requestsTimeout","undefined","freshContent","content","invalid","_addRequest","push","setTimeout","unref","stopCapturingRequests","clearTimeout","get","info","loc","set","log","newInfo","delete","items","size","debug","getContentStats","count","s","getSize","_findLocation","i","length","_gcAndUpdateLocation","usedItems","newLoc","lastGC","_persistFreshContent","itemsCount","packCount","Math","ceil","itemsPerPack","packs","ignoreNextTimeTick","createNextPack","pack","Set","map","add","PackContent","PackContentItems","join","_optimizeSmallContent","smallUsedContents","smallUsedContentSize","smallUnusedContents","smallUnusedContentSize","outdated","used","mergedIndices","mergedContent","mergedItems","mergedUsedItems","addToMergedMap","unpack","Promise","all","fn","_optimizeUnusedContent","total","unusedItems","usedOfUnusedItems","newUnusedLoc","_gcOldestContent","oldest","values","writeSeparate","keys","lazy","name","item","clear","infoItems","idx","snapshot","rollback","profile","key","start","process","hrtime","durationHr","duration","error","warn","e","msg","message","includes","stack","dataOrFn","lazyName","timeMessage","time","then","timeEnd","unMemoizeLazy","reason","options","oldMap","allowCollectingMemory","buf","wasted","buffer","byteLength","Buffer","from","PackFileCacheStrategy","compiler","fs","context","cacheLocation","compression","fileSerializer","output","hashFunction","fileSystemInfo","managedPaths","immutablePaths","getChildLogger","_extension","newBuildDependencies","packPromise","_openPack","storePromise","resolve","_getPack","filename","extension","retainedBuffer","catch","err","code","packContainer","reject","checkSnapshotValid","valid","checkResolveResultsValid","buildSnapshotValid","resolveValid","d","addAll","store","toString","restore","storeBuildDependencies","dependencies","afterAllStored","reportProgress","getReporter","promise","dep","has","Array","resolveBuildDependencies","result","files","directories","missing","resolveDependencies","createSnapshot","Error","mergeSnapshots","updatedBuildDependencies","stats","round","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/cache/PackFileCacheStrategy.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst FileSystemInfo = require(\"../FileSystemInfo\");\nconst ProgressPlugin = require(\"../ProgressPlugin\");\nconst { formatSize } = require(\"../SizeFormatHelpers\");\nconst SerializerMiddleware = require(\"../serialization/SerializerMiddleware\");\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\nconst memoize = require(\"../util/memoize\");\nconst {\n\tcreateFileSerializer,\n\tNOT_SERIALIZABLE\n} = require(\"../util/serialization\");\n\n/** @typedef {import(\"../../declarations/WebpackOptions\").SnapshotOptions} SnapshotOptions */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n/** @typedef {import(\"../logging/Logger\").Logger} Logger */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nclass PackContainer {\n\t/**\n\t * @param {Object} data stored data\n\t * @param {string} version version identifier\n\t * @param {Snapshot} buildSnapshot snapshot of all build dependencies\n\t * @param {Set<string>} buildDependencies list of all unresolved build dependencies captured\n\t * @param {Map<string, string | false>} resolveResults result of the resolved build dependencies\n\t * @param {Snapshot} resolveBuildDependenciesSnapshot snapshot of the dependencies of the build dependencies resolving\n\t */\n\tconstructor(\n\t\tdata,\n\t\tversion,\n\t\tbuildSnapshot,\n\t\tbuildDependencies,\n\t\tresolveResults,\n\t\tresolveBuildDependenciesSnapshot\n\t) {\n\t\tthis.data = data;\n\t\tthis.version = version;\n\t\tthis.buildSnapshot = buildSnapshot;\n\t\tthis.buildDependencies = buildDependencies;\n\t\tthis.resolveResults = resolveResults;\n\t\tthis.resolveBuildDependenciesSnapshot = resolveBuildDependenciesSnapshot;\n\t}\n\n\tserialize({ write, writeLazy }) {\n\t\twrite(this.version);\n\t\twrite(this.buildSnapshot);\n\t\twrite(this.buildDependencies);\n\t\twrite(this.resolveResults);\n\t\twrite(this.resolveBuildDependenciesSnapshot);\n\t\twriteLazy(this.data);\n\t}\n\n\tdeserialize({ read }) {\n\t\tthis.version = read();\n\t\tthis.buildSnapshot = read();\n\t\tthis.buildDependencies = read();\n\t\tthis.resolveResults = read();\n\t\tthis.resolveBuildDependenciesSnapshot = read();\n\t\tthis.data = read();\n\t}\n}\n\nmakeSerializable(\n\tPackContainer,\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\n\t\"PackContainer\"\n);\n\nconst MIN_CONTENT_SIZE = 1024 * 1024; // 1 MB\nconst CONTENT_COUNT_TO_MERGE = 10;\nconst MIN_ITEMS_IN_FRESH_PACK = 100;\nconst MAX_ITEMS_IN_FRESH_PACK = 50000;\nconst MAX_TIME_IN_FRESH_PACK = 1 * 60 * 1000; // 1 min\n\nclass PackItemInfo {\n\t/**\n\t * @param {string} identifier identifier of item\n\t * @param {string | null} etag etag of item\n\t * @param {any} value fresh value of item\n\t */\n\tconstructor(identifier, etag, value) {\n\t\tthis.identifier = identifier;\n\t\tthis.etag = etag;\n\t\tthis.location = -1;\n\t\tthis.lastAccess = Date.now();\n\t\tthis.freshValue = value;\n\t}\n}\n\nclass Pack {\n\tconstructor(logger, maxAge) {\n\t\t/** @type {Map<string, PackItemInfo>} */\n\t\tthis.itemInfo = new Map();\n\t\t/** @type {string[]} */\n\t\tthis.requests = [];\n\t\tthis.requestsTimeout = undefined;\n\t\t/** @type {Map<string, PackItemInfo>} */\n\t\tthis.freshContent = new Map();\n\t\t/** @type {(undefined | PackContent)[]} */\n\t\tthis.content = [];\n\t\tthis.invalid = false;\n\t\tthis.logger = logger;\n\t\tthis.maxAge = maxAge;\n\t}\n\n\t_addRequest(identifier) {\n\t\tthis.requests.push(identifier);\n\t\tif (this.requestsTimeout === undefined) {\n\t\t\tthis.requestsTimeout = setTimeout(() => {\n\t\t\t\tthis.requests.push(undefined);\n\t\t\t\tthis.requestsTimeout = undefined;\n\t\t\t}, MAX_TIME_IN_FRESH_PACK);\n\t\t\tif (this.requestsTimeout.unref) this.requestsTimeout.unref();\n\t\t}\n\t}\n\n\tstopCapturingRequests() {\n\t\tif (this.requestsTimeout !== undefined) {\n\t\t\tclearTimeout(this.requestsTimeout);\n\t\t\tthis.requestsTimeout = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {string | null} etag etag of the resource\n\t * @returns {any} cached content\n\t */\n\tget(identifier, etag) {\n\t\tconst info = this.itemInfo.get(identifier);\n\t\tthis._addRequest(identifier);\n\t\tif (info === undefined) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (info.etag !== etag) return null;\n\t\tinfo.lastAccess = Date.now();\n\t\tconst loc = info.location;\n\t\tif (loc === -1) {\n\t\t\treturn info.freshValue;\n\t\t} else {\n\t\t\tif (!this.content[loc]) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\treturn this.content[loc].get(identifier);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {string | null} etag etag of the resource\n\t * @param {any} data cached content\n\t * @returns {void}\n\t */\n\tset(identifier, etag, data) {\n\t\tif (!this.invalid) {\n\t\t\tthis.invalid = true;\n\t\t\tthis.logger.log(`Pack got invalid because of write to: ${identifier}`);\n\t\t}\n\t\tconst info = this.itemInfo.get(identifier);\n\t\tif (info === undefined) {\n\t\t\tconst newInfo = new PackItemInfo(identifier, etag, data);\n\t\t\tthis.itemInfo.set(identifier, newInfo);\n\t\t\tthis._addRequest(identifier);\n\t\t\tthis.freshContent.set(identifier, newInfo);\n\t\t} else {\n\t\t\tconst loc = info.location;\n\t\t\tif (loc >= 0) {\n\t\t\t\tthis._addRequest(identifier);\n\t\t\t\tthis.freshContent.set(identifier, info);\n\t\t\t\tconst content = this.content[loc];\n\t\t\t\tcontent.delete(identifier);\n\t\t\t\tif (content.items.size === 0) {\n\t\t\t\t\tthis.content[loc] = undefined;\n\t\t\t\t\tthis.logger.debug(\"Pack %d got empty and is removed\", loc);\n\t\t\t\t}\n\t\t\t}\n\t\t\tinfo.freshValue = data;\n\t\t\tinfo.lastAccess = Date.now();\n\t\t\tinfo.etag = etag;\n\t\t\tinfo.location = -1;\n\t\t}\n\t}\n\n\tgetContentStats() {\n\t\tlet count = 0;\n\t\tlet size = 0;\n\t\tfor (const content of this.content) {\n\t\t\tif (content !== undefined) {\n\t\t\t\tcount++;\n\t\t\t\tconst s = content.getSize();\n\t\t\t\tif (s > 0) {\n\t\t\t\t\tsize += s;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { count, size };\n\t}\n\n\t/**\n\t * @returns {number} new location of data entries\n\t */\n\t_findLocation() {\n\t\tlet i;\n\t\tfor (i = 0; i < this.content.length && this.content[i] !== undefined; i++);\n\t\treturn i;\n\t}\n\n\t_gcAndUpdateLocation(items, usedItems, newLoc) {\n\t\tlet count = 0;\n\t\tlet lastGC;\n\t\tconst now = Date.now();\n\t\tfor (const identifier of items) {\n\t\t\tconst info = this.itemInfo.get(identifier);\n\t\t\tif (now - info.lastAccess > this.maxAge) {\n\t\t\t\tthis.itemInfo.delete(identifier);\n\t\t\t\titems.delete(identifier);\n\t\t\t\tusedItems.delete(identifier);\n\t\t\t\tcount++;\n\t\t\t\tlastGC = identifier;\n\t\t\t} else {\n\t\t\t\tinfo.location = newLoc;\n\t\t\t}\n\t\t}\n\t\tif (count > 0) {\n\t\t\tthis.logger.log(\n\t\t\t\t\"Garbage Collected %d old items at pack %d (%d items remaining) e. g. %s\",\n\t\t\t\tcount,\n\t\t\t\tnewLoc,\n\t\t\t\titems.size,\n\t\t\t\tlastGC\n\t\t\t);\n\t\t}\n\t}\n\n\t_persistFreshContent() {\n\t\tconst itemsCount = this.freshContent.size;\n\t\tif (itemsCount > 0) {\n\t\t\tconst packCount = Math.ceil(itemsCount / MAX_ITEMS_IN_FRESH_PACK);\n\t\t\tconst itemsPerPack = Math.ceil(itemsCount / packCount);\n\t\t\tconst packs = [];\n\t\t\tlet i = 0;\n\t\t\tlet ignoreNextTimeTick = false;\n\t\t\tconst createNextPack = () => {\n\t\t\t\tconst loc = this._findLocation();\n\t\t\t\tthis.content[loc] = null; // reserve\n\t\t\t\tconst pack = {\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\titems: new Set(),\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tmap: new Map(),\n\t\t\t\t\tloc\n\t\t\t\t};\n\t\t\t\tpacks.push(pack);\n\t\t\t\treturn pack;\n\t\t\t};\n\t\t\tlet pack = createNextPack();\n\t\t\tif (this.requestsTimeout !== undefined)\n\t\t\t\tclearTimeout(this.requestsTimeout);\n\t\t\tfor (const identifier of this.requests) {\n\t\t\t\tif (identifier === undefined) {\n\t\t\t\t\tif (ignoreNextTimeTick) {\n\t\t\t\t\t\tignoreNextTimeTick = false;\n\t\t\t\t\t} else if (pack.items.size >= MIN_ITEMS_IN_FRESH_PACK) {\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\tpack = createNextPack();\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst info = this.freshContent.get(identifier);\n\t\t\t\tif (info === undefined) continue;\n\t\t\t\tpack.items.add(identifier);\n\t\t\t\tpack.map.set(identifier, info.freshValue);\n\t\t\t\tinfo.location = pack.loc;\n\t\t\t\tinfo.freshValue = undefined;\n\t\t\t\tthis.freshContent.delete(identifier);\n\t\t\t\tif (++i > itemsPerPack) {\n\t\t\t\t\ti = 0;\n\t\t\t\t\tpack = createNextPack();\n\t\t\t\t\tignoreNextTimeTick = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.requests.length = 0;\n\t\t\tfor (const pack of packs) {\n\t\t\t\tthis.content[pack.loc] = new PackContent(\n\t\t\t\t\tpack.items,\n\t\t\t\t\tnew Set(pack.items),\n\t\t\t\t\tnew PackContentItems(pack.map)\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.logger.log(\n\t\t\t\t`${itemsCount} fresh items in cache put into pack ${\n\t\t\t\t\tpacks.length > 1\n\t\t\t\t\t\t? packs\n\t\t\t\t\t\t\t\t.map(pack => `${pack.loc} (${pack.items.size} items)`)\n\t\t\t\t\t\t\t\t.join(\", \")\n\t\t\t\t\t\t: packs[0].loc\n\t\t\t\t}`\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Merges small content files to a single content file\n\t */\n\t_optimizeSmallContent() {\n\t\t// 1. Find all small content files\n\t\t// Treat unused content files separately to avoid\n\t\t// a merge-split cycle\n\t\t/** @type {number[]} */\n\t\tconst smallUsedContents = [];\n\t\t/** @type {number} */\n\t\tlet smallUsedContentSize = 0;\n\t\t/** @type {number[]} */\n\t\tconst smallUnusedContents = [];\n\t\t/** @type {number} */\n\t\tlet smallUnusedContentSize = 0;\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content === undefined) continue;\n\t\t\tif (content.outdated) continue;\n\t\t\tconst size = content.getSize();\n\t\t\tif (size < 0 || size > MIN_CONTENT_SIZE) continue;\n\t\t\tif (content.used.size > 0) {\n\t\t\t\tsmallUsedContents.push(i);\n\t\t\t\tsmallUsedContentSize += size;\n\t\t\t} else {\n\t\t\t\tsmallUnusedContents.push(i);\n\t\t\t\tsmallUnusedContentSize += size;\n\t\t\t}\n\t\t}\n\n\t\t// 2. Check if minimum number is reached\n\t\tlet mergedIndices;\n\t\tif (\n\t\t\tsmallUsedContents.length >= CONTENT_COUNT_TO_MERGE ||\n\t\t\tsmallUsedContentSize > MIN_CONTENT_SIZE\n\t\t) {\n\t\t\tmergedIndices = smallUsedContents;\n\t\t} else if (\n\t\t\tsmallUnusedContents.length >= CONTENT_COUNT_TO_MERGE ||\n\t\t\tsmallUnusedContentSize > MIN_CONTENT_SIZE\n\t\t) {\n\t\t\tmergedIndices = smallUnusedContents;\n\t\t} else return;\n\n\t\tconst mergedContent = [];\n\n\t\t// 3. Remove old content entries\n\t\tfor (const i of mergedIndices) {\n\t\t\tmergedContent.push(this.content[i]);\n\t\t\tthis.content[i] = undefined;\n\t\t}\n\n\t\t// 4. Determine merged items\n\t\t/** @type {Set<string>} */\n\t\tconst mergedItems = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst mergedUsedItems = new Set();\n\t\t/** @type {(function(Map<string, any>): Promise)[]} */\n\t\tconst addToMergedMap = [];\n\t\tfor (const content of mergedContent) {\n\t\t\tfor (const identifier of content.items) {\n\t\t\t\tmergedItems.add(identifier);\n\t\t\t}\n\t\t\tfor (const identifier of content.used) {\n\t\t\t\tmergedUsedItems.add(identifier);\n\t\t\t}\n\t\t\taddToMergedMap.push(async map => {\n\t\t\t\t// unpack existing content\n\t\t\t\t// after that values are accessible in .content\n\t\t\t\tawait content.unpack(\n\t\t\t\t\t\"it should be merged with other small pack contents\"\n\t\t\t\t);\n\t\t\t\tfor (const [identifier, value] of content.content) {\n\t\t\t\t\tmap.set(identifier, value);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// 5. GC and update location of merged items\n\t\tconst newLoc = this._findLocation();\n\t\tthis._gcAndUpdateLocation(mergedItems, mergedUsedItems, newLoc);\n\n\t\t// 6. If not empty, store content somewhere\n\t\tif (mergedItems.size > 0) {\n\t\t\tthis.content[newLoc] = new PackContent(\n\t\t\t\tmergedItems,\n\t\t\t\tmergedUsedItems,\n\t\t\t\tmemoize(async () => {\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\tawait Promise.all(addToMergedMap.map(fn => fn(map)));\n\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t})\n\t\t\t);\n\t\t\tthis.logger.log(\n\t\t\t\t\"Merged %d small files with %d cache items into pack %d\",\n\t\t\t\tmergedContent.length,\n\t\t\t\tmergedItems.size,\n\t\t\t\tnewLoc\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Split large content files with used and unused items\n\t * into two parts to separate used from unused items\n\t */\n\t_optimizeUnusedContent() {\n\t\t// 1. Find a large content file with used and unused items\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content === undefined) continue;\n\t\t\tconst size = content.getSize();\n\t\t\tif (size < MIN_CONTENT_SIZE) continue;\n\t\t\tconst used = content.used.size;\n\t\t\tconst total = content.items.size;\n\t\t\tif (used > 0 && used < total) {\n\t\t\t\t// 2. Remove this content\n\t\t\t\tthis.content[i] = undefined;\n\n\t\t\t\t// 3. Determine items for the used content file\n\t\t\t\tconst usedItems = new Set(content.used);\n\t\t\t\tconst newLoc = this._findLocation();\n\t\t\t\tthis._gcAndUpdateLocation(usedItems, usedItems, newLoc);\n\n\t\t\t\t// 4. Create content file for used items\n\t\t\t\tif (usedItems.size > 0) {\n\t\t\t\t\tthis.content[newLoc] = new PackContent(\n\t\t\t\t\t\tusedItems,\n\t\t\t\t\t\tnew Set(usedItems),\n\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of usedItems) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// 5. Determine items for the unused content file\n\t\t\t\tconst unusedItems = new Set(content.items);\n\t\t\t\tconst usedOfUnusedItems = new Set();\n\t\t\t\tfor (const identifier of usedItems) {\n\t\t\t\t\tunusedItems.delete(identifier);\n\t\t\t\t}\n\t\t\t\tconst newUnusedLoc = this._findLocation();\n\t\t\t\tthis._gcAndUpdateLocation(unusedItems, usedOfUnusedItems, newUnusedLoc);\n\n\t\t\t\t// 6. Create content file for unused items\n\t\t\t\tif (unusedItems.size > 0) {\n\t\t\t\t\tthis.content[newUnusedLoc] = new PackContent(\n\t\t\t\t\t\tunusedItems,\n\t\t\t\t\t\tusedOfUnusedItems,\n\t\t\t\t\t\tasync () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it should be splitted into used and unused items\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of unusedItems) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tthis.logger.log(\n\t\t\t\t\t\"Split pack %d into pack %d with %d used items and pack %d with %d unused items\",\n\t\t\t\t\ti,\n\t\t\t\t\tnewLoc,\n\t\t\t\t\tusedItems.size,\n\t\t\t\t\tnewUnusedLoc,\n\t\t\t\t\tunusedItems.size\n\t\t\t\t);\n\n\t\t\t\t// optimizing only one of them is good enough and\n\t\t\t\t// reduces the amount of serialization needed\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Find the content with the oldest item and run GC on that.\n\t * Only runs for one content to avoid large invalidation.\n\t */\n\t_gcOldestContent() {\n\t\t/** @type {PackItemInfo} */\n\t\tlet oldest = undefined;\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\tif (oldest === undefined || info.lastAccess < oldest.lastAccess) {\n\t\t\t\toldest = info;\n\t\t\t}\n\t\t}\n\t\tif (Date.now() - oldest.lastAccess > this.maxAge) {\n\t\t\tconst loc = oldest.location;\n\t\t\tif (loc < 0) return;\n\t\t\tconst content = this.content[loc];\n\t\t\tconst items = new Set(content.items);\n\t\t\tconst usedItems = new Set(content.used);\n\t\t\tthis._gcAndUpdateLocation(items, usedItems, loc);\n\n\t\t\tthis.content[loc] =\n\t\t\t\titems.size > 0\n\t\t\t\t\t? new PackContent(items, usedItems, async () => {\n\t\t\t\t\t\t\tawait content.unpack(\n\t\t\t\t\t\t\t\t\"it contains old items that should be garbage collected\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst map = new Map();\n\t\t\t\t\t\t\tfor (const identifier of items) {\n\t\t\t\t\t\t\t\tmap.set(identifier, content.content.get(identifier));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t\t  })\n\t\t\t\t\t: undefined;\n\t\t}\n\t}\n\n\tserialize({ write, writeSeparate }) {\n\t\tthis._persistFreshContent();\n\t\tthis._optimizeSmallContent();\n\t\tthis._optimizeUnusedContent();\n\t\tthis._gcOldestContent();\n\t\tfor (const identifier of this.itemInfo.keys()) {\n\t\t\twrite(identifier);\n\t\t}\n\t\twrite(null); // null as marker of the end of keys\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\twrite(info.etag);\n\t\t}\n\t\tfor (const info of this.itemInfo.values()) {\n\t\t\twrite(info.lastAccess);\n\t\t}\n\t\tfor (let i = 0; i < this.content.length; i++) {\n\t\t\tconst content = this.content[i];\n\t\t\tif (content !== undefined) {\n\t\t\t\twrite(content.items);\n\t\t\t\tcontent.writeLazy(lazy => writeSeparate(lazy, { name: `${i}` }));\n\t\t\t} else {\n\t\t\t\twrite(undefined); // undefined marks an empty content slot\n\t\t\t}\n\t\t}\n\t\twrite(null); // null as marker of the end of items\n\t}\n\n\tdeserialize({ read, logger }) {\n\t\tthis.logger = logger;\n\t\t{\n\t\t\tconst items = [];\n\t\t\tlet item = read();\n\t\t\twhile (item !== null) {\n\t\t\t\titems.push(item);\n\t\t\t\titem = read();\n\t\t\t}\n\t\t\tthis.itemInfo.clear();\n\t\t\tconst infoItems = items.map(identifier => {\n\t\t\t\tconst info = new PackItemInfo(identifier, undefined, undefined);\n\t\t\t\tthis.itemInfo.set(identifier, info);\n\t\t\t\treturn info;\n\t\t\t});\n\t\t\tfor (const info of infoItems) {\n\t\t\t\tinfo.etag = read();\n\t\t\t}\n\t\t\tfor (const info of infoItems) {\n\t\t\t\tinfo.lastAccess = read();\n\t\t\t}\n\t\t}\n\t\tthis.content.length = 0;\n\t\tlet items = read();\n\t\twhile (items !== null) {\n\t\t\tif (items === undefined) {\n\t\t\t\tthis.content.push(items);\n\t\t\t} else {\n\t\t\t\tconst idx = this.content.length;\n\t\t\t\tconst lazy = read();\n\t\t\t\tthis.content.push(\n\t\t\t\t\tnew PackContent(\n\t\t\t\t\t\titems,\n\t\t\t\t\t\tnew Set(),\n\t\t\t\t\t\tlazy,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t`${this.content.length}`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tfor (const identifier of items) {\n\t\t\t\t\tthis.itemInfo.get(identifier).location = idx;\n\t\t\t\t}\n\t\t\t}\n\t\t\titems = read();\n\t\t}\n\t}\n}\n\nmakeSerializable(Pack, \"webpack/lib/cache/PackFileCacheStrategy\", \"Pack\");\n\nclass PackContentItems {\n\t/**\n\t * @param {Map<string, any>} map items\n\t */\n\tconstructor(map) {\n\t\tthis.map = map;\n\t}\n\n\tserialize({ write, snapshot, rollback, logger, profile }) {\n\t\tif (profile) {\n\t\t\twrite(false);\n\t\t\tfor (const [key, value] of this.map) {\n\t\t\t\tconst s = snapshot();\n\t\t\t\ttry {\n\t\t\t\t\twrite(key);\n\t\t\t\t\tconst start = process.hrtime();\n\t\t\t\t\twrite(value);\n\t\t\t\t\tconst durationHr = process.hrtime(start);\n\t\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\t\t\t\t\tif (duration > 1) {\n\t\t\t\t\t\tif (duration > 500)\n\t\t\t\t\t\t\tlogger.error(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 50)\n\t\t\t\t\t\t\tlogger.warn(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 10)\n\t\t\t\t\t\t\tlogger.info(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse if (duration > 5)\n\t\t\t\t\t\t\tlogger.log(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t\telse logger.debug(`Serialization of '${key}': ${duration} ms`);\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\trollback(s);\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\n\t\t\t\t\tconst msg = \"Skipped not serializable cache item\";\n\t\t\t\t\tif (e.message.includes(\"ModuleBuildError\")) {\n\t\t\t\t\t\tlogger.log(`${msg} (in build error): ${e.message}`);\n\t\t\t\t\t\tlogger.debug(`${msg} '${key}' (in build error): ${e.stack}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.warn(`${msg}: ${e.message}`);\n\t\t\t\t\t\tlogger.debug(`${msg} '${key}': ${e.stack}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite(null);\n\t\t\treturn;\n\t\t}\n\t\t// Try to serialize all at once\n\t\tconst s = snapshot();\n\t\ttry {\n\t\t\twrite(true);\n\t\t\twrite(this.map);\n\t\t} catch (e) {\n\t\t\trollback(s);\n\n\t\t\t// Try to serialize each item on it's own\n\t\t\twrite(false);\n\t\t\tfor (const [key, value] of this.map) {\n\t\t\t\tconst s = snapshot();\n\t\t\t\ttry {\n\t\t\t\t\twrite(key);\n\t\t\t\t\twrite(value);\n\t\t\t\t} catch (e) {\n\t\t\t\t\trollback(s);\n\t\t\t\t\tif (e === NOT_SERIALIZABLE) continue;\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Skipped not serializable cache item '${key}': ${e.message}`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(e.stack);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite(null);\n\t\t}\n\t}\n\n\tdeserialize({ read, logger, profile }) {\n\t\tif (read()) {\n\t\t\tthis.map = read();\n\t\t} else if (profile) {\n\t\t\tconst map = new Map();\n\t\t\tlet key = read();\n\t\t\twhile (key !== null) {\n\t\t\t\tconst start = process.hrtime();\n\t\t\t\tconst value = read();\n\t\t\t\tconst durationHr = process.hrtime(start);\n\t\t\t\tconst duration = durationHr[0] * 1000 + durationHr[1] / 1e6;\n\t\t\t\tif (duration > 1) {\n\t\t\t\t\tif (duration > 100)\n\t\t\t\t\t\tlogger.error(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 20)\n\t\t\t\t\t\tlogger.warn(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 5)\n\t\t\t\t\t\tlogger.info(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse if (duration > 2)\n\t\t\t\t\t\tlogger.log(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t\telse logger.debug(`Deserialization of '${key}': ${duration} ms`);\n\t\t\t\t}\n\t\t\t\tmap.set(key, value);\n\t\t\t\tkey = read();\n\t\t\t}\n\t\t\tthis.map = map;\n\t\t} else {\n\t\t\tconst map = new Map();\n\t\t\tlet key = read();\n\t\t\twhile (key !== null) {\n\t\t\t\tmap.set(key, read());\n\t\t\t\tkey = read();\n\t\t\t}\n\t\t\tthis.map = map;\n\t\t}\n\t}\n}\n\nmakeSerializable(\n\tPackContentItems,\n\t\"webpack/lib/cache/PackFileCacheStrategy\",\n\t\"PackContentItems\"\n);\n\nclass PackContent {\n\t/*\n\t\tThis class can be in these states:\n\t\t   |   this.lazy    | this.content | this.outdated | state\n\t\tA1 |   undefined    |     Map      |     false     | fresh content\n\t\tA2 |   undefined    |     Map      |     true      | (will not happen)\n\t\tB1 | lazy () => {}  |  undefined   |     false     | not deserialized\n\t\tB2 | lazy () => {}  |  undefined   |     true      | not deserialized, but some items has been removed\n\t\tC1 | lazy* () => {} |     Map      |     false     | deserialized\n\t\tC2 | lazy* () => {} |     Map      |     true      | deserialized, and some items has been removed\n\n\t\tthis.used is a subset of this.items.\n\t\tthis.items is a subset of this.content.keys() resp. this.lazy().map.keys()\n\t\tWhen this.outdated === false, this.items === this.content.keys() resp. this.lazy().map.keys()\n\t\tWhen this.outdated === true, this.items should be used to recreated this.lazy/this.content.\n\t\tWhen this.lazy and this.content is set, they contain the same data.\n\t\tthis.get must only be called with a valid item from this.items.\n\t\tIn state C this.lazy is unMemoized\n\t*/\n\n\t/**\n\t * @param {Set<string>} items keys\n\t * @param {Set<string>} usedItems used keys\n\t * @param {PackContentItems | function(): Promise<PackContentItems>} dataOrFn sync or async content\n\t * @param {Logger=} logger logger for logging\n\t * @param {string=} lazyName name of dataOrFn for logging\n\t */\n\tconstructor(items, usedItems, dataOrFn, logger, lazyName) {\n\t\tthis.items = items;\n\t\t/** @type {function(): Promise<PackContentItems> | PackContentItems} */\n\t\tthis.lazy = typeof dataOrFn === \"function\" ? dataOrFn : undefined;\n\t\t/** @type {Map<string, any>} */\n\t\tthis.content = typeof dataOrFn === \"function\" ? undefined : dataOrFn.map;\n\t\tthis.outdated = false;\n\t\tthis.used = usedItems;\n\t\tthis.logger = logger;\n\t\tthis.lazyName = lazyName;\n\t}\n\n\tget(identifier) {\n\t\tthis.used.add(identifier);\n\t\tif (this.content) {\n\t\t\treturn this.content.get(identifier);\n\t\t}\n\n\t\t// We are in state B\n\t\tconst { lazyName } = this;\n\t\tlet timeMessage;\n\t\tif (lazyName) {\n\t\t\t// only log once\n\t\t\tthis.lazyName = undefined;\n\t\t\ttimeMessage = `restore cache content ${lazyName} (${formatSize(\n\t\t\t\tthis.getSize()\n\t\t\t)})`;\n\t\t\tthis.logger.log(\n\t\t\t\t`starting to restore cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)}) because of request to: ${identifier}`\n\t\t\t);\n\t\t\tthis.logger.time(timeMessage);\n\t\t}\n\t\tconst value = this.lazy();\n\t\tif (\"then\" in value) {\n\t\t\treturn value.then(data => {\n\t\t\t\tconst map = data.map;\n\t\t\t\tif (timeMessage) {\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t}\n\t\t\t\t// Move to state C\n\t\t\t\tthis.content = map;\n\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\t\t\t\treturn map.get(identifier);\n\t\t\t});\n\t\t} else {\n\t\t\tconst map = value.map;\n\t\t\tif (timeMessage) {\n\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t}\n\t\t\t// Move to state C\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\t\t\treturn map.get(identifier);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} reason explanation why unpack is necessary\n\t * @returns {void | Promise} maybe a promise if lazy\n\t */\n\tunpack(reason) {\n\t\tif (this.content) return;\n\n\t\t// Move from state B to C\n\t\tif (this.lazy) {\n\t\t\tconst { lazyName } = this;\n\t\t\tlet timeMessage;\n\t\t\tif (lazyName) {\n\t\t\t\t// only log once\n\t\t\t\tthis.lazyName = undefined;\n\t\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)})`;\n\t\t\t\tthis.logger.log(\n\t\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\t\tthis.getSize()\n\t\t\t\t\t)}) because ${reason}`\n\t\t\t\t);\n\t\t\t\tthis.logger.time(timeMessage);\n\t\t\t}\n\t\t\tconst value = this.lazy();\n\t\t\tif (\"then\" in value) {\n\t\t\t\treturn value.then(data => {\n\t\t\t\t\tif (timeMessage) {\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t\t}\n\t\t\t\t\tthis.content = data.map;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (timeMessage) {\n\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t}\n\t\t\t\tthis.content = value.map;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {number} size of the content or -1 if not known\n\t */\n\tgetSize() {\n\t\tif (!this.lazy) return -1;\n\t\tconst options = /** @type {any} */ (this.lazy).options;\n\t\tif (!options) return -1;\n\t\tconst size = options.size;\n\t\tif (typeof size !== \"number\") return -1;\n\t\treturn size;\n\t}\n\n\tdelete(identifier) {\n\t\tthis.items.delete(identifier);\n\t\tthis.used.delete(identifier);\n\t\tthis.outdated = true;\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(any): function(): Promise<PackContentItems> | PackContentItems} write write function\n\t * @returns {void}\n\t */\n\twriteLazy(write) {\n\t\tif (!this.outdated && this.lazy) {\n\t\t\t// State B1 or C1\n\t\t\t// this.lazy is still the valid deserialized version\n\t\t\twrite(this.lazy);\n\t\t\treturn;\n\t\t}\n\t\tif (!this.outdated && this.content) {\n\t\t\t// State A1\n\t\t\tconst map = new Map(this.content);\n\t\t\t// Move to state C1\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\n\t\t\t\twrite(() => new PackContentItems(map))\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\tif (this.content) {\n\t\t\t// State A2 or C2\n\t\t\t/** @type {Map<string, any>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const item of this.items) {\n\t\t\t\tmap.set(item, this.content.get(item));\n\t\t\t}\n\t\t\t// Move to state C1\n\t\t\tthis.outdated = false;\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(\n\t\t\t\twrite(() => new PackContentItems(map))\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\t// State B2\n\t\tconst { lazyName } = this;\n\t\tlet timeMessage;\n\t\tif (lazyName) {\n\t\t\t// only log once\n\t\t\tthis.lazyName = undefined;\n\t\t\ttimeMessage = `unpack cache content ${lazyName} (${formatSize(\n\t\t\t\tthis.getSize()\n\t\t\t)})`;\n\t\t\tthis.logger.log(\n\t\t\t\t`starting to unpack cache content ${lazyName} (${formatSize(\n\t\t\t\t\tthis.getSize()\n\t\t\t\t)}) because it's outdated and need to be serialized`\n\t\t\t);\n\t\t\tthis.logger.time(timeMessage);\n\t\t}\n\t\tconst value = this.lazy();\n\t\tthis.outdated = false;\n\t\tif (\"then\" in value) {\n\t\t\t// Move to state B1\n\t\t\tthis.lazy = write(() =>\n\t\t\t\tvalue.then(data => {\n\t\t\t\t\tif (timeMessage) {\n\t\t\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t\t\t}\n\t\t\t\t\tconst oldMap = data.map;\n\t\t\t\t\t/** @type {Map<string, any>} */\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\tfor (const item of this.items) {\n\t\t\t\t\t\tmap.set(item, oldMap.get(item));\n\t\t\t\t\t}\n\t\t\t\t\t// Move to state C1 (or maybe C2)\n\t\t\t\t\tthis.content = map;\n\t\t\t\t\tthis.lazy = SerializerMiddleware.unMemoizeLazy(this.lazy);\n\n\t\t\t\t\treturn new PackContentItems(map);\n\t\t\t\t})\n\t\t\t);\n\t\t} else {\n\t\t\t// Move to state C1\n\t\t\tif (timeMessage) {\n\t\t\t\tthis.logger.timeEnd(timeMessage);\n\t\t\t}\n\t\t\tconst oldMap = value.map;\n\t\t\t/** @type {Map<string, any>} */\n\t\t\tconst map = new Map();\n\t\t\tfor (const item of this.items) {\n\t\t\t\tmap.set(item, oldMap.get(item));\n\t\t\t}\n\t\t\tthis.content = map;\n\t\t\tthis.lazy = write(() => new PackContentItems(map));\n\t\t}\n\t}\n}\n\nconst allowCollectingMemory = buf => {\n\tconst wasted = buf.buffer.byteLength - buf.byteLength;\n\tif (wasted > 8192 && (wasted > 1048576 || wasted > buf.byteLength)) {\n\t\treturn Buffer.from(buf);\n\t}\n\treturn buf;\n};\n\nclass PackFileCacheStrategy {\n\t/**\n\t * @param {Object} options options\n\t * @param {Compiler} options.compiler the compiler\n\t * @param {IntermediateFileSystem} options.fs the filesystem\n\t * @param {string} options.context the context directory\n\t * @param {string} options.cacheLocation the location of the cache data\n\t * @param {string} options.version version identifier\n\t * @param {Logger} options.logger a logger\n\t * @param {SnapshotOptions} options.snapshot options regarding snapshotting\n\t * @param {number} options.maxAge max age of cache items\n\t * @param {boolean} options.profile track and log detailed timing information for individual cache items\n\t * @param {boolean} options.allowCollectingMemory allow to collect unused memory created during deserialization\n\t * @param {false | \"gzip\" | \"brotli\"} options.compression compression used\n\t */\n\tconstructor({\n\t\tcompiler,\n\t\tfs,\n\t\tcontext,\n\t\tcacheLocation,\n\t\tversion,\n\t\tlogger,\n\t\tsnapshot,\n\t\tmaxAge,\n\t\tprofile,\n\t\tallowCollectingMemory,\n\t\tcompression\n\t}) {\n\t\tthis.fileSerializer = createFileSerializer(\n\t\t\tfs,\n\t\t\tcompiler.options.output.hashFunction\n\t\t);\n\t\tthis.fileSystemInfo = new FileSystemInfo(fs, {\n\t\t\tmanagedPaths: snapshot.managedPaths,\n\t\t\timmutablePaths: snapshot.immutablePaths,\n\t\t\tlogger: logger.getChildLogger(\"webpack.FileSystemInfo\"),\n\t\t\thashFunction: compiler.options.output.hashFunction\n\t\t});\n\t\tthis.compiler = compiler;\n\t\tthis.context = context;\n\t\tthis.cacheLocation = cacheLocation;\n\t\tthis.version = version;\n\t\tthis.logger = logger;\n\t\tthis.maxAge = maxAge;\n\t\tthis.profile = profile;\n\t\tthis.allowCollectingMemory = allowCollectingMemory;\n\t\tthis.compression = compression;\n\t\tthis._extension =\n\t\t\tcompression === \"brotli\"\n\t\t\t\t? \".pack.br\"\n\t\t\t\t: compression === \"gzip\"\n\t\t\t\t? \".pack.gz\"\n\t\t\t\t: \".pack\";\n\t\tthis.snapshot = snapshot;\n\t\t/** @type {Set<string>} */\n\t\tthis.buildDependencies = new Set();\n\t\t/** @type {LazySet<string>} */\n\t\tthis.newBuildDependencies = new LazySet();\n\t\t/** @type {Snapshot} */\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\n\t\t/** @type {Map<string, string | false>} */\n\t\tthis.resolveResults = undefined;\n\t\t/** @type {Snapshot} */\n\t\tthis.buildSnapshot = undefined;\n\t\t/** @type {Promise<Pack>} */\n\t\tthis.packPromise = this._openPack();\n\t\tthis.storePromise = Promise.resolve();\n\t}\n\n\t_getPack() {\n\t\tif (this.packPromise === undefined) {\n\t\t\tthis.packPromise = this.storePromise.then(() => this._openPack());\n\t\t}\n\t\treturn this.packPromise;\n\t}\n\n\t/**\n\t * @returns {Promise<Pack>} the pack\n\t */\n\t_openPack() {\n\t\tconst { logger, profile, cacheLocation, version } = this;\n\t\t/** @type {Snapshot} */\n\t\tlet buildSnapshot;\n\t\t/** @type {Set<string>} */\n\t\tlet buildDependencies;\n\t\t/** @type {Set<string>} */\n\t\tlet newBuildDependencies;\n\t\t/** @type {Snapshot} */\n\t\tlet resolveBuildDependenciesSnapshot;\n\t\t/** @type {Map<string, string | false>} */\n\t\tlet resolveResults;\n\t\tlogger.time(\"restore cache container\");\n\t\treturn this.fileSerializer\n\t\t\t.deserialize(null, {\n\t\t\t\tfilename: `${cacheLocation}/index${this._extension}`,\n\t\t\t\textension: `${this._extension}`,\n\t\t\t\tlogger,\n\t\t\t\tprofile,\n\t\t\t\tretainedBuffer: this.allowCollectingMemory\n\t\t\t\t\t? allowCollectingMemory\n\t\t\t\t\t: undefined\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tif (err.code !== \"ENOENT\") {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Restoring pack failed from ${cacheLocation}${this._extension}: ${err}`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`No pack exists at ${cacheLocation}${this._extension}: ${err}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t})\n\t\t\t.then(packContainer => {\n\t\t\t\tlogger.timeEnd(\"restore cache container\");\n\t\t\t\tif (!packContainer) return undefined;\n\t\t\t\tif (!(packContainer instanceof PackContainer)) {\n\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but contained content is unexpected.`,\n\t\t\t\t\t\tpackContainer\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (packContainer.version !== version) {\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but version doesn't match.`\n\t\t\t\t\t);\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tlogger.time(\"check build dependencies\");\n\t\t\t\treturn Promise.all([\n\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\tpackContainer.buildSnapshot,\n\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!valid) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies have changed.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbuildSnapshot = packContainer.buildSnapshot;\n\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}),\n\t\t\t\t\tnew Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot,\n\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but checking snapshot of resolving of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\t\tresolveBuildDependenciesSnapshot =\n\t\t\t\t\t\t\t\t\t\tpackContainer.resolveBuildDependenciesSnapshot;\n\t\t\t\t\t\t\t\t\tbuildDependencies = packContainer.buildDependencies;\n\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\n\t\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\"resolving of build dependencies is invalid, will re-resolve build dependencies\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.checkResolveResultsValid(\n\t\t\t\t\t\t\t\t\tpackContainer.resolveResults,\n\t\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but resolving of build dependencies errored: ${err}.`\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (valid) {\n\t\t\t\t\t\t\t\t\t\t\tnewBuildDependencies = packContainer.buildDependencies;\n\t\t\t\t\t\t\t\t\t\t\tresolveResults = packContainer.resolveResults;\n\t\t\t\t\t\t\t\t\t\t\treturn resolve(true);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t`Restored pack from ${cacheLocation}${this._extension}, but build dependencies resolve to different locations.`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn resolve(false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t})\n\t\t\t\t])\n\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t})\n\t\t\t\t\t.then(([buildSnapshotValid, resolveValid]) => {\n\t\t\t\t\t\tlogger.timeEnd(\"check build dependencies\");\n\t\t\t\t\t\tif (buildSnapshotValid && resolveValid) {\n\t\t\t\t\t\t\tlogger.time(\"restore cache content metadata\");\n\t\t\t\t\t\t\tconst d = packContainer.data();\n\t\t\t\t\t\t\tlogger.timeEnd(\"restore cache content metadata\");\n\t\t\t\t\t\t\treturn d;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t});\n\t\t\t})\n\t\t\t.then(pack => {\n\t\t\t\tif (pack) {\n\t\t\t\t\tpack.maxAge = this.maxAge;\n\t\t\t\t\tthis.buildSnapshot = buildSnapshot;\n\t\t\t\t\tif (buildDependencies) this.buildDependencies = buildDependencies;\n\t\t\t\t\tif (newBuildDependencies)\n\t\t\t\t\t\tthis.newBuildDependencies.addAll(newBuildDependencies);\n\t\t\t\t\tthis.resolveResults = resolveResults;\n\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\n\t\t\t\t\t\tresolveBuildDependenciesSnapshot;\n\t\t\t\t\treturn pack;\n\t\t\t\t}\n\t\t\t\treturn new Pack(logger, this.maxAge);\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthis.logger.warn(\n\t\t\t\t\t`Restoring pack from ${cacheLocation}${this._extension} failed: ${err}`\n\t\t\t\t);\n\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\treturn new Pack(logger, this.maxAge);\n\t\t\t});\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {Etag | null} etag etag of the resource\n\t * @param {any} data cached content\n\t * @returns {Promise<void>} promise\n\t */\n\tstore(identifier, etag, data) {\n\t\treturn this._getPack().then(pack => {\n\t\t\tpack.set(identifier, etag === null ? null : etag.toString(), data);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} identifier unique name for the resource\n\t * @param {Etag | null} etag etag of the resource\n\t * @returns {Promise<any>} promise to the cached content\n\t */\n\trestore(identifier, etag) {\n\t\treturn this._getPack()\n\t\t\t.then(pack =>\n\t\t\t\tpack.get(identifier, etag === null ? null : etag.toString())\n\t\t\t)\n\t\t\t.catch(err => {\n\t\t\t\tif (err && err.code !== \"ENOENT\") {\n\t\t\t\t\tthis.logger.warn(\n\t\t\t\t\t\t`Restoring failed for ${identifier} from pack: ${err}`\n\t\t\t\t\t);\n\t\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\tstoreBuildDependencies(dependencies) {\n\t\tthis.newBuildDependencies.addAll(dependencies);\n\t}\n\n\tafterAllStored() {\n\t\tconst packPromise = this.packPromise;\n\t\tif (packPromise === undefined) return Promise.resolve();\n\t\tconst reportProgress = ProgressPlugin.getReporter(this.compiler);\n\t\treturn (this.storePromise = packPromise\n\t\t\t.then(pack => {\n\t\t\t\tpack.stopCapturingRequests();\n\t\t\t\tif (!pack.invalid) return;\n\t\t\t\tthis.packPromise = undefined;\n\t\t\t\tthis.logger.log(`Storing pack...`);\n\t\t\t\tlet promise;\n\t\t\t\tconst newBuildDependencies = new Set();\n\t\t\t\tfor (const dep of this.newBuildDependencies) {\n\t\t\t\t\tif (!this.buildDependencies.has(dep)) {\n\t\t\t\t\t\tnewBuildDependencies.add(dep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (newBuildDependencies.size > 0 || !this.buildSnapshot) {\n\t\t\t\t\tif (reportProgress) reportProgress(0.5, \"resolve build dependencies\");\n\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t`Capturing build dependencies... (${Array.from(\n\t\t\t\t\t\t\tnewBuildDependencies\n\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t);\n\t\t\t\t\tpromise = new Promise((resolve, reject) => {\n\t\t\t\t\t\tthis.logger.time(\"resolve build dependencies\");\n\t\t\t\t\t\tthis.fileSystemInfo.resolveBuildDependencies(\n\t\t\t\t\t\t\tthis.context,\n\t\t\t\t\t\t\tnewBuildDependencies,\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"resolve build dependencies\");\n\t\t\t\t\t\t\t\tif (err) return reject(err);\n\n\t\t\t\t\t\t\t\tthis.logger.time(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t\t\t\tdirectories,\n\t\t\t\t\t\t\t\t\tmissing,\n\t\t\t\t\t\t\t\t\tresolveResults,\n\t\t\t\t\t\t\t\t\tresolveDependencies\n\t\t\t\t\t\t\t\t} = result;\n\t\t\t\t\t\t\t\tif (this.resolveResults) {\n\t\t\t\t\t\t\t\t\tfor (const [key, value] of resolveResults) {\n\t\t\t\t\t\t\t\t\t\tthis.resolveResults.set(key, value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.resolveResults = resolveResults;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (reportProgress) {\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t0.6,\n\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\n\t\t\t\t\t\t\t\t\t\t\"resolving\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\tresolveDependencies.files,\n\t\t\t\t\t\t\t\t\tresolveDependencies.directories,\n\t\t\t\t\t\t\t\t\tresolveDependencies.missing,\n\t\t\t\t\t\t\t\t\tthis.snapshot.resolveBuildDependencies,\n\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot resolve dependencies\")\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (this.resolveBuildDependenciesSnapshot) {\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot =\n\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot = snapshot;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (reportProgress) {\n\t\t\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t\t\t0.7,\n\t\t\t\t\t\t\t\t\t\t\t\t\"snapshot build dependencies\",\n\t\t\t\t\t\t\t\t\t\t\t\t\"modules\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t\t\t\t\t\tdirectories,\n\t\t\t\t\t\t\t\t\t\t\tmissing,\n\t\t\t\t\t\t\t\t\t\t\tthis.snapshot.buildDependencies,\n\t\t\t\t\t\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.timeEnd(\"snapshot build dependencies\");\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\"Unable to snapshot build dependencies\")\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\"Captured build dependencies\");\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.buildSnapshot) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.fileSystemInfo.mergeSnapshots(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.buildSnapshot = snapshot;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tpromise = Promise.resolve();\n\t\t\t\t}\n\t\t\t\treturn promise.then(() => {\n\t\t\t\t\tif (reportProgress) reportProgress(0.8, \"serialize pack\");\n\t\t\t\t\tthis.logger.time(`store pack`);\n\t\t\t\t\tconst updatedBuildDependencies = new Set(this.buildDependencies);\n\t\t\t\t\tfor (const dep of newBuildDependencies) {\n\t\t\t\t\t\tupdatedBuildDependencies.add(dep);\n\t\t\t\t\t}\n\t\t\t\t\tconst content = new PackContainer(\n\t\t\t\t\t\tpack,\n\t\t\t\t\t\tthis.version,\n\t\t\t\t\t\tthis.buildSnapshot,\n\t\t\t\t\t\tupdatedBuildDependencies,\n\t\t\t\t\t\tthis.resolveResults,\n\t\t\t\t\t\tthis.resolveBuildDependenciesSnapshot\n\t\t\t\t\t);\n\t\t\t\t\treturn this.fileSerializer\n\t\t\t\t\t\t.serialize(content, {\n\t\t\t\t\t\t\tfilename: `${this.cacheLocation}/index${this._extension}`,\n\t\t\t\t\t\t\textension: `${this._extension}`,\n\t\t\t\t\t\t\tlogger: this.logger,\n\t\t\t\t\t\t\tprofile: this.profile\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\tfor (const dep of newBuildDependencies) {\n\t\t\t\t\t\t\t\tthis.buildDependencies.add(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.newBuildDependencies.clear();\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\n\t\t\t\t\t\t\tconst stats = pack.getContentStats();\n\t\t\t\t\t\t\tthis.logger.log(\n\t\t\t\t\t\t\t\t\"Stored pack (%d items, %d files, %d MiB)\",\n\t\t\t\t\t\t\t\tpack.itemInfo.size,\n\t\t\t\t\t\t\t\tstats.count,\n\t\t\t\t\t\t\t\tMath.round(stats.size / 1024 / 1024)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(err => {\n\t\t\t\t\t\t\tthis.logger.timeEnd(`store pack`);\n\t\t\t\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\n\t\t\t\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(err => {\n\t\t\t\tthis.logger.warn(`Caching failed for pack: ${err}`);\n\t\t\t\tthis.logger.debug(err.stack);\n\t\t\t}));\n\t}\n\n\tclear() {\n\t\tthis.fileSystemInfo.clear();\n\t\tthis.buildDependencies.clear();\n\t\tthis.newBuildDependencies.clear();\n\t\tthis.resolveBuildDependenciesSnapshot = undefined;\n\t\tthis.resolveResults = undefined;\n\t\tthis.buildSnapshot = undefined;\n\t\tthis.packPromise = undefined;\n\t}\n}\n\nmodule.exports = PackFileCacheStrategy;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}