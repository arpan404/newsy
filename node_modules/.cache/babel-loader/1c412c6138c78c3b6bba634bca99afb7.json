{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  SyncBailHook\n} = require(\"tapable\");\n\nconst {\n  RawSource,\n  CachedSource,\n  CompatSource\n} = require(\"webpack-sources\");\n\nconst Compilation = require(\"../Compilation\");\n\nconst WebpackError = require(\"../WebpackError\");\n\nconst {\n  compareSelect,\n  compareStrings\n} = require(\"../util/comparators\");\n\nconst createHash = require(\"../util/createHash\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n\nconst EMPTY_SET = new Set();\n\nconst addToList = (itemOrItems, list) => {\n  if (Array.isArray(itemOrItems)) {\n    for (const item of itemOrItems) {\n      list.add(item);\n    }\n  } else if (itemOrItems) {\n    list.add(itemOrItems);\n  }\n};\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\n\n\nconst mapAndDeduplicateBuffers = (input, fn) => {\n  // Buffer.equals compares size first so this should be efficient enough\n  // If it becomes a performance problem we can use a map and group by size\n  // instead of looping over all assets.\n  const result = [];\n\n  outer: for (const value of input) {\n    const buf = fn(value);\n\n    for (const other of result) {\n      if (buf.equals(other)) continue outer;\n    }\n\n    result.push(buf);\n  }\n\n  return result;\n};\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\n\n\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst cachedSourceMap = new WeakMap();\n\nconst toCachedSource = source => {\n  if (source instanceof CachedSource) {\n    return source;\n  }\n\n  const entry = cachedSourceMap.get(source);\n  if (entry !== undefined) return entry;\n  const newSource = new CachedSource(CompatSource.from(source));\n  cachedSourceMap.set(source, newSource);\n  return newSource;\n};\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {Set<string>} ownHashes\n * @property {Promise} contentComputePromise\n * @property {Promise} contentComputeWithoutOwnPromise\n * @property {Set<string>} referencedHashes\n * @property {Set<string>} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\n\n\nconst compilationHooksMap = new WeakMap();\n\nclass RealContentHashPlugin {\n  /**\n   * @param {Compilation} compilation the compilation\n   * @returns {CompilationHooks} the attached hooks\n   */\n  static getCompilationHooks(compilation) {\n    if (!(compilation instanceof Compilation)) {\n      throw new TypeError(\"The 'compilation' argument must be an instance of Compilation\");\n    }\n\n    let hooks = compilationHooksMap.get(compilation);\n\n    if (hooks === undefined) {\n      hooks = {\n        updateHash: new SyncBailHook([\"content\", \"oldHash\"])\n      };\n      compilationHooksMap.set(compilation, hooks);\n    }\n\n    return hooks;\n  }\n\n  constructor(_ref) {\n    let {\n      hashFunction,\n      hashDigest\n    } = _ref;\n    this._hashFunction = hashFunction;\n    this._hashDigest = hashDigest;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\n      const cacheAnalyse = compilation.getCache(\"RealContentHashPlugin|analyse\");\n      const cacheGenerate = compilation.getCache(\"RealContentHashPlugin|generate\");\n      const hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n      compilation.hooks.processAssets.tapPromise({\n        name: \"RealContentHashPlugin\",\n        stage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n      }, async () => {\n        const assets = compilation.getAssets();\n        /** @type {AssetInfoForRealContentHash[]} */\n\n        const assetsWithInfo = [];\n        const hashToAssets = new Map();\n\n        for (const {\n          source,\n          info,\n          name\n        } of assets) {\n          const cachedSource = toCachedSource(source);\n          const content = cachedSource.source();\n          /** @type {Set<string>} */\n\n          const hashes = new Set();\n          addToList(info.contenthash, hashes);\n          const data = {\n            name,\n            info,\n            source: cachedSource,\n\n            /** @type {RawSource | undefined} */\n            newSource: undefined,\n\n            /** @type {RawSource | undefined} */\n            newSourceWithoutOwn: undefined,\n            content,\n\n            /** @type {Set<string>} */\n            ownHashes: undefined,\n            contentComputePromise: undefined,\n            contentComputeWithoutOwnPromise: undefined,\n\n            /** @type {Set<string>} */\n            referencedHashes: undefined,\n            hashes\n          };\n          assetsWithInfo.push(data);\n\n          for (const hash of hashes) {\n            const list = hashToAssets.get(hash);\n\n            if (list === undefined) {\n              hashToAssets.set(hash, [data]);\n            } else {\n              list.push(data);\n            }\n          }\n        }\n\n        if (hashToAssets.size === 0) return;\n        const hashRegExp = new RegExp(Array.from(hashToAssets.keys(), quoteMeta).join(\"|\"), \"g\");\n        await Promise.all(assetsWithInfo.map(async asset => {\n          const {\n            name,\n            source,\n            content,\n            hashes\n          } = asset;\n\n          if (Buffer.isBuffer(content)) {\n            asset.referencedHashes = EMPTY_SET;\n            asset.ownHashes = EMPTY_SET;\n            return;\n          }\n\n          const etag = cacheAnalyse.mergeEtags(cacheAnalyse.getLazyHashedEtag(source), Array.from(hashes).join(\"|\"));\n          [asset.referencedHashes, asset.ownHashes] = await cacheAnalyse.providePromise(name, etag, () => {\n            const referencedHashes = new Set();\n            let ownHashes = new Set();\n            const inContent = content.match(hashRegExp);\n\n            if (inContent) {\n              for (const hash of inContent) {\n                if (hashes.has(hash)) {\n                  ownHashes.add(hash);\n                  continue;\n                }\n\n                referencedHashes.add(hash);\n              }\n            }\n\n            return [referencedHashes, ownHashes];\n          });\n        }));\n\n        const getDependencies = hash => {\n          const assets = hashToAssets.get(hash);\n\n          if (!assets) {\n            const referencingAssets = assetsWithInfo.filter(asset => asset.referencedHashes.has(hash));\n            const err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets.map(a => {\n              const match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(a.content);\n              return ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\n            }).join(\"\\n\")}`);\n            compilation.errors.push(err);\n            return undefined;\n          }\n\n          const hashes = new Set();\n\n          for (const {\n            referencedHashes,\n            ownHashes\n          } of assets) {\n            if (!ownHashes.has(hash)) {\n              for (const hash of ownHashes) {\n                hashes.add(hash);\n              }\n            }\n\n            for (const hash of referencedHashes) {\n              hashes.add(hash);\n            }\n          }\n\n          return hashes;\n        };\n\n        const hashInfo = hash => {\n          const assets = hashToAssets.get(hash);\n          return `${hash} (${Array.from(assets, a => a.name)})`;\n        };\n\n        const hashesInOrder = new Set();\n\n        for (const hash of hashToAssets.keys()) {\n          const add = (hash, stack) => {\n            const deps = getDependencies(hash);\n            if (!deps) return;\n            stack.add(hash);\n\n            for (const dep of deps) {\n              if (hashesInOrder.has(dep)) continue;\n\n              if (stack.has(dep)) {\n                throw new Error(`Circular hash dependency ${Array.from(stack, hashInfo).join(\" -> \")} -> ${hashInfo(dep)}`);\n              }\n\n              add(dep, stack);\n            }\n\n            hashesInOrder.add(hash);\n            stack.delete(hash);\n          };\n\n          if (hashesInOrder.has(hash)) continue;\n          add(hash, new Set());\n        }\n\n        const hashToNewHash = new Map();\n\n        const getEtag = asset => cacheGenerate.mergeEtags(cacheGenerate.getLazyHashedEtag(asset.source), Array.from(asset.referencedHashes, hash => hashToNewHash.get(hash)).join(\"|\"));\n\n        const computeNewContent = asset => {\n          if (asset.contentComputePromise) return asset.contentComputePromise;\n          return asset.contentComputePromise = (async () => {\n            if (asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(hash => hashToNewHash.get(hash) !== hash)) {\n              const identifier = asset.name;\n              const etag = getEtag(asset);\n              asset.newSource = await cacheGenerate.providePromise(identifier, etag, () => {\n                const newContent = asset.content.replace(hashRegExp, hash => hashToNewHash.get(hash));\n                return new RawSource(newContent);\n              });\n            }\n          })();\n        };\n\n        const computeNewContentWithoutOwn = asset => {\n          if (asset.contentComputeWithoutOwnPromise) return asset.contentComputeWithoutOwnPromise;\n          return asset.contentComputeWithoutOwnPromise = (async () => {\n            if (asset.ownHashes.size > 0 || Array.from(asset.referencedHashes).some(hash => hashToNewHash.get(hash) !== hash)) {\n              const identifier = asset.name + \"|without-own\";\n              const etag = getEtag(asset);\n              asset.newSourceWithoutOwn = await cacheGenerate.providePromise(identifier, etag, () => {\n                const newContent = asset.content.replace(hashRegExp, hash => {\n                  if (asset.ownHashes.has(hash)) {\n                    return \"\";\n                  }\n\n                  return hashToNewHash.get(hash);\n                });\n                return new RawSource(newContent);\n              });\n            }\n          })();\n        };\n\n        const comparator = compareSelect(a => a.name, compareStrings);\n\n        for (const oldHash of hashesInOrder) {\n          const assets = hashToAssets.get(oldHash);\n          assets.sort(comparator);\n          const hash = createHash(this._hashFunction);\n          await Promise.all(assets.map(asset => asset.ownHashes.has(oldHash) ? computeNewContentWithoutOwn(asset) : computeNewContent(asset)));\n          const assetsContent = mapAndDeduplicateBuffers(assets, asset => {\n            if (asset.ownHashes.has(oldHash)) {\n              return asset.newSourceWithoutOwn ? asset.newSourceWithoutOwn.buffer() : asset.source.buffer();\n            } else {\n              return asset.newSource ? asset.newSource.buffer() : asset.source.buffer();\n            }\n          });\n          let newHash = hooks.updateHash.call(assetsContent, oldHash);\n\n          if (!newHash) {\n            for (const content of assetsContent) {\n              hash.update(content);\n            }\n\n            const digest = hash.digest(this._hashDigest);\n            newHash =\n            /** @type {string} */\n            digest.slice(0, oldHash.length);\n          }\n\n          hashToNewHash.set(oldHash, newHash);\n        }\n\n        await Promise.all(assetsWithInfo.map(async asset => {\n          await computeNewContent(asset);\n          const newName = asset.name.replace(hashRegExp, hash => hashToNewHash.get(hash));\n          const infoUpdate = {};\n          const hash = asset.info.contenthash;\n          infoUpdate.contenthash = Array.isArray(hash) ? hash.map(hash => hashToNewHash.get(hash)) : hashToNewHash.get(hash);\n\n          if (asset.newSource !== undefined) {\n            compilation.updateAsset(asset.name, asset.newSource, infoUpdate);\n          } else {\n            compilation.updateAsset(asset.name, asset.source, infoUpdate);\n          }\n\n          if (asset.name !== newName) {\n            compilation.renameAsset(asset.name, newName);\n          }\n        }));\n      });\n    });\n  }\n\n}\n\nmodule.exports = RealContentHashPlugin;","map":{"version":3,"names":["SyncBailHook","require","RawSource","CachedSource","CompatSource","Compilation","WebpackError","compareSelect","compareStrings","createHash","EMPTY_SET","Set","addToList","itemOrItems","list","Array","isArray","item","add","mapAndDeduplicateBuffers","input","fn","result","outer","value","buf","other","equals","push","quoteMeta","str","replace","cachedSourceMap","WeakMap","toCachedSource","source","entry","get","undefined","newSource","from","set","compilationHooksMap","RealContentHashPlugin","getCompilationHooks","compilation","TypeError","hooks","updateHash","constructor","hashFunction","hashDigest","_hashFunction","_hashDigest","apply","compiler","tap","cacheAnalyse","getCache","cacheGenerate","processAssets","tapPromise","name","stage","PROCESS_ASSETS_STAGE_OPTIMIZE_HASH","assets","getAssets","assetsWithInfo","hashToAssets","Map","info","cachedSource","content","hashes","contenthash","data","newSourceWithoutOwn","ownHashes","contentComputePromise","contentComputeWithoutOwnPromise","referencedHashes","hash","size","hashRegExp","RegExp","keys","join","Promise","all","map","asset","Buffer","isBuffer","etag","mergeEtags","getLazyHashedEtag","providePromise","inContent","match","has","getDependencies","referencingAssets","filter","err","a","exec","errors","hashInfo","hashesInOrder","stack","deps","dep","Error","delete","hashToNewHash","getEtag","computeNewContent","some","identifier","newContent","computeNewContentWithoutOwn","comparator","oldHash","sort","assetsContent","buffer","newHash","call","update","digest","slice","length","newName","infoUpdate","updateAsset","renameAsset","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/optimize/RealContentHashPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncBailHook } = require(\"tapable\");\nconst { RawSource, CachedSource, CompatSource } = require(\"webpack-sources\");\nconst Compilation = require(\"../Compilation\");\nconst WebpackError = require(\"../WebpackError\");\nconst { compareSelect, compareStrings } = require(\"../util/comparators\");\nconst createHash = require(\"../util/createHash\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\nconst EMPTY_SET = new Set();\n\nconst addToList = (itemOrItems, list) => {\n\tif (Array.isArray(itemOrItems)) {\n\t\tfor (const item of itemOrItems) {\n\t\t\tlist.add(item);\n\t\t}\n\t} else if (itemOrItems) {\n\t\tlist.add(itemOrItems);\n\t}\n};\n\n/**\n * @template T\n * @param {T[]} input list\n * @param {function(T): Buffer} fn map function\n * @returns {Buffer[]} buffers without duplicates\n */\nconst mapAndDeduplicateBuffers = (input, fn) => {\n\t// Buffer.equals compares size first so this should be efficient enough\n\t// If it becomes a performance problem we can use a map and group by size\n\t// instead of looping over all assets.\n\tconst result = [];\n\touter: for (const value of input) {\n\t\tconst buf = fn(value);\n\t\tfor (const other of result) {\n\t\t\tif (buf.equals(other)) continue outer;\n\t\t}\n\t\tresult.push(buf);\n\t}\n\treturn result;\n};\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst cachedSourceMap = new WeakMap();\n\nconst toCachedSource = source => {\n\tif (source instanceof CachedSource) {\n\t\treturn source;\n\t}\n\tconst entry = cachedSourceMap.get(source);\n\tif (entry !== undefined) return entry;\n\tconst newSource = new CachedSource(CompatSource.from(source));\n\tcachedSourceMap.set(source, newSource);\n\treturn newSource;\n};\n\n/**\n * @typedef {Object} AssetInfoForRealContentHash\n * @property {string} name\n * @property {AssetInfo} info\n * @property {Source} source\n * @property {RawSource | undefined} newSource\n * @property {RawSource | undefined} newSourceWithoutOwn\n * @property {string} content\n * @property {Set<string>} ownHashes\n * @property {Promise} contentComputePromise\n * @property {Promise} contentComputeWithoutOwnPromise\n * @property {Set<string>} referencedHashes\n * @property {Set<string>} hashes\n */\n\n/**\n * @typedef {Object} CompilationHooks\n * @property {SyncBailHook<[Buffer[], string], string>} updateHash\n */\n\n/** @type {WeakMap<Compilation, CompilationHooks>} */\nconst compilationHooksMap = new WeakMap();\n\nclass RealContentHashPlugin {\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @returns {CompilationHooks} the attached hooks\n\t */\n\tstatic getCompilationHooks(compilation) {\n\t\tif (!(compilation instanceof Compilation)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"The 'compilation' argument must be an instance of Compilation\"\n\t\t\t);\n\t\t}\n\t\tlet hooks = compilationHooksMap.get(compilation);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\tupdateHash: new SyncBailHook([\"content\", \"oldHash\"])\n\t\t\t};\n\t\t\tcompilationHooksMap.set(compilation, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\tconstructor({ hashFunction, hashDigest }) {\n\t\tthis._hashFunction = hashFunction;\n\t\tthis._hashDigest = hashDigest;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RealContentHashPlugin\", compilation => {\n\t\t\tconst cacheAnalyse = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|analyse\"\n\t\t\t);\n\t\t\tconst cacheGenerate = compilation.getCache(\n\t\t\t\t\"RealContentHashPlugin|generate\"\n\t\t\t);\n\t\t\tconst hooks = RealContentHashPlugin.getCompilationHooks(compilation);\n\t\t\tcompilation.hooks.processAssets.tapPromise(\n\t\t\t\t{\n\t\t\t\t\tname: \"RealContentHashPlugin\",\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH\n\t\t\t\t},\n\t\t\t\tasync () => {\n\t\t\t\t\tconst assets = compilation.getAssets();\n\t\t\t\t\t/** @type {AssetInfoForRealContentHash[]} */\n\t\t\t\t\tconst assetsWithInfo = [];\n\t\t\t\t\tconst hashToAssets = new Map();\n\t\t\t\t\tfor (const { source, info, name } of assets) {\n\t\t\t\t\t\tconst cachedSource = toCachedSource(source);\n\t\t\t\t\t\tconst content = cachedSource.source();\n\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\taddToList(info.contenthash, hashes);\n\t\t\t\t\t\tconst data = {\n\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\tinfo,\n\t\t\t\t\t\t\tsource: cachedSource,\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\n\t\t\t\t\t\t\tnewSource: undefined,\n\t\t\t\t\t\t\t/** @type {RawSource | undefined} */\n\t\t\t\t\t\t\tnewSourceWithoutOwn: undefined,\n\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\townHashes: undefined,\n\t\t\t\t\t\t\tcontentComputePromise: undefined,\n\t\t\t\t\t\t\tcontentComputeWithoutOwnPromise: undefined,\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\treferencedHashes: undefined,\n\t\t\t\t\t\t\thashes\n\t\t\t\t\t\t};\n\t\t\t\t\t\tassetsWithInfo.push(data);\n\t\t\t\t\t\tfor (const hash of hashes) {\n\t\t\t\t\t\t\tconst list = hashToAssets.get(hash);\n\t\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\t\thashToAssets.set(hash, [data]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlist.push(data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (hashToAssets.size === 0) return;\n\t\t\t\t\tconst hashRegExp = new RegExp(\n\t\t\t\t\t\tArray.from(hashToAssets.keys(), quoteMeta).join(\"|\"),\n\t\t\t\t\t\t\"g\"\n\t\t\t\t\t);\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tconst { name, source, content, hashes } = asset;\n\t\t\t\t\t\t\tif (Buffer.isBuffer(content)) {\n\t\t\t\t\t\t\t\tasset.referencedHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\tasset.ownHashes = EMPTY_SET;\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst etag = cacheAnalyse.mergeEtags(\n\t\t\t\t\t\t\t\tcacheAnalyse.getLazyHashedEtag(source),\n\t\t\t\t\t\t\t\tArray.from(hashes).join(\"|\")\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t[asset.referencedHashes, asset.ownHashes] =\n\t\t\t\t\t\t\t\tawait cacheAnalyse.providePromise(name, etag, () => {\n\t\t\t\t\t\t\t\t\tconst referencedHashes = new Set();\n\t\t\t\t\t\t\t\t\tlet ownHashes = new Set();\n\t\t\t\t\t\t\t\t\tconst inContent = content.match(hashRegExp);\n\t\t\t\t\t\t\t\t\tif (inContent) {\n\t\t\t\t\t\t\t\t\t\tfor (const hash of inContent) {\n\t\t\t\t\t\t\t\t\t\t\tif (hashes.has(hash)) {\n\t\t\t\t\t\t\t\t\t\t\t\townHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treferencedHashes.add(hash);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn [referencedHashes, ownHashes];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t\tconst getDependencies = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\tif (!assets) {\n\t\t\t\t\t\t\tconst referencingAssets = assetsWithInfo.filter(asset =>\n\t\t\t\t\t\t\t\tasset.referencedHashes.has(hash)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst err = new WebpackError(`RealContentHashPlugin\nSome kind of unexpected caching problem occurred.\nAn asset was cached with a reference to another asset (${hash}) that's not in the compilation anymore.\nEither the asset was incorrectly cached, or the referenced asset should also be restored from cache.\nReferenced by:\n${referencingAssets\n\t.map(a => {\n\t\tconst match = new RegExp(`.{0,20}${quoteMeta(hash)}.{0,20}`).exec(\n\t\t\ta.content\n\t\t);\n\t\treturn ` - ${a.name}: ...${match ? match[0] : \"???\"}...`;\n\t})\n\t.join(\"\\n\")}`);\n\t\t\t\t\t\t\tcompilation.errors.push(err);\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst hashes = new Set();\n\t\t\t\t\t\tfor (const { referencedHashes, ownHashes } of assets) {\n\t\t\t\t\t\t\tif (!ownHashes.has(hash)) {\n\t\t\t\t\t\t\t\tfor (const hash of ownHashes) {\n\t\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const hash of referencedHashes) {\n\t\t\t\t\t\t\t\thashes.add(hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn hashes;\n\t\t\t\t\t};\n\t\t\t\t\tconst hashInfo = hash => {\n\t\t\t\t\t\tconst assets = hashToAssets.get(hash);\n\t\t\t\t\t\treturn `${hash} (${Array.from(assets, a => a.name)})`;\n\t\t\t\t\t};\n\t\t\t\t\tconst hashesInOrder = new Set();\n\t\t\t\t\tfor (const hash of hashToAssets.keys()) {\n\t\t\t\t\t\tconst add = (hash, stack) => {\n\t\t\t\t\t\t\tconst deps = getDependencies(hash);\n\t\t\t\t\t\t\tif (!deps) return;\n\t\t\t\t\t\t\tstack.add(hash);\n\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\tif (hashesInOrder.has(dep)) continue;\n\t\t\t\t\t\t\t\tif (stack.has(dep)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t`Circular hash dependency ${Array.from(\n\t\t\t\t\t\t\t\t\t\t\tstack,\n\t\t\t\t\t\t\t\t\t\t\thashInfo\n\t\t\t\t\t\t\t\t\t\t).join(\" -> \")} -> ${hashInfo(dep)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tadd(dep, stack);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thashesInOrder.add(hash);\n\t\t\t\t\t\t\tstack.delete(hash);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (hashesInOrder.has(hash)) continue;\n\t\t\t\t\t\tadd(hash, new Set());\n\t\t\t\t\t}\n\t\t\t\t\tconst hashToNewHash = new Map();\n\t\t\t\t\tconst getEtag = asset =>\n\t\t\t\t\t\tcacheGenerate.mergeEtags(\n\t\t\t\t\t\t\tcacheGenerate.getLazyHashedEtag(asset.source),\n\t\t\t\t\t\t\tArray.from(asset.referencedHashes, hash =>\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t).join(\"|\")\n\t\t\t\t\t\t);\n\t\t\t\t\tconst computeNewContent = asset => {\n\t\t\t\t\t\tif (asset.contentComputePromise) return asset.contentComputePromise;\n\t\t\t\t\t\treturn (asset.contentComputePromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name;\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSource = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\tconst computeNewContentWithoutOwn = asset => {\n\t\t\t\t\t\tif (asset.contentComputeWithoutOwnPromise)\n\t\t\t\t\t\t\treturn asset.contentComputeWithoutOwnPromise;\n\t\t\t\t\t\treturn (asset.contentComputeWithoutOwnPromise = (async () => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tasset.ownHashes.size > 0 ||\n\t\t\t\t\t\t\t\tArray.from(asset.referencedHashes).some(\n\t\t\t\t\t\t\t\t\thash => hashToNewHash.get(hash) !== hash\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst identifier = asset.name + \"|without-own\";\n\t\t\t\t\t\t\t\tconst etag = getEtag(asset);\n\t\t\t\t\t\t\t\tasset.newSourceWithoutOwn = await cacheGenerate.providePromise(\n\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\tetag,\n\t\t\t\t\t\t\t\t\t() => {\n\t\t\t\t\t\t\t\t\t\tconst newContent = asset.content.replace(\n\t\t\t\t\t\t\t\t\t\t\thashRegExp,\n\t\t\t\t\t\t\t\t\t\t\thash => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (asset.ownHashes.has(hash)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\treturn hashToNewHash.get(hash);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn new RawSource(newContent);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})());\n\t\t\t\t\t};\n\t\t\t\t\tconst comparator = compareSelect(a => a.name, compareStrings);\n\t\t\t\t\tfor (const oldHash of hashesInOrder) {\n\t\t\t\t\t\tconst assets = hashToAssets.get(oldHash);\n\t\t\t\t\t\tassets.sort(comparator);\n\t\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\t\tassets.map(asset =>\n\t\t\t\t\t\t\t\tasset.ownHashes.has(oldHash)\n\t\t\t\t\t\t\t\t\t? computeNewContentWithoutOwn(asset)\n\t\t\t\t\t\t\t\t\t: computeNewContent(asset)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst assetsContent = mapAndDeduplicateBuffers(assets, asset => {\n\t\t\t\t\t\t\tif (asset.ownHashes.has(oldHash)) {\n\t\t\t\t\t\t\t\treturn asset.newSourceWithoutOwn\n\t\t\t\t\t\t\t\t\t? asset.newSourceWithoutOwn.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn asset.newSource\n\t\t\t\t\t\t\t\t\t? asset.newSource.buffer()\n\t\t\t\t\t\t\t\t\t: asset.source.buffer();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tlet newHash = hooks.updateHash.call(assetsContent, oldHash);\n\t\t\t\t\t\tif (!newHash) {\n\t\t\t\t\t\t\tfor (const content of assetsContent) {\n\t\t\t\t\t\t\t\thash.update(content);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst digest = hash.digest(this._hashDigest);\n\t\t\t\t\t\t\tnewHash = /** @type {string} */ (digest.slice(0, oldHash.length));\n\t\t\t\t\t\t}\n\t\t\t\t\t\thashToNewHash.set(oldHash, newHash);\n\t\t\t\t\t}\n\t\t\t\t\tawait Promise.all(\n\t\t\t\t\t\tassetsWithInfo.map(async asset => {\n\t\t\t\t\t\t\tawait computeNewContent(asset);\n\t\t\t\t\t\t\tconst newName = asset.name.replace(hashRegExp, hash =>\n\t\t\t\t\t\t\t\thashToNewHash.get(hash)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst infoUpdate = {};\n\t\t\t\t\t\t\tconst hash = asset.info.contenthash;\n\t\t\t\t\t\t\tinfoUpdate.contenthash = Array.isArray(hash)\n\t\t\t\t\t\t\t\t? hash.map(hash => hashToNewHash.get(hash))\n\t\t\t\t\t\t\t\t: hashToNewHash.get(hash);\n\n\t\t\t\t\t\t\tif (asset.newSource !== undefined) {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(\n\t\t\t\t\t\t\t\t\tasset.name,\n\t\t\t\t\t\t\t\t\tasset.newSource,\n\t\t\t\t\t\t\t\t\tinfoUpdate\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcompilation.updateAsset(asset.name, asset.source, infoUpdate);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (asset.name !== newName) {\n\t\t\t\t\t\t\t\tcompilation.renameAsset(asset.name, newName);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = RealContentHashPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}