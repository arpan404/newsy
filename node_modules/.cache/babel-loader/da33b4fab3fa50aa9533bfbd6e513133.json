{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Hash = require(\"./Hash\");\n\nconst BULK_SIZE = 2000; // We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\n\nconst digestCaches = {};\n\nclass BulkUpdateDecorator extends Hash {\n  /**\n   * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n   * @param {string=} hashKey key for caching\n   */\n  constructor(hashOrFactory, hashKey) {\n    super();\n    this.hashKey = hashKey;\n\n    if (typeof hashOrFactory === \"function\") {\n      this.hashFactory = hashOrFactory;\n      this.hash = undefined;\n    } else {\n      this.hashFactory = undefined;\n      this.hash = hashOrFactory;\n    }\n\n    this.buffer = \"\";\n  }\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n\n\n  update(data, inputEncoding) {\n    if (inputEncoding !== undefined || typeof data !== \"string\" || data.length > BULK_SIZE) {\n      if (this.hash === undefined) this.hash = this.hashFactory();\n\n      if (this.buffer.length > 0) {\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n\n      this.hash.update(data, inputEncoding);\n    } else {\n      this.buffer += data;\n\n      if (this.buffer.length > BULK_SIZE) {\n        if (this.hash === undefined) this.hash = this.hashFactory();\n        this.hash.update(this.buffer);\n        this.buffer = \"\";\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n\n\n  digest(encoding) {\n    let digestCache;\n    const buffer = this.buffer;\n\n    if (this.hash === undefined) {\n      // short data for hash, we can use caching\n      const cacheKey = `${this.hashKey}-${encoding}`;\n      digestCache = digestCaches[cacheKey];\n\n      if (digestCache === undefined) {\n        digestCache = digestCaches[cacheKey] = new Map();\n      }\n\n      const cacheEntry = digestCache.get(buffer);\n      if (cacheEntry !== undefined) return cacheEntry;\n      this.hash = this.hashFactory();\n    }\n\n    if (buffer.length > 0) {\n      this.hash.update(buffer);\n    }\n\n    const digestResult = this.hash.digest(encoding);\n    const result = typeof digestResult === \"string\" ? digestResult : digestResult.toString();\n\n    if (digestCache !== undefined) {\n      digestCache.set(buffer, result);\n    }\n\n    return result;\n  }\n\n}\n/* istanbul ignore next */\n\n\nclass DebugHash extends Hash {\n  constructor() {\n    super();\n    this.string = \"\";\n  }\n  /**\n   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n   * @param {string|Buffer} data data\n   * @param {string=} inputEncoding data encoding\n   * @returns {this} updated hash\n   */\n\n\n  update(data, inputEncoding) {\n    if (typeof data !== \"string\") data = data.toString(\"utf-8\");\n\n    if (data.startsWith(\"debug-digest-\")) {\n      data = Buffer.from(data.slice(\"debug-digest-\".length), \"hex\").toString();\n    }\n\n    this.string += `[${data}](${new Error().stack.split(\"\\n\", 3)[2]})\\n`;\n    return this;\n  }\n  /**\n   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n   * @param {string=} encoding encoding of the return value\n   * @returns {string|Buffer} digest\n   */\n\n\n  digest(encoding) {\n    return \"debug-digest-\" + Buffer.from(this.string).toString(\"hex\");\n  }\n\n}\n\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\n/**\n * Creates a hash by name or function\n * @param {string | typeof Hash} algorithm the algorithm name or a constructor creating a hash\n * @returns {Hash} the hash\n */\n\nmodule.exports = algorithm => {\n  if (typeof algorithm === \"function\") {\n    return new BulkUpdateDecorator(() => new algorithm());\n  }\n\n  switch (algorithm) {\n    // TODO add non-cryptographic algorithm here\n    case \"debug\":\n      return new DebugHash();\n\n    case \"xxhash64\":\n      if (createXXHash64 === undefined) {\n        createXXHash64 = require(\"./hash/xxhash64\");\n\n        if (BatchedHash === undefined) {\n          BatchedHash = require(\"./hash/BatchedHash\");\n        }\n      }\n\n      return new BatchedHash(createXXHash64());\n\n    case \"md4\":\n      if (createMd4 === undefined) {\n        createMd4 = require(\"./hash/md4\");\n\n        if (BatchedHash === undefined) {\n          BatchedHash = require(\"./hash/BatchedHash\");\n        }\n      }\n\n      return new BatchedHash(createMd4());\n\n    case \"native-md4\":\n      if (crypto === undefined) crypto = require(\"crypto\");\n      return new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n\n    default:\n      if (crypto === undefined) crypto = require(\"crypto\");\n      return new BulkUpdateDecorator(() => crypto.createHash(algorithm), algorithm);\n  }\n};","map":{"version":3,"names":["Hash","require","BULK_SIZE","digestCaches","BulkUpdateDecorator","constructor","hashOrFactory","hashKey","hashFactory","hash","undefined","buffer","update","data","inputEncoding","length","digest","encoding","digestCache","cacheKey","Map","cacheEntry","get","digestResult","result","toString","set","DebugHash","string","startsWith","Buffer","from","slice","Error","stack","split","crypto","createXXHash64","createMd4","BatchedHash","module","exports","algorithm","createHash"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/util/createHash.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Hash = require(\"./Hash\");\n\nconst BULK_SIZE = 2000;\n\n// We are using an object instead of a Map as this will stay static during the runtime\n// so access to it can be optimized by v8\nconst digestCaches = {};\n\nclass BulkUpdateDecorator extends Hash {\n\t/**\n\t * @param {Hash | function(): Hash} hashOrFactory function to create a hash\n\t * @param {string=} hashKey key for caching\n\t */\n\tconstructor(hashOrFactory, hashKey) {\n\t\tsuper();\n\t\tthis.hashKey = hashKey;\n\t\tif (typeof hashOrFactory === \"function\") {\n\t\t\tthis.hashFactory = hashOrFactory;\n\t\t\tthis.hash = undefined;\n\t\t} else {\n\t\t\tthis.hashFactory = undefined;\n\t\t\tthis.hash = hashOrFactory;\n\t\t}\n\t\tthis.buffer = \"\";\n\t}\n\n\t/**\n\t * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t * @param {string|Buffer} data data\n\t * @param {string=} inputEncoding data encoding\n\t * @returns {this} updated hash\n\t */\n\tupdate(data, inputEncoding) {\n\t\tif (\n\t\t\tinputEncoding !== undefined ||\n\t\t\ttypeof data !== \"string\" ||\n\t\t\tdata.length > BULK_SIZE\n\t\t) {\n\t\t\tif (this.hash === undefined) this.hash = this.hashFactory();\n\t\t\tif (this.buffer.length > 0) {\n\t\t\t\tthis.hash.update(this.buffer);\n\t\t\t\tthis.buffer = \"\";\n\t\t\t}\n\t\t\tthis.hash.update(data, inputEncoding);\n\t\t} else {\n\t\t\tthis.buffer += data;\n\t\t\tif (this.buffer.length > BULK_SIZE) {\n\t\t\t\tif (this.hash === undefined) this.hash = this.hashFactory();\n\t\t\t\tthis.hash.update(this.buffer);\n\t\t\t\tthis.buffer = \"\";\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t * @param {string=} encoding encoding of the return value\n\t * @returns {string|Buffer} digest\n\t */\n\tdigest(encoding) {\n\t\tlet digestCache;\n\t\tconst buffer = this.buffer;\n\t\tif (this.hash === undefined) {\n\t\t\t// short data for hash, we can use caching\n\t\t\tconst cacheKey = `${this.hashKey}-${encoding}`;\n\t\t\tdigestCache = digestCaches[cacheKey];\n\t\t\tif (digestCache === undefined) {\n\t\t\t\tdigestCache = digestCaches[cacheKey] = new Map();\n\t\t\t}\n\t\t\tconst cacheEntry = digestCache.get(buffer);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tthis.hash = this.hashFactory();\n\t\t}\n\t\tif (buffer.length > 0) {\n\t\t\tthis.hash.update(buffer);\n\t\t}\n\t\tconst digestResult = this.hash.digest(encoding);\n\t\tconst result =\n\t\t\ttypeof digestResult === \"string\" ? digestResult : digestResult.toString();\n\t\tif (digestCache !== undefined) {\n\t\t\tdigestCache.set(buffer, result);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/* istanbul ignore next */\nclass DebugHash extends Hash {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.string = \"\";\n\t}\n\n\t/**\n\t * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}\n\t * @param {string|Buffer} data data\n\t * @param {string=} inputEncoding data encoding\n\t * @returns {this} updated hash\n\t */\n\tupdate(data, inputEncoding) {\n\t\tif (typeof data !== \"string\") data = data.toString(\"utf-8\");\n\t\tif (data.startsWith(\"debug-digest-\")) {\n\t\t\tdata = Buffer.from(data.slice(\"debug-digest-\".length), \"hex\").toString();\n\t\t}\n\t\tthis.string += `[${data}](${new Error().stack.split(\"\\n\", 3)[2]})\\n`;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}\n\t * @param {string=} encoding encoding of the return value\n\t * @returns {string|Buffer} digest\n\t */\n\tdigest(encoding) {\n\t\treturn \"debug-digest-\" + Buffer.from(this.string).toString(\"hex\");\n\t}\n}\n\nlet crypto = undefined;\nlet createXXHash64 = undefined;\nlet createMd4 = undefined;\nlet BatchedHash = undefined;\n\n/**\n * Creates a hash by name or function\n * @param {string | typeof Hash} algorithm the algorithm name or a constructor creating a hash\n * @returns {Hash} the hash\n */\nmodule.exports = algorithm => {\n\tif (typeof algorithm === \"function\") {\n\t\treturn new BulkUpdateDecorator(() => new algorithm());\n\t}\n\tswitch (algorithm) {\n\t\t// TODO add non-cryptographic algorithm here\n\t\tcase \"debug\":\n\t\t\treturn new DebugHash();\n\t\tcase \"xxhash64\":\n\t\t\tif (createXXHash64 === undefined) {\n\t\t\t\tcreateXXHash64 = require(\"./hash/xxhash64\");\n\t\t\t\tif (BatchedHash === undefined) {\n\t\t\t\t\tBatchedHash = require(\"./hash/BatchedHash\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new BatchedHash(createXXHash64());\n\t\tcase \"md4\":\n\t\t\tif (createMd4 === undefined) {\n\t\t\t\tcreateMd4 = require(\"./hash/md4\");\n\t\t\t\tif (BatchedHash === undefined) {\n\t\t\t\t\tBatchedHash = require(\"./hash/BatchedHash\");\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new BatchedHash(createMd4());\n\t\tcase \"native-md4\":\n\t\t\tif (crypto === undefined) crypto = require(\"crypto\");\n\t\t\treturn new BulkUpdateDecorator(() => crypto.createHash(\"md4\"), \"md4\");\n\t\tdefault:\n\t\t\tif (crypto === undefined) crypto = require(\"crypto\");\n\t\t\treturn new BulkUpdateDecorator(\n\t\t\t\t() => crypto.createHash(algorithm),\n\t\t\t\talgorithm\n\t\t\t);\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}