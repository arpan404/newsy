{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Cache\").Etag} Etag */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n\nclass MemoryWithGcCachePlugin {\n  constructor(_ref) {\n    let {\n      maxGenerations\n    } = _ref;\n    this._maxGenerations = maxGenerations;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const maxGenerations = this._maxGenerations;\n    /** @type {Map<string, { etag: Etag | null, data: any }>} */\n\n    const cache = new Map();\n    /** @type {Map<string, { entry: { etag: Etag | null, data: any }, until: number }>} */\n\n    const oldCache = new Map();\n    let generation = 0;\n    let cachePosition = 0;\n    const logger = compiler.getInfrastructureLogger(\"MemoryWithGcCachePlugin\");\n    compiler.hooks.afterDone.tap(\"MemoryWithGcCachePlugin\", () => {\n      generation++;\n      let clearedEntries = 0;\n      let lastClearedIdentifier;\n\n      for (const [identifier, entry] of oldCache) {\n        if (entry.until > generation) break;\n        oldCache.delete(identifier);\n\n        if (cache.get(identifier) === undefined) {\n          cache.delete(identifier);\n          clearedEntries++;\n          lastClearedIdentifier = identifier;\n        }\n      }\n\n      if (clearedEntries > 0 || oldCache.size > 0) {\n        logger.log(`${cache.size - oldCache.size} active entries, ${oldCache.size} recently unused cached entries${clearedEntries > 0 ? `, ${clearedEntries} old unused cache entries removed e. g. ${lastClearedIdentifier}` : \"\"}`);\n      }\n\n      let i = cache.size / maxGenerations | 0;\n      let j = cachePosition >= cache.size ? 0 : cachePosition;\n      cachePosition = j + i;\n\n      for (const [identifier, entry] of cache) {\n        if (j !== 0) {\n          j--;\n          continue;\n        }\n\n        if (entry !== undefined) {\n          // We don't delete the cache entry, but set it to undefined instead\n          // This reserves the location in the data table and avoids rehashing\n          // when constantly adding and removing entries.\n          // It will be deleted when removed from oldCache.\n          cache.set(identifier, undefined);\n          oldCache.delete(identifier);\n          oldCache.set(identifier, {\n            entry,\n            until: generation + maxGenerations\n          });\n          if (i-- === 0) break;\n        }\n      }\n    });\n    compiler.cache.hooks.store.tap({\n      name: \"MemoryWithGcCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, (identifier, etag, data) => {\n      cache.set(identifier, {\n        etag,\n        data\n      });\n    });\n    compiler.cache.hooks.get.tap({\n      name: \"MemoryWithGcCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, (identifier, etag, gotHandlers) => {\n      const cacheEntry = cache.get(identifier);\n\n      if (cacheEntry === null) {\n        return null;\n      } else if (cacheEntry !== undefined) {\n        return cacheEntry.etag === etag ? cacheEntry.data : null;\n      }\n\n      const oldCacheEntry = oldCache.get(identifier);\n\n      if (oldCacheEntry !== undefined) {\n        const cacheEntry = oldCacheEntry.entry;\n\n        if (cacheEntry === null) {\n          oldCache.delete(identifier);\n          cache.set(identifier, cacheEntry);\n          return null;\n        } else {\n          if (cacheEntry.etag !== etag) return null;\n          oldCache.delete(identifier);\n          cache.set(identifier, cacheEntry);\n          return cacheEntry.data;\n        }\n      }\n\n      gotHandlers.push((result, callback) => {\n        if (result === undefined) {\n          cache.set(identifier, null);\n        } else {\n          cache.set(identifier, {\n            etag,\n            data: result\n          });\n        }\n\n        return callback();\n      });\n    });\n    compiler.cache.hooks.shutdown.tap({\n      name: \"MemoryWithGcCachePlugin\",\n      stage: Cache.STAGE_MEMORY\n    }, () => {\n      cache.clear();\n      oldCache.clear();\n    });\n  }\n\n}\n\nmodule.exports = MemoryWithGcCachePlugin;","map":{"version":3,"names":["Cache","require","MemoryWithGcCachePlugin","constructor","maxGenerations","_maxGenerations","apply","compiler","cache","Map","oldCache","generation","cachePosition","logger","getInfrastructureLogger","hooks","afterDone","tap","clearedEntries","lastClearedIdentifier","identifier","entry","until","delete","get","undefined","size","log","i","j","set","store","name","stage","STAGE_MEMORY","etag","data","gotHandlers","cacheEntry","oldCacheEntry","push","result","callback","shutdown","clear","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/cache/MemoryWithGcCachePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Cache = require(\"../Cache\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Cache\").Etag} Etag */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\nclass MemoryWithGcCachePlugin {\n\tconstructor({ maxGenerations }) {\n\t\tthis._maxGenerations = maxGenerations;\n\t}\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst maxGenerations = this._maxGenerations;\n\t\t/** @type {Map<string, { etag: Etag | null, data: any }>} */\n\t\tconst cache = new Map();\n\t\t/** @type {Map<string, { entry: { etag: Etag | null, data: any }, until: number }>} */\n\t\tconst oldCache = new Map();\n\t\tlet generation = 0;\n\t\tlet cachePosition = 0;\n\t\tconst logger = compiler.getInfrastructureLogger(\"MemoryWithGcCachePlugin\");\n\t\tcompiler.hooks.afterDone.tap(\"MemoryWithGcCachePlugin\", () => {\n\t\t\tgeneration++;\n\t\t\tlet clearedEntries = 0;\n\t\t\tlet lastClearedIdentifier;\n\t\t\tfor (const [identifier, entry] of oldCache) {\n\t\t\t\tif (entry.until > generation) break;\n\n\t\t\t\toldCache.delete(identifier);\n\t\t\t\tif (cache.get(identifier) === undefined) {\n\t\t\t\t\tcache.delete(identifier);\n\t\t\t\t\tclearedEntries++;\n\t\t\t\t\tlastClearedIdentifier = identifier;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (clearedEntries > 0 || oldCache.size > 0) {\n\t\t\t\tlogger.log(\n\t\t\t\t\t`${cache.size - oldCache.size} active entries, ${\n\t\t\t\t\t\toldCache.size\n\t\t\t\t\t} recently unused cached entries${\n\t\t\t\t\t\tclearedEntries > 0\n\t\t\t\t\t\t\t? `, ${clearedEntries} old unused cache entries removed e. g. ${lastClearedIdentifier}`\n\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t}`\n\t\t\t\t);\n\t\t\t}\n\t\t\tlet i = (cache.size / maxGenerations) | 0;\n\t\t\tlet j = cachePosition >= cache.size ? 0 : cachePosition;\n\t\t\tcachePosition = j + i;\n\t\t\tfor (const [identifier, entry] of cache) {\n\t\t\t\tif (j !== 0) {\n\t\t\t\t\tj--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (entry !== undefined) {\n\t\t\t\t\t// We don't delete the cache entry, but set it to undefined instead\n\t\t\t\t\t// This reserves the location in the data table and avoids rehashing\n\t\t\t\t\t// when constantly adding and removing entries.\n\t\t\t\t\t// It will be deleted when removed from oldCache.\n\t\t\t\t\tcache.set(identifier, undefined);\n\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\toldCache.set(identifier, {\n\t\t\t\t\t\tentry,\n\t\t\t\t\t\tuntil: generation + maxGenerations\n\t\t\t\t\t});\n\t\t\t\t\tif (i-- === 0) break;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tcompiler.cache.hooks.store.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, data) => {\n\t\t\t\tcache.set(identifier, { etag, data });\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.get.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t(identifier, etag, gotHandlers) => {\n\t\t\t\tconst cacheEntry = cache.get(identifier);\n\t\t\t\tif (cacheEntry === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else if (cacheEntry !== undefined) {\n\t\t\t\t\treturn cacheEntry.etag === etag ? cacheEntry.data : null;\n\t\t\t\t}\n\t\t\t\tconst oldCacheEntry = oldCache.get(identifier);\n\t\t\t\tif (oldCacheEntry !== undefined) {\n\t\t\t\t\tconst cacheEntry = oldCacheEntry.entry;\n\t\t\t\t\tif (cacheEntry === null) {\n\t\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\t\tcache.set(identifier, cacheEntry);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (cacheEntry.etag !== etag) return null;\n\t\t\t\t\t\toldCache.delete(identifier);\n\t\t\t\t\t\tcache.set(identifier, cacheEntry);\n\t\t\t\t\t\treturn cacheEntry.data;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgotHandlers.push((result, callback) => {\n\t\t\t\t\tif (result === undefined) {\n\t\t\t\t\t\tcache.set(identifier, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcache.set(identifier, { etag, data: result });\n\t\t\t\t\t}\n\t\t\t\t\treturn callback();\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t\tcompiler.cache.hooks.shutdown.tap(\n\t\t\t{ name: \"MemoryWithGcCachePlugin\", stage: Cache.STAGE_MEMORY },\n\t\t\t() => {\n\t\t\t\tcache.clear();\n\t\t\t\toldCache.clear();\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = MemoryWithGcCachePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}