{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  Parser: AcornParser\n} = require(\"acorn\");\n\nconst {\n  importAssertions\n} = require(\"acorn-import-assertions\");\n\nconst {\n  SyncBailHook,\n  HookMap\n} = require(\"tapable\");\n\nconst vm = require(\"vm\");\n\nconst Parser = require(\"../Parser\");\n\nconst StackedMap = require(\"../util/StackedMap\");\n\nconst binarySearchBounds = require(\"../util/binarySearchBounds\");\n\nconst memoize = require(\"../util/memoize\");\n\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n/** @typedef {import(\"acorn\").Options} AcornOptions */\n\n/** @typedef {import(\"estree\").ArrayExpression} ArrayExpressionNode */\n\n/** @typedef {import(\"estree\").BinaryExpression} BinaryExpressionNode */\n\n/** @typedef {import(\"estree\").BlockStatement} BlockStatementNode */\n\n/** @typedef {import(\"estree\").SequenceExpression} SequenceExpressionNode */\n\n/** @typedef {import(\"estree\").CallExpression} CallExpressionNode */\n\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n\n/** @typedef {import(\"estree\").Comment} CommentNode */\n\n/** @typedef {import(\"estree\").ConditionalExpression} ConditionalExpressionNode */\n\n/** @typedef {import(\"estree\").Declaration} DeclarationNode */\n\n/** @typedef {import(\"estree\").PrivateIdentifier} PrivateIdentifierNode */\n\n/** @typedef {import(\"estree\").PropertyDefinition} PropertyDefinitionNode */\n\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n\n/** @typedef {import(\"estree\").Identifier} IdentifierNode */\n\n/** @typedef {import(\"estree\").IfStatement} IfStatementNode */\n\n/** @typedef {import(\"estree\").LabeledStatement} LabeledStatementNode */\n\n/** @typedef {import(\"estree\").Literal} LiteralNode */\n\n/** @typedef {import(\"estree\").LogicalExpression} LogicalExpressionNode */\n\n/** @typedef {import(\"estree\").ChainExpression} ChainExpressionNode */\n\n/** @typedef {import(\"estree\").MemberExpression} MemberExpressionNode */\n\n/** @typedef {import(\"estree\").MetaProperty} MetaPropertyNode */\n\n/** @typedef {import(\"estree\").MethodDefinition} MethodDefinitionNode */\n\n/** @typedef {import(\"estree\").ModuleDeclaration} ModuleDeclarationNode */\n\n/** @typedef {import(\"estree\").NewExpression} NewExpressionNode */\n\n/** @typedef {import(\"estree\").Node} AnyNode */\n\n/** @typedef {import(\"estree\").Program} ProgramNode */\n\n/** @typedef {import(\"estree\").Statement} StatementNode */\n\n/** @typedef {import(\"estree\").ImportDeclaration} ImportDeclarationNode */\n\n/** @typedef {import(\"estree\").ExportNamedDeclaration} ExportNamedDeclarationNode */\n\n/** @typedef {import(\"estree\").ExportDefaultDeclaration} ExportDefaultDeclarationNode */\n\n/** @typedef {import(\"estree\").ExportAllDeclaration} ExportAllDeclarationNode */\n\n/** @typedef {import(\"estree\").Super} SuperNode */\n\n/** @typedef {import(\"estree\").TaggedTemplateExpression} TaggedTemplateExpressionNode */\n\n/** @typedef {import(\"estree\").TemplateLiteral} TemplateLiteralNode */\n\n/** @typedef {import(\"estree\").ThisExpression} ThisExpressionNode */\n\n/** @typedef {import(\"estree\").UnaryExpression} UnaryExpressionNode */\n\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\n\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n\n/** @typedef {{declaredScope: ScopeInfo, freeName: string | true, tagInfo: TagInfo | undefined}} VariableInfoInterface */\n\n/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[], getMembersOptionals: () => boolean[] }} GetInfoResult */\n\n\nconst EMPTY_ARRAY = [];\nconst ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;\nconst ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;\nconst ALLOWED_MEMBER_TYPES_ALL = 0b11; // Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst parser = AcornParser.extend(importAssertions);\n\nclass VariableInfo {\n  /**\n   * @param {ScopeInfo} declaredScope scope in which the variable is declared\n   * @param {string | true} freeName which free name the variable aliases, or true when none\n   * @param {TagInfo | undefined} tagInfo info about tags\n   */\n  constructor(declaredScope, freeName, tagInfo) {\n    this.declaredScope = declaredScope;\n    this.freeName = freeName;\n    this.tagInfo = tagInfo;\n  }\n\n}\n/** @typedef {string | ScopeInfo | VariableInfo} ExportedVariableInfo */\n\n/** @typedef {LiteralNode | string | null | undefined} ImportSource */\n\n/** @typedef {Omit<AcornOptions, \"sourceType\" | \"ecmaVersion\"> & { sourceType: \"module\" | \"script\" | \"auto\", ecmaVersion?: AcornOptions[\"ecmaVersion\"] }} ParseOptions */\n\n/**\n * @typedef {Object} TagInfo\n * @property {any} tag\n * @property {any} data\n * @property {TagInfo | undefined} next\n */\n\n/**\n * @typedef {Object} ScopeInfo\n * @property {StackedMap<string, VariableInfo | ScopeInfo>} definitions\n * @property {boolean | \"arrow\"} topLevelScope\n * @property {boolean} inShorthand\n * @property {boolean} isStrict\n * @property {boolean} isAsmJs\n * @property {boolean} inTry\n */\n\n\nconst joinRanges = (startRange, endRange) => {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\n\nconst objectAndMembersToName = (object, membersReversed) => {\n  let name = object;\n\n  for (let i = membersReversed.length - 1; i >= 0; i--) {\n    name = name + \".\" + membersReversed[i];\n  }\n\n  return name;\n};\n\nconst getRootName = expression => {\n  switch (expression.type) {\n    case \"Identifier\":\n      return expression.name;\n\n    case \"ThisExpression\":\n      return \"this\";\n\n    case \"MetaProperty\":\n      return `${expression.meta.name}.${expression.property.name}`;\n\n    default:\n      return undefined;\n  }\n};\n/** @type {AcornOptions} */\n\n\nconst defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: \"latest\",\n  sourceType: \"module\",\n  // https://github.com/tc39/proposal-hashbang\n  allowHashBang: true,\n  onComment: null\n}; // regexp to match at least one \"magic comment\"\n\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nconst EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\n\nclass JavascriptParser extends Parser {\n  /**\n   * @param {\"module\" | \"script\" | \"auto\"} sourceType default source type\n   */\n  constructor() {\n    let sourceType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"auto\";\n    super();\n    this.hooks = Object.freeze({\n      /** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateDefinedIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[NewExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateNewExpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[CallExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateCallExpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */\n      evaluateCallExpressionMember: new HookMap(() => new SyncBailHook([\"expression\", \"param\"])),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */\n      isPure: new HookMap(() => new SyncBailHook([\"expression\", \"commentsStartPosition\"])),\n\n      /** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n      preStatement: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n      blockPreStatement: new SyncBailHook([\"declaration\"]),\n\n      /** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n      statement: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[IfStatementNode], boolean | void>} */\n      statementIf: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n      classExtendsExpression: new SyncBailHook([\"expression\", \"classDefinition\"]),\n\n      /** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n      classBodyElement: new SyncBailHook([\"element\", \"classDefinition\"]),\n\n      /** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n      classBodyValue: new SyncBailHook([\"expression\", \"element\", \"classDefinition\"]),\n\n      /** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */\n      label: new HookMap(() => new SyncBailHook([\"statement\"])),\n\n      /** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */\n      import: new SyncBailHook([\"statement\", \"source\"]),\n\n      /** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */\n      export: new SyncBailHook([\"statement\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\n      /** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n\n      /** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n\n      /** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n      preDeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\n      /** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n      declarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\n      /** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n      varDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\n      /** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */\n      pattern: new HookMap(() => new SyncBailHook([\"pattern\"])),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      canRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      rename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\n      /** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression], boolean | void>>} */\n      assign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression, string[]], boolean | void>>} */\n      assignMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\"])),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      typeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      importCall: new SyncBailHook([\"expression\"]),\n\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      topLevelAwait: new SyncBailHook([\"expression\"]),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      call: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** Something like \"a.b()\" */\n\n      /** @type {HookMap<SyncBailHook<[CallExpressionNode, string[], boolean[]], boolean | void>>} */\n      callMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\", \"membersOptionals\"])),\n\n      /** Something like \"a.b().c.d\" */\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n      memberChainOfCallMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"calleeMembers\", \"callExpression\", \"members\"])),\n\n      /** Something like \"a.b().c.d()\"\" */\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n      callMemberChainOfCallMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"calleeMembers\", \"innerCallExpression\", \"members\"])),\n\n      /** @type {SyncBailHook<[ChainExpressionNode], boolean | void>} */\n      optionalChaining: new SyncBailHook([\"optionalChaining\"]),\n\n      /** @type {HookMap<SyncBailHook<[NewExpressionNode], boolean | void>>} */\n      new: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {SyncBailHook<[BinaryExpressionNode], boolean | void>} */\n      binaryExpression: new SyncBailHook([\"binaryExpression\"]),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n      expression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[], boolean[]], boolean | void>>} */\n      expressionMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\", \"membersOptionals\"])),\n\n      /** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */\n      unhandledExpressionMemberChain: new HookMap(() => new SyncBailHook([\"expression\", \"members\"])),\n\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\n      /** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\n      /** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n      program: new SyncBailHook([\"ast\", \"comments\"]),\n\n      /** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n      finish: new SyncBailHook([\"ast\", \"comments\"])\n    });\n    this.sourceType = sourceType;\n    /** @type {ScopeInfo} */\n\n    this.scope = undefined;\n    /** @type {ParserState} */\n\n    this.state = undefined;\n    this.comments = undefined;\n    this.semicolons = undefined;\n    /** @type {(StatementNode|ExpressionNode)[]} */\n\n    this.statementPath = undefined;\n    this.prevStatement = undefined;\n    this.currentTagData = undefined;\n\n    this._initializeEvaluating();\n  }\n\n  _initializeEvaluating() {\n    this.hooks.evaluate.for(\"Literal\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {LiteralNode} */\n      _expr;\n\n      switch (typeof expr.value) {\n        case \"number\":\n          return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n\n        case \"bigint\":\n          return new BasicEvaluatedExpression().setBigInt(expr.value).setRange(expr.range);\n\n        case \"string\":\n          return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n\n        case \"boolean\":\n          return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n      }\n\n      if (expr.value === null) {\n        return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n      }\n\n      if (expr.value instanceof RegExp) {\n        return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"NewExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {NewExpressionNode} */\n      _expr;\n      const callee = expr.callee;\n      if (callee.type !== \"Identifier\") return;\n\n      if (callee.name !== \"RegExp\") {\n        return this.callHooksForName(this.hooks.evaluateNewExpression, callee.name, expr);\n      } else if (expr.arguments.length > 2 || this.getVariableInfo(\"RegExp\") !== \"RegExp\") return;\n\n      let regExp, flags;\n      const arg1 = expr.arguments[0];\n\n      if (arg1) {\n        if (arg1.type === \"SpreadElement\") return;\n        const evaluatedRegExp = this.evaluateExpression(arg1);\n        if (!evaluatedRegExp) return;\n        regExp = evaluatedRegExp.asString();\n        if (!regExp) return;\n      } else {\n        return new BasicEvaluatedExpression().setRegExp(new RegExp(\"\")).setRange(expr.range);\n      }\n\n      const arg2 = expr.arguments[1];\n\n      if (arg2) {\n        if (arg2.type === \"SpreadElement\") return;\n        const evaluatedFlags = this.evaluateExpression(arg2);\n        if (!evaluatedFlags) return;\n\n        if (!evaluatedFlags.isUndefined()) {\n          flags = evaluatedFlags.asString();\n          if (flags === undefined || !BasicEvaluatedExpression.isValidRegExpFlags(flags)) return;\n        }\n      }\n\n      return new BasicEvaluatedExpression().setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp)).setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"LogicalExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {LogicalExpressionNode} */\n      _expr;\n      const left = this.evaluateExpression(expr.left);\n      let returnRight = false;\n      /** @type {boolean|undefined} */\n\n      let allowedRight;\n\n      if (expr.operator === \"&&\") {\n        const leftAsBool = left.asBool();\n        if (leftAsBool === false) return left.setRange(expr.range);\n        returnRight = leftAsBool === true;\n        allowedRight = false;\n      } else if (expr.operator === \"||\") {\n        const leftAsBool = left.asBool();\n        if (leftAsBool === true) return left.setRange(expr.range);\n        returnRight = leftAsBool === false;\n        allowedRight = true;\n      } else if (expr.operator === \"??\") {\n        const leftAsNullish = left.asNullish();\n        if (leftAsNullish === false) return left.setRange(expr.range);\n        if (leftAsNullish !== true) return;\n        returnRight = true;\n      } else return;\n\n      const right = this.evaluateExpression(expr.right);\n\n      if (returnRight) {\n        if (left.couldHaveSideEffects()) right.setSideEffects();\n        return right.setRange(expr.range);\n      }\n\n      const asBool = right.asBool();\n\n      if (allowedRight === true && asBool === true) {\n        return new BasicEvaluatedExpression().setRange(expr.range).setTruthy();\n      } else if (allowedRight === false && asBool === false) {\n        return new BasicEvaluatedExpression().setRange(expr.range).setFalsy();\n      }\n    });\n\n    const valueAsExpression = (value, expr, sideEffects) => {\n      switch (typeof value) {\n        case \"boolean\":\n          return new BasicEvaluatedExpression().setBoolean(value).setSideEffects(sideEffects).setRange(expr.range);\n\n        case \"number\":\n          return new BasicEvaluatedExpression().setNumber(value).setSideEffects(sideEffects).setRange(expr.range);\n\n        case \"bigint\":\n          return new BasicEvaluatedExpression().setBigInt(value).setSideEffects(sideEffects).setRange(expr.range);\n\n        case \"string\":\n          return new BasicEvaluatedExpression().setString(value).setSideEffects(sideEffects).setRange(expr.range);\n      }\n    };\n\n    this.hooks.evaluate.for(\"BinaryExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {BinaryExpressionNode} */\n      _expr;\n\n      const handleConstOperation = fn => {\n        const left = this.evaluateExpression(expr.left);\n        if (!left.isCompileTimeValue()) return;\n        const right = this.evaluateExpression(expr.right);\n        if (!right.isCompileTimeValue()) return;\n        const result = fn(left.asCompileTimeValue(), right.asCompileTimeValue());\n        return valueAsExpression(result, expr, left.couldHaveSideEffects() || right.couldHaveSideEffects());\n      };\n\n      const isAlwaysDifferent = (a, b) => a === true && b === false || a === false && b === true;\n\n      const handleTemplateStringCompare = (left, right, res, eql) => {\n        const getPrefix = parts => {\n          let value = \"\";\n\n          for (const p of parts) {\n            const v = p.asString();\n            if (v !== undefined) value += v;else break;\n          }\n\n          return value;\n        };\n\n        const getSuffix = parts => {\n          let value = \"\";\n\n          for (let i = parts.length - 1; i >= 0; i--) {\n            const v = parts[i].asString();\n            if (v !== undefined) value = v + value;else break;\n          }\n\n          return value;\n        };\n\n        const leftPrefix = getPrefix(left.parts);\n        const rightPrefix = getPrefix(right.parts);\n        const leftSuffix = getSuffix(left.parts);\n        const rightSuffix = getSuffix(right.parts);\n        const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);\n        const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);\n\n        if (leftPrefix.slice(0, lenPrefix) !== rightPrefix.slice(0, lenPrefix) || leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n      };\n\n      const handleStrictEqualityComparison = eql => {\n        const left = this.evaluateExpression(expr.left);\n        const right = this.evaluateExpression(expr.right);\n        const res = new BasicEvaluatedExpression();\n        res.setRange(expr.range);\n        const leftConst = left.isCompileTimeValue();\n        const rightConst = right.isCompileTimeValue();\n\n        if (leftConst && rightConst) {\n          return res.setBoolean(eql === (left.asCompileTimeValue() === right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n\n        if (left.isArray() && right.isArray()) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n\n        if (left.isTemplateString() && right.isTemplateString()) {\n          return handleTemplateStringCompare(left, right, res, eql);\n        }\n\n        const leftPrimitive = left.isPrimitiveType();\n        const rightPrimitive = right.isPrimitiveType();\n\n        if ( // Primitive !== Object or\n        // compile-time object types are never equal to something at runtime\n        leftPrimitive === false && (leftConst || rightPrimitive === true) || rightPrimitive === false && (rightConst || leftPrimitive === true) || // Different nullish or boolish status also means not equal\n        isAlwaysDifferent(left.asBool(), right.asBool()) || isAlwaysDifferent(left.asNullish(), right.asNullish())) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n      };\n\n      const handleAbstractEqualityComparison = eql => {\n        const left = this.evaluateExpression(expr.left);\n        const right = this.evaluateExpression(expr.right);\n        const res = new BasicEvaluatedExpression();\n        res.setRange(expr.range);\n        const leftConst = left.isCompileTimeValue();\n        const rightConst = right.isCompileTimeValue();\n\n        if (leftConst && rightConst) {\n          return res.setBoolean(eql === ( // eslint-disable-next-line eqeqeq\n          left.asCompileTimeValue() == right.asCompileTimeValue())).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n\n        if (left.isArray() && right.isArray()) {\n          return res.setBoolean(!eql).setSideEffects(left.couldHaveSideEffects() || right.couldHaveSideEffects());\n        }\n\n        if (left.isTemplateString() && right.isTemplateString()) {\n          return handleTemplateStringCompare(left, right, res, eql);\n        }\n      };\n\n      if (expr.operator === \"+\") {\n        const left = this.evaluateExpression(expr.left);\n        const right = this.evaluateExpression(expr.right);\n        const res = new BasicEvaluatedExpression();\n\n        if (left.isString()) {\n          if (right.isString()) {\n            res.setString(left.string + right.string);\n          } else if (right.isNumber()) {\n            res.setString(left.string + right.number);\n          } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n            // \"left\" + (\"prefix\" + inner + \"postfix\")\n            // => (\"leftPrefix\" + inner + \"postfix\")\n            res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // \"left\" + ([null] + inner + \"postfix\")\n            // => (\"left\" + inner + \"postfix\")\n            res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n          } else {\n            // \"left\" + expr\n            // => (\"left\" + expr + \"\")\n            res.setWrapped(left, null, [right]);\n          }\n        } else if (left.isNumber()) {\n          if (right.isString()) {\n            res.setString(left.number + right.string);\n          } else if (right.isNumber()) {\n            res.setNumber(left.number + right.number);\n          } else {\n            return;\n          }\n        } else if (left.isBigInt()) {\n          if (right.isBigInt()) {\n            res.setBigInt(left.bigint + right.bigint);\n          }\n        } else if (left.isWrapped()) {\n          if (left.postfix && left.postfix.isString() && right.isString()) {\n            // (\"prefix\" + inner + \"postfix\") + \"right\"\n            // => (\"prefix\" + inner + \"postfixRight\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n            // (\"prefix\" + inner + \"postfix\") + 123\n            // => (\"prefix\" + inner + \"postfix123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (right.isString()) {\n            // (\"prefix\" + inner + [null]) + \"right\"\n            // => (\"prefix\" + inner + \"right\")\n            res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n          } else if (right.isNumber()) {\n            // (\"prefix\" + inner + [null]) + 123\n            // => (\"prefix\" + inner + \"123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n            // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n            res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n          } else {\n            // (\"prefix\" + inner + postfix) + expr\n            // => (\"prefix\" + inner + postfix + expr + [null])\n            res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n          }\n        } else {\n          if (right.isString()) {\n            // left + \"right\"\n            // => ([null] + left + \"right\")\n            res.setWrapped(null, right, [left]);\n          } else if (right.isWrapped()) {\n            // left + (prefix + inner + \"postfix\")\n            // => ([null] + left + prefix + inner + \"postfix\")\n            res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n          } else {\n            return;\n          }\n        }\n\n        if (left.couldHaveSideEffects() || right.couldHaveSideEffects()) res.setSideEffects();\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"-\") {\n        return handleConstOperation((l, r) => l - r);\n      } else if (expr.operator === \"*\") {\n        return handleConstOperation((l, r) => l * r);\n      } else if (expr.operator === \"/\") {\n        return handleConstOperation((l, r) => l / r);\n      } else if (expr.operator === \"**\") {\n        return handleConstOperation((l, r) => l ** r);\n      } else if (expr.operator === \"===\") {\n        return handleStrictEqualityComparison(true);\n      } else if (expr.operator === \"==\") {\n        return handleAbstractEqualityComparison(true);\n      } else if (expr.operator === \"!==\") {\n        return handleStrictEqualityComparison(false);\n      } else if (expr.operator === \"!=\") {\n        return handleAbstractEqualityComparison(false);\n      } else if (expr.operator === \"&\") {\n        return handleConstOperation((l, r) => l & r);\n      } else if (expr.operator === \"|\") {\n        return handleConstOperation((l, r) => l | r);\n      } else if (expr.operator === \"^\") {\n        return handleConstOperation((l, r) => l ^ r);\n      } else if (expr.operator === \">>>\") {\n        return handleConstOperation((l, r) => l >>> r);\n      } else if (expr.operator === \">>\") {\n        return handleConstOperation((l, r) => l >> r);\n      } else if (expr.operator === \"<<\") {\n        return handleConstOperation((l, r) => l << r);\n      } else if (expr.operator === \"<\") {\n        return handleConstOperation((l, r) => l < r);\n      } else if (expr.operator === \">\") {\n        return handleConstOperation((l, r) => l > r);\n      } else if (expr.operator === \"<=\") {\n        return handleConstOperation((l, r) => l <= r);\n      } else if (expr.operator === \">=\") {\n        return handleConstOperation((l, r) => l >= r);\n      }\n    });\n    this.hooks.evaluate.for(\"UnaryExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {UnaryExpressionNode} */\n      _expr;\n\n      const handleConstOperation = fn => {\n        const argument = this.evaluateExpression(expr.argument);\n        if (!argument.isCompileTimeValue()) return;\n        const result = fn(argument.asCompileTimeValue());\n        return valueAsExpression(result, expr, argument.couldHaveSideEffects());\n      };\n\n      if (expr.operator === \"typeof\") {\n        switch (expr.argument.type) {\n          case \"Identifier\":\n            {\n              const res = this.callHooksForName(this.hooks.evaluateTypeof, expr.argument.name, expr);\n              if (res !== undefined) return res;\n              break;\n            }\n\n          case \"MetaProperty\":\n            {\n              const res = this.callHooksForName(this.hooks.evaluateTypeof, getRootName(expr.argument), expr);\n              if (res !== undefined) return res;\n              break;\n            }\n\n          case \"MemberExpression\":\n            {\n              const res = this.callHooksForExpression(this.hooks.evaluateTypeof, expr.argument, expr);\n              if (res !== undefined) return res;\n              break;\n            }\n\n          case \"ChainExpression\":\n            {\n              const res = this.callHooksForExpression(this.hooks.evaluateTypeof, expr.argument.expression, expr);\n              if (res !== undefined) return res;\n              break;\n            }\n\n          case \"FunctionExpression\":\n            {\n              return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n            }\n        }\n\n        const arg = this.evaluateExpression(expr.argument);\n        if (arg.isUnknown()) return;\n\n        if (arg.isString()) {\n          return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n        }\n\n        if (arg.isWrapped()) {\n          return new BasicEvaluatedExpression().setString(\"string\").setSideEffects().setRange(expr.range);\n        }\n\n        if (arg.isUndefined()) {\n          return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n        }\n\n        if (arg.isNumber()) {\n          return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n        }\n\n        if (arg.isBigInt()) {\n          return new BasicEvaluatedExpression().setString(\"bigint\").setRange(expr.range);\n        }\n\n        if (arg.isBoolean()) {\n          return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n        }\n\n        if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {\n          return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n        }\n\n        if (arg.isArray()) {\n          return new BasicEvaluatedExpression().setString(\"object\").setSideEffects(arg.couldHaveSideEffects()).setRange(expr.range);\n        }\n      } else if (expr.operator === \"!\") {\n        const argument = this.evaluateExpression(expr.argument);\n        const bool = argument.asBool();\n        if (typeof bool !== \"boolean\") return;\n        return new BasicEvaluatedExpression().setBoolean(!bool).setSideEffects(argument.couldHaveSideEffects()).setRange(expr.range);\n      } else if (expr.operator === \"~\") {\n        return handleConstOperation(v => ~v);\n      } else if (expr.operator === \"+\") {\n        return handleConstOperation(v => +v);\n      } else if (expr.operator === \"-\") {\n        return handleConstOperation(v => -v);\n      }\n    });\n    this.hooks.evaluateTypeof.for(\"undefined\").tap(\"JavascriptParser\", expr => {\n      return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"Identifier\").tap(\"JavascriptParser\", expr => {\n      if (\n      /** @type {IdentifierNode} */\n      expr.name === \"undefined\") {\n        return new BasicEvaluatedExpression().setUndefined().setRange(expr.range);\n      }\n    });\n    /**\n     * @param {string} exprType expression type name\n     * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info\n     * @returns {void}\n     */\n\n    const tapEvaluateWithVariableInfo = (exprType, getInfo) => {\n      /** @type {ExpressionNode | undefined} */\n      let cachedExpression = undefined;\n      /** @type {GetInfoResult | undefined} */\n\n      let cachedInfo = undefined;\n      this.hooks.evaluate.for(exprType).tap(\"JavascriptParser\", expr => {\n        const expression =\n        /** @type {MemberExpressionNode} */\n        expr;\n        const info = getInfo(expr);\n\n        if (info !== undefined) {\n          return this.callHooksForInfoWithFallback(this.hooks.evaluateIdentifier, info.name, name => {\n            cachedExpression = expression;\n            cachedInfo = info;\n          }, name => {\n            const hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\n            if (hook !== undefined) {\n              return hook.call(expression);\n            }\n          }, expression);\n        }\n      });\n      this.hooks.evaluate.for(exprType).tap({\n        name: \"JavascriptParser\",\n        stage: 100\n      }, expr => {\n        const info = cachedExpression === expr ? cachedInfo : getInfo(expr);\n\n        if (info !== undefined) {\n          return new BasicEvaluatedExpression().setIdentifier(info.name, info.rootInfo, info.getMembers, info.getMembersOptionals).setRange(expr.range);\n        }\n      });\n      this.hooks.finish.tap(\"JavascriptParser\", () => {\n        // Cleanup for GC\n        cachedExpression = cachedInfo = undefined;\n      });\n    };\n\n    tapEvaluateWithVariableInfo(\"Identifier\", expr => {\n      const info = this.getVariableInfo(\n      /** @type {IdentifierNode} */\n      expr.name);\n\n      if (typeof info === \"string\" || info instanceof VariableInfo && typeof info.freeName === \"string\") {\n        return {\n          name: info,\n          rootInfo: info,\n          getMembers: () => [],\n          getMembersOptionals: () => []\n        };\n      }\n    });\n    tapEvaluateWithVariableInfo(\"ThisExpression\", expr => {\n      const info = this.getVariableInfo(\"this\");\n\n      if (typeof info === \"string\" || info instanceof VariableInfo && typeof info.freeName === \"string\") {\n        return {\n          name: info,\n          rootInfo: info,\n          getMembers: () => [],\n          getMembersOptionals: () => []\n        };\n      }\n    });\n    this.hooks.evaluate.for(\"MetaProperty\").tap(\"JavascriptParser\", expr => {\n      const metaProperty =\n      /** @type {MetaPropertyNode} */\n      expr;\n      return this.callHooksForName(this.hooks.evaluateIdentifier, getRootName(expr), metaProperty);\n    });\n    tapEvaluateWithVariableInfo(\"MemberExpression\", expr => this.getMemberExpressionInfo(\n    /** @type {MemberExpressionNode} */\n    expr, ALLOWED_MEMBER_TYPES_EXPRESSION));\n    this.hooks.evaluate.for(\"CallExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {CallExpressionNode} */\n      _expr;\n\n      if (expr.callee.type === \"MemberExpression\" && expr.callee.property.type === (expr.callee.computed ? \"Literal\" : \"Identifier\")) {\n        // type Super also possible here\n        const param = this.evaluateExpression(\n        /** @type {ExpressionNode} */\n        expr.callee.object);\n        const property = expr.callee.property.type === \"Literal\" ? `${expr.callee.property.value}` : expr.callee.property.name;\n        const hook = this.hooks.evaluateCallExpressionMember.get(property);\n\n        if (hook !== undefined) {\n          return hook.call(expr, param);\n        }\n      } else if (expr.callee.type === \"Identifier\") {\n        return this.callHooksForName(this.hooks.evaluateCallExpression, expr.callee.name, expr);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"indexOf\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length === 0) return;\n      const [arg1, arg2] = expr.arguments;\n      if (arg1.type === \"SpreadElement\") return;\n      const arg1Eval = this.evaluateExpression(arg1);\n      if (!arg1Eval.isString()) return;\n      const arg1Value = arg1Eval.string;\n      let result;\n\n      if (arg2) {\n        if (arg2.type === \"SpreadElement\") return;\n        const arg2Eval = this.evaluateExpression(arg2);\n        if (!arg2Eval.isNumber()) return;\n        result = param.string.indexOf(arg1Value, arg2Eval.number);\n      } else {\n        result = param.string.indexOf(arg1Value);\n      }\n\n      return new BasicEvaluatedExpression().setNumber(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 2) return;\n      if (expr.arguments[0].type === \"SpreadElement\") return;\n      if (expr.arguments[1].type === \"SpreadElement\") return;\n      let arg1 = this.evaluateExpression(expr.arguments[0]);\n      let arg2 = this.evaluateExpression(expr.arguments[1]);\n      if (!arg1.isString() && !arg1.isRegExp()) return;\n      const arg1Value = arg1.regExp || arg1.string;\n      if (!arg2.isString()) return;\n      const arg2Value = arg2.string;\n      return new BasicEvaluatedExpression().setString(param.string.replace(arg1Value, arg2Value)).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n    });\n    [\"substr\", \"substring\", \"slice\"].forEach(fn => {\n      this.hooks.evaluateCallExpressionMember.for(fn).tap(\"JavascriptParser\", (expr, param) => {\n        if (!param.isString()) return;\n        let arg1;\n        let result,\n            str = param.string;\n\n        switch (expr.arguments.length) {\n          case 1:\n            if (expr.arguments[0].type === \"SpreadElement\") return;\n            arg1 = this.evaluateExpression(expr.arguments[0]);\n            if (!arg1.isNumber()) return;\n            result = str[fn](arg1.number);\n            break;\n\n          case 2:\n            {\n              if (expr.arguments[0].type === \"SpreadElement\") return;\n              if (expr.arguments[1].type === \"SpreadElement\") return;\n              arg1 = this.evaluateExpression(expr.arguments[0]);\n              const arg2 = this.evaluateExpression(expr.arguments[1]);\n              if (!arg1.isNumber()) return;\n              if (!arg2.isNumber()) return;\n              result = str[fn](arg1.number, arg2.number);\n              break;\n            }\n\n          default:\n            return;\n        }\n\n        return new BasicEvaluatedExpression().setString(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n      });\n    });\n    /**\n     * @param {\"cooked\" | \"raw\"} kind kind of values to get\n     * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr\n     * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n     */\n\n    const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n      /** @type {BasicEvaluatedExpression[]} */\n      const quasis = [];\n      /** @type {BasicEvaluatedExpression[]} */\n\n      const parts = [];\n\n      for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n        const quasiExpr = templateLiteralExpr.quasis[i];\n        const quasi = quasiExpr.value[kind];\n\n        if (i > 0) {\n          const prevExpr = parts[parts.length - 1];\n          const expr = this.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n          const exprAsString = expr.asString();\n\n          if (typeof exprAsString === \"string\" && !expr.couldHaveSideEffects()) {\n            // We can merge quasi + expr + quasi when expr\n            // is a const string\n            prevExpr.setString(prevExpr.string + exprAsString + quasi);\n            prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]); // We unset the expression as it doesn't match to a single expression\n\n            prevExpr.setExpression(undefined);\n            continue;\n          }\n\n          parts.push(expr);\n        }\n\n        const part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);\n        quasis.push(part);\n        parts.push(part);\n      }\n\n      return {\n        quasis,\n        parts\n      };\n    };\n\n    this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"JavascriptParser\", _node => {\n      const node =\n      /** @type {TemplateLiteralNode} */\n      _node;\n      const {\n        quasis,\n        parts\n      } = getSimplifiedTemplateResult(\"cooked\", node);\n\n      if (parts.length === 1) {\n        return parts[0].setRange(node.range);\n      }\n\n      return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(node.range);\n    });\n    this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"JavascriptParser\", _node => {\n      const node =\n      /** @type {TaggedTemplateExpressionNode} */\n      _node;\n      const tag = this.evaluateExpression(node.tag);\n\n      if (tag.isIdentifier() && tag.identifier === \"String.raw\") {\n        const {\n          quasis,\n          parts\n        } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(node.range);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString() && !param.isWrapped()) return;\n      let stringSuffix = null;\n      let hasUnknownParams = false;\n      const innerExpressions = [];\n\n      for (let i = expr.arguments.length - 1; i >= 0; i--) {\n        const arg = expr.arguments[i];\n        if (arg.type === \"SpreadElement\") return;\n        const argExpr = this.evaluateExpression(arg);\n\n        if (hasUnknownParams || !argExpr.isString() && !argExpr.isNumber()) {\n          hasUnknownParams = true;\n          innerExpressions.push(argExpr);\n          continue;\n        }\n\n        const value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n        const newString = value + (stringSuffix ? stringSuffix.string : \"\");\n        const newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n        stringSuffix = new BasicEvaluatedExpression().setString(newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || argExpr.couldHaveSideEffects()).setRange(newRange);\n      }\n\n      if (hasUnknownParams) {\n        const prefix = param.isString() ? param : param.prefix;\n        const inner = param.isWrapped() && param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();\n        return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix, inner).setRange(expr.range);\n      } else if (param.isWrapped()) {\n        const postfix = stringSuffix || param.postfix;\n        const inner = param.wrappedInnerExpressions ? param.wrappedInnerExpressions.concat(innerExpressions.reverse()) : innerExpressions.reverse();\n        return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix, inner).setRange(expr.range);\n      } else {\n        const newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n        return new BasicEvaluatedExpression().setString(newString).setSideEffects(stringSuffix && stringSuffix.couldHaveSideEffects() || param.couldHaveSideEffects()).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"JavascriptParser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 1) return;\n      if (expr.arguments[0].type === \"SpreadElement\") return;\n      let result;\n      const arg = this.evaluateExpression(expr.arguments[0]);\n\n      if (arg.isString()) {\n        result = param.string.split(arg.string);\n      } else if (arg.isRegExp()) {\n        result = param.string.split(arg.regExp);\n      } else {\n        return;\n      }\n\n      return new BasicEvaluatedExpression().setArray(result).setSideEffects(param.couldHaveSideEffects()).setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {ConditionalExpressionNode} */\n      _expr;\n      const condition = this.evaluateExpression(expr.test);\n      const conditionValue = condition.asBool();\n      let res;\n\n      if (conditionValue === undefined) {\n        const consequent = this.evaluateExpression(expr.consequent);\n        const alternate = this.evaluateExpression(expr.alternate);\n        res = new BasicEvaluatedExpression();\n\n        if (consequent.isConditional()) {\n          res.setOptions(consequent.options);\n        } else {\n          res.setOptions([consequent]);\n        }\n\n        if (alternate.isConditional()) {\n          res.addOptions(alternate.options);\n        } else {\n          res.addOptions([alternate]);\n        }\n      } else {\n        res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n        if (condition.couldHaveSideEffects()) res.setSideEffects();\n      }\n\n      res.setRange(expr.range);\n      return res;\n    });\n    this.hooks.evaluate.for(\"ArrayExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {ArrayExpressionNode} */\n      _expr;\n      const items = expr.elements.map(element => {\n        return element !== null && element.type !== \"SpreadElement\" && this.evaluateExpression(element);\n      });\n      if (!items.every(Boolean)) return;\n      return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"ChainExpression\").tap(\"JavascriptParser\", _expr => {\n      const expr =\n      /** @type {ChainExpressionNode} */\n      _expr;\n      /** @type {ExpressionNode[]} */\n\n      const optionalExpressionsStack = [];\n      /** @type {ExpressionNode|SuperNode} */\n\n      let next = expr.expression;\n\n      while (next.type === \"MemberExpression\" || next.type === \"CallExpression\") {\n        if (next.type === \"MemberExpression\") {\n          if (next.optional) {\n            // SuperNode can not be optional\n            optionalExpressionsStack.push(\n            /** @type {ExpressionNode} */\n            next.object);\n          }\n\n          next = next.object;\n        } else {\n          if (next.optional) {\n            // SuperNode can not be optional\n            optionalExpressionsStack.push(\n            /** @type {ExpressionNode} */\n            next.callee);\n          }\n\n          next = next.callee;\n        }\n      }\n\n      while (optionalExpressionsStack.length > 0) {\n        const expression = optionalExpressionsStack.pop();\n        const evaluated = this.evaluateExpression(expression);\n\n        if (evaluated.asNullish()) {\n          return evaluated.setRange(_expr.range);\n        }\n      }\n\n      return this.evaluateExpression(expr.expression);\n    });\n  }\n\n  getRenameIdentifier(expr) {\n    const result = this.evaluateExpression(expr);\n\n    if (result.isIdentifier()) {\n      return result.identifier;\n    }\n  }\n  /**\n   * @param {ClassExpressionNode | ClassDeclarationNode} classy a class node\n   * @returns {void}\n   */\n\n\n  walkClass(classy) {\n    if (classy.superClass) {\n      if (!this.hooks.classExtendsExpression.call(classy.superClass, classy)) {\n        this.walkExpression(classy.superClass);\n      }\n    }\n\n    if (classy.body && classy.body.type === \"ClassBody\") {\n      for (const classElement of\n      /** @type {TODO} */\n      classy.body.body) {\n        if (!this.hooks.classBodyElement.call(classElement, classy)) {\n          if (classElement.computed && classElement.key) {\n            this.walkExpression(classElement.key);\n          }\n\n          if (classElement.value) {\n            if (!this.hooks.classBodyValue.call(classElement.value, classElement, classy)) {\n              const wasTopLevel = this.scope.topLevelScope;\n              this.scope.topLevelScope = false;\n              this.walkExpression(classElement.value);\n              this.scope.topLevelScope = wasTopLevel;\n            }\n          }\n        }\n      }\n    }\n  } // Pre walking iterates the scope for variable declarations\n\n\n  preWalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.preWalkStatement(statement);\n    }\n  } // Block pre walking iterates the scope for block variable declarations\n\n\n  blockPreWalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.blockPreWalkStatement(statement);\n    }\n  } // Walking iterates the statements and expressions and processes them\n\n\n  walkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.walkStatement(statement);\n    }\n  }\n\n  preWalkStatement(statement) {\n    this.statementPath.push(statement);\n\n    if (this.hooks.preStatement.call(statement)) {\n      this.prevStatement = this.statementPath.pop();\n      return;\n    }\n\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.preWalkBlockStatement(statement);\n        break;\n\n      case \"DoWhileStatement\":\n        this.preWalkDoWhileStatement(statement);\n        break;\n\n      case \"ForInStatement\":\n        this.preWalkForInStatement(statement);\n        break;\n\n      case \"ForOfStatement\":\n        this.preWalkForOfStatement(statement);\n        break;\n\n      case \"ForStatement\":\n        this.preWalkForStatement(statement);\n        break;\n\n      case \"FunctionDeclaration\":\n        this.preWalkFunctionDeclaration(statement);\n        break;\n\n      case \"IfStatement\":\n        this.preWalkIfStatement(statement);\n        break;\n\n      case \"LabeledStatement\":\n        this.preWalkLabeledStatement(statement);\n        break;\n\n      case \"SwitchStatement\":\n        this.preWalkSwitchStatement(statement);\n        break;\n\n      case \"TryStatement\":\n        this.preWalkTryStatement(statement);\n        break;\n\n      case \"VariableDeclaration\":\n        this.preWalkVariableDeclaration(statement);\n        break;\n\n      case \"WhileStatement\":\n        this.preWalkWhileStatement(statement);\n        break;\n\n      case \"WithStatement\":\n        this.preWalkWithStatement(statement);\n        break;\n    }\n\n    this.prevStatement = this.statementPath.pop();\n  }\n\n  blockPreWalkStatement(statement) {\n    this.statementPath.push(statement);\n\n    if (this.hooks.blockPreStatement.call(statement)) {\n      this.prevStatement = this.statementPath.pop();\n      return;\n    }\n\n    switch (statement.type) {\n      case \"ImportDeclaration\":\n        this.blockPreWalkImportDeclaration(statement);\n        break;\n\n      case \"ExportAllDeclaration\":\n        this.blockPreWalkExportAllDeclaration(statement);\n        break;\n\n      case \"ExportDefaultDeclaration\":\n        this.blockPreWalkExportDefaultDeclaration(statement);\n        break;\n\n      case \"ExportNamedDeclaration\":\n        this.blockPreWalkExportNamedDeclaration(statement);\n        break;\n\n      case \"VariableDeclaration\":\n        this.blockPreWalkVariableDeclaration(statement);\n        break;\n\n      case \"ClassDeclaration\":\n        this.blockPreWalkClassDeclaration(statement);\n        break;\n    }\n\n    this.prevStatement = this.statementPath.pop();\n  }\n\n  walkStatement(statement) {\n    this.statementPath.push(statement);\n\n    if (this.hooks.statement.call(statement) !== undefined) {\n      this.prevStatement = this.statementPath.pop();\n      return;\n    }\n\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.walkBlockStatement(statement);\n        break;\n\n      case \"ClassDeclaration\":\n        this.walkClassDeclaration(statement);\n        break;\n\n      case \"DoWhileStatement\":\n        this.walkDoWhileStatement(statement);\n        break;\n\n      case \"ExportDefaultDeclaration\":\n        this.walkExportDefaultDeclaration(statement);\n        break;\n\n      case \"ExportNamedDeclaration\":\n        this.walkExportNamedDeclaration(statement);\n        break;\n\n      case \"ExpressionStatement\":\n        this.walkExpressionStatement(statement);\n        break;\n\n      case \"ForInStatement\":\n        this.walkForInStatement(statement);\n        break;\n\n      case \"ForOfStatement\":\n        this.walkForOfStatement(statement);\n        break;\n\n      case \"ForStatement\":\n        this.walkForStatement(statement);\n        break;\n\n      case \"FunctionDeclaration\":\n        this.walkFunctionDeclaration(statement);\n        break;\n\n      case \"IfStatement\":\n        this.walkIfStatement(statement);\n        break;\n\n      case \"LabeledStatement\":\n        this.walkLabeledStatement(statement);\n        break;\n\n      case \"ReturnStatement\":\n        this.walkReturnStatement(statement);\n        break;\n\n      case \"SwitchStatement\":\n        this.walkSwitchStatement(statement);\n        break;\n\n      case \"ThrowStatement\":\n        this.walkThrowStatement(statement);\n        break;\n\n      case \"TryStatement\":\n        this.walkTryStatement(statement);\n        break;\n\n      case \"VariableDeclaration\":\n        this.walkVariableDeclaration(statement);\n        break;\n\n      case \"WhileStatement\":\n        this.walkWhileStatement(statement);\n        break;\n\n      case \"WithStatement\":\n        this.walkWithStatement(statement);\n        break;\n    }\n\n    this.prevStatement = this.statementPath.pop();\n  }\n  /**\n   * Walks a statements that is nested within a parent statement\n   * and can potentially be a non-block statement.\n   * This enforces the nested statement to never be in ASI position.\n   * @param {StatementNode} statement the nested statement\n   * @returns {void}\n   */\n\n\n  walkNestedStatement(statement) {\n    this.prevStatement = undefined;\n    this.walkStatement(statement);\n  } // Real Statements\n\n\n  preWalkBlockStatement(statement) {\n    this.preWalkStatements(statement.body);\n  }\n\n  walkBlockStatement(statement) {\n    this.inBlockScope(() => {\n      const body = statement.body;\n      const prev = this.prevStatement;\n      this.blockPreWalkStatements(body);\n      this.prevStatement = prev;\n      this.walkStatements(body);\n    });\n  }\n\n  walkExpressionStatement(statement) {\n    this.walkExpression(statement.expression);\n  }\n\n  preWalkIfStatement(statement) {\n    this.preWalkStatement(statement.consequent);\n\n    if (statement.alternate) {\n      this.preWalkStatement(statement.alternate);\n    }\n  }\n\n  walkIfStatement(statement) {\n    const result = this.hooks.statementIf.call(statement);\n\n    if (result === undefined) {\n      this.walkExpression(statement.test);\n      this.walkNestedStatement(statement.consequent);\n\n      if (statement.alternate) {\n        this.walkNestedStatement(statement.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkNestedStatement(statement.consequent);\n      } else if (statement.alternate) {\n        this.walkNestedStatement(statement.alternate);\n      }\n    }\n  }\n\n  preWalkLabeledStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n\n  walkLabeledStatement(statement) {\n    const hook = this.hooks.label.get(statement.label.name);\n\n    if (hook !== undefined) {\n      const result = hook.call(statement);\n      if (result === true) return;\n    }\n\n    this.walkNestedStatement(statement.body);\n  }\n\n  preWalkWithStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n\n  walkWithStatement(statement) {\n    this.walkExpression(statement.object);\n    this.walkNestedStatement(statement.body);\n  }\n\n  preWalkSwitchStatement(statement) {\n    this.preWalkSwitchCases(statement.cases);\n  }\n\n  walkSwitchStatement(statement) {\n    this.walkExpression(statement.discriminant);\n    this.walkSwitchCases(statement.cases);\n  }\n\n  walkTerminatingStatement(statement) {\n    if (statement.argument) this.walkExpression(statement.argument);\n  }\n\n  walkReturnStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n\n  walkThrowStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n\n  preWalkTryStatement(statement) {\n    this.preWalkStatement(statement.block);\n    if (statement.handler) this.preWalkCatchClause(statement.handler);\n    if (statement.finializer) this.preWalkStatement(statement.finializer);\n  }\n\n  walkTryStatement(statement) {\n    if (this.scope.inTry) {\n      this.walkStatement(statement.block);\n    } else {\n      this.scope.inTry = true;\n      this.walkStatement(statement.block);\n      this.scope.inTry = false;\n    }\n\n    if (statement.handler) this.walkCatchClause(statement.handler);\n    if (statement.finalizer) this.walkStatement(statement.finalizer);\n  }\n\n  preWalkWhileStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n\n  walkWhileStatement(statement) {\n    this.walkExpression(statement.test);\n    this.walkNestedStatement(statement.body);\n  }\n\n  preWalkDoWhileStatement(statement) {\n    this.preWalkStatement(statement.body);\n  }\n\n  walkDoWhileStatement(statement) {\n    this.walkNestedStatement(statement.body);\n    this.walkExpression(statement.test);\n  }\n\n  preWalkForStatement(statement) {\n    if (statement.init) {\n      if (statement.init.type === \"VariableDeclaration\") {\n        this.preWalkStatement(statement.init);\n      }\n    }\n\n    this.preWalkStatement(statement.body);\n  }\n\n  walkForStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.blockPreWalkVariableDeclaration(statement.init);\n          this.prevStatement = undefined;\n          this.walkStatement(statement.init);\n        } else {\n          this.walkExpression(statement.init);\n        }\n      }\n\n      if (statement.test) {\n        this.walkExpression(statement.test);\n      }\n\n      if (statement.update) {\n        this.walkExpression(statement.update);\n      }\n\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        const prev = this.prevStatement;\n        this.blockPreWalkStatements(body.body);\n        this.prevStatement = prev;\n        this.walkStatements(body.body);\n      } else {\n        this.walkNestedStatement(body);\n      }\n    });\n  }\n\n  preWalkForInStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.preWalkVariableDeclaration(statement.left);\n    }\n\n    this.preWalkStatement(statement.body);\n  }\n\n  walkForInStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPreWalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n\n      this.walkExpression(statement.right);\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        const prev = this.prevStatement;\n        this.blockPreWalkStatements(body.body);\n        this.prevStatement = prev;\n        this.walkStatements(body.body);\n      } else {\n        this.walkNestedStatement(body);\n      }\n    });\n  }\n\n  preWalkForOfStatement(statement) {\n    if (statement.await && this.scope.topLevelScope === true) {\n      this.hooks.topLevelAwait.call(statement);\n    }\n\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.preWalkVariableDeclaration(statement.left);\n    }\n\n    this.preWalkStatement(statement.body);\n  }\n\n  walkForOfStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPreWalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n\n      this.walkExpression(statement.right);\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        const prev = this.prevStatement;\n        this.blockPreWalkStatements(body.body);\n        this.prevStatement = prev;\n        this.walkStatements(body.body);\n      } else {\n        this.walkNestedStatement(body);\n      }\n    });\n  } // Declarations\n\n\n  preWalkFunctionDeclaration(statement) {\n    if (statement.id) {\n      this.defineVariable(statement.id.name);\n    }\n  }\n\n  walkFunctionDeclaration(statement) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    this.inFunctionScope(true, statement.params, () => {\n      for (const param of statement.params) {\n        this.walkPattern(param);\n      }\n\n      if (statement.body.type === \"BlockStatement\") {\n        this.detectMode(statement.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(statement.body);\n        this.prevStatement = prev;\n        this.walkStatement(statement.body);\n      } else {\n        this.walkExpression(statement.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  blockPreWalkImportDeclaration(statement) {\n    const source = statement.source.value;\n    this.hooks.import.call(statement, source);\n\n    for (const specifier of statement.specifiers) {\n      const name = specifier.local.name;\n\n      switch (specifier.type) {\n        case \"ImportDefaultSpecifier\":\n          if (!this.hooks.importSpecifier.call(statement, source, \"default\", name)) {\n            this.defineVariable(name);\n          }\n\n          break;\n\n        case \"ImportSpecifier\":\n          if (!this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name)) {\n            this.defineVariable(name);\n          }\n\n          break;\n\n        case \"ImportNamespaceSpecifier\":\n          if (!this.hooks.importSpecifier.call(statement, source, null, name)) {\n            this.defineVariable(name);\n          }\n\n          break;\n\n        default:\n          this.defineVariable(name);\n      }\n    }\n  }\n\n  enterDeclaration(declaration, onIdent) {\n    switch (declaration.type) {\n      case \"VariableDeclaration\":\n        for (const declarator of declaration.declarations) {\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                this.enterPattern(declarator.id, onIdent);\n                break;\n              }\n          }\n        }\n\n        break;\n\n      case \"FunctionDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n\n      case \"ClassDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n    }\n  }\n\n  blockPreWalkExportNamedDeclaration(statement) {\n    let source;\n\n    if (statement.source) {\n      source = statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n    } else {\n      this.hooks.export.call(statement);\n    }\n\n    if (statement.declaration) {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        const prev = this.prevStatement;\n        this.preWalkStatement(statement.declaration);\n        this.prevStatement = prev;\n        this.blockPreWalkStatement(statement.declaration);\n        let index = 0;\n        this.enterDeclaration(statement.declaration, def => {\n          this.hooks.exportSpecifier.call(statement, def, def, index++);\n        });\n      }\n    }\n\n    if (statement.specifiers) {\n      for (let specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n        const specifier = statement.specifiers[specifierIndex];\n\n        switch (specifier.type) {\n          case \"ExportSpecifier\":\n            {\n              const name = specifier.exported.name;\n\n              if (source) {\n                this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n              } else {\n                this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n              }\n\n              break;\n            }\n        }\n      }\n    }\n  }\n\n  walkExportNamedDeclaration(statement) {\n    if (statement.declaration) {\n      this.walkStatement(statement.declaration);\n    }\n  }\n\n  blockPreWalkExportDefaultDeclaration(statement) {\n    const prev = this.prevStatement;\n    this.preWalkStatement(statement.declaration);\n    this.prevStatement = prev;\n    this.blockPreWalkStatement(statement.declaration);\n\n    if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, \"default\", undefined);\n    }\n  }\n\n  walkExportDefaultDeclaration(statement) {\n    this.hooks.export.call(statement);\n\n    if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        this.walkStatement(statement.declaration);\n      }\n    } else {\n      // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n      // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n      // These nodes must be treated as expressions.\n      if (statement.declaration.type === \"FunctionDeclaration\" || statement.declaration.type === \"ClassDeclaration\") {\n        this.walkStatement(statement.declaration);\n      } else {\n        this.walkExpression(statement.declaration);\n      }\n\n      if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n        this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\", undefined);\n      }\n    }\n  }\n\n  blockPreWalkExportAllDeclaration(statement) {\n    const source = statement.source.value;\n    const name = statement.exported ? statement.exported.name : null;\n    this.hooks.exportImport.call(statement, source);\n    this.hooks.exportImportSpecifier.call(statement, source, null, name, 0);\n  }\n\n  preWalkVariableDeclaration(statement) {\n    if (statement.kind !== \"var\") return;\n\n    this._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n  }\n\n  blockPreWalkVariableDeclaration(statement) {\n    if (statement.kind === \"var\") return;\n    const hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;\n\n    this._preWalkVariableDeclaration(statement, hookMap);\n  }\n\n  _preWalkVariableDeclaration(statement, hookMap) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            if (!this.hooks.preDeclarator.call(declarator, statement)) {\n              this.enterPattern(declarator.id, (name, decl) => {\n                let hook = hookMap.get(name);\n\n                if (hook === undefined || !hook.call(decl)) {\n                  hook = this.hooks.varDeclaration.get(name);\n\n                  if (hook === undefined || !hook.call(decl)) {\n                    this.defineVariable(name);\n                  }\n                }\n              });\n            }\n\n            break;\n          }\n      }\n    }\n  }\n\n  walkVariableDeclaration(statement) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            const renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n\n            if (renameIdentifier && declarator.id.type === \"Identifier\") {\n              const hook = this.hooks.canRename.get(renameIdentifier);\n\n              if (hook !== undefined && hook.call(declarator.init)) {\n                // renaming with \"var a = b;\"\n                const hook = this.hooks.rename.get(renameIdentifier);\n\n                if (hook === undefined || !hook.call(declarator.init)) {\n                  this.setVariable(declarator.id.name, renameIdentifier);\n                }\n\n                break;\n              }\n            }\n\n            if (!this.hooks.declarator.call(declarator, statement)) {\n              this.walkPattern(declarator.id);\n              if (declarator.init) this.walkExpression(declarator.init);\n            }\n\n            break;\n          }\n      }\n    }\n  }\n\n  blockPreWalkClassDeclaration(statement) {\n    if (statement.id) {\n      this.defineVariable(statement.id.name);\n    }\n  }\n\n  walkClassDeclaration(statement) {\n    this.walkClass(statement);\n  }\n\n  preWalkSwitchCases(switchCases) {\n    for (let index = 0, len = switchCases.length; index < len; index++) {\n      const switchCase = switchCases[index];\n      this.preWalkStatements(switchCase.consequent);\n    }\n  }\n\n  walkSwitchCases(switchCases) {\n    this.inBlockScope(() => {\n      const len = switchCases.length; // we need to pre walk all statements first since we can have invalid code\n      // import A from \"module\";\n      // switch(1) {\n      //    case 1:\n      //      console.log(A); // should fail at runtime\n      //    case 2:\n      //      const A = 1;\n      // }\n\n      for (let index = 0; index < len; index++) {\n        const switchCase = switchCases[index];\n\n        if (switchCase.consequent.length > 0) {\n          const prev = this.prevStatement;\n          this.blockPreWalkStatements(switchCase.consequent);\n          this.prevStatement = prev;\n        }\n      }\n\n      for (let index = 0; index < len; index++) {\n        const switchCase = switchCases[index];\n\n        if (switchCase.test) {\n          this.walkExpression(switchCase.test);\n        }\n\n        if (switchCase.consequent.length > 0) {\n          this.walkStatements(switchCase.consequent);\n        }\n      }\n    });\n  }\n\n  preWalkCatchClause(catchClause) {\n    this.preWalkStatement(catchClause.body);\n  }\n\n  walkCatchClause(catchClause) {\n    this.inBlockScope(() => {\n      // Error binding is optional in catch clause since ECMAScript 2019\n      if (catchClause.param !== null) {\n        this.enterPattern(catchClause.param, ident => {\n          this.defineVariable(ident);\n        });\n        this.walkPattern(catchClause.param);\n      }\n\n      const prev = this.prevStatement;\n      this.blockPreWalkStatement(catchClause.body);\n      this.prevStatement = prev;\n      this.walkStatement(catchClause.body);\n    });\n  }\n\n  walkPattern(pattern) {\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.walkArrayPattern(pattern);\n        break;\n\n      case \"AssignmentPattern\":\n        this.walkAssignmentPattern(pattern);\n        break;\n\n      case \"MemberExpression\":\n        this.walkMemberExpression(pattern);\n        break;\n\n      case \"ObjectPattern\":\n        this.walkObjectPattern(pattern);\n        break;\n\n      case \"RestElement\":\n        this.walkRestElement(pattern);\n        break;\n    }\n  }\n\n  walkAssignmentPattern(pattern) {\n    this.walkExpression(pattern.right);\n    this.walkPattern(pattern.left);\n  }\n\n  walkObjectPattern(pattern) {\n    for (let i = 0, len = pattern.properties.length; i < len; i++) {\n      const prop = pattern.properties[i];\n\n      if (prop) {\n        if (prop.computed) this.walkExpression(prop.key);\n        if (prop.value) this.walkPattern(prop.value);\n      }\n    }\n  }\n\n  walkArrayPattern(pattern) {\n    for (let i = 0, len = pattern.elements.length; i < len; i++) {\n      const element = pattern.elements[i];\n      if (element) this.walkPattern(element);\n    }\n  }\n\n  walkRestElement(pattern) {\n    this.walkPattern(pattern.argument);\n  }\n\n  walkExpressions(expressions) {\n    for (const expression of expressions) {\n      if (expression) {\n        this.walkExpression(expression);\n      }\n    }\n  }\n\n  walkExpression(expression) {\n    switch (expression.type) {\n      case \"ArrayExpression\":\n        this.walkArrayExpression(expression);\n        break;\n\n      case \"ArrowFunctionExpression\":\n        this.walkArrowFunctionExpression(expression);\n        break;\n\n      case \"AssignmentExpression\":\n        this.walkAssignmentExpression(expression);\n        break;\n\n      case \"AwaitExpression\":\n        this.walkAwaitExpression(expression);\n        break;\n\n      case \"BinaryExpression\":\n        this.walkBinaryExpression(expression);\n        break;\n\n      case \"CallExpression\":\n        this.walkCallExpression(expression);\n        break;\n\n      case \"ChainExpression\":\n        this.walkChainExpression(expression);\n        break;\n\n      case \"ClassExpression\":\n        this.walkClassExpression(expression);\n        break;\n\n      case \"ConditionalExpression\":\n        this.walkConditionalExpression(expression);\n        break;\n\n      case \"FunctionExpression\":\n        this.walkFunctionExpression(expression);\n        break;\n\n      case \"Identifier\":\n        this.walkIdentifier(expression);\n        break;\n\n      case \"ImportExpression\":\n        this.walkImportExpression(expression);\n        break;\n\n      case \"LogicalExpression\":\n        this.walkLogicalExpression(expression);\n        break;\n\n      case \"MetaProperty\":\n        this.walkMetaProperty(expression);\n        break;\n\n      case \"MemberExpression\":\n        this.walkMemberExpression(expression);\n        break;\n\n      case \"NewExpression\":\n        this.walkNewExpression(expression);\n        break;\n\n      case \"ObjectExpression\":\n        this.walkObjectExpression(expression);\n        break;\n\n      case \"SequenceExpression\":\n        this.walkSequenceExpression(expression);\n        break;\n\n      case \"SpreadElement\":\n        this.walkSpreadElement(expression);\n        break;\n\n      case \"TaggedTemplateExpression\":\n        this.walkTaggedTemplateExpression(expression);\n        break;\n\n      case \"TemplateLiteral\":\n        this.walkTemplateLiteral(expression);\n        break;\n\n      case \"ThisExpression\":\n        this.walkThisExpression(expression);\n        break;\n\n      case \"UnaryExpression\":\n        this.walkUnaryExpression(expression);\n        break;\n\n      case \"UpdateExpression\":\n        this.walkUpdateExpression(expression);\n        break;\n\n      case \"YieldExpression\":\n        this.walkYieldExpression(expression);\n        break;\n    }\n  }\n\n  walkAwaitExpression(expression) {\n    if (this.scope.topLevelScope === true) this.hooks.topLevelAwait.call(expression);\n    this.walkExpression(expression.argument);\n  }\n\n  walkArrayExpression(expression) {\n    if (expression.elements) {\n      this.walkExpressions(expression.elements);\n    }\n  }\n\n  walkSpreadElement(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n\n  walkObjectExpression(expression) {\n    for (let propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n      const prop = expression.properties[propIndex];\n      this.walkProperty(prop);\n    }\n  }\n\n  walkProperty(prop) {\n    if (prop.type === \"SpreadElement\") {\n      this.walkExpression(prop.argument);\n      return;\n    }\n\n    if (prop.computed) {\n      this.walkExpression(prop.key);\n    }\n\n    if (prop.shorthand && prop.value && prop.value.type === \"Identifier\") {\n      this.scope.inShorthand = prop.value.name;\n      this.walkIdentifier(prop.value);\n      this.scope.inShorthand = false;\n    } else {\n      this.walkExpression(prop.value);\n    }\n  }\n\n  walkFunctionExpression(expression) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    const scopeParams = expression.params; // Add function name in scope for recursive calls\n\n    if (expression.id) {\n      scopeParams.push(expression.id.name);\n    }\n\n    this.inFunctionScope(true, scopeParams, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(expression.body);\n        this.prevStatement = prev;\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  walkArrowFunctionExpression(expression) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = wasTopLevel ? \"arrow\" : false;\n    this.inFunctionScope(false, expression.params, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(expression.body);\n        this.prevStatement = prev;\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n  /**\n   * @param {SequenceExpressionNode} expression the sequence\n   */\n\n\n  walkSequenceExpression(expression) {\n    if (!expression.expressions) return; // We treat sequence expressions like statements when they are one statement level\n    // This has some benefits for optimizations that only work on statement level\n\n    const currentStatement = this.statementPath[this.statementPath.length - 1];\n\n    if (currentStatement === expression || currentStatement.type === \"ExpressionStatement\" && currentStatement.expression === expression) {\n      const old = this.statementPath.pop();\n\n      for (const expr of expression.expressions) {\n        this.statementPath.push(expr);\n        this.walkExpression(expr);\n        this.statementPath.pop();\n      }\n\n      this.statementPath.push(old);\n    } else {\n      this.walkExpressions(expression.expressions);\n    }\n  }\n\n  walkUpdateExpression(expression) {\n    this.walkExpression(expression.argument);\n  }\n\n  walkUnaryExpression(expression) {\n    if (expression.operator === \"typeof\") {\n      const result = this.callHooksForExpression(this.hooks.typeof, expression.argument, expression);\n      if (result === true) return;\n\n      if (expression.argument.type === \"ChainExpression\") {\n        const result = this.callHooksForExpression(this.hooks.typeof, expression.argument.expression, expression);\n        if (result === true) return;\n      }\n    }\n\n    this.walkExpression(expression.argument);\n  }\n\n  walkLeftRightExpression(expression) {\n    this.walkExpression(expression.left);\n    this.walkExpression(expression.right);\n  }\n\n  walkBinaryExpression(expression) {\n    if (this.hooks.binaryExpression.call(expression) === undefined) {\n      this.walkLeftRightExpression(expression);\n    }\n  }\n\n  walkLogicalExpression(expression) {\n    const result = this.hooks.expressionLogicalOperator.call(expression);\n\n    if (result === undefined) {\n      this.walkLeftRightExpression(expression);\n    } else {\n      if (result) {\n        this.walkExpression(expression.right);\n      }\n    }\n  }\n\n  walkAssignmentExpression(expression) {\n    if (expression.left.type === \"Identifier\") {\n      const renameIdentifier = this.getRenameIdentifier(expression.right);\n\n      if (renameIdentifier) {\n        if (this.callHooksForInfo(this.hooks.canRename, renameIdentifier, expression.right)) {\n          // renaming \"a = b;\"\n          if (!this.callHooksForInfo(this.hooks.rename, renameIdentifier, expression.right)) {\n            this.setVariable(expression.left.name, typeof renameIdentifier === \"string\" ? this.getVariableInfo(renameIdentifier) : renameIdentifier);\n          }\n\n          return;\n        }\n      }\n\n      this.walkExpression(expression.right);\n      this.enterPattern(expression.left, (name, decl) => {\n        if (!this.callHooksForName(this.hooks.assign, name, expression)) {\n          this.walkExpression(expression.left);\n        }\n      });\n      return;\n    }\n\n    if (expression.left.type.endsWith(\"Pattern\")) {\n      this.walkExpression(expression.right);\n      this.enterPattern(expression.left, (name, decl) => {\n        if (!this.callHooksForName(this.hooks.assign, name, expression)) {\n          this.defineVariable(name);\n        }\n      });\n      this.walkPattern(expression.left);\n    } else if (expression.left.type === \"MemberExpression\") {\n      const exprName = this.getMemberExpressionInfo(expression.left, ALLOWED_MEMBER_TYPES_EXPRESSION);\n\n      if (exprName) {\n        if (this.callHooksForInfo(this.hooks.assignMemberChain, exprName.rootInfo, expression, exprName.getMembers())) {\n          return;\n        }\n      }\n\n      this.walkExpression(expression.right);\n      this.walkExpression(expression.left);\n    } else {\n      this.walkExpression(expression.right);\n      this.walkExpression(expression.left);\n    }\n  }\n\n  walkConditionalExpression(expression) {\n    const result = this.hooks.expressionConditionalOperator.call(expression);\n\n    if (result === undefined) {\n      this.walkExpression(expression.test);\n      this.walkExpression(expression.consequent);\n\n      if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkExpression(expression.consequent);\n      } else if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    }\n  }\n\n  walkNewExpression(expression) {\n    const result = this.callHooksForExpression(this.hooks.new, expression.callee, expression);\n    if (result === true) return;\n    this.walkExpression(expression.callee);\n\n    if (expression.arguments) {\n      this.walkExpressions(expression.arguments);\n    }\n  }\n\n  walkYieldExpression(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n\n  walkTemplateLiteral(expression) {\n    if (expression.expressions) {\n      this.walkExpressions(expression.expressions);\n    }\n  }\n\n  walkTaggedTemplateExpression(expression) {\n    if (expression.tag) {\n      this.walkExpression(expression.tag);\n    }\n\n    if (expression.quasi && expression.quasi.expressions) {\n      this.walkExpressions(expression.quasi.expressions);\n    }\n  }\n\n  walkClassExpression(expression) {\n    this.walkClass(expression);\n  }\n  /**\n   * @param {ChainExpressionNode} expression expression\n   */\n\n\n  walkChainExpression(expression) {\n    const result = this.hooks.optionalChaining.call(expression);\n\n    if (result === undefined) {\n      if (expression.expression.type === \"CallExpression\") {\n        this.walkCallExpression(expression.expression);\n      } else {\n        this.walkMemberExpression(expression.expression);\n      }\n    }\n  }\n\n  _walkIIFE(functionExpression, options, currentThis) {\n    const getVarInfo = argOrThis => {\n      const renameIdentifier = this.getRenameIdentifier(argOrThis);\n\n      if (renameIdentifier) {\n        if (this.callHooksForInfo(this.hooks.canRename, renameIdentifier, argOrThis)) {\n          if (!this.callHooksForInfo(this.hooks.rename, renameIdentifier, argOrThis)) {\n            return typeof renameIdentifier === \"string\" ? this.getVariableInfo(renameIdentifier) : renameIdentifier;\n          }\n        }\n      }\n\n      this.walkExpression(argOrThis);\n    };\n\n    const {\n      params,\n      type\n    } = functionExpression;\n    const arrow = type === \"ArrowFunctionExpression\";\n    const renameThis = currentThis ? getVarInfo(currentThis) : null;\n    const varInfoForArgs = options.map(getVarInfo);\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = wasTopLevel && arrow ? \"arrow\" : false;\n    const scopeParams = params.filter((identifier, idx) => !varInfoForArgs[idx]); // Add function name in scope for recursive calls\n\n    if (functionExpression.id) {\n      scopeParams.push(functionExpression.id.name);\n    }\n\n    this.inFunctionScope(true, scopeParams, () => {\n      if (renameThis && !arrow) {\n        this.setVariable(\"this\", renameThis);\n      }\n\n      for (let i = 0; i < varInfoForArgs.length; i++) {\n        const varInfo = varInfoForArgs[i];\n        if (!varInfo) continue;\n        if (!params[i] || params[i].type !== \"Identifier\") continue;\n        this.setVariable(params[i].name, varInfo);\n      }\n\n      if (functionExpression.body.type === \"BlockStatement\") {\n        this.detectMode(functionExpression.body.body);\n        const prev = this.prevStatement;\n        this.preWalkStatement(functionExpression.body);\n        this.prevStatement = prev;\n        this.walkStatement(functionExpression.body);\n      } else {\n        this.walkExpression(functionExpression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  walkImportExpression(expression) {\n    let result = this.hooks.importCall.call(expression);\n    if (result === true) return;\n    this.walkExpression(expression.source);\n  }\n\n  walkCallExpression(expression) {\n    const isSimpleFunction = fn => {\n      return fn.params.every(p => p.type === \"Identifier\");\n    };\n\n    if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type.endsWith(\"FunctionExpression\") && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0 && isSimpleFunction(expression.callee.object)) {\n      // (function() { }.call/bind(?, ))\n      this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n    } else if (expression.callee.type.endsWith(\"FunctionExpression\") && isSimpleFunction(expression.callee)) {\n      // (function() { }())\n      this._walkIIFE(expression.callee, expression.arguments, null);\n    } else {\n      if (expression.callee.type === \"MemberExpression\") {\n        const exprInfo = this.getMemberExpressionInfo(expression.callee, ALLOWED_MEMBER_TYPES_CALL_EXPRESSION);\n\n        if (exprInfo && exprInfo.type === \"call\") {\n          const result = this.callHooksForInfo(this.hooks.callMemberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers());\n          if (result === true) return;\n        }\n      }\n\n      const callee = this.evaluateExpression(expression.callee);\n\n      if (callee.isIdentifier()) {\n        const result1 = this.callHooksForInfo(this.hooks.callMemberChain, callee.rootInfo, expression, callee.getMembers(), callee.getMembersOptionals ? callee.getMembersOptionals() : callee.getMembers().map(() => false));\n        if (result1 === true) return;\n        const result2 = this.callHooksForInfo(this.hooks.call, callee.identifier, expression);\n        if (result2 === true) return;\n      }\n\n      if (expression.callee) {\n        if (expression.callee.type === \"MemberExpression\") {\n          // because of call context we need to walk the call context as expression\n          this.walkExpression(expression.callee.object);\n          if (expression.callee.computed === true) this.walkExpression(expression.callee.property);\n        } else {\n          this.walkExpression(expression.callee);\n        }\n      }\n\n      if (expression.arguments) this.walkExpressions(expression.arguments);\n    }\n  }\n\n  walkMemberExpression(expression) {\n    const exprInfo = this.getMemberExpressionInfo(expression, ALLOWED_MEMBER_TYPES_ALL);\n\n    if (exprInfo) {\n      switch (exprInfo.type) {\n        case \"expression\":\n          {\n            const result1 = this.callHooksForInfo(this.hooks.expression, exprInfo.name, expression);\n            if (result1 === true) return;\n            const members = exprInfo.getMembers();\n            const membersOptionals = exprInfo.getMembersOptionals();\n            const result2 = this.callHooksForInfo(this.hooks.expressionMemberChain, exprInfo.rootInfo, expression, members, membersOptionals);\n            if (result2 === true) return;\n            this.walkMemberExpressionWithExpressionName(expression, exprInfo.name, exprInfo.rootInfo, members.slice(), () => this.callHooksForInfo(this.hooks.unhandledExpressionMemberChain, exprInfo.rootInfo, expression, members));\n            return;\n          }\n\n        case \"call\":\n          {\n            const result = this.callHooksForInfo(this.hooks.memberChainOfCallMemberChain, exprInfo.rootInfo, expression, exprInfo.getCalleeMembers(), exprInfo.call, exprInfo.getMembers());\n            if (result === true) return; // Fast skip over the member chain as we already called memberChainOfCallMemberChain\n            // and call computed property are literals anyway\n\n            this.walkExpression(exprInfo.call);\n            return;\n          }\n      }\n    }\n\n    this.walkExpression(expression.object);\n    if (expression.computed === true) this.walkExpression(expression.property);\n  }\n\n  walkMemberExpressionWithExpressionName(expression, name, rootInfo, members, onUnhandled) {\n    if (expression.object.type === \"MemberExpression\") {\n      // optimize the case where expression.object is a MemberExpression too.\n      // we can keep info here when calling walkMemberExpression directly\n      const property = expression.property.name || `${expression.property.value}`;\n      name = name.slice(0, -property.length - 1);\n      members.pop();\n      const result = this.callHooksForInfo(this.hooks.expression, name, expression.object);\n      if (result === true) return;\n      this.walkMemberExpressionWithExpressionName(expression.object, name, rootInfo, members, onUnhandled);\n    } else if (!onUnhandled || !onUnhandled()) {\n      this.walkExpression(expression.object);\n    }\n\n    if (expression.computed === true) this.walkExpression(expression.property);\n  }\n\n  walkThisExpression(expression) {\n    this.callHooksForName(this.hooks.expression, \"this\", expression);\n  }\n\n  walkIdentifier(expression) {\n    this.callHooksForName(this.hooks.expression, expression.name, expression);\n  }\n  /**\n   * @param {MetaPropertyNode} metaProperty meta property\n   */\n\n\n  walkMetaProperty(metaProperty) {\n    this.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);\n  }\n\n  callHooksForExpression(hookMap, expr) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return this.callHooksForExpressionWithFallback(hookMap, expr, undefined, undefined, ...args);\n  }\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {MemberExpressionNode} expr expression info\n   * @param {function(string, string | ScopeInfo | VariableInfo, function(): string[]): any} fallback callback when variable in not handled by hooks\n   * @param {function(string): any} defined callback when variable is defined\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R} result of hook\n   */\n\n\n  callHooksForExpressionWithFallback(hookMap, expr, fallback, defined) {\n    const exprName = this.getMemberExpressionInfo(expr, ALLOWED_MEMBER_TYPES_EXPRESSION);\n\n    if (exprName !== undefined) {\n      const members = exprName.getMembers();\n\n      for (var _len2 = arguments.length, args = new Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {\n        args[_key2 - 4] = arguments[_key2];\n      }\n\n      return this.callHooksForInfoWithFallback(hookMap, members.length === 0 ? exprName.rootInfo : exprName.name, fallback && (name => fallback(name, exprName.rootInfo, exprName.getMembers)), defined && (() => defined(exprName.name)), ...args);\n    }\n  }\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {string} name key in map\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R} result of hook\n   */\n\n\n  callHooksForName(hookMap, name) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      args[_key3 - 2] = arguments[_key3];\n    }\n\n    return this.callHooksForNameWithFallback(hookMap, name, undefined, undefined, ...args);\n  }\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks that should be called\n   * @param {ExportedVariableInfo} info variable info\n   * @param  {AsArray<T>} args args for the hook\n   * @returns {R} result of hook\n   */\n\n\n  callHooksForInfo(hookMap, info) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n      args[_key4 - 2] = arguments[_key4];\n    }\n\n    return this.callHooksForInfoWithFallback(hookMap, info, undefined, undefined, ...args);\n  }\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {ExportedVariableInfo} info variable info\n   * @param {function(string): any} fallback callback when variable in not handled by hooks\n   * @param {function(): any} defined callback when variable is defined\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R} result of hook\n   */\n\n\n  callHooksForInfoWithFallback(hookMap, info, fallback, defined) {\n    let name;\n\n    for (var _len5 = arguments.length, args = new Array(_len5 > 4 ? _len5 - 4 : 0), _key5 = 4; _key5 < _len5; _key5++) {\n      args[_key5 - 4] = arguments[_key5];\n    }\n\n    if (typeof info === \"string\") {\n      name = info;\n    } else {\n      if (!(info instanceof VariableInfo)) {\n        if (defined !== undefined) {\n          return defined();\n        }\n\n        return;\n      }\n\n      let tagInfo = info.tagInfo;\n\n      while (tagInfo !== undefined) {\n        const hook = hookMap.get(tagInfo.tag);\n\n        if (hook !== undefined) {\n          this.currentTagData = tagInfo.data;\n          const result = hook.call(...args);\n          this.currentTagData = undefined;\n          if (result !== undefined) return result;\n        }\n\n        tagInfo = tagInfo.next;\n      }\n\n      if (info.freeName === true) {\n        if (defined !== undefined) {\n          return defined();\n        }\n\n        return;\n      }\n\n      name = info.freeName;\n    }\n\n    const hook = hookMap.get(name);\n\n    if (hook !== undefined) {\n      const result = hook.call(...args);\n      if (result !== undefined) return result;\n    }\n\n    if (fallback !== undefined) {\n      return fallback(name);\n    }\n  }\n  /**\n   * @template T\n   * @template R\n   * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n   * @param {string} name key in map\n   * @param {function(string): any} fallback callback when variable in not handled by hooks\n   * @param {function(): any} defined callback when variable is defined\n   * @param {AsArray<T>} args args for the hook\n   * @returns {R} result of hook\n   */\n\n\n  callHooksForNameWithFallback(hookMap, name, fallback, defined) {\n    for (var _len6 = arguments.length, args = new Array(_len6 > 4 ? _len6 - 4 : 0), _key6 = 4; _key6 < _len6; _key6++) {\n      args[_key6 - 4] = arguments[_key6];\n    }\n\n    return this.callHooksForInfoWithFallback(hookMap, this.getVariableInfo(name), fallback, defined, ...args);\n  }\n  /**\n   * @deprecated\n   * @param {any} params scope params\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n\n\n  inScope(params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild()\n    };\n    this.undefineVariable(\"this\");\n    this.enterPatterns(params, (ident, pattern) => {\n      this.defineVariable(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n\n  inFunctionScope(hasThis, params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild()\n    };\n\n    if (hasThis) {\n      this.undefineVariable(\"this\");\n    }\n\n    this.enterPatterns(params, (ident, pattern) => {\n      this.defineVariable(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n\n  inBlockScope(fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: oldScope.inTry,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild()\n    };\n    fn();\n    this.scope = oldScope;\n  }\n\n  detectMode(statements) {\n    const isLiteral = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\";\n\n    if (isLiteral && statements[0].expression.value === \"use strict\") {\n      this.scope.isStrict = true;\n    }\n\n    if (isLiteral && statements[0].expression.value === \"use asm\") {\n      this.scope.isAsmJs = true;\n    }\n  }\n\n  enterPatterns(patterns, onIdent) {\n    for (const pattern of patterns) {\n      if (typeof pattern !== \"string\") {\n        this.enterPattern(pattern, onIdent);\n      } else if (pattern) {\n        onIdent(pattern);\n      }\n    }\n  }\n\n  enterPattern(pattern, onIdent) {\n    if (!pattern) return;\n\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.enterArrayPattern(pattern, onIdent);\n        break;\n\n      case \"AssignmentPattern\":\n        this.enterAssignmentPattern(pattern, onIdent);\n        break;\n\n      case \"Identifier\":\n        this.enterIdentifier(pattern, onIdent);\n        break;\n\n      case \"ObjectPattern\":\n        this.enterObjectPattern(pattern, onIdent);\n        break;\n\n      case \"RestElement\":\n        this.enterRestElement(pattern, onIdent);\n        break;\n\n      case \"Property\":\n        if (pattern.shorthand && pattern.value.type === \"Identifier\") {\n          this.scope.inShorthand = pattern.value.name;\n          this.enterIdentifier(pattern.value, onIdent);\n          this.scope.inShorthand = false;\n        } else {\n          this.enterPattern(pattern.value, onIdent);\n        }\n\n        break;\n    }\n  }\n\n  enterIdentifier(pattern, onIdent) {\n    if (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {\n      onIdent(pattern.name, pattern);\n    }\n  }\n\n  enterObjectPattern(pattern, onIdent) {\n    for (let propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n      const prop = pattern.properties[propIndex];\n      this.enterPattern(prop, onIdent);\n    }\n  }\n\n  enterArrayPattern(pattern, onIdent) {\n    for (let elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n      const element = pattern.elements[elementIndex];\n      this.enterPattern(element, onIdent);\n    }\n  }\n\n  enterRestElement(pattern, onIdent) {\n    this.enterPattern(pattern.argument, onIdent);\n  }\n\n  enterAssignmentPattern(pattern, onIdent) {\n    this.enterPattern(pattern.left, onIdent);\n  }\n  /**\n   * @param {ExpressionNode} expression expression node\n   * @returns {BasicEvaluatedExpression} evaluation result\n   */\n\n\n  evaluateExpression(expression) {\n    try {\n      const hook = this.hooks.evaluate.get(expression.type);\n\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n\n        if (result !== undefined && result !== null) {\n          result.setExpression(expression);\n          return result;\n        }\n      }\n    } catch (e) {\n      console.warn(e); // ignore error\n    }\n\n    return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);\n  }\n\n  parseString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          return this.parseString(expression.left) + this.parseString(expression.right);\n        }\n\n        break;\n\n      case \"Literal\":\n        return expression.value + \"\";\n    }\n\n    throw new Error(expression.type + \" is not supported as parameter for require\");\n  }\n\n  parseCalculatedString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          const left = this.parseCalculatedString(expression.left);\n          const right = this.parseCalculatedString(expression.right);\n\n          if (left.code) {\n            return {\n              range: left.range,\n              value: left.value,\n              code: true,\n              conditional: false\n            };\n          } else if (right.code) {\n            return {\n              range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n              value: left.value + right.value,\n              code: true,\n              conditional: false\n            };\n          } else {\n            return {\n              range: [left.range[0], right.range[1]],\n              value: left.value + right.value,\n              code: false,\n              conditional: false\n            };\n          }\n        }\n\n        break;\n\n      case \"ConditionalExpression\":\n        {\n          const consequent = this.parseCalculatedString(expression.consequent);\n          const alternate = this.parseCalculatedString(expression.alternate);\n          const items = [];\n\n          if (consequent.conditional) {\n            items.push(...consequent.conditional);\n          } else if (!consequent.code) {\n            items.push(consequent);\n          } else {\n            break;\n          }\n\n          if (alternate.conditional) {\n            items.push(...alternate.conditional);\n          } else if (!alternate.code) {\n            items.push(alternate);\n          } else {\n            break;\n          }\n\n          return {\n            range: undefined,\n            value: \"\",\n            code: true,\n            conditional: items\n          };\n        }\n\n      case \"Literal\":\n        return {\n          range: expression.range,\n          value: expression.value + \"\",\n          code: false,\n          conditional: false\n        };\n    }\n\n    return {\n      range: undefined,\n      value: \"\",\n      code: true,\n      conditional: false\n    };\n  }\n  /**\n   * @param {string | Buffer | PreparsedAst} source the source to parse\n   * @param {ParserState} state the parser state\n   * @returns {ParserState} the parser state\n   */\n\n\n  parse(source, state) {\n    let ast;\n    let comments;\n    const semicolons = new Set();\n\n    if (source === null) {\n      throw new Error(\"source must not be null\");\n    }\n\n    if (Buffer.isBuffer(source)) {\n      source = source.toString(\"utf-8\");\n    }\n\n    if (typeof source === \"object\") {\n      ast =\n      /** @type {ProgramNode} */\n      source;\n      comments = source.comments;\n    } else {\n      comments = [];\n      ast = JavascriptParser._parse(source, {\n        sourceType: this.sourceType,\n        onComment: comments,\n        onInsertedSemicolon: pos => semicolons.add(pos)\n      });\n    }\n\n    const oldScope = this.scope;\n    const oldState = this.state;\n    const oldComments = this.comments;\n    const oldSemicolons = this.semicolons;\n    const oldStatementPath = this.statementPath;\n    const oldPrevStatement = this.prevStatement;\n    this.scope = {\n      topLevelScope: true,\n      inTry: false,\n      inShorthand: false,\n      isStrict: false,\n      isAsmJs: false,\n      definitions: new StackedMap()\n    };\n    /** @type {ParserState} */\n\n    this.state = state;\n    this.comments = comments;\n    this.semicolons = semicolons;\n    this.statementPath = [];\n    this.prevStatement = undefined;\n\n    if (this.hooks.program.call(ast, comments) === undefined) {\n      this.detectMode(ast.body);\n      this.preWalkStatements(ast.body);\n      this.prevStatement = undefined;\n      this.blockPreWalkStatements(ast.body);\n      this.prevStatement = undefined;\n      this.walkStatements(ast.body);\n    }\n\n    this.hooks.finish.call(ast, comments);\n    this.scope = oldScope;\n    /** @type {ParserState} */\n\n    this.state = oldState;\n    this.comments = oldComments;\n    this.semicolons = oldSemicolons;\n    this.statementPath = oldStatementPath;\n    this.prevStatement = oldPrevStatement;\n    return state;\n  }\n  /**\n   * @param {string} source source code\n   * @returns {BasicEvaluatedExpression} evaluation result\n   */\n\n\n  evaluate(source) {\n    const ast = JavascriptParser._parse(\"(\" + source + \")\", {\n      sourceType: this.sourceType,\n      locations: false\n    });\n\n    if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n      throw new Error(\"evaluate: Source is not a expression\");\n    }\n\n    return this.evaluateExpression(ast.body[0].expression);\n  }\n  /**\n   * @param {ExpressionNode | DeclarationNode | PrivateIdentifierNode | null | undefined} expr an expression\n   * @param {number} commentsStartPos source position from which annotation comments are checked\n   * @returns {boolean} true, when the expression is pure\n   */\n\n\n  isPure(expr, commentsStartPos) {\n    if (!expr) return true;\n    const result = this.hooks.isPure.for(expr.type).call(expr, commentsStartPos);\n    if (typeof result === \"boolean\") return result;\n\n    switch (expr.type) {\n      case \"ClassDeclaration\":\n      case \"ClassExpression\":\n        {\n          if (expr.body.type !== \"ClassBody\") return false;\n\n          if (expr.superClass && !this.isPure(expr.superClass, expr.range[0])) {\n            return false;\n          }\n\n          const items =\n          /** @type {(MethodDefinitionNode | PropertyDefinitionNode)[]} */\n          expr.body.body;\n          return items.every(item => (!item.computed || !item.key || this.isPure(item.key, item.range[0])) && (!item.static || !item.value || this.isPure(item.value, item.key ? item.key.range[1] : item.range[0])));\n        }\n\n      case \"FunctionDeclaration\":\n      case \"FunctionExpression\":\n      case \"ArrowFunctionExpression\":\n      case \"Literal\":\n      case \"PrivateIdentifier\":\n        return true;\n\n      case \"VariableDeclaration\":\n        return expr.declarations.every(decl => this.isPure(decl.init, decl.range[0]));\n\n      case \"ConditionalExpression\":\n        return this.isPure(expr.test, commentsStartPos) && this.isPure(expr.consequent, expr.test.range[1]) && this.isPure(expr.alternate, expr.consequent.range[1]);\n\n      case \"SequenceExpression\":\n        return expr.expressions.every(expr => {\n          const pureFlag = this.isPure(expr, commentsStartPos);\n          commentsStartPos = expr.range[1];\n          return pureFlag;\n        });\n\n      case \"CallExpression\":\n        {\n          const pureFlag = expr.range[0] - commentsStartPos > 12 && this.getComments([commentsStartPos, expr.range[0]]).some(comment => comment.type === \"Block\" && /^\\s*(#|@)__PURE__\\s*$/.test(comment.value));\n          if (!pureFlag) return false;\n          commentsStartPos = expr.callee.range[1];\n          return expr.arguments.every(arg => {\n            if (arg.type === \"SpreadElement\") return false;\n            const pureFlag = this.isPure(arg, commentsStartPos);\n            commentsStartPos = arg.range[1];\n            return pureFlag;\n          });\n        }\n    }\n\n    const evaluated = this.evaluateExpression(expr);\n    return !evaluated.couldHaveSideEffects();\n  }\n\n  getComments(range) {\n    const [rangeStart, rangeEnd] = range;\n\n    const compare = (comment, needle) => comment.range[0] - needle;\n\n    let idx = binarySearchBounds.ge(this.comments, rangeStart, compare);\n    let commentsInRange = [];\n\n    while (this.comments[idx] && this.comments[idx].range[1] <= rangeEnd) {\n      commentsInRange.push(this.comments[idx]);\n      idx++;\n    }\n\n    return commentsInRange;\n  }\n  /**\n   * @param {number} pos source code position\n   * @returns {boolean} true when a semicolon has been inserted before this position, false if not\n   */\n\n\n  isAsiPosition(pos) {\n    const currentStatement = this.statementPath[this.statementPath.length - 1];\n    if (currentStatement === undefined) throw new Error(\"Not in statement\");\n    return (// Either asking directly for the end position of the current statement\n      currentStatement.range[1] === pos && this.semicolons.has(pos) || // Or asking for the start position of the current statement,\n      // here we have to check multiple things\n      currentStatement.range[0] === pos && // is there a previous statement which might be relevant?\n      this.prevStatement !== undefined && // is the end position of the previous statement an ASI position?\n      this.semicolons.has(this.prevStatement.range[1])\n    );\n  }\n  /**\n   * @param {number} pos source code position\n   * @returns {void}\n   */\n\n\n  unsetAsiPosition(pos) {\n    this.semicolons.delete(pos);\n  }\n\n  isStatementLevelExpression(expr) {\n    const currentStatement = this.statementPath[this.statementPath.length - 1];\n    return expr === currentStatement || currentStatement.type === \"ExpressionStatement\" && currentStatement.expression === expr;\n  }\n\n  getTagData(name, tag) {\n    const info = this.scope.definitions.get(name);\n\n    if (info instanceof VariableInfo) {\n      let tagInfo = info.tagInfo;\n\n      while (tagInfo !== undefined) {\n        if (tagInfo.tag === tag) return tagInfo.data;\n        tagInfo = tagInfo.next;\n      }\n    }\n  }\n\n  tagVariable(name, tag, data) {\n    const oldInfo = this.scope.definitions.get(name);\n    /** @type {VariableInfo} */\n\n    let newInfo;\n\n    if (oldInfo === undefined) {\n      newInfo = new VariableInfo(this.scope, name, {\n        tag,\n        data,\n        next: undefined\n      });\n    } else if (oldInfo instanceof VariableInfo) {\n      newInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {\n        tag,\n        data,\n        next: oldInfo.tagInfo\n      });\n    } else {\n      newInfo = new VariableInfo(oldInfo, true, {\n        tag,\n        data,\n        next: undefined\n      });\n    }\n\n    this.scope.definitions.set(name, newInfo);\n  }\n\n  defineVariable(name) {\n    const oldInfo = this.scope.definitions.get(name); // Don't redefine variable in same scope to keep existing tags\n\n    if (oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope) return;\n    this.scope.definitions.set(name, this.scope);\n  }\n\n  undefineVariable(name) {\n    this.scope.definitions.delete(name);\n  }\n\n  isVariableDefined(name) {\n    const info = this.scope.definitions.get(name);\n    if (info === undefined) return false;\n\n    if (info instanceof VariableInfo) {\n      return info.freeName === true;\n    }\n\n    return true;\n  }\n  /**\n   * @param {string} name variable name\n   * @returns {ExportedVariableInfo} info for this variable\n   */\n\n\n  getVariableInfo(name) {\n    const value = this.scope.definitions.get(name);\n\n    if (value === undefined) {\n      return name;\n    } else {\n      return value;\n    }\n  }\n  /**\n   * @param {string} name variable name\n   * @param {ExportedVariableInfo} variableInfo new info for this variable\n   * @returns {void}\n   */\n\n\n  setVariable(name, variableInfo) {\n    if (typeof variableInfo === \"string\") {\n      if (variableInfo === name) {\n        this.scope.definitions.delete(name);\n      } else {\n        this.scope.definitions.set(name, new VariableInfo(this.scope, variableInfo, undefined));\n      }\n    } else {\n      this.scope.definitions.set(name, variableInfo);\n    }\n  }\n\n  evaluatedVariable(tagInfo) {\n    return new VariableInfo(this.scope, undefined, tagInfo);\n  }\n\n  parseCommentOptions(range) {\n    const comments = this.getComments(range);\n\n    if (comments.length === 0) {\n      return EMPTY_COMMENT_OPTIONS;\n    }\n\n    let options = {};\n    let errors = [];\n\n    for (const comment of comments) {\n      const {\n        value\n      } = comment;\n\n      if (value && webpackCommentRegExp.test(value)) {\n        // try compile only if webpack options comment is present\n        try {\n          const val = vm.runInNewContext(`(function(){return {${value}};})()`);\n          Object.assign(options, val);\n        } catch (e) {\n          e.comment = comment;\n          errors.push(e);\n        }\n      }\n    }\n\n    return {\n      options,\n      errors\n    };\n  }\n  /**\n   * @param {MemberExpressionNode} expression a member expression\n   * @returns {{ members: string[], object: ExpressionNode | SuperNode, membersOptionals: boolean[] }} member names (reverse order) and remaining object\n   */\n\n\n  extractMemberExpressionChain(expression) {\n    /** @type {AnyNode} */\n    let expr = expression;\n    const members = [];\n    const membersOptionals = [];\n\n    while (expr.type === \"MemberExpression\") {\n      if (expr.computed) {\n        if (expr.property.type !== \"Literal\") break;\n        members.push(`${expr.property.value}`);\n      } else {\n        if (expr.property.type !== \"Identifier\") break;\n        members.push(expr.property.name);\n      }\n\n      membersOptionals.push(expr.optional);\n      expr = expr.object;\n    }\n\n    return {\n      members,\n      membersOptionals,\n      object: expr\n    };\n  }\n  /**\n   * @param {string} varName variable name\n   * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that\n   */\n\n\n  getFreeInfoFromVariable(varName) {\n    const info = this.getVariableInfo(varName);\n    let name;\n\n    if (info instanceof VariableInfo) {\n      name = info.freeName;\n      if (typeof name !== \"string\") return undefined;\n    } else if (typeof info !== \"string\") {\n      return undefined;\n    } else {\n      name = info;\n    }\n\n    return {\n      info,\n      name\n    };\n  }\n  /** @typedef {{ type: \"call\", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[], getMembersOptionals: () => boolean[]}} CallExpressionInfo */\n\n  /** @typedef {{ type: \"expression\", rootInfo: string | VariableInfo, name: string, getMembers: () => string[], getMembersOptionals: () => boolean[]}} ExpressionExpressionInfo */\n\n  /**\n   * @param {MemberExpressionNode} expression a member expression\n   * @param {number} allowedTypes which types should be returned, presented in bit mask\n   * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info\n   */\n\n\n  getMemberExpressionInfo(expression, allowedTypes) {\n    const {\n      object,\n      members,\n      membersOptionals\n    } = this.extractMemberExpressionChain(expression);\n\n    switch (object.type) {\n      case \"CallExpression\":\n        {\n          if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0) return undefined;\n          let callee = object.callee;\n          let rootMembers = EMPTY_ARRAY;\n\n          if (callee.type === \"MemberExpression\") {\n            ({\n              object: callee,\n              members: rootMembers\n            } = this.extractMemberExpressionChain(callee));\n          }\n\n          const rootName = getRootName(callee);\n          if (!rootName) return undefined;\n          const result = this.getFreeInfoFromVariable(rootName);\n          if (!result) return undefined;\n          const {\n            info: rootInfo,\n            name: resolvedRoot\n          } = result;\n          const calleeName = objectAndMembersToName(resolvedRoot, rootMembers);\n          return {\n            type: \"call\",\n            call: object,\n            calleeName,\n            rootInfo,\n            getCalleeMembers: memoize(() => rootMembers.reverse()),\n            name: objectAndMembersToName(`${calleeName}()`, members),\n            getMembers: memoize(() => members.reverse()),\n            getMembersOptionals: memoize(() => membersOptionals.reverse())\n          };\n        }\n\n      case \"Identifier\":\n      case \"MetaProperty\":\n      case \"ThisExpression\":\n        {\n          if ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0) return undefined;\n          const rootName = getRootName(object);\n          if (!rootName) return undefined;\n          const result = this.getFreeInfoFromVariable(rootName);\n          if (!result) return undefined;\n          const {\n            info: rootInfo,\n            name: resolvedRoot\n          } = result;\n          return {\n            type: \"expression\",\n            name: objectAndMembersToName(resolvedRoot, members),\n            rootInfo,\n            getMembers: memoize(() => members.reverse()),\n            getMembersOptionals: memoize(() => membersOptionals.reverse())\n          };\n        }\n    }\n  }\n  /**\n   * @param {MemberExpressionNode} expression an expression\n   * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]}} name info\n   */\n\n\n  getNameForExpression(expression) {\n    return this.getMemberExpressionInfo(expression, ALLOWED_MEMBER_TYPES_EXPRESSION);\n  }\n  /**\n   * @param {string} code source code\n   * @param {ParseOptions} options parsing options\n   * @returns {ProgramNode} parsed ast\n   */\n\n\n  static _parse(code, options) {\n    const type = options ? options.sourceType : \"module\";\n    /** @type {AcornOptions} */\n\n    const parserOptions = { ...defaultParserOptions,\n      allowReturnOutsideFunction: type === \"script\",\n      ...options,\n      sourceType: type === \"auto\" ? \"module\" : type\n    };\n    /** @type {AnyNode} */\n\n    let ast;\n    let error;\n    let threw = false;\n\n    try {\n      ast =\n      /** @type {AnyNode} */\n      parser.parse(code, parserOptions);\n    } catch (e) {\n      error = e;\n      threw = true;\n    }\n\n    if (threw && type === \"auto\") {\n      parserOptions.sourceType = \"script\";\n\n      if (!(\"allowReturnOutsideFunction\" in options)) {\n        parserOptions.allowReturnOutsideFunction = true;\n      }\n\n      if (Array.isArray(parserOptions.onComment)) {\n        parserOptions.onComment.length = 0;\n      }\n\n      try {\n        ast =\n        /** @type {AnyNode} */\n        parser.parse(code, parserOptions);\n        threw = false;\n      } catch (e) {// we use the error from first parse try\n        // so nothing to do here\n      }\n    }\n\n    if (threw) {\n      throw error;\n    }\n\n    return (\n      /** @type {ProgramNode} */\n      ast\n    );\n  }\n\n}\n\nmodule.exports = JavascriptParser;\nmodule.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;\nmodule.exports.ALLOWED_MEMBER_TYPES_EXPRESSION = ALLOWED_MEMBER_TYPES_EXPRESSION;\nmodule.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = ALLOWED_MEMBER_TYPES_CALL_EXPRESSION;","map":{"version":3,"names":["Parser","AcornParser","require","importAssertions","SyncBailHook","HookMap","vm","StackedMap","binarySearchBounds","memoize","BasicEvaluatedExpression","EMPTY_ARRAY","ALLOWED_MEMBER_TYPES_CALL_EXPRESSION","ALLOWED_MEMBER_TYPES_EXPRESSION","ALLOWED_MEMBER_TYPES_ALL","parser","extend","VariableInfo","constructor","declaredScope","freeName","tagInfo","joinRanges","startRange","endRange","objectAndMembersToName","object","membersReversed","name","i","length","getRootName","expression","type","meta","property","undefined","defaultParserOptions","ranges","locations","ecmaVersion","sourceType","allowHashBang","onComment","webpackCommentRegExp","RegExp","EMPTY_COMMENT_OPTIONS","options","errors","JavascriptParser","hooks","Object","freeze","evaluateTypeof","evaluate","evaluateIdentifier","evaluateDefinedIdentifier","evaluateNewExpression","evaluateCallExpression","evaluateCallExpressionMember","isPure","preStatement","blockPreStatement","statement","statementIf","classExtendsExpression","classBodyElement","classBodyValue","label","import","importSpecifier","export","exportImport","exportDeclaration","exportExpression","exportSpecifier","exportImportSpecifier","preDeclarator","declarator","varDeclaration","varDeclarationLet","varDeclarationConst","varDeclarationVar","pattern","canRename","rename","assign","assignMemberChain","typeof","importCall","topLevelAwait","call","callMemberChain","memberChainOfCallMemberChain","callMemberChainOfCallMemberChain","optionalChaining","new","binaryExpression","expressionMemberChain","unhandledExpressionMemberChain","expressionConditionalOperator","expressionLogicalOperator","program","finish","scope","state","comments","semicolons","statementPath","prevStatement","currentTagData","_initializeEvaluating","for","tap","_expr","expr","value","setNumber","setRange","range","setBigInt","setString","setBoolean","setNull","setRegExp","callee","callHooksForName","arguments","getVariableInfo","regExp","flags","arg1","evaluatedRegExp","evaluateExpression","asString","arg2","evaluatedFlags","isUndefined","isValidRegExpFlags","left","returnRight","allowedRight","operator","leftAsBool","asBool","leftAsNullish","asNullish","right","couldHaveSideEffects","setSideEffects","setTruthy","setFalsy","valueAsExpression","sideEffects","handleConstOperation","fn","isCompileTimeValue","result","asCompileTimeValue","isAlwaysDifferent","a","b","handleTemplateStringCompare","res","eql","getPrefix","parts","p","v","getSuffix","leftPrefix","rightPrefix","leftSuffix","rightSuffix","lenPrefix","Math","min","lenSuffix","slice","handleStrictEqualityComparison","leftConst","rightConst","isArray","isTemplateString","leftPrimitive","isPrimitiveType","rightPrimitive","handleAbstractEqualityComparison","isString","string","isNumber","number","isWrapped","prefix","setWrapped","postfix","wrappedInnerExpressions","isBigInt","bigint","concat","l","r","argument","callHooksForExpression","arg","isUnknown","isBoolean","isConstArray","isRegExp","isNull","bool","setUndefined","tapEvaluateWithVariableInfo","exprType","getInfo","cachedExpression","cachedInfo","info","callHooksForInfoWithFallback","hook","get","stage","setIdentifier","rootInfo","getMembers","getMembersOptionals","metaProperty","getMemberExpressionInfo","computed","param","arg1Eval","arg1Value","arg2Eval","indexOf","arg2Value","replace","forEach","str","getSimplifiedTemplateResult","kind","templateLiteralExpr","quasis","quasiExpr","quasi","prevExpr","expressions","exprAsString","setExpression","push","part","_node","node","setTemplateString","tag","isIdentifier","identifier","stringSuffix","hasUnknownParams","innerExpressions","argExpr","newString","newRange","inner","reverse","split","setArray","condition","test","conditionValue","consequent","alternate","isConditional","setOptions","addOptions","items","elements","map","element","every","Boolean","setItems","optionalExpressionsStack","next","optional","pop","evaluated","getRenameIdentifier","walkClass","classy","superClass","walkExpression","body","classElement","key","wasTopLevel","topLevelScope","preWalkStatements","statements","index","len","preWalkStatement","blockPreWalkStatements","blockPreWalkStatement","walkStatements","walkStatement","preWalkBlockStatement","preWalkDoWhileStatement","preWalkForInStatement","preWalkForOfStatement","preWalkForStatement","preWalkFunctionDeclaration","preWalkIfStatement","preWalkLabeledStatement","preWalkSwitchStatement","preWalkTryStatement","preWalkVariableDeclaration","preWalkWhileStatement","preWalkWithStatement","blockPreWalkImportDeclaration","blockPreWalkExportAllDeclaration","blockPreWalkExportDefaultDeclaration","blockPreWalkExportNamedDeclaration","blockPreWalkVariableDeclaration","blockPreWalkClassDeclaration","walkBlockStatement","walkClassDeclaration","walkDoWhileStatement","walkExportDefaultDeclaration","walkExportNamedDeclaration","walkExpressionStatement","walkForInStatement","walkForOfStatement","walkForStatement","walkFunctionDeclaration","walkIfStatement","walkLabeledStatement","walkReturnStatement","walkSwitchStatement","walkThrowStatement","walkTryStatement","walkVariableDeclaration","walkWhileStatement","walkWithStatement","walkNestedStatement","inBlockScope","prev","preWalkSwitchCases","cases","discriminant","walkSwitchCases","walkTerminatingStatement","block","handler","preWalkCatchClause","finializer","inTry","walkCatchClause","finalizer","init","update","walkPattern","await","id","defineVariable","inFunctionScope","params","detectMode","source","specifier","specifiers","local","imported","enterDeclaration","declaration","onIdent","declarations","enterPattern","def","specifierIndex","exported","_preWalkVariableDeclaration","hookMap","decl","renameIdentifier","setVariable","switchCases","switchCase","catchClause","ident","walkArrayPattern","walkAssignmentPattern","walkMemberExpression","walkObjectPattern","walkRestElement","properties","prop","walkExpressions","walkArrayExpression","walkArrowFunctionExpression","walkAssignmentExpression","walkAwaitExpression","walkBinaryExpression","walkCallExpression","walkChainExpression","walkClassExpression","walkConditionalExpression","walkFunctionExpression","walkIdentifier","walkImportExpression","walkLogicalExpression","walkMetaProperty","walkNewExpression","walkObjectExpression","walkSequenceExpression","walkSpreadElement","walkTaggedTemplateExpression","walkTemplateLiteral","walkThisExpression","walkUnaryExpression","walkUpdateExpression","walkYieldExpression","propIndex","walkProperty","shorthand","inShorthand","scopeParams","currentStatement","old","walkLeftRightExpression","callHooksForInfo","endsWith","exprName","_walkIIFE","functionExpression","currentThis","getVarInfo","argOrThis","arrow","renameThis","varInfoForArgs","filter","idx","varInfo","isSimpleFunction","exprInfo","getCalleeMembers","result1","result2","members","membersOptionals","walkMemberExpressionWithExpressionName","onUnhandled","args","callHooksForExpressionWithFallback","fallback","defined","callHooksForNameWithFallback","data","inScope","oldScope","isStrict","isAsmJs","definitions","createChild","undefineVariable","enterPatterns","hasThis","isLiteral","patterns","enterArrayPattern","enterAssignmentPattern","enterIdentifier","enterObjectPattern","enterRestElement","elementIndex","e","console","warn","parseString","Error","parseCalculatedString","code","conditional","parse","ast","Set","Buffer","isBuffer","toString","_parse","onInsertedSemicolon","pos","add","oldState","oldComments","oldSemicolons","oldStatementPath","oldPrevStatement","commentsStartPos","item","static","pureFlag","getComments","some","comment","rangeStart","rangeEnd","compare","needle","ge","commentsInRange","isAsiPosition","has","unsetAsiPosition","delete","isStatementLevelExpression","getTagData","tagVariable","oldInfo","newInfo","set","isVariableDefined","variableInfo","evaluatedVariable","parseCommentOptions","val","runInNewContext","extractMemberExpressionChain","getFreeInfoFromVariable","varName","allowedTypes","rootMembers","rootName","resolvedRoot","calleeName","getNameForExpression","parserOptions","allowReturnOutsideFunction","error","threw","Array","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/javascript/JavascriptParser.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { Parser: AcornParser } = require(\"acorn\");\nconst { importAssertions } = require(\"acorn-import-assertions\");\nconst { SyncBailHook, HookMap } = require(\"tapable\");\nconst vm = require(\"vm\");\nconst Parser = require(\"../Parser\");\nconst StackedMap = require(\"../util/StackedMap\");\nconst binarySearchBounds = require(\"../util/binarySearchBounds\");\nconst memoize = require(\"../util/memoize\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\n/** @typedef {import(\"acorn\").Options} AcornOptions */\n/** @typedef {import(\"estree\").ArrayExpression} ArrayExpressionNode */\n/** @typedef {import(\"estree\").BinaryExpression} BinaryExpressionNode */\n/** @typedef {import(\"estree\").BlockStatement} BlockStatementNode */\n/** @typedef {import(\"estree\").SequenceExpression} SequenceExpressionNode */\n/** @typedef {import(\"estree\").CallExpression} CallExpressionNode */\n/** @typedef {import(\"estree\").ClassDeclaration} ClassDeclarationNode */\n/** @typedef {import(\"estree\").ClassExpression} ClassExpressionNode */\n/** @typedef {import(\"estree\").Comment} CommentNode */\n/** @typedef {import(\"estree\").ConditionalExpression} ConditionalExpressionNode */\n/** @typedef {import(\"estree\").Declaration} DeclarationNode */\n/** @typedef {import(\"estree\").PrivateIdentifier} PrivateIdentifierNode */\n/** @typedef {import(\"estree\").PropertyDefinition} PropertyDefinitionNode */\n/** @typedef {import(\"estree\").Expression} ExpressionNode */\n/** @typedef {import(\"estree\").Identifier} IdentifierNode */\n/** @typedef {import(\"estree\").IfStatement} IfStatementNode */\n/** @typedef {import(\"estree\").LabeledStatement} LabeledStatementNode */\n/** @typedef {import(\"estree\").Literal} LiteralNode */\n/** @typedef {import(\"estree\").LogicalExpression} LogicalExpressionNode */\n/** @typedef {import(\"estree\").ChainExpression} ChainExpressionNode */\n/** @typedef {import(\"estree\").MemberExpression} MemberExpressionNode */\n/** @typedef {import(\"estree\").MetaProperty} MetaPropertyNode */\n/** @typedef {import(\"estree\").MethodDefinition} MethodDefinitionNode */\n/** @typedef {import(\"estree\").ModuleDeclaration} ModuleDeclarationNode */\n/** @typedef {import(\"estree\").NewExpression} NewExpressionNode */\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"estree\").Program} ProgramNode */\n/** @typedef {import(\"estree\").Statement} StatementNode */\n/** @typedef {import(\"estree\").ImportDeclaration} ImportDeclarationNode */\n/** @typedef {import(\"estree\").ExportNamedDeclaration} ExportNamedDeclarationNode */\n/** @typedef {import(\"estree\").ExportDefaultDeclaration} ExportDefaultDeclarationNode */\n/** @typedef {import(\"estree\").ExportAllDeclaration} ExportAllDeclarationNode */\n/** @typedef {import(\"estree\").Super} SuperNode */\n/** @typedef {import(\"estree\").TaggedTemplateExpression} TaggedTemplateExpressionNode */\n/** @typedef {import(\"estree\").TemplateLiteral} TemplateLiteralNode */\n/** @typedef {import(\"estree\").ThisExpression} ThisExpressionNode */\n/** @typedef {import(\"estree\").UnaryExpression} UnaryExpressionNode */\n/** @typedef {import(\"estree\").VariableDeclarator} VariableDeclaratorNode */\n/** @template T @typedef {import(\"tapable\").AsArray<T>} AsArray<T> */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../Parser\").PreparsedAst} PreparsedAst */\n/** @typedef {{declaredScope: ScopeInfo, freeName: string | true, tagInfo: TagInfo | undefined}} VariableInfoInterface */\n/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[], getMembersOptionals: () => boolean[] }} GetInfoResult */\n\nconst EMPTY_ARRAY = [];\nconst ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;\nconst ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;\nconst ALLOWED_MEMBER_TYPES_ALL = 0b11;\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst parser = AcornParser.extend(importAssertions);\n\nclass VariableInfo {\n\t/**\n\t * @param {ScopeInfo} declaredScope scope in which the variable is declared\n\t * @param {string | true} freeName which free name the variable aliases, or true when none\n\t * @param {TagInfo | undefined} tagInfo info about tags\n\t */\n\tconstructor(declaredScope, freeName, tagInfo) {\n\t\tthis.declaredScope = declaredScope;\n\t\tthis.freeName = freeName;\n\t\tthis.tagInfo = tagInfo;\n\t}\n}\n\n/** @typedef {string | ScopeInfo | VariableInfo} ExportedVariableInfo */\n/** @typedef {LiteralNode | string | null | undefined} ImportSource */\n/** @typedef {Omit<AcornOptions, \"sourceType\" | \"ecmaVersion\"> & { sourceType: \"module\" | \"script\" | \"auto\", ecmaVersion?: AcornOptions[\"ecmaVersion\"] }} ParseOptions */\n\n/**\n * @typedef {Object} TagInfo\n * @property {any} tag\n * @property {any} data\n * @property {TagInfo | undefined} next\n */\n\n/**\n * @typedef {Object} ScopeInfo\n * @property {StackedMap<string, VariableInfo | ScopeInfo>} definitions\n * @property {boolean | \"arrow\"} topLevelScope\n * @property {boolean} inShorthand\n * @property {boolean} isStrict\n * @property {boolean} isAsmJs\n * @property {boolean} inTry\n */\n\nconst joinRanges = (startRange, endRange) => {\n\tif (!endRange) return startRange;\n\tif (!startRange) return endRange;\n\treturn [startRange[0], endRange[1]];\n};\n\nconst objectAndMembersToName = (object, membersReversed) => {\n\tlet name = object;\n\tfor (let i = membersReversed.length - 1; i >= 0; i--) {\n\t\tname = name + \".\" + membersReversed[i];\n\t}\n\treturn name;\n};\n\nconst getRootName = expression => {\n\tswitch (expression.type) {\n\t\tcase \"Identifier\":\n\t\t\treturn expression.name;\n\t\tcase \"ThisExpression\":\n\t\t\treturn \"this\";\n\t\tcase \"MetaProperty\":\n\t\t\treturn `${expression.meta.name}.${expression.property.name}`;\n\t\tdefault:\n\t\t\treturn undefined;\n\t}\n};\n\n/** @type {AcornOptions} */\nconst defaultParserOptions = {\n\tranges: true,\n\tlocations: true,\n\tecmaVersion: \"latest\",\n\tsourceType: \"module\",\n\t// https://github.com/tc39/proposal-hashbang\n\tallowHashBang: true,\n\tonComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\n\nconst EMPTY_COMMENT_OPTIONS = {\n\toptions: null,\n\terrors: null\n};\n\nclass JavascriptParser extends Parser {\n\t/**\n\t * @param {\"module\" | \"script\" | \"auto\"} sourceType default source type\n\t */\n\tconstructor(sourceType = \"auto\") {\n\t\tsuper();\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {HookMap<SyncBailHook<[UnaryExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode | MetaPropertyNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[IdentifierNode | ThisExpressionNode | MemberExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateDefinedIdentifier: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[NewExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateNewExpression: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpressionNode], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateCallExpression: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpressionNode, BasicEvaluatedExpression | undefined], BasicEvaluatedExpression | undefined | null>>} */\n\t\t\tevaluateCallExpressionMember: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"param\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode | DeclarationNode | PrivateIdentifierNode, number], boolean | void>>} */\n\t\t\tisPure: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"commentsStartPosition\"])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n\t\t\tpreStatement: new SyncBailHook([\"statement\"]),\n\n\t\t\t/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n\t\t\tblockPreStatement: new SyncBailHook([\"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[StatementNode | ModuleDeclarationNode], boolean | void>} */\n\t\t\tstatement: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[IfStatementNode], boolean | void>} */\n\t\t\tstatementIf: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n\t\t\tclassExtendsExpression: new SyncBailHook([\n\t\t\t\t\"expression\",\n\t\t\t\t\"classDefinition\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n\t\t\tclassBodyElement: new SyncBailHook([\"element\", \"classDefinition\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode, MethodDefinitionNode | PropertyDefinitionNode, ClassExpressionNode | ClassDeclarationNode], boolean | void>} */\n\t\t\tclassBodyValue: new SyncBailHook([\n\t\t\t\t\"expression\",\n\t\t\t\t\"element\",\n\t\t\t\t\"classDefinition\"\n\t\t\t]),\n\t\t\t/** @type {HookMap<SyncBailHook<[LabeledStatementNode], boolean | void>>} */\n\t\t\tlabel: new HookMap(() => new SyncBailHook([\"statement\"])),\n\t\t\t/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource], boolean | void>} */\n\t\t\timport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\t/** @type {SyncBailHook<[ImportDeclarationNode, ImportSource, string, string], boolean | void>} */\n\t\t\timportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"identifierName\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode], boolean | void>} */\n\t\t\texport: new SyncBailHook([\"statement\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource], boolean | void>} */\n\t\t\texportImport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, DeclarationNode], boolean | void>} */\n\t\t\texportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[ExportDefaultDeclarationNode, DeclarationNode], boolean | void>} */\n\t\t\texportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, string, string, number | undefined], boolean | void>} */\n\t\t\texportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[ExportNamedDeclarationNode | ExportAllDeclarationNode, ImportSource, string, string, number | undefined], boolean | void>} */\n\t\t\texportImportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\t/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n\t\t\tpreDeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\t\t\t/** @type {SyncBailHook<[VariableDeclaratorNode, StatementNode], boolean | void>} */\n\t\t\tdeclarator: new SyncBailHook([\"declarator\", \"statement\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[DeclarationNode], boolean | void>>} */\n\t\t\tvarDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[IdentifierNode], boolean | void>>} */\n\t\t\tpattern: new HookMap(() => new SyncBailHook([\"pattern\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\tcanRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\trename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression], boolean | void>>} */\n\t\t\tassign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[import(\"estree\").AssignmentExpression, string[]], boolean | void>>} */\n\t\t\tassignMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\ttypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\timportCall: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\ttopLevelAwait: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\tcall: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** Something like \"a.b()\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[CallExpressionNode, string[], boolean[]], boolean | void>>} */\n\t\t\tcallMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\", \"membersOptionals\"])\n\t\t\t),\n\t\t\t/** Something like \"a.b().c.d\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n\t\t\tmemberChainOfCallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"calleeMembers\",\n\t\t\t\t\t\t\"callExpression\",\n\t\t\t\t\t\t\"members\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** Something like \"a.b().c.d()\"\" */\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], CallExpressionNode, string[]], boolean | void>>} */\n\t\t\tcallMemberChainOfCallMemberChain: new HookMap(\n\t\t\t\t() =>\n\t\t\t\t\tnew SyncBailHook([\n\t\t\t\t\t\t\"expression\",\n\t\t\t\t\t\t\"calleeMembers\",\n\t\t\t\t\t\t\"innerCallExpression\",\n\t\t\t\t\t\t\"members\"\n\t\t\t\t\t])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[ChainExpressionNode], boolean | void>} */\n\t\t\toptionalChaining: new SyncBailHook([\"optionalChaining\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[NewExpressionNode], boolean | void>>} */\n\t\t\tnew: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {SyncBailHook<[BinaryExpressionNode], boolean | void>} */\n\t\t\tbinaryExpression: new SyncBailHook([\"binaryExpression\"]),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode], boolean | void>>} */\n\t\t\texpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[], boolean[]], boolean | void>>} */\n\t\t\texpressionMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\", \"membersOptionals\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncBailHook<[ExpressionNode, string[]], boolean | void>>} */\n\t\t\tunhandledExpressionMemberChain: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"members\"])\n\t\t\t),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\texpressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[ExpressionNode], boolean | void>} */\n\t\t\texpressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\t\t\t/** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n\t\t\tprogram: new SyncBailHook([\"ast\", \"comments\"]),\n\t\t\t/** @type {SyncBailHook<[ProgramNode, CommentNode[]], boolean | void>} */\n\t\t\tfinish: new SyncBailHook([\"ast\", \"comments\"])\n\t\t});\n\t\tthis.sourceType = sourceType;\n\t\t/** @type {ScopeInfo} */\n\t\tthis.scope = undefined;\n\t\t/** @type {ParserState} */\n\t\tthis.state = undefined;\n\t\tthis.comments = undefined;\n\t\tthis.semicolons = undefined;\n\t\t/** @type {(StatementNode|ExpressionNode)[]} */\n\t\tthis.statementPath = undefined;\n\t\tthis.prevStatement = undefined;\n\t\tthis.currentTagData = undefined;\n\t\tthis._initializeEvaluating();\n\t}\n\n\t_initializeEvaluating() {\n\t\tthis.hooks.evaluate.for(\"Literal\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {LiteralNode} */ (_expr);\n\n\t\t\tswitch (typeof expr.value) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"bigint\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBigInt(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value === null) {\n\t\t\t\treturn new BasicEvaluatedExpression().setNull().setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value instanceof RegExp) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(expr.value)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"NewExpression\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {NewExpressionNode} */ (_expr);\n\t\t\tconst callee = expr.callee;\n\t\t\tif (callee.type !== \"Identifier\") return;\n\t\t\tif (callee.name !== \"RegExp\") {\n\t\t\t\treturn this.callHooksForName(\n\t\t\t\t\tthis.hooks.evaluateNewExpression,\n\t\t\t\t\tcallee.name,\n\t\t\t\t\texpr\n\t\t\t\t);\n\t\t\t} else if (\n\t\t\t\texpr.arguments.length > 2 ||\n\t\t\t\tthis.getVariableInfo(\"RegExp\") !== \"RegExp\"\n\t\t\t)\n\t\t\t\treturn;\n\n\t\t\tlet regExp, flags;\n\t\t\tconst arg1 = expr.arguments[0];\n\n\t\t\tif (arg1) {\n\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\n\t\t\t\tconst evaluatedRegExp = this.evaluateExpression(arg1);\n\n\t\t\t\tif (!evaluatedRegExp) return;\n\n\t\t\t\tregExp = evaluatedRegExp.asString();\n\n\t\t\t\tif (!regExp) return;\n\t\t\t} else {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(new RegExp(\"\"))\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\n\t\t\tconst arg2 = expr.arguments[1];\n\n\t\t\tif (arg2) {\n\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\n\t\t\t\tconst evaluatedFlags = this.evaluateExpression(arg2);\n\n\t\t\t\tif (!evaluatedFlags) return;\n\n\t\t\t\tif (!evaluatedFlags.isUndefined()) {\n\t\t\t\t\tflags = evaluatedFlags.asString();\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tflags === undefined ||\n\t\t\t\t\t\t!BasicEvaluatedExpression.isValidRegExpFlags(flags)\n\t\t\t\t\t)\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"LogicalExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {LogicalExpressionNode} */ (_expr);\n\n\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\tlet returnRight = false;\n\t\t\t\t/** @type {boolean|undefined} */\n\t\t\t\tlet allowedRight;\n\t\t\t\tif (expr.operator === \"&&\") {\n\t\t\t\t\tconst leftAsBool = left.asBool();\n\t\t\t\t\tif (leftAsBool === false) return left.setRange(expr.range);\n\t\t\t\t\treturnRight = leftAsBool === true;\n\t\t\t\t\tallowedRight = false;\n\t\t\t\t} else if (expr.operator === \"||\") {\n\t\t\t\t\tconst leftAsBool = left.asBool();\n\t\t\t\t\tif (leftAsBool === true) return left.setRange(expr.range);\n\t\t\t\t\treturnRight = leftAsBool === false;\n\t\t\t\t\tallowedRight = true;\n\t\t\t\t} else if (expr.operator === \"??\") {\n\t\t\t\t\tconst leftAsNullish = left.asNullish();\n\t\t\t\t\tif (leftAsNullish === false) return left.setRange(expr.range);\n\t\t\t\t\tif (leftAsNullish !== true) return;\n\t\t\t\t\treturnRight = true;\n\t\t\t\t} else return;\n\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\tif (returnRight) {\n\t\t\t\t\tif (left.couldHaveSideEffects()) right.setSideEffects();\n\t\t\t\t\treturn right.setRange(expr.range);\n\t\t\t\t}\n\n\t\t\t\tconst asBool = right.asBool();\n\n\t\t\t\tif (allowedRight === true && asBool === true) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setRange(expr.range)\n\t\t\t\t\t\t.setTruthy();\n\t\t\t\t} else if (allowedRight === false && asBool === false) {\n\t\t\t\t\treturn new BasicEvaluatedExpression().setRange(expr.range).setFalsy();\n\t\t\t\t}\n\t\t\t});\n\n\t\tconst valueAsExpression = (value, expr, sideEffects) => {\n\t\t\tswitch (typeof value) {\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"bigint\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBigInt(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(value)\n\t\t\t\t\t\t.setSideEffects(sideEffects)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t};\n\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"BinaryExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {BinaryExpressionNode} */ (_expr);\n\n\t\t\t\tconst handleConstOperation = fn => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tif (!left.isCompileTimeValue()) return;\n\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tif (!right.isCompileTimeValue()) return;\n\n\t\t\t\t\tconst result = fn(\n\t\t\t\t\t\tleft.asCompileTimeValue(),\n\t\t\t\t\t\tright.asCompileTimeValue()\n\t\t\t\t\t);\n\t\t\t\t\treturn valueAsExpression(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tconst isAlwaysDifferent = (a, b) =>\n\t\t\t\t\t(a === true && b === false) || (a === false && b === true);\n\n\t\t\t\tconst handleTemplateStringCompare = (left, right, res, eql) => {\n\t\t\t\t\tconst getPrefix = parts => {\n\t\t\t\t\t\tlet value = \"\";\n\t\t\t\t\t\tfor (const p of parts) {\n\t\t\t\t\t\t\tconst v = p.asString();\n\t\t\t\t\t\t\tif (v !== undefined) value += v;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t\tconst getSuffix = parts => {\n\t\t\t\t\t\tlet value = \"\";\n\t\t\t\t\t\tfor (let i = parts.length - 1; i >= 0; i--) {\n\t\t\t\t\t\t\tconst v = parts[i].asString();\n\t\t\t\t\t\t\tif (v !== undefined) value = v + value;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t};\n\t\t\t\t\tconst leftPrefix = getPrefix(left.parts);\n\t\t\t\t\tconst rightPrefix = getPrefix(right.parts);\n\t\t\t\t\tconst leftSuffix = getSuffix(left.parts);\n\t\t\t\t\tconst rightSuffix = getSuffix(right.parts);\n\t\t\t\t\tconst lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);\n\t\t\t\t\tconst lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);\n\t\t\t\t\tif (\n\t\t\t\t\t\tleftPrefix.slice(0, lenPrefix) !==\n\t\t\t\t\t\t\trightPrefix.slice(0, lenPrefix) ||\n\t\t\t\t\t\tleftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst handleStrictEqualityComparison = eql => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tres.setRange(expr.range);\n\n\t\t\t\t\tconst leftConst = left.isCompileTimeValue();\n\t\t\t\t\tconst rightConst = right.isCompileTimeValue();\n\n\t\t\t\t\tif (leftConst && rightConst) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(\n\t\t\t\t\t\t\t\teql ===\n\t\t\t\t\t\t\t\t\t(left.asCompileTimeValue() === right.asCompileTimeValue())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (left.isArray() && right.isArray()) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (left.isTemplateString() && right.isTemplateString()) {\n\t\t\t\t\t\treturn handleTemplateStringCompare(left, right, res, eql);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst leftPrimitive = left.isPrimitiveType();\n\t\t\t\t\tconst rightPrimitive = right.isPrimitiveType();\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Primitive !== Object or\n\t\t\t\t\t\t// compile-time object types are never equal to something at runtime\n\t\t\t\t\t\t(leftPrimitive === false &&\n\t\t\t\t\t\t\t(leftConst || rightPrimitive === true)) ||\n\t\t\t\t\t\t(rightPrimitive === false &&\n\t\t\t\t\t\t\t(rightConst || leftPrimitive === true)) ||\n\t\t\t\t\t\t// Different nullish or boolish status also means not equal\n\t\t\t\t\t\tisAlwaysDifferent(left.asBool(), right.asBool()) ||\n\t\t\t\t\t\tisAlwaysDifferent(left.asNullish(), right.asNullish())\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst handleAbstractEqualityComparison = eql => {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tres.setRange(expr.range);\n\n\t\t\t\t\tconst leftConst = left.isCompileTimeValue();\n\t\t\t\t\tconst rightConst = right.isCompileTimeValue();\n\n\t\t\t\t\tif (leftConst && rightConst) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(\n\t\t\t\t\t\t\t\teql ===\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\t\t\t\t\t(left.asCompileTimeValue() == right.asCompileTimeValue())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (left.isArray() && right.isArray()) {\n\t\t\t\t\t\treturn res\n\t\t\t\t\t\t\t.setBoolean(!eql)\n\t\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t\tleft.couldHaveSideEffects() || right.couldHaveSideEffects()\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (left.isTemplateString() && right.isTemplateString()) {\n\t\t\t\t\t\treturn handleTemplateStringCompare(left, right, res, eql);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (expr.operator === \"+\") {\n\t\t\t\t\tconst left = this.evaluateExpression(expr.left);\n\t\t\t\t\tconst right = this.evaluateExpression(expr.right);\n\t\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\t\tif (left.isString()) {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\tres.setString(left.string + right.string);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\tres.setString(left.string + right.number);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tright.isWrapped() &&\n\t\t\t\t\t\t\tright.prefix &&\n\t\t\t\t\t\t\tright.prefix.isString()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// \"left\" + (\"prefix\" + inner + \"postfix\")\n\t\t\t\t\t\t\t// => (\"leftPrefix\" + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.string + right.prefix.string)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.range, right.prefix.range)),\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// \"left\" + ([null] + inner + \"postfix\")\n\t\t\t\t\t\t\t// => (\"left\" + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// \"left\" + expr\n\t\t\t\t\t\t\t// => (\"left\" + expr + \"\")\n\t\t\t\t\t\t\tres.setWrapped(left, null, [right]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isNumber()) {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\tres.setString(left.number + right.string);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\tres.setNumber(left.number + right.number);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isBigInt()) {\n\t\t\t\t\t\tif (right.isBigInt()) {\n\t\t\t\t\t\t\tres.setBigInt(left.bigint + right.bigint);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (left.isWrapped()) {\n\t\t\t\t\t\tif (left.postfix && left.postfix.isString() && right.isString()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + \"right\"\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfixRight\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.string)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tleft.postfix &&\n\t\t\t\t\t\t\tleft.postfix.isString() &&\n\t\t\t\t\t\t\tright.isNumber()\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + 123\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfix123\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.number)\n\t\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isString()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + \"right\"\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"right\")\n\t\t\t\t\t\t\tres.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n\t\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + 123\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + \"123\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t\t.setString(right.number + \"\")\n\t\t\t\t\t\t\t\t\t.setRange(right.range),\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t\t.concat(left.postfix ? [left.postfix] : [])\n\t\t\t\t\t\t\t\t\t\t.concat(right.prefix ? [right.prefix] : [])\n\t\t\t\t\t\t\t\t\t\t.concat(right.wrappedInnerExpressions)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// (\"prefix\" + inner + postfix) + expr\n\t\t\t\t\t\t\t// => (\"prefix\" + inner + postfix + expr + [null])\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions.concat(\n\t\t\t\t\t\t\t\t\t\tleft.postfix ? [left.postfix, right] : [right]\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t\t// left + \"right\"\n\t\t\t\t\t\t\t// => ([null] + left + \"right\")\n\t\t\t\t\t\t\tres.setWrapped(null, right, [left]);\n\t\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t\t// left + (prefix + inner + \"postfix\")\n\t\t\t\t\t\t\t// => ([null] + left + prefix + inner + \"postfix\")\n\t\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t\t(right.prefix ? [left, right.prefix] : [left]).concat(\n\t\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (left.couldHaveSideEffects() || right.couldHaveSideEffects())\n\t\t\t\t\t\tres.setSideEffects();\n\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\treturn res;\n\t\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l - r);\n\t\t\t\t} else if (expr.operator === \"*\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l * r);\n\t\t\t\t} else if (expr.operator === \"/\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l / r);\n\t\t\t\t} else if (expr.operator === \"**\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l ** r);\n\t\t\t\t} else if (expr.operator === \"===\") {\n\t\t\t\t\treturn handleStrictEqualityComparison(true);\n\t\t\t\t} else if (expr.operator === \"==\") {\n\t\t\t\t\treturn handleAbstractEqualityComparison(true);\n\t\t\t\t} else if (expr.operator === \"!==\") {\n\t\t\t\t\treturn handleStrictEqualityComparison(false);\n\t\t\t\t} else if (expr.operator === \"!=\") {\n\t\t\t\t\treturn handleAbstractEqualityComparison(false);\n\t\t\t\t} else if (expr.operator === \"&\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l & r);\n\t\t\t\t} else if (expr.operator === \"|\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l | r);\n\t\t\t\t} else if (expr.operator === \"^\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l ^ r);\n\t\t\t\t} else if (expr.operator === \">>>\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >>> r);\n\t\t\t\t} else if (expr.operator === \">>\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >> r);\n\t\t\t\t} else if (expr.operator === \"<<\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l << r);\n\t\t\t\t} else if (expr.operator === \"<\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l < r);\n\t\t\t\t} else if (expr.operator === \">\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l > r);\n\t\t\t\t} else if (expr.operator === \"<=\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l <= r);\n\t\t\t\t} else if (expr.operator === \">=\") {\n\t\t\t\t\treturn handleConstOperation((l, r) => l >= r);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"UnaryExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {UnaryExpressionNode} */ (_expr);\n\n\t\t\t\tconst handleConstOperation = fn => {\n\t\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\t\tif (!argument.isCompileTimeValue()) return;\n\t\t\t\t\tconst result = fn(argument.asCompileTimeValue());\n\t\t\t\t\treturn valueAsExpression(\n\t\t\t\t\t\tresult,\n\t\t\t\t\t\texpr,\n\t\t\t\t\t\targument.couldHaveSideEffects()\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tif (expr.operator === \"typeof\") {\n\t\t\t\t\tswitch (expr.argument.type) {\n\t\t\t\t\t\tcase \"Identifier\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForName(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument.name,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"MetaProperty\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForName(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\tgetRootName(expr.argument),\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"MemberExpression\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForExpression(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"ChainExpression\": {\n\t\t\t\t\t\t\tconst res = this.callHooksForExpression(\n\t\t\t\t\t\t\t\tthis.hooks.evaluateTypeof,\n\t\t\t\t\t\t\t\texpr.argument.expression,\n\t\t\t\t\t\t\t\texpr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase \"FunctionExpression\": {\n\t\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(\"function\")\n\t\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst arg = this.evaluateExpression(expr.argument);\n\t\t\t\t\tif (arg.isUnknown()) return;\n\t\t\t\t\tif (arg.isString()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isWrapped()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t\t.setSideEffects()\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isUndefined()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"undefined\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isNumber()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"number\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isBigInt()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"bigint\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isBoolean()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"boolean\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t\tif (arg.isArray()) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t\t.setSideEffects(arg.couldHaveSideEffects())\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t} else if (expr.operator === \"!\") {\n\t\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\t\tconst bool = argument.asBool();\n\t\t\t\t\tif (typeof bool !== \"boolean\") return;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!bool)\n\t\t\t\t\t\t.setSideEffects(argument.couldHaveSideEffects())\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (expr.operator === \"~\") {\n\t\t\t\t\treturn handleConstOperation(v => ~v);\n\t\t\t\t} else if (expr.operator === \"+\") {\n\t\t\t\t\treturn handleConstOperation(v => +v);\n\t\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\t\treturn handleConstOperation(v => -v);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateTypeof.for(\"undefined\").tap(\"JavascriptParser\", expr => {\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setString(\"undefined\")\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"Identifier\").tap(\"JavascriptParser\", expr => {\n\t\t\tif (/** @type {IdentifierNode} */ (expr).name === \"undefined\") {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setUndefined()\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\t/**\n\t\t * @param {string} exprType expression type name\n\t\t * @param {function(ExpressionNode): GetInfoResult | undefined} getInfo get info\n\t\t * @returns {void}\n\t\t */\n\t\tconst tapEvaluateWithVariableInfo = (exprType, getInfo) => {\n\t\t\t/** @type {ExpressionNode | undefined} */\n\t\t\tlet cachedExpression = undefined;\n\t\t\t/** @type {GetInfoResult | undefined} */\n\t\t\tlet cachedInfo = undefined;\n\t\t\tthis.hooks.evaluate.for(exprType).tap(\"JavascriptParser\", expr => {\n\t\t\t\tconst expression = /** @type {MemberExpressionNode} */ (expr);\n\n\t\t\t\tconst info = getInfo(expr);\n\t\t\t\tif (info !== undefined) {\n\t\t\t\t\treturn this.callHooksForInfoWithFallback(\n\t\t\t\t\t\tthis.hooks.evaluateIdentifier,\n\t\t\t\t\t\tinfo.name,\n\t\t\t\t\t\tname => {\n\t\t\t\t\t\t\tcachedExpression = expression;\n\t\t\t\t\t\t\tcachedInfo = info;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tname => {\n\t\t\t\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\t\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\t\treturn hook.call(expression);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\texpression\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.hooks.evaluate\n\t\t\t\t.for(exprType)\n\t\t\t\t.tap({ name: \"JavascriptParser\", stage: 100 }, expr => {\n\t\t\t\t\tconst info = cachedExpression === expr ? cachedInfo : getInfo(expr);\n\t\t\t\t\tif (info !== undefined) {\n\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t.setIdentifier(\n\t\t\t\t\t\t\t\tinfo.name,\n\t\t\t\t\t\t\t\tinfo.rootInfo,\n\t\t\t\t\t\t\t\tinfo.getMembers,\n\t\t\t\t\t\t\t\tinfo.getMembersOptionals\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\tthis.hooks.finish.tap(\"JavascriptParser\", () => {\n\t\t\t\t// Cleanup for GC\n\t\t\t\tcachedExpression = cachedInfo = undefined;\n\t\t\t});\n\t\t};\n\t\ttapEvaluateWithVariableInfo(\"Identifier\", expr => {\n\t\t\tconst info = this.getVariableInfo(\n\t\t\t\t/** @type {IdentifierNode} */ (expr).name\n\t\t\t);\n\t\t\tif (\n\t\t\t\ttypeof info === \"string\" ||\n\t\t\t\t(info instanceof VariableInfo && typeof info.freeName === \"string\")\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tname: info,\n\t\t\t\t\trootInfo: info,\n\t\t\t\t\tgetMembers: () => [],\n\t\t\t\t\tgetMembersOptionals: () => []\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\ttapEvaluateWithVariableInfo(\"ThisExpression\", expr => {\n\t\t\tconst info = this.getVariableInfo(\"this\");\n\t\t\tif (\n\t\t\t\ttypeof info === \"string\" ||\n\t\t\t\t(info instanceof VariableInfo && typeof info.freeName === \"string\")\n\t\t\t) {\n\t\t\t\treturn {\n\t\t\t\t\tname: info,\n\t\t\t\t\trootInfo: info,\n\t\t\t\t\tgetMembers: () => [],\n\t\t\t\t\tgetMembersOptionals: () => []\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"MetaProperty\").tap(\"JavascriptParser\", expr => {\n\t\t\tconst metaProperty = /** @type {MetaPropertyNode} */ (expr);\n\n\t\t\treturn this.callHooksForName(\n\t\t\t\tthis.hooks.evaluateIdentifier,\n\t\t\t\tgetRootName(expr),\n\t\t\t\tmetaProperty\n\t\t\t);\n\t\t});\n\t\ttapEvaluateWithVariableInfo(\"MemberExpression\", expr =>\n\t\t\tthis.getMemberExpressionInfo(\n\t\t\t\t/** @type {MemberExpressionNode} */ (expr),\n\t\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t\t)\n\t\t);\n\n\t\tthis.hooks.evaluate.for(\"CallExpression\").tap(\"JavascriptParser\", _expr => {\n\t\t\tconst expr = /** @type {CallExpressionNode} */ (_expr);\n\t\t\tif (\n\t\t\t\texpr.callee.type === \"MemberExpression\" &&\n\t\t\t\texpr.callee.property.type ===\n\t\t\t\t\t(expr.callee.computed ? \"Literal\" : \"Identifier\")\n\t\t\t) {\n\t\t\t\t// type Super also possible here\n\t\t\t\tconst param = this.evaluateExpression(\n\t\t\t\t\t/** @type {ExpressionNode} */ (expr.callee.object)\n\t\t\t\t);\n\t\t\t\tconst property =\n\t\t\t\t\texpr.callee.property.type === \"Literal\"\n\t\t\t\t\t\t? `${expr.callee.property.value}`\n\t\t\t\t\t\t: expr.callee.property.name;\n\t\t\t\tconst hook = this.hooks.evaluateCallExpressionMember.get(property);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\treturn hook.call(expr, param);\n\t\t\t\t}\n\t\t\t} else if (expr.callee.type === \"Identifier\") {\n\t\t\t\treturn this.callHooksForName(\n\t\t\t\t\tthis.hooks.evaluateCallExpression,\n\t\t\t\t\texpr.callee.name,\n\t\t\t\t\texpr\n\t\t\t\t);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"indexOf\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length === 0) return;\n\t\t\t\tconst [arg1, arg2] = expr.arguments;\n\t\t\t\tif (arg1.type === \"SpreadElement\") return;\n\t\t\t\tconst arg1Eval = this.evaluateExpression(arg1);\n\t\t\t\tif (!arg1Eval.isString()) return;\n\t\t\t\tconst arg1Value = arg1Eval.string;\n\n\t\t\t\tlet result;\n\t\t\t\tif (arg2) {\n\t\t\t\t\tif (arg2.type === \"SpreadElement\") return;\n\t\t\t\t\tconst arg2Eval = this.evaluateExpression(arg2);\n\t\t\t\t\tif (!arg2Eval.isNumber()) return;\n\t\t\t\t\tresult = param.string.indexOf(arg1Value, arg2Eval.number);\n\t\t\t\t} else {\n\t\t\t\t\tresult = param.string.indexOf(arg1Value);\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setNumber(result)\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"replace\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 2) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\tlet arg1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tlet arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\tif (!arg1.isString() && !arg1.isRegExp()) return;\n\t\t\t\tconst arg1Value = arg1.regExp || arg1.string;\n\t\t\t\tif (!arg2.isString()) return;\n\t\t\t\tconst arg2Value = arg2.string;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(param.string.replace(arg1Value, arg2Value))\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\t[\"substr\", \"substring\", \"slice\"].forEach(fn => {\n\t\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t\t.for(fn)\n\t\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\t\tif (!param.isString()) return;\n\t\t\t\t\tlet arg1;\n\t\t\t\t\tlet result,\n\t\t\t\t\t\tstr = param.string;\n\t\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\tif (expr.arguments[1].type === \"SpreadElement\") return;\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tconst arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tif (!arg2.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number, arg2.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(result)\n\t\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t});\n\t\t});\n\n\t\t/**\n\t\t * @param {\"cooked\" | \"raw\"} kind kind of values to get\n\t\t * @param {TemplateLiteralNode} templateLiteralExpr TemplateLiteral expr\n\t\t * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n\t\t */\n\t\tconst getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\tconst quasis = [];\n\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\tconst parts = [];\n\n\t\t\tfor (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n\t\t\t\tconst quasiExpr = templateLiteralExpr.quasis[i];\n\t\t\t\tconst quasi = quasiExpr.value[kind];\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tconst prevExpr = parts[parts.length - 1];\n\t\t\t\t\tconst expr = this.evaluateExpression(\n\t\t\t\t\t\ttemplateLiteralExpr.expressions[i - 1]\n\t\t\t\t\t);\n\t\t\t\t\tconst exprAsString = expr.asString();\n\t\t\t\t\tif (\n\t\t\t\t\t\ttypeof exprAsString === \"string\" &&\n\t\t\t\t\t\t!expr.couldHaveSideEffects()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// We can merge quasi + expr + quasi when expr\n\t\t\t\t\t\t// is a const string\n\n\t\t\t\t\t\tprevExpr.setString(prevExpr.string + exprAsString + quasi);\n\t\t\t\t\t\tprevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n\t\t\t\t\t\t// We unset the expression as it doesn't match to a single expression\n\t\t\t\t\t\tprevExpr.setExpression(undefined);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tparts.push(expr);\n\t\t\t\t}\n\n\t\t\t\tconst part = new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(quasi)\n\t\t\t\t\t.setRange(quasiExpr.range)\n\t\t\t\t\t.setExpression(quasiExpr);\n\t\t\t\tquasis.push(part);\n\t\t\t\tparts.push(part);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquasis,\n\t\t\t\tparts\n\t\t\t};\n\t\t};\n\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"TemplateLiteral\")\n\t\t\t.tap(\"JavascriptParser\", _node => {\n\t\t\t\tconst node = /** @type {TemplateLiteralNode} */ (_node);\n\n\t\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"cooked\", node);\n\t\t\t\tif (parts.length === 1) {\n\t\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setTemplateString(quasis, parts, \"cooked\")\n\t\t\t\t\t.setRange(node.range);\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"TaggedTemplateExpression\")\n\t\t\t.tap(\"JavascriptParser\", _node => {\n\t\t\t\tconst node = /** @type {TaggedTemplateExpressionNode} */ (_node);\n\t\t\t\tconst tag = this.evaluateExpression(node.tag);\n\n\t\t\t\tif (tag.isIdentifier() && tag.identifier === \"String.raw\") {\n\t\t\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\n\t\t\t\t\t\t\"raw\",\n\t\t\t\t\t\tnode.quasi\n\t\t\t\t\t);\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setTemplateString(quasis, parts, \"raw\")\n\t\t\t\t\t\t.setRange(node.range);\n\t\t\t\t}\n\t\t\t});\n\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"concat\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString() && !param.isWrapped()) return;\n\n\t\t\t\tlet stringSuffix = null;\n\t\t\t\tlet hasUnknownParams = false;\n\t\t\t\tconst innerExpressions = [];\n\t\t\t\tfor (let i = expr.arguments.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst arg = expr.arguments[i];\n\t\t\t\t\tif (arg.type === \"SpreadElement\") return;\n\t\t\t\t\tconst argExpr = this.evaluateExpression(arg);\n\t\t\t\t\tif (\n\t\t\t\t\t\thasUnknownParams ||\n\t\t\t\t\t\t(!argExpr.isString() && !argExpr.isNumber())\n\t\t\t\t\t) {\n\t\t\t\t\t\thasUnknownParams = true;\n\t\t\t\t\t\tinnerExpressions.push(argExpr);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = argExpr.isString()\n\t\t\t\t\t\t? argExpr.string\n\t\t\t\t\t\t: \"\" + argExpr.number;\n\n\t\t\t\t\tconst newString = value + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\tconst newRange = [\n\t\t\t\t\t\targExpr.range[0],\n\t\t\t\t\t\t(stringSuffix || argExpr).range[1]\n\t\t\t\t\t];\n\t\t\t\t\tstringSuffix = new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t(stringSuffix && stringSuffix.couldHaveSideEffects()) ||\n\t\t\t\t\t\t\t\targExpr.couldHaveSideEffects()\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.setRange(newRange);\n\t\t\t\t}\n\n\t\t\t\tif (hasUnknownParams) {\n\t\t\t\t\tconst prefix = param.isString() ? param : param.prefix;\n\t\t\t\t\tconst inner =\n\t\t\t\t\t\tparam.isWrapped() && param.wrappedInnerExpressions\n\t\t\t\t\t\t\t? param.wrappedInnerExpressions.concat(innerExpressions.reverse())\n\t\t\t\t\t\t\t: innerExpressions.reverse();\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(prefix, stringSuffix, inner)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (param.isWrapped()) {\n\t\t\t\t\tconst postfix = stringSuffix || param.postfix;\n\t\t\t\t\tconst inner = param.wrappedInnerExpressions\n\t\t\t\t\t\t? param.wrappedInnerExpressions.concat(innerExpressions.reverse())\n\t\t\t\t\t\t: innerExpressions.reverse();\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(param.prefix, postfix, inner)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst newString =\n\t\t\t\t\t\tparam.string + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setSideEffects(\n\t\t\t\t\t\t\t(stringSuffix && stringSuffix.couldHaveSideEffects()) ||\n\t\t\t\t\t\t\t\tparam.couldHaveSideEffects()\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"split\")\n\t\t\t.tap(\"JavascriptParser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\t\tif (expr.arguments[0].type === \"SpreadElement\") return;\n\t\t\t\tlet result;\n\t\t\t\tconst arg = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tresult = param.string.split(arg.string);\n\t\t\t\t} else if (arg.isRegExp()) {\n\t\t\t\t\tresult = param.string.split(arg.regExp);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setArray(result)\n\t\t\t\t\t.setSideEffects(param.couldHaveSideEffects())\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ConditionalExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ConditionalExpressionNode} */ (_expr);\n\n\t\t\t\tconst condition = this.evaluateExpression(expr.test);\n\t\t\t\tconst conditionValue = condition.asBool();\n\t\t\t\tlet res;\n\t\t\t\tif (conditionValue === undefined) {\n\t\t\t\t\tconst consequent = this.evaluateExpression(expr.consequent);\n\t\t\t\t\tconst alternate = this.evaluateExpression(expr.alternate);\n\t\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\t\tif (consequent.isConditional()) {\n\t\t\t\t\t\tres.setOptions(consequent.options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.setOptions([consequent]);\n\t\t\t\t\t}\n\t\t\t\t\tif (alternate.isConditional()) {\n\t\t\t\t\t\tres.addOptions(alternate.options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres.addOptions([alternate]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tres = this.evaluateExpression(\n\t\t\t\t\t\tconditionValue ? expr.consequent : expr.alternate\n\t\t\t\t\t);\n\t\t\t\t\tif (condition.couldHaveSideEffects()) res.setSideEffects();\n\t\t\t\t}\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ArrayExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ArrayExpressionNode} */ (_expr);\n\n\t\t\t\tconst items = expr.elements.map(element => {\n\t\t\t\t\treturn (\n\t\t\t\t\t\telement !== null &&\n\t\t\t\t\t\telement.type !== \"SpreadElement\" &&\n\t\t\t\t\t\tthis.evaluateExpression(element)\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\tif (!items.every(Boolean)) return;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setItems(items)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluate\n\t\t\t.for(\"ChainExpression\")\n\t\t\t.tap(\"JavascriptParser\", _expr => {\n\t\t\t\tconst expr = /** @type {ChainExpressionNode} */ (_expr);\n\t\t\t\t/** @type {ExpressionNode[]} */\n\t\t\t\tconst optionalExpressionsStack = [];\n\t\t\t\t/** @type {ExpressionNode|SuperNode} */\n\t\t\t\tlet next = expr.expression;\n\n\t\t\t\twhile (\n\t\t\t\t\tnext.type === \"MemberExpression\" ||\n\t\t\t\t\tnext.type === \"CallExpression\"\n\t\t\t\t) {\n\t\t\t\t\tif (next.type === \"MemberExpression\") {\n\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (next.object)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext = next.object;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (next.optional) {\n\t\t\t\t\t\t\t// SuperNode can not be optional\n\t\t\t\t\t\t\toptionalExpressionsStack.push(\n\t\t\t\t\t\t\t\t/** @type {ExpressionNode} */ (next.callee)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnext = next.callee;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (optionalExpressionsStack.length > 0) {\n\t\t\t\t\tconst expression = optionalExpressionsStack.pop();\n\t\t\t\t\tconst evaluated = this.evaluateExpression(expression);\n\n\t\t\t\t\tif (evaluated.asNullish()) {\n\t\t\t\t\t\treturn evaluated.setRange(_expr.range);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this.evaluateExpression(expr.expression);\n\t\t\t});\n\t}\n\n\tgetRenameIdentifier(expr) {\n\t\tconst result = this.evaluateExpression(expr);\n\t\tif (result.isIdentifier()) {\n\t\t\treturn result.identifier;\n\t\t}\n\t}\n\n\t/**\n\t * @param {ClassExpressionNode | ClassDeclarationNode} classy a class node\n\t * @returns {void}\n\t */\n\twalkClass(classy) {\n\t\tif (classy.superClass) {\n\t\t\tif (!this.hooks.classExtendsExpression.call(classy.superClass, classy)) {\n\t\t\t\tthis.walkExpression(classy.superClass);\n\t\t\t}\n\t\t}\n\t\tif (classy.body && classy.body.type === \"ClassBody\") {\n\t\t\tfor (const classElement of /** @type {TODO} */ (classy.body.body)) {\n\t\t\t\tif (!this.hooks.classBodyElement.call(classElement, classy)) {\n\t\t\t\t\tif (classElement.computed && classElement.key) {\n\t\t\t\t\t\tthis.walkExpression(classElement.key);\n\t\t\t\t\t}\n\t\t\t\t\tif (classElement.value) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!this.hooks.classBodyValue.call(\n\t\t\t\t\t\t\t\tclassElement.value,\n\t\t\t\t\t\t\t\tclassElement,\n\t\t\t\t\t\t\t\tclassy\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\t\t\t\t\tthis.scope.topLevelScope = false;\n\t\t\t\t\t\t\tthis.walkExpression(classElement.value);\n\t\t\t\t\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Pre walking iterates the scope for variable declarations\n\tpreWalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.preWalkStatement(statement);\n\t\t}\n\t}\n\n\t// Block pre walking iterates the scope for block variable declarations\n\tblockPreWalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.blockPreWalkStatement(statement);\n\t\t}\n\t}\n\n\t// Walking iterates the statements and expressions and processes them\n\twalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.walkStatement(statement);\n\t\t}\n\t}\n\n\tpreWalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.preStatement.call(statement)) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.preWalkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.preWalkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.preWalkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.preWalkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.preWalkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.preWalkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.preWalkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.preWalkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.preWalkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.preWalkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.preWalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.preWalkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.preWalkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\tblockPreWalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.blockPreStatement.call(statement)) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"ImportDeclaration\":\n\t\t\t\tthis.blockPreWalkImportDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\tthis.blockPreWalkExportAllDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.blockPreWalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.blockPreWalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.blockPreWalkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\twalkStatement(statement) {\n\t\tthis.statementPath.push(statement);\n\t\tif (this.hooks.statement.call(statement) !== undefined) {\n\t\t\tthis.prevStatement = this.statementPath.pop();\n\t\t\treturn;\n\t\t}\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.walkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.walkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.walkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.walkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.walkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.walkExpressionStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.walkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.walkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.walkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.walkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.walkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.walkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ReturnStatement\":\n\t\t\t\tthis.walkReturnStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.walkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ThrowStatement\":\n\t\t\t\tthis.walkThrowStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.walkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.walkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.walkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.walkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.prevStatement = this.statementPath.pop();\n\t}\n\n\t/**\n\t * Walks a statements that is nested within a parent statement\n\t * and can potentially be a non-block statement.\n\t * This enforces the nested statement to never be in ASI position.\n\t * @param {StatementNode} statement the nested statement\n\t * @returns {void}\n\t */\n\twalkNestedStatement(statement) {\n\t\tthis.prevStatement = undefined;\n\t\tthis.walkStatement(statement);\n\t}\n\n\t// Real Statements\n\tpreWalkBlockStatement(statement) {\n\t\tthis.preWalkStatements(statement.body);\n\t}\n\n\twalkBlockStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst body = statement.body;\n\t\t\tconst prev = this.prevStatement;\n\t\t\tthis.blockPreWalkStatements(body);\n\t\t\tthis.prevStatement = prev;\n\t\t\tthis.walkStatements(body);\n\t\t});\n\t}\n\n\twalkExpressionStatement(statement) {\n\t\tthis.walkExpression(statement.expression);\n\t}\n\n\tpreWalkIfStatement(statement) {\n\t\tthis.preWalkStatement(statement.consequent);\n\t\tif (statement.alternate) {\n\t\t\tthis.preWalkStatement(statement.alternate);\n\t\t}\n\t}\n\n\twalkIfStatement(statement) {\n\t\tconst result = this.hooks.statementIf.call(statement);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(statement.test);\n\t\t\tthis.walkNestedStatement(statement.consequent);\n\t\t\tif (statement.alternate) {\n\t\t\t\tthis.walkNestedStatement(statement.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkNestedStatement(statement.consequent);\n\t\t\t} else if (statement.alternate) {\n\t\t\t\tthis.walkNestedStatement(statement.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\tpreWalkLabeledStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkLabeledStatement(statement) {\n\t\tconst hook = this.hooks.label.get(statement.label.name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(statement);\n\t\t\tif (result === true) return;\n\t\t}\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\tpreWalkWithStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkWithStatement(statement) {\n\t\tthis.walkExpression(statement.object);\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\tpreWalkSwitchStatement(statement) {\n\t\tthis.preWalkSwitchCases(statement.cases);\n\t}\n\n\twalkSwitchStatement(statement) {\n\t\tthis.walkExpression(statement.discriminant);\n\t\tthis.walkSwitchCases(statement.cases);\n\t}\n\n\twalkTerminatingStatement(statement) {\n\t\tif (statement.argument) this.walkExpression(statement.argument);\n\t}\n\n\twalkReturnStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\twalkThrowStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\tpreWalkTryStatement(statement) {\n\t\tthis.preWalkStatement(statement.block);\n\t\tif (statement.handler) this.preWalkCatchClause(statement.handler);\n\t\tif (statement.finializer) this.preWalkStatement(statement.finializer);\n\t}\n\n\twalkTryStatement(statement) {\n\t\tif (this.scope.inTry) {\n\t\t\tthis.walkStatement(statement.block);\n\t\t} else {\n\t\t\tthis.scope.inTry = true;\n\t\t\tthis.walkStatement(statement.block);\n\t\t\tthis.scope.inTry = false;\n\t\t}\n\t\tif (statement.handler) this.walkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.walkStatement(statement.finalizer);\n\t}\n\n\tpreWalkWhileStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkWhileStatement(statement) {\n\t\tthis.walkExpression(statement.test);\n\t\tthis.walkNestedStatement(statement.body);\n\t}\n\n\tpreWalkDoWhileStatement(statement) {\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkDoWhileStatement(statement) {\n\t\tthis.walkNestedStatement(statement.body);\n\t\tthis.walkExpression(statement.test);\n\t}\n\n\tpreWalkForStatement(statement) {\n\t\tif (statement.init) {\n\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\tthis.preWalkStatement(statement.init);\n\t\t\t}\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkForStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.init) {\n\t\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.init);\n\t\t\t\t\tthis.prevStatement = undefined;\n\t\t\t\t\tthis.walkStatement(statement.init);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(statement.init);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (statement.test) {\n\t\t\t\tthis.walkExpression(statement.test);\n\t\t\t}\n\t\t\tif (statement.update) {\n\t\t\t\tthis.walkExpression(statement.update);\n\t\t\t}\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tpreWalkForInStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.preWalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkForInStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tpreWalkForOfStatement(statement) {\n\t\tif (statement.await && this.scope.topLevelScope === true) {\n\t\t\tthis.hooks.topLevelAwait.call(statement);\n\t\t}\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.preWalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.preWalkStatement(statement.body);\n\t}\n\n\twalkForOfStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPreWalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.blockPreWalkStatements(body.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkNestedStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Declarations\n\tpreWalkFunctionDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.defineVariable(statement.id.name);\n\t\t}\n\t}\n\n\twalkFunctionDeclaration(statement) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tthis.inFunctionScope(true, statement.params, () => {\n\t\t\tfor (const param of statement.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (statement.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(statement.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(statement.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(statement.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\tblockPreWalkImportDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.import.call(statement, source);\n\t\tfor (const specifier of statement.specifiers) {\n\t\t\tconst name = specifier.local.name;\n\t\t\tswitch (specifier.type) {\n\t\t\t\tcase \"ImportDefaultSpecifier\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.hooks.importSpecifier.call(statement, source, \"default\", name)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportSpecifier\":\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.hooks.importSpecifier.call(\n\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\tspecifier.imported.name,\n\t\t\t\t\t\t\tname\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportNamespaceSpecifier\":\n\t\t\t\t\tif (!this.hooks.importSpecifier.call(statement, source, null, name)) {\n\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis.defineVariable(name);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterDeclaration(declaration, onIdent) {\n\t\tswitch (declaration.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tfor (const declarator of declaration.declarations) {\n\t\t\t\t\tswitch (declarator.type) {\n\t\t\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\t\t\tthis.enterPattern(declarator.id, onIdent);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPreWalkExportNamedDeclaration(statement) {\n\t\tlet source;\n\t\tif (statement.source) {\n\t\t\tsource = statement.source.value;\n\t\t\tthis.hooks.exportImport.call(statement, source);\n\t\t} else {\n\t\t\tthis.hooks.export.call(statement);\n\t\t}\n\t\tif (statement.declaration) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(statement.declaration);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.blockPreWalkStatement(statement.declaration);\n\t\t\t\tlet index = 0;\n\t\t\t\tthis.enterDeclaration(statement.declaration, def => {\n\t\t\t\t\tthis.hooks.exportSpecifier.call(statement, def, def, index++);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (statement.specifiers) {\n\t\t\tfor (\n\t\t\t\tlet specifierIndex = 0;\n\t\t\t\tspecifierIndex < statement.specifiers.length;\n\t\t\t\tspecifierIndex++\n\t\t\t) {\n\t\t\t\tconst specifier = statement.specifiers[specifierIndex];\n\t\t\t\tswitch (specifier.type) {\n\t\t\t\t\tcase \"ExportSpecifier\": {\n\t\t\t\t\t\tconst name = specifier.exported.name;\n\t\t\t\t\t\tif (source) {\n\t\t\t\t\t\t\tthis.hooks.exportImportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.walkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tblockPreWalkExportDefaultDeclaration(statement) {\n\t\tconst prev = this.prevStatement;\n\t\tthis.preWalkStatement(statement.declaration);\n\t\tthis.prevStatement = prev;\n\t\tthis.blockPreWalkStatement(statement.declaration);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\tstatement,\n\t\t\t\tstatement.declaration.id.name,\n\t\t\t\t\"default\",\n\t\t\t\tundefined\n\t\t\t);\n\t\t}\n\t}\n\n\twalkExportDefaultDeclaration(statement) {\n\t\tthis.hooks.export.call(statement);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t}\n\t\t} else {\n\t\t\t// Acorn parses `export default function() {}` as `FunctionDeclaration` and\n\t\t\t// `export default class {}` as `ClassDeclaration`, both with `id = null`.\n\t\t\t// These nodes must be treated as expressions.\n\t\t\tif (\n\t\t\t\tstatement.declaration.type === \"FunctionDeclaration\" ||\n\t\t\t\tstatement.declaration.type === \"ClassDeclaration\"\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.declaration);\n\t\t\t}\n\t\t\tif (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\tstatement,\n\t\t\t\t\tstatement.declaration,\n\t\t\t\t\t\"default\",\n\t\t\t\t\tundefined\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPreWalkExportAllDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tconst name = statement.exported ? statement.exported.name : null;\n\t\tthis.hooks.exportImport.call(statement, source);\n\t\tthis.hooks.exportImportSpecifier.call(statement, source, null, name, 0);\n\t}\n\n\tpreWalkVariableDeclaration(statement) {\n\t\tif (statement.kind !== \"var\") return;\n\t\tthis._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n\t}\n\n\tblockPreWalkVariableDeclaration(statement) {\n\t\tif (statement.kind === \"var\") return;\n\t\tconst hookMap =\n\t\t\tstatement.kind === \"const\"\n\t\t\t\t? this.hooks.varDeclarationConst\n\t\t\t\t: this.hooks.varDeclarationLet;\n\t\tthis._preWalkVariableDeclaration(statement, hookMap);\n\t}\n\n\t_preWalkVariableDeclaration(statement, hookMap) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tif (!this.hooks.preDeclarator.call(declarator, statement)) {\n\t\t\t\t\t\tthis.enterPattern(declarator.id, (name, decl) => {\n\t\t\t\t\t\t\tlet hook = hookMap.get(name);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\thook = this.hooks.varDeclaration.get(name);\n\t\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkVariableDeclaration(statement) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tconst renameIdentifier =\n\t\t\t\t\t\tdeclarator.init && this.getRenameIdentifier(declarator.init);\n\t\t\t\t\tif (renameIdentifier && declarator.id.type === \"Identifier\") {\n\t\t\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\t\t\tif (hook !== undefined && hook.call(declarator.init)) {\n\t\t\t\t\t\t\t// renaming with \"var a = b;\"\n\t\t\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(declarator.init)) {\n\t\t\t\t\t\t\t\tthis.setVariable(declarator.id.name, renameIdentifier);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.hooks.declarator.call(declarator, statement)) {\n\t\t\t\t\t\tthis.walkPattern(declarator.id);\n\t\t\t\t\t\tif (declarator.init) this.walkExpression(declarator.init);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPreWalkClassDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.defineVariable(statement.id.name);\n\t\t}\n\t}\n\n\twalkClassDeclaration(statement) {\n\t\tthis.walkClass(statement);\n\t}\n\n\tpreWalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\t\t\tthis.preWalkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkSwitchCases(switchCases) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst len = switchCases.length;\n\n\t\t\t// we need to pre walk all statements first since we can have invalid code\n\t\t\t// import A from \"module\";\n\t\t\t// switch(1) {\n\t\t\t//    case 1:\n\t\t\t//      console.log(A); // should fail at runtime\n\t\t\t//    case 2:\n\t\t\t//      const A = 1;\n\t\t\t// }\n\t\t\tfor (let index = 0; index < len; index++) {\n\t\t\t\tconst switchCase = switchCases[index];\n\n\t\t\t\tif (switchCase.consequent.length > 0) {\n\t\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\t\tthis.blockPreWalkStatements(switchCase.consequent);\n\t\t\t\t\tthis.prevStatement = prev;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let index = 0; index < len; index++) {\n\t\t\t\tconst switchCase = switchCases[index];\n\n\t\t\t\tif (switchCase.test) {\n\t\t\t\t\tthis.walkExpression(switchCase.test);\n\t\t\t\t}\n\t\t\t\tif (switchCase.consequent.length > 0) {\n\t\t\t\t\tthis.walkStatements(switchCase.consequent);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpreWalkCatchClause(catchClause) {\n\t\tthis.preWalkStatement(catchClause.body);\n\t}\n\n\twalkCatchClause(catchClause) {\n\t\tthis.inBlockScope(() => {\n\t\t\t// Error binding is optional in catch clause since ECMAScript 2019\n\t\t\tif (catchClause.param !== null) {\n\t\t\t\tthis.enterPattern(catchClause.param, ident => {\n\t\t\t\t\tthis.defineVariable(ident);\n\t\t\t\t});\n\t\t\t\tthis.walkPattern(catchClause.param);\n\t\t\t}\n\t\t\tconst prev = this.prevStatement;\n\t\t\tthis.blockPreWalkStatement(catchClause.body);\n\t\t\tthis.prevStatement = prev;\n\t\t\tthis.walkStatement(catchClause.body);\n\t\t});\n\t}\n\n\twalkPattern(pattern) {\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.walkArrayPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.walkAssignmentPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.walkObjectPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.walkRestElement(pattern);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAssignmentPattern(pattern) {\n\t\tthis.walkExpression(pattern.right);\n\t\tthis.walkPattern(pattern.left);\n\t}\n\n\twalkObjectPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.properties.length; i < len; i++) {\n\t\t\tconst prop = pattern.properties[i];\n\t\t\tif (prop) {\n\t\t\t\tif (prop.computed) this.walkExpression(prop.key);\n\t\t\t\tif (prop.value) this.walkPattern(prop.value);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkArrayPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.elements.length; i < len; i++) {\n\t\t\tconst element = pattern.elements[i];\n\t\t\tif (element) this.walkPattern(element);\n\t\t}\n\t}\n\n\twalkRestElement(pattern) {\n\t\tthis.walkPattern(pattern.argument);\n\t}\n\n\twalkExpressions(expressions) {\n\t\tfor (const expression of expressions) {\n\t\t\tif (expression) {\n\t\t\t\tthis.walkExpression(expression);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExpression(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"ArrayExpression\":\n\t\t\t\tthis.walkArrayExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\t\tthis.walkArrowFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.walkAssignmentExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AwaitExpression\":\n\t\t\t\tthis.walkAwaitExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tthis.walkBinaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"CallExpression\":\n\t\t\t\tthis.walkCallExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ChainExpression\":\n\t\t\t\tthis.walkChainExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassExpression\":\n\t\t\t\tthis.walkClassExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\tthis.walkConditionalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionExpression\":\n\t\t\t\tthis.walkFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.walkIdentifier(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ImportExpression\":\n\t\t\t\tthis.walkImportExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\tthis.walkLogicalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MetaProperty\":\n\t\t\t\tthis.walkMetaProperty(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"NewExpression\":\n\t\t\t\tthis.walkNewExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectExpression\":\n\t\t\t\tthis.walkObjectExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\tthis.walkSequenceExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SpreadElement\":\n\t\t\t\tthis.walkSpreadElement(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TaggedTemplateExpression\":\n\t\t\t\tthis.walkTaggedTemplateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TemplateLiteral\":\n\t\t\t\tthis.walkTemplateLiteral(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ThisExpression\":\n\t\t\t\tthis.walkThisExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UnaryExpression\":\n\t\t\t\tthis.walkUnaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UpdateExpression\":\n\t\t\t\tthis.walkUpdateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"YieldExpression\":\n\t\t\t\tthis.walkYieldExpression(expression);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAwaitExpression(expression) {\n\t\tif (this.scope.topLevelScope === true)\n\t\t\tthis.hooks.topLevelAwait.call(expression);\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkArrayExpression(expression) {\n\t\tif (expression.elements) {\n\t\t\tthis.walkExpressions(expression.elements);\n\t\t}\n\t}\n\n\twalkSpreadElement(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkObjectExpression(expression) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = expression.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = expression.properties[propIndex];\n\t\t\tthis.walkProperty(prop);\n\t\t}\n\t}\n\n\twalkProperty(prop) {\n\t\tif (prop.type === \"SpreadElement\") {\n\t\t\tthis.walkExpression(prop.argument);\n\t\t\treturn;\n\t\t}\n\t\tif (prop.computed) {\n\t\t\tthis.walkExpression(prop.key);\n\t\t}\n\t\tif (prop.shorthand && prop.value && prop.value.type === \"Identifier\") {\n\t\t\tthis.scope.inShorthand = prop.value.name;\n\t\t\tthis.walkIdentifier(prop.value);\n\t\t\tthis.scope.inShorthand = false;\n\t\t} else {\n\t\t\tthis.walkExpression(prop.value);\n\t\t}\n\t}\n\n\twalkFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = expression.params;\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (expression.id) {\n\t\t\tscopeParams.push(expression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(expression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkArrowFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = wasTopLevel ? \"arrow\" : false;\n\t\tthis.inFunctionScope(false, expression.params, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(expression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\t/**\n\t * @param {SequenceExpressionNode} expression the sequence\n\t */\n\twalkSequenceExpression(expression) {\n\t\tif (!expression.expressions) return;\n\t\t// We treat sequence expressions like statements when they are one statement level\n\t\t// This has some benefits for optimizations that only work on statement level\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\tif (\n\t\t\tcurrentStatement === expression ||\n\t\t\t(currentStatement.type === \"ExpressionStatement\" &&\n\t\t\t\tcurrentStatement.expression === expression)\n\t\t) {\n\t\t\tconst old = this.statementPath.pop();\n\t\t\tfor (const expr of expression.expressions) {\n\t\t\t\tthis.statementPath.push(expr);\n\t\t\t\tthis.walkExpression(expr);\n\t\t\t\tthis.statementPath.pop();\n\t\t\t}\n\t\t\tthis.statementPath.push(old);\n\t\t} else {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\twalkUpdateExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkUnaryExpression(expression) {\n\t\tif (expression.operator === \"typeof\") {\n\t\t\tconst result = this.callHooksForExpression(\n\t\t\t\tthis.hooks.typeof,\n\t\t\t\texpression.argument,\n\t\t\t\texpression\n\t\t\t);\n\t\t\tif (result === true) return;\n\t\t\tif (expression.argument.type === \"ChainExpression\") {\n\t\t\t\tconst result = this.callHooksForExpression(\n\t\t\t\t\tthis.hooks.typeof,\n\t\t\t\t\texpression.argument.expression,\n\t\t\t\t\texpression\n\t\t\t\t);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkLeftRightExpression(expression) {\n\t\tthis.walkExpression(expression.left);\n\t\tthis.walkExpression(expression.right);\n\t}\n\n\twalkBinaryExpression(expression) {\n\t\tif (this.hooks.binaryExpression.call(expression) === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t}\n\t}\n\n\twalkLogicalExpression(expression) {\n\t\tconst result = this.hooks.expressionLogicalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkAssignmentExpression(expression) {\n\t\tif (expression.left.type === \"Identifier\") {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(expression.right);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.canRename,\n\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\texpression.right\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\t// renaming \"a = b;\"\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.callHooksForInfo(\n\t\t\t\t\t\t\tthis.hooks.rename,\n\t\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\t\texpression.right\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.setVariable(\n\t\t\t\t\t\t\texpression.left.name,\n\t\t\t\t\t\t\ttypeof renameIdentifier === \"string\"\n\t\t\t\t\t\t\t\t? this.getVariableInfo(renameIdentifier)\n\t\t\t\t\t\t\t\t: renameIdentifier\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\t\tif (!this.callHooksForName(this.hooks.assign, name, expression)) {\n\t\t\t\t\tthis.walkExpression(expression.left);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tif (expression.left.type.endsWith(\"Pattern\")) {\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\t\tif (!this.callHooksForName(this.hooks.assign, name, expression)) {\n\t\t\t\t\tthis.defineVariable(name);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.walkPattern(expression.left);\n\t\t} else if (expression.left.type === \"MemberExpression\") {\n\t\t\tconst exprName = this.getMemberExpressionInfo(\n\t\t\t\texpression.left,\n\t\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t\t);\n\t\t\tif (exprName) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.assignMemberChain,\n\t\t\t\t\t\texprName.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprName.getMembers()\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.walkExpression(expression.left);\n\t\t} else {\n\t\t\tthis.walkExpression(expression.right);\n\t\t\tthis.walkExpression(expression.left);\n\t\t}\n\t}\n\n\twalkConditionalExpression(expression) {\n\t\tconst result = this.hooks.expressionConditionalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(expression.test);\n\t\t\tthis.walkExpression(expression.consequent);\n\t\t\tif (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.consequent);\n\t\t\t} else if (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkNewExpression(expression) {\n\t\tconst result = this.callHooksForExpression(\n\t\t\tthis.hooks.new,\n\t\t\texpression.callee,\n\t\t\texpression\n\t\t);\n\t\tif (result === true) return;\n\t\tthis.walkExpression(expression.callee);\n\t\tif (expression.arguments) {\n\t\t\tthis.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkYieldExpression(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkTemplateLiteral(expression) {\n\t\tif (expression.expressions) {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\twalkTaggedTemplateExpression(expression) {\n\t\tif (expression.tag) {\n\t\t\tthis.walkExpression(expression.tag);\n\t\t}\n\t\tif (expression.quasi && expression.quasi.expressions) {\n\t\t\tthis.walkExpressions(expression.quasi.expressions);\n\t\t}\n\t}\n\n\twalkClassExpression(expression) {\n\t\tthis.walkClass(expression);\n\t}\n\n\t/**\n\t * @param {ChainExpressionNode} expression expression\n\t */\n\twalkChainExpression(expression) {\n\t\tconst result = this.hooks.optionalChaining.call(expression);\n\n\t\tif (result === undefined) {\n\t\t\tif (expression.expression.type === \"CallExpression\") {\n\t\t\t\tthis.walkCallExpression(expression.expression);\n\t\t\t} else {\n\t\t\t\tthis.walkMemberExpression(expression.expression);\n\t\t\t}\n\t\t}\n\t}\n\n\t_walkIIFE(functionExpression, options, currentThis) {\n\t\tconst getVarInfo = argOrThis => {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(argOrThis);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tif (\n\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.canRename,\n\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\targOrThis\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.callHooksForInfo(\n\t\t\t\t\t\t\tthis.hooks.rename,\n\t\t\t\t\t\t\trenameIdentifier,\n\t\t\t\t\t\t\targOrThis\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn typeof renameIdentifier === \"string\"\n\t\t\t\t\t\t\t? this.getVariableInfo(renameIdentifier)\n\t\t\t\t\t\t\t: renameIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(argOrThis);\n\t\t};\n\t\tconst { params, type } = functionExpression;\n\t\tconst arrow = type === \"ArrowFunctionExpression\";\n\t\tconst renameThis = currentThis ? getVarInfo(currentThis) : null;\n\t\tconst varInfoForArgs = options.map(getVarInfo);\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = wasTopLevel && arrow ? \"arrow\" : false;\n\t\tconst scopeParams = params.filter(\n\t\t\t(identifier, idx) => !varInfoForArgs[idx]\n\t\t);\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (functionExpression.id) {\n\t\t\tscopeParams.push(functionExpression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tif (renameThis && !arrow) {\n\t\t\t\tthis.setVariable(\"this\", renameThis);\n\t\t\t}\n\t\t\tfor (let i = 0; i < varInfoForArgs.length; i++) {\n\t\t\t\tconst varInfo = varInfoForArgs[i];\n\t\t\t\tif (!varInfo) continue;\n\t\t\t\tif (!params[i] || params[i].type !== \"Identifier\") continue;\n\t\t\t\tthis.setVariable(params[i].name, varInfo);\n\t\t\t}\n\t\t\tif (functionExpression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(functionExpression.body.body);\n\t\t\t\tconst prev = this.prevStatement;\n\t\t\t\tthis.preWalkStatement(functionExpression.body);\n\t\t\t\tthis.prevStatement = prev;\n\t\t\t\tthis.walkStatement(functionExpression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(functionExpression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkImportExpression(expression) {\n\t\tlet result = this.hooks.importCall.call(expression);\n\t\tif (result === true) return;\n\n\t\tthis.walkExpression(expression.source);\n\t}\n\n\twalkCallExpression(expression) {\n\t\tconst isSimpleFunction = fn => {\n\t\t\treturn fn.params.every(p => p.type === \"Identifier\");\n\t\t};\n\t\tif (\n\t\t\texpression.callee.type === \"MemberExpression\" &&\n\t\t\texpression.callee.object.type.endsWith(\"FunctionExpression\") &&\n\t\t\t!expression.callee.computed &&\n\t\t\t(expression.callee.property.name === \"call\" ||\n\t\t\t\texpression.callee.property.name === \"bind\") &&\n\t\t\texpression.arguments.length > 0 &&\n\t\t\tisSimpleFunction(expression.callee.object)\n\t\t) {\n\t\t\t// (function() { }.call/bind(?, ))\n\t\t\tthis._walkIIFE(\n\t\t\t\texpression.callee.object,\n\t\t\t\texpression.arguments.slice(1),\n\t\t\t\texpression.arguments[0]\n\t\t\t);\n\t\t} else if (\n\t\t\texpression.callee.type.endsWith(\"FunctionExpression\") &&\n\t\t\tisSimpleFunction(expression.callee)\n\t\t) {\n\t\t\t// (function() { }())\n\t\t\tthis._walkIIFE(expression.callee, expression.arguments, null);\n\t\t} else {\n\t\t\tif (expression.callee.type === \"MemberExpression\") {\n\t\t\t\tconst exprInfo = this.getMemberExpressionInfo(\n\t\t\t\t\texpression.callee,\n\t\t\t\t\tALLOWED_MEMBER_TYPES_CALL_EXPRESSION\n\t\t\t\t);\n\t\t\t\tif (exprInfo && exprInfo.type === \"call\") {\n\t\t\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.callMemberChainOfCallMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.getCalleeMembers(),\n\t\t\t\t\t\texprInfo.call,\n\t\t\t\t\t\texprInfo.getMembers()\n\t\t\t\t\t);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\t\tif (callee.isIdentifier()) {\n\t\t\t\tconst result1 = this.callHooksForInfo(\n\t\t\t\t\tthis.hooks.callMemberChain,\n\t\t\t\t\tcallee.rootInfo,\n\t\t\t\t\texpression,\n\t\t\t\t\tcallee.getMembers(),\n\t\t\t\t\tcallee.getMembersOptionals\n\t\t\t\t\t\t? callee.getMembersOptionals()\n\t\t\t\t\t\t: callee.getMembers().map(() => false)\n\t\t\t\t);\n\t\t\t\tif (result1 === true) return;\n\t\t\t\tconst result2 = this.callHooksForInfo(\n\t\t\t\t\tthis.hooks.call,\n\t\t\t\t\tcallee.identifier,\n\t\t\t\t\texpression\n\t\t\t\t);\n\t\t\t\tif (result2 === true) return;\n\t\t\t}\n\n\t\t\tif (expression.callee) {\n\t\t\t\tif (expression.callee.type === \"MemberExpression\") {\n\t\t\t\t\t// because of call context we need to walk the call context as expression\n\t\t\t\t\tthis.walkExpression(expression.callee.object);\n\t\t\t\t\tif (expression.callee.computed === true)\n\t\t\t\t\t\tthis.walkExpression(expression.callee.property);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(expression.callee);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkMemberExpression(expression) {\n\t\tconst exprInfo = this.getMemberExpressionInfo(\n\t\t\texpression,\n\t\t\tALLOWED_MEMBER_TYPES_ALL\n\t\t);\n\t\tif (exprInfo) {\n\t\t\tswitch (exprInfo.type) {\n\t\t\t\tcase \"expression\": {\n\t\t\t\t\tconst result1 = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.expression,\n\t\t\t\t\t\texprInfo.name,\n\t\t\t\t\t\texpression\n\t\t\t\t\t);\n\t\t\t\t\tif (result1 === true) return;\n\t\t\t\t\tconst members = exprInfo.getMembers();\n\t\t\t\t\tconst membersOptionals = exprInfo.getMembersOptionals();\n\t\t\t\t\tconst result2 = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.expressionMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\tmembers,\n\t\t\t\t\t\tmembersOptionals\n\t\t\t\t\t);\n\t\t\t\t\tif (result2 === true) return;\n\t\t\t\t\tthis.walkMemberExpressionWithExpressionName(\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.name,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\tmembers.slice(),\n\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\tthis.callHooksForInfo(\n\t\t\t\t\t\t\t\tthis.hooks.unhandledExpressionMemberChain,\n\t\t\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\t\t\texpression,\n\t\t\t\t\t\t\t\tmembers\n\t\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcase \"call\": {\n\t\t\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\t\t\tthis.hooks.memberChainOfCallMemberChain,\n\t\t\t\t\t\texprInfo.rootInfo,\n\t\t\t\t\t\texpression,\n\t\t\t\t\t\texprInfo.getCalleeMembers(),\n\t\t\t\t\t\texprInfo.call,\n\t\t\t\t\t\texprInfo.getMembers()\n\t\t\t\t\t);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t\t// Fast skip over the member chain as we already called memberChainOfCallMemberChain\n\t\t\t\t\t// and call computed property are literals anyway\n\t\t\t\t\tthis.walkExpression(exprInfo.call);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.object);\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkMemberExpressionWithExpressionName(\n\t\texpression,\n\t\tname,\n\t\trootInfo,\n\t\tmembers,\n\t\tonUnhandled\n\t) {\n\t\tif (expression.object.type === \"MemberExpression\") {\n\t\t\t// optimize the case where expression.object is a MemberExpression too.\n\t\t\t// we can keep info here when calling walkMemberExpression directly\n\t\t\tconst property =\n\t\t\t\texpression.property.name || `${expression.property.value}`;\n\t\t\tname = name.slice(0, -property.length - 1);\n\t\t\tmembers.pop();\n\t\t\tconst result = this.callHooksForInfo(\n\t\t\t\tthis.hooks.expression,\n\t\t\t\tname,\n\t\t\t\texpression.object\n\t\t\t);\n\t\t\tif (result === true) return;\n\t\t\tthis.walkMemberExpressionWithExpressionName(\n\t\t\t\texpression.object,\n\t\t\t\tname,\n\t\t\t\trootInfo,\n\t\t\t\tmembers,\n\t\t\t\tonUnhandled\n\t\t\t);\n\t\t} else if (!onUnhandled || !onUnhandled()) {\n\t\t\tthis.walkExpression(expression.object);\n\t\t}\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkThisExpression(expression) {\n\t\tthis.callHooksForName(this.hooks.expression, \"this\", expression);\n\t}\n\n\twalkIdentifier(expression) {\n\t\tthis.callHooksForName(this.hooks.expression, expression.name, expression);\n\t}\n\n\t/**\n\t * @param {MetaPropertyNode} metaProperty meta property\n\t */\n\twalkMetaProperty(metaProperty) {\n\t\tthis.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);\n\t}\n\n\tcallHooksForExpression(hookMap, expr, ...args) {\n\t\treturn this.callHooksForExpressionWithFallback(\n\t\t\thookMap,\n\t\t\texpr,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {MemberExpressionNode} expr expression info\n\t * @param {function(string, string | ScopeInfo | VariableInfo, function(): string[]): any} fallback callback when variable in not handled by hooks\n\t * @param {function(string): any} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForExpressionWithFallback(\n\t\thookMap,\n\t\texpr,\n\t\tfallback,\n\t\tdefined,\n\t\t...args\n\t) {\n\t\tconst exprName = this.getMemberExpressionInfo(\n\t\t\texpr,\n\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t);\n\t\tif (exprName !== undefined) {\n\t\t\tconst members = exprName.getMembers();\n\t\t\treturn this.callHooksForInfoWithFallback(\n\t\t\t\thookMap,\n\t\t\t\tmembers.length === 0 ? exprName.rootInfo : exprName.name,\n\t\t\t\tfallback &&\n\t\t\t\t\t(name => fallback(name, exprName.rootInfo, exprName.getMembers)),\n\t\t\t\tdefined && (() => defined(exprName.name)),\n\t\t\t\t...args\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {string} name key in map\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForName(hookMap, name, ...args) {\n\t\treturn this.callHooksForNameWithFallback(\n\t\t\thookMap,\n\t\t\tname,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks that should be called\n\t * @param {ExportedVariableInfo} info variable info\n\t * @param  {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForInfo(hookMap, info, ...args) {\n\t\treturn this.callHooksForInfoWithFallback(\n\t\t\thookMap,\n\t\t\tinfo,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {ExportedVariableInfo} info variable info\n\t * @param {function(string): any} fallback callback when variable in not handled by hooks\n\t * @param {function(): any} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForInfoWithFallback(hookMap, info, fallback, defined, ...args) {\n\t\tlet name;\n\t\tif (typeof info === \"string\") {\n\t\t\tname = info;\n\t\t} else {\n\t\t\tif (!(info instanceof VariableInfo)) {\n\t\t\t\tif (defined !== undefined) {\n\t\t\t\t\treturn defined();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet tagInfo = info.tagInfo;\n\t\t\twhile (tagInfo !== undefined) {\n\t\t\t\tconst hook = hookMap.get(tagInfo.tag);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tthis.currentTagData = tagInfo.data;\n\t\t\t\t\tconst result = hook.call(...args);\n\t\t\t\t\tthis.currentTagData = undefined;\n\t\t\t\t\tif (result !== undefined) return result;\n\t\t\t\t}\n\t\t\t\ttagInfo = tagInfo.next;\n\t\t\t}\n\t\t\tif (info.freeName === true) {\n\t\t\t\tif (defined !== undefined) {\n\t\t\t\t\treturn defined();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tname = info.freeName;\n\t\t}\n\t\tconst hook = hookMap.get(name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(...args);\n\t\t\tif (result !== undefined) return result;\n\t\t}\n\t\tif (fallback !== undefined) {\n\t\t\treturn fallback(name);\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template R\n\t * @param {HookMap<SyncBailHook<T, R>>} hookMap hooks the should be called\n\t * @param {string} name key in map\n\t * @param {function(string): any} fallback callback when variable in not handled by hooks\n\t * @param {function(): any} defined callback when variable is defined\n\t * @param {AsArray<T>} args args for the hook\n\t * @returns {R} result of hook\n\t */\n\tcallHooksForNameWithFallback(hookMap, name, fallback, defined, ...args) {\n\t\treturn this.callHooksForInfoWithFallback(\n\t\t\thookMap,\n\t\t\tthis.getVariableInfo(name),\n\t\t\tfallback,\n\t\t\tdefined,\n\t\t\t...args\n\t\t);\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinScope(params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tthis.undefineVariable(\"this\");\n\n\t\tthis.enterPatterns(params, (ident, pattern) => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinFunctionScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.undefineVariable(\"this\");\n\t\t}\n\n\t\tthis.enterPatterns(params, (ident, pattern) => {\n\t\t\tthis.defineVariable(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinBlockScope(fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: oldScope.inTry,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild()\n\t\t};\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tdetectMode(statements) {\n\t\tconst isLiteral =\n\t\t\tstatements.length >= 1 &&\n\t\t\tstatements[0].type === \"ExpressionStatement\" &&\n\t\t\tstatements[0].expression.type === \"Literal\";\n\t\tif (isLiteral && statements[0].expression.value === \"use strict\") {\n\t\t\tthis.scope.isStrict = true;\n\t\t}\n\t\tif (isLiteral && statements[0].expression.value === \"use asm\") {\n\t\t\tthis.scope.isAsmJs = true;\n\t\t}\n\t}\n\n\tenterPatterns(patterns, onIdent) {\n\t\tfor (const pattern of patterns) {\n\t\t\tif (typeof pattern !== \"string\") {\n\t\t\t\tthis.enterPattern(pattern, onIdent);\n\t\t\t} else if (pattern) {\n\t\t\t\tonIdent(pattern);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterPattern(pattern, onIdent) {\n\t\tif (!pattern) return;\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.enterArrayPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.enterAssignmentPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.enterIdentifier(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.enterObjectPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.enterRestElement(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Property\":\n\t\t\t\tif (pattern.shorthand && pattern.value.type === \"Identifier\") {\n\t\t\t\t\tthis.scope.inShorthand = pattern.value.name;\n\t\t\t\t\tthis.enterIdentifier(pattern.value, onIdent);\n\t\t\t\t\tthis.scope.inShorthand = false;\n\t\t\t\t} else {\n\t\t\t\t\tthis.enterPattern(pattern.value, onIdent);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tenterIdentifier(pattern, onIdent) {\n\t\tif (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {\n\t\t\tonIdent(pattern.name, pattern);\n\t\t}\n\t}\n\n\tenterObjectPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = pattern.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = pattern.properties[propIndex];\n\t\t\tthis.enterPattern(prop, onIdent);\n\t\t}\n\t}\n\n\tenterArrayPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet elementIndex = 0, len = pattern.elements.length;\n\t\t\telementIndex < len;\n\t\t\telementIndex++\n\t\t) {\n\t\t\tconst element = pattern.elements[elementIndex];\n\t\t\tthis.enterPattern(element, onIdent);\n\t\t}\n\t}\n\n\tenterRestElement(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.argument, onIdent);\n\t}\n\n\tenterAssignmentPattern(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.left, onIdent);\n\t}\n\n\t/**\n\t * @param {ExpressionNode} expression expression node\n\t * @returns {BasicEvaluatedExpression} evaluation result\n\t */\n\tevaluateExpression(expression) {\n\t\ttry {\n\t\t\tconst hook = this.hooks.evaluate.get(expression.type);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result !== undefined && result !== null) {\n\t\t\t\t\tresult.setExpression(expression);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t\t// ignore error\n\t\t}\n\t\treturn new BasicEvaluatedExpression()\n\t\t\t.setRange(expression.range)\n\t\t\t.setExpression(expression);\n\t}\n\n\tparseString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.parseString(expression.left) +\n\t\t\t\t\t\tthis.parseString(expression.right)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Literal\":\n\t\t\t\treturn expression.value + \"\";\n\t\t}\n\t\tthrow new Error(\n\t\t\texpression.type + \" is not supported as parameter for require\"\n\t\t);\n\t}\n\n\tparseCalculatedString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\tconst left = this.parseCalculatedString(expression.left);\n\t\t\t\t\tconst right = this.parseCalculatedString(expression.right);\n\t\t\t\t\tif (left.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: left.range,\n\t\t\t\t\t\t\tvalue: left.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (right.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t\tleft.range[0],\n\t\t\t\t\t\t\t\tright.range ? right.range[1] : left.range[1]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [left.range[0], right.range[1]],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: false,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\": {\n\t\t\t\tconst consequent = this.parseCalculatedString(expression.consequent);\n\t\t\t\tconst alternate = this.parseCalculatedString(expression.alternate);\n\t\t\t\tconst items = [];\n\t\t\t\tif (consequent.conditional) {\n\t\t\t\t\titems.push(...consequent.conditional);\n\t\t\t\t} else if (!consequent.code) {\n\t\t\t\t\titems.push(consequent);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (alternate.conditional) {\n\t\t\t\t\titems.push(...alternate.conditional);\n\t\t\t\t} else if (!alternate.code) {\n\t\t\t\t\titems.push(alternate);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tcode: true,\n\t\t\t\t\tconditional: items\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Literal\":\n\t\t\t\treturn {\n\t\t\t\t\trange: expression.range,\n\t\t\t\t\tvalue: expression.value + \"\",\n\t\t\t\t\tcode: false,\n\t\t\t\t\tconditional: false\n\t\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trange: undefined,\n\t\t\tvalue: \"\",\n\t\t\tcode: true,\n\t\t\tconditional: false\n\t\t};\n\t}\n\n\t/**\n\t * @param {string | Buffer | PreparsedAst} source the source to parse\n\t * @param {ParserState} state the parser state\n\t * @returns {ParserState} the parser state\n\t */\n\tparse(source, state) {\n\t\tlet ast;\n\t\tlet comments;\n\t\tconst semicolons = new Set();\n\t\tif (source === null) {\n\t\t\tthrow new Error(\"source must not be null\");\n\t\t}\n\t\tif (Buffer.isBuffer(source)) {\n\t\t\tsource = source.toString(\"utf-8\");\n\t\t}\n\t\tif (typeof source === \"object\") {\n\t\t\tast = /** @type {ProgramNode} */ (source);\n\t\t\tcomments = source.comments;\n\t\t} else {\n\t\t\tcomments = [];\n\t\t\tast = JavascriptParser._parse(source, {\n\t\t\t\tsourceType: this.sourceType,\n\t\t\t\tonComment: comments,\n\t\t\t\tonInsertedSemicolon: pos => semicolons.add(pos)\n\t\t\t});\n\t\t}\n\n\t\tconst oldScope = this.scope;\n\t\tconst oldState = this.state;\n\t\tconst oldComments = this.comments;\n\t\tconst oldSemicolons = this.semicolons;\n\t\tconst oldStatementPath = this.statementPath;\n\t\tconst oldPrevStatement = this.prevStatement;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: true,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: false,\n\t\t\tisAsmJs: false,\n\t\t\tdefinitions: new StackedMap()\n\t\t};\n\t\t/** @type {ParserState} */\n\t\tthis.state = state;\n\t\tthis.comments = comments;\n\t\tthis.semicolons = semicolons;\n\t\tthis.statementPath = [];\n\t\tthis.prevStatement = undefined;\n\t\tif (this.hooks.program.call(ast, comments) === undefined) {\n\t\t\tthis.detectMode(ast.body);\n\t\t\tthis.preWalkStatements(ast.body);\n\t\t\tthis.prevStatement = undefined;\n\t\t\tthis.blockPreWalkStatements(ast.body);\n\t\t\tthis.prevStatement = undefined;\n\t\t\tthis.walkStatements(ast.body);\n\t\t}\n\t\tthis.hooks.finish.call(ast, comments);\n\t\tthis.scope = oldScope;\n\t\t/** @type {ParserState} */\n\t\tthis.state = oldState;\n\t\tthis.comments = oldComments;\n\t\tthis.semicolons = oldSemicolons;\n\t\tthis.statementPath = oldStatementPath;\n\t\tthis.prevStatement = oldPrevStatement;\n\t\treturn state;\n\t}\n\n\t/**\n\t * @param {string} source source code\n\t * @returns {BasicEvaluatedExpression} evaluation result\n\t */\n\tevaluate(source) {\n\t\tconst ast = JavascriptParser._parse(\"(\" + source + \")\", {\n\t\t\tsourceType: this.sourceType,\n\t\t\tlocations: false\n\t\t});\n\t\tif (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n\t\t\tthrow new Error(\"evaluate: Source is not a expression\");\n\t\t}\n\t\treturn this.evaluateExpression(ast.body[0].expression);\n\t}\n\n\t/**\n\t * @param {ExpressionNode | DeclarationNode | PrivateIdentifierNode | null | undefined} expr an expression\n\t * @param {number} commentsStartPos source position from which annotation comments are checked\n\t * @returns {boolean} true, when the expression is pure\n\t */\n\tisPure(expr, commentsStartPos) {\n\t\tif (!expr) return true;\n\t\tconst result = this.hooks.isPure\n\t\t\t.for(expr.type)\n\t\t\t.call(expr, commentsStartPos);\n\t\tif (typeof result === \"boolean\") return result;\n\t\tswitch (expr.type) {\n\t\t\tcase \"ClassDeclaration\":\n\t\t\tcase \"ClassExpression\": {\n\t\t\t\tif (expr.body.type !== \"ClassBody\") return false;\n\t\t\t\tif (expr.superClass && !this.isPure(expr.superClass, expr.range[0])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tconst items =\n\t\t\t\t\t/** @type {(MethodDefinitionNode | PropertyDefinitionNode)[]} */ (\n\t\t\t\t\t\texpr.body.body\n\t\t\t\t\t);\n\t\t\t\treturn items.every(\n\t\t\t\t\titem =>\n\t\t\t\t\t\t(!item.computed ||\n\t\t\t\t\t\t\t!item.key ||\n\t\t\t\t\t\t\tthis.isPure(item.key, item.range[0])) &&\n\t\t\t\t\t\t(!item.static ||\n\t\t\t\t\t\t\t!item.value ||\n\t\t\t\t\t\t\tthis.isPure(\n\t\t\t\t\t\t\t\titem.value,\n\t\t\t\t\t\t\t\titem.key ? item.key.range[1] : item.range[0]\n\t\t\t\t\t\t\t))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\tcase \"FunctionExpression\":\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\tcase \"Literal\":\n\t\t\tcase \"PrivateIdentifier\":\n\t\t\t\treturn true;\n\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\treturn expr.declarations.every(decl =>\n\t\t\t\t\tthis.isPure(decl.init, decl.range[0])\n\t\t\t\t);\n\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\treturn (\n\t\t\t\t\tthis.isPure(expr.test, commentsStartPos) &&\n\t\t\t\t\tthis.isPure(expr.consequent, expr.test.range[1]) &&\n\t\t\t\t\tthis.isPure(expr.alternate, expr.consequent.range[1])\n\t\t\t\t);\n\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\treturn expr.expressions.every(expr => {\n\t\t\t\t\tconst pureFlag = this.isPure(expr, commentsStartPos);\n\t\t\t\t\tcommentsStartPos = expr.range[1];\n\t\t\t\t\treturn pureFlag;\n\t\t\t\t});\n\n\t\t\tcase \"CallExpression\": {\n\t\t\t\tconst pureFlag =\n\t\t\t\t\texpr.range[0] - commentsStartPos > 12 &&\n\t\t\t\t\tthis.getComments([commentsStartPos, expr.range[0]]).some(\n\t\t\t\t\t\tcomment =>\n\t\t\t\t\t\t\tcomment.type === \"Block\" &&\n\t\t\t\t\t\t\t/^\\s*(#|@)__PURE__\\s*$/.test(comment.value)\n\t\t\t\t\t);\n\t\t\t\tif (!pureFlag) return false;\n\t\t\t\tcommentsStartPos = expr.callee.range[1];\n\t\t\t\treturn expr.arguments.every(arg => {\n\t\t\t\t\tif (arg.type === \"SpreadElement\") return false;\n\t\t\t\t\tconst pureFlag = this.isPure(arg, commentsStartPos);\n\t\t\t\t\tcommentsStartPos = arg.range[1];\n\t\t\t\t\treturn pureFlag;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tconst evaluated = this.evaluateExpression(expr);\n\t\treturn !evaluated.couldHaveSideEffects();\n\t}\n\n\tgetComments(range) {\n\t\tconst [rangeStart, rangeEnd] = range;\n\t\tconst compare = (comment, needle) => comment.range[0] - needle;\n\t\tlet idx = binarySearchBounds.ge(this.comments, rangeStart, compare);\n\t\tlet commentsInRange = [];\n\t\twhile (this.comments[idx] && this.comments[idx].range[1] <= rangeEnd) {\n\t\t\tcommentsInRange.push(this.comments[idx]);\n\t\t\tidx++;\n\t\t}\n\n\t\treturn commentsInRange;\n\t}\n\n\t/**\n\t * @param {number} pos source code position\n\t * @returns {boolean} true when a semicolon has been inserted before this position, false if not\n\t */\n\tisAsiPosition(pos) {\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\tif (currentStatement === undefined) throw new Error(\"Not in statement\");\n\t\treturn (\n\t\t\t// Either asking directly for the end position of the current statement\n\t\t\t(currentStatement.range[1] === pos && this.semicolons.has(pos)) ||\n\t\t\t// Or asking for the start position of the current statement,\n\t\t\t// here we have to check multiple things\n\t\t\t(currentStatement.range[0] === pos &&\n\t\t\t\t// is there a previous statement which might be relevant?\n\t\t\t\tthis.prevStatement !== undefined &&\n\t\t\t\t// is the end position of the previous statement an ASI position?\n\t\t\t\tthis.semicolons.has(this.prevStatement.range[1]))\n\t\t);\n\t}\n\n\t/**\n\t * @param {number} pos source code position\n\t * @returns {void}\n\t */\n\tunsetAsiPosition(pos) {\n\t\tthis.semicolons.delete(pos);\n\t}\n\n\tisStatementLevelExpression(expr) {\n\t\tconst currentStatement = this.statementPath[this.statementPath.length - 1];\n\t\treturn (\n\t\t\texpr === currentStatement ||\n\t\t\t(currentStatement.type === \"ExpressionStatement\" &&\n\t\t\t\tcurrentStatement.expression === expr)\n\t\t);\n\t}\n\n\tgetTagData(name, tag) {\n\t\tconst info = this.scope.definitions.get(name);\n\t\tif (info instanceof VariableInfo) {\n\t\t\tlet tagInfo = info.tagInfo;\n\t\t\twhile (tagInfo !== undefined) {\n\t\t\t\tif (tagInfo.tag === tag) return tagInfo.data;\n\t\t\t\ttagInfo = tagInfo.next;\n\t\t\t}\n\t\t}\n\t}\n\n\ttagVariable(name, tag, data) {\n\t\tconst oldInfo = this.scope.definitions.get(name);\n\t\t/** @type {VariableInfo} */\n\t\tlet newInfo;\n\t\tif (oldInfo === undefined) {\n\t\t\tnewInfo = new VariableInfo(this.scope, name, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: undefined\n\t\t\t});\n\t\t} else if (oldInfo instanceof VariableInfo) {\n\t\t\tnewInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: oldInfo.tagInfo\n\t\t\t});\n\t\t} else {\n\t\t\tnewInfo = new VariableInfo(oldInfo, true, {\n\t\t\t\ttag,\n\t\t\t\tdata,\n\t\t\t\tnext: undefined\n\t\t\t});\n\t\t}\n\t\tthis.scope.definitions.set(name, newInfo);\n\t}\n\n\tdefineVariable(name) {\n\t\tconst oldInfo = this.scope.definitions.get(name);\n\t\t// Don't redefine variable in same scope to keep existing tags\n\t\tif (oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope)\n\t\t\treturn;\n\t\tthis.scope.definitions.set(name, this.scope);\n\t}\n\n\tundefineVariable(name) {\n\t\tthis.scope.definitions.delete(name);\n\t}\n\n\tisVariableDefined(name) {\n\t\tconst info = this.scope.definitions.get(name);\n\t\tif (info === undefined) return false;\n\t\tif (info instanceof VariableInfo) {\n\t\t\treturn info.freeName === true;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @returns {ExportedVariableInfo} info for this variable\n\t */\n\tgetVariableInfo(name) {\n\t\tconst value = this.scope.definitions.get(name);\n\t\tif (value === undefined) {\n\t\t\treturn name;\n\t\t} else {\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name variable name\n\t * @param {ExportedVariableInfo} variableInfo new info for this variable\n\t * @returns {void}\n\t */\n\tsetVariable(name, variableInfo) {\n\t\tif (typeof variableInfo === \"string\") {\n\t\t\tif (variableInfo === name) {\n\t\t\t\tthis.scope.definitions.delete(name);\n\t\t\t} else {\n\t\t\t\tthis.scope.definitions.set(\n\t\t\t\t\tname,\n\t\t\t\t\tnew VariableInfo(this.scope, variableInfo, undefined)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.scope.definitions.set(name, variableInfo);\n\t\t}\n\t}\n\n\tevaluatedVariable(tagInfo) {\n\t\treturn new VariableInfo(this.scope, undefined, tagInfo);\n\t}\n\n\tparseCommentOptions(range) {\n\t\tconst comments = this.getComments(range);\n\t\tif (comments.length === 0) {\n\t\t\treturn EMPTY_COMMENT_OPTIONS;\n\t\t}\n\t\tlet options = {};\n\t\tlet errors = [];\n\t\tfor (const comment of comments) {\n\t\t\tconst { value } = comment;\n\t\t\tif (value && webpackCommentRegExp.test(value)) {\n\t\t\t\t// try compile only if webpack options comment is present\n\t\t\t\ttry {\n\t\t\t\t\tconst val = vm.runInNewContext(`(function(){return {${value}};})()`);\n\t\t\t\t\tObject.assign(options, val);\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.comment = comment;\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { options, errors };\n\t}\n\n\t/**\n\t * @param {MemberExpressionNode} expression a member expression\n\t * @returns {{ members: string[], object: ExpressionNode | SuperNode, membersOptionals: boolean[] }} member names (reverse order) and remaining object\n\t */\n\textractMemberExpressionChain(expression) {\n\t\t/** @type {AnyNode} */\n\t\tlet expr = expression;\n\t\tconst members = [];\n\t\tconst membersOptionals = [];\n\t\twhile (expr.type === \"MemberExpression\") {\n\t\t\tif (expr.computed) {\n\t\t\t\tif (expr.property.type !== \"Literal\") break;\n\t\t\t\tmembers.push(`${expr.property.value}`);\n\t\t\t} else {\n\t\t\t\tif (expr.property.type !== \"Identifier\") break;\n\t\t\t\tmembers.push(expr.property.name);\n\t\t\t}\n\t\t\tmembersOptionals.push(expr.optional);\n\t\t\texpr = expr.object;\n\t\t}\n\n\t\treturn {\n\t\t\tmembers,\n\t\t\tmembersOptionals,\n\t\t\tobject: expr\n\t\t};\n\t}\n\n\t/**\n\t * @param {string} varName variable name\n\t * @returns {{name: string, info: VariableInfo | string}} name of the free variable and variable info for that\n\t */\n\tgetFreeInfoFromVariable(varName) {\n\t\tconst info = this.getVariableInfo(varName);\n\t\tlet name;\n\t\tif (info instanceof VariableInfo) {\n\t\t\tname = info.freeName;\n\t\t\tif (typeof name !== \"string\") return undefined;\n\t\t} else if (typeof info !== \"string\") {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tname = info;\n\t\t}\n\t\treturn { info, name };\n\t}\n\n\t/** @typedef {{ type: \"call\", call: CallExpressionNode, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[], getMembersOptionals: () => boolean[]}} CallExpressionInfo */\n\t/** @typedef {{ type: \"expression\", rootInfo: string | VariableInfo, name: string, getMembers: () => string[], getMembersOptionals: () => boolean[]}} ExpressionExpressionInfo */\n\n\t/**\n\t * @param {MemberExpressionNode} expression a member expression\n\t * @param {number} allowedTypes which types should be returned, presented in bit mask\n\t * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined} expression info\n\t */\n\tgetMemberExpressionInfo(expression, allowedTypes) {\n\t\tconst { object, members, membersOptionals } =\n\t\t\tthis.extractMemberExpressionChain(expression);\n\t\tswitch (object.type) {\n\t\t\tcase \"CallExpression\": {\n\t\t\t\tif ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0)\n\t\t\t\t\treturn undefined;\n\t\t\t\tlet callee = object.callee;\n\t\t\t\tlet rootMembers = EMPTY_ARRAY;\n\t\t\t\tif (callee.type === \"MemberExpression\") {\n\t\t\t\t\t({ object: callee, members: rootMembers } =\n\t\t\t\t\t\tthis.extractMemberExpressionChain(callee));\n\t\t\t\t}\n\t\t\t\tconst rootName = getRootName(callee);\n\t\t\t\tif (!rootName) return undefined;\n\t\t\t\tconst result = this.getFreeInfoFromVariable(rootName);\n\t\t\t\tif (!result) return undefined;\n\t\t\t\tconst { info: rootInfo, name: resolvedRoot } = result;\n\t\t\t\tconst calleeName = objectAndMembersToName(resolvedRoot, rootMembers);\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"call\",\n\t\t\t\t\tcall: object,\n\t\t\t\t\tcalleeName,\n\t\t\t\t\trootInfo,\n\t\t\t\t\tgetCalleeMembers: memoize(() => rootMembers.reverse()),\n\t\t\t\t\tname: objectAndMembersToName(`${calleeName}()`, members),\n\t\t\t\t\tgetMembers: memoize(() => members.reverse()),\n\t\t\t\t\tgetMembersOptionals: memoize(() => membersOptionals.reverse())\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Identifier\":\n\t\t\tcase \"MetaProperty\":\n\t\t\tcase \"ThisExpression\": {\n\t\t\t\tif ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0)\n\t\t\t\t\treturn undefined;\n\t\t\t\tconst rootName = getRootName(object);\n\t\t\t\tif (!rootName) return undefined;\n\n\t\t\t\tconst result = this.getFreeInfoFromVariable(rootName);\n\t\t\t\tif (!result) return undefined;\n\t\t\t\tconst { info: rootInfo, name: resolvedRoot } = result;\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"expression\",\n\t\t\t\t\tname: objectAndMembersToName(resolvedRoot, members),\n\t\t\t\t\trootInfo,\n\t\t\t\t\tgetMembers: memoize(() => members.reverse()),\n\t\t\t\t\tgetMembersOptionals: memoize(() => membersOptionals.reverse())\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {MemberExpressionNode} expression an expression\n\t * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]}} name info\n\t */\n\tgetNameForExpression(expression) {\n\t\treturn this.getMemberExpressionInfo(\n\t\t\texpression,\n\t\t\tALLOWED_MEMBER_TYPES_EXPRESSION\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} code source code\n\t * @param {ParseOptions} options parsing options\n\t * @returns {ProgramNode} parsed ast\n\t */\n\tstatic _parse(code, options) {\n\t\tconst type = options ? options.sourceType : \"module\";\n\t\t/** @type {AcornOptions} */\n\t\tconst parserOptions = {\n\t\t\t...defaultParserOptions,\n\t\t\tallowReturnOutsideFunction: type === \"script\",\n\t\t\t...options,\n\t\t\tsourceType: type === \"auto\" ? \"module\" : type\n\t\t};\n\n\t\t/** @type {AnyNode} */\n\t\tlet ast;\n\t\tlet error;\n\t\tlet threw = false;\n\t\ttry {\n\t\t\tast = /** @type {AnyNode} */ (parser.parse(code, parserOptions));\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t\tthrew = true;\n\t\t}\n\n\t\tif (threw && type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"script\";\n\t\t\tif (!(\"allowReturnOutsideFunction\" in options)) {\n\t\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t\t}\n\t\t\tif (Array.isArray(parserOptions.onComment)) {\n\t\t\t\tparserOptions.onComment.length = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tast = /** @type {AnyNode} */ (parser.parse(code, parserOptions));\n\t\t\t\tthrew = false;\n\t\t\t} catch (e) {\n\t\t\t\t// we use the error from first parse try\n\t\t\t\t// so nothing to do here\n\t\t\t}\n\t\t}\n\n\t\tif (threw) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn /** @type {ProgramNode} */ (ast);\n\t}\n}\n\nmodule.exports = JavascriptParser;\nmodule.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;\nmodule.exports.ALLOWED_MEMBER_TYPES_EXPRESSION =\n\tALLOWED_MEMBER_TYPES_EXPRESSION;\nmodule.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION =\n\tALLOWED_MEMBER_TYPES_CALL_EXPRESSION;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}