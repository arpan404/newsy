{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nconst {\n  stringHints,\n  numberHints\n} = require(\"./util/hints\");\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n\n/** @typedef {import(\"./validate\").Schema} Schema */\n\n/** @typedef {import(\"./validate\").ValidationErrorConfiguration} ValidationErrorConfiguration */\n\n/** @typedef {import(\"./validate\").PostFormatter} PostFormatter */\n\n/** @typedef {import(\"./validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n\n/** @enum {number} */\n\n\nconst SPECIFICITY = {\n  type: 1,\n  not: 1,\n  oneOf: 1,\n  anyOf: 1,\n  if: 1,\n  enum: 1,\n  const: 1,\n  instanceof: 1,\n  required: 2,\n  pattern: 2,\n  patternRequired: 2,\n  format: 2,\n  formatMinimum: 2,\n  formatMaximum: 2,\n  minimum: 2,\n  exclusiveMinimum: 2,\n  maximum: 2,\n  exclusiveMaximum: 2,\n  multipleOf: 2,\n  uniqueItems: 2,\n  contains: 2,\n  minLength: 2,\n  maxLength: 2,\n  minItems: 2,\n  maxItems: 2,\n  minProperties: 2,\n  maxProperties: 2,\n  dependencies: 2,\n  propertyNames: 2,\n  additionalItems: 2,\n  additionalProperties: 2,\n  absolutePath: 2\n};\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} array\n * @param {(item: SchemaUtilErrorObject) => number} fn\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\nfunction filterMax(array, fn) {\n  const evaluatedMax = array.reduce((max, item) => Math.max(max, fn(item)), 0);\n  return array.filter(item => fn(item) === evaluatedMax);\n}\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} children\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction filterChildren(children) {\n  let newChildren = children;\n  newChildren = filterMax(newChildren,\n  /**\n   *\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => error.dataPath ? error.dataPath.length : 0);\n  newChildren = filterMax(newChildren,\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => SPECIFICITY[\n  /** @type {keyof typeof SPECIFICITY} */\n  error.keyword] || 2);\n  return newChildren;\n}\n/**\n * Find all children errors\n * @param {Array<SchemaUtilErrorObject>} children\n * @param {Array<string>} schemaPaths\n * @return {number} returns index of first child\n */\n\n\nfunction findAllChildren(children, schemaPaths) {\n  let i = children.length - 1;\n\n  const predicate =\n  /**\n   * @param {string} schemaPath\n   * @returns {boolean}\n   */\n  schemaPath => children[i].schemaPath.indexOf(schemaPath) !== 0;\n\n  while (i > -1 && !schemaPaths.every(predicate)) {\n    if (children[i].keyword === \"anyOf\" || children[i].keyword === \"oneOf\") {\n      const refs = extractRefs(children[i]);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));\n      i = childrenStart - 1;\n    } else {\n      i -= 1;\n    }\n  }\n\n  return i + 1;\n}\n/**\n * Extracts all refs from schema\n * @param {SchemaUtilErrorObject} error\n * @return {Array<string>}\n */\n\n\nfunction extractRefs(error) {\n  const {\n    schema\n  } = error;\n\n  if (!Array.isArray(schema)) {\n    return [];\n  }\n\n  return schema.map(_ref => {\n    let {\n      $ref\n    } = _ref;\n    return $ref;\n  }).filter(s => s);\n}\n/**\n * Groups children by their first level parent (assuming that error is root)\n * @param {Array<SchemaUtilErrorObject>} children\n * @return {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction groupChildrenByFirstChild(children) {\n  const result = [];\n  let i = children.length - 1;\n\n  while (i > 0) {\n    const child = children[i];\n\n    if (child.keyword === \"anyOf\" || child.keyword === \"oneOf\") {\n      const refs = extractRefs(child);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));\n\n      if (childrenStart !== i) {\n        result.push(Object.assign({}, child, {\n          children: children.slice(childrenStart, i)\n        }));\n        i = childrenStart;\n      } else {\n        result.push(child);\n      }\n    } else {\n      result.push(child);\n    }\n\n    i -= 1;\n  }\n\n  if (i === 0) {\n    result.push(children[i]);\n  }\n\n  return result.reverse();\n}\n/**\n * @param {string} str\n * @param {string} prefix\n * @returns {string}\n */\n\n\nfunction indent(str, prefix) {\n  return str.replace(/\\n(?!$)/g, `\\n${prefix}`);\n}\n/**\n * @param {Schema} schema\n * @returns {schema is (Schema & {not: Schema})}\n */\n\n\nfunction hasNotInSchema(schema) {\n  return !!schema.not;\n}\n/**\n * @param {Schema} schema\n * @return {Schema}\n */\n\n\nfunction findFirstTypedSchema(schema) {\n  if (hasNotInSchema(schema)) {\n    return findFirstTypedSchema(schema.not);\n  }\n\n  return schema;\n}\n/**\n * @param {Schema} schema\n * @return {boolean}\n */\n\n\nfunction canApplyNot(schema) {\n  const typedSchema = findFirstTypedSchema(schema);\n  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);\n}\n/**\n * @param {any} maybeObj\n * @returns {boolean}\n */\n\n\nfunction isObject(maybeObj) {\n  return typeof maybeObj === \"object\" && maybeObj !== null;\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNumber(schema) {\n  return schema.type === \"number\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeInteger(schema) {\n  return schema.type === \"integer\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeString(schema) {\n  return schema.type === \"string\" || typeof schema.minLength !== \"undefined\" || typeof schema.maxLength !== \"undefined\" || typeof schema.pattern !== \"undefined\" || typeof schema.format !== \"undefined\" || typeof schema.formatMinimum !== \"undefined\" || typeof schema.formatMaximum !== \"undefined\";\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeBoolean(schema) {\n  return schema.type === \"boolean\";\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeArray(schema) {\n  return schema.type === \"array\" || typeof schema.minItems === \"number\" || typeof schema.maxItems === \"number\" || typeof schema.uniqueItems !== \"undefined\" || typeof schema.items !== \"undefined\" || typeof schema.additionalItems !== \"undefined\" || typeof schema.contains !== \"undefined\";\n}\n/**\n * @param {Schema & {patternRequired?: Array<string>}} schema\n * @returns {boolean}\n */\n\n\nfunction likeObject(schema) {\n  return schema.type === \"object\" || typeof schema.minProperties !== \"undefined\" || typeof schema.maxProperties !== \"undefined\" || typeof schema.required !== \"undefined\" || typeof schema.properties !== \"undefined\" || typeof schema.patternProperties !== \"undefined\" || typeof schema.additionalProperties !== \"undefined\" || typeof schema.dependencies !== \"undefined\" || typeof schema.propertyNames !== \"undefined\" || typeof schema.patternRequired !== \"undefined\";\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNull(schema) {\n  return schema.type === \"null\";\n}\n/**\n * @param {string} type\n * @returns {string}\n */\n\n\nfunction getArticle(type) {\n  if (/^[aeiou]/i.test(type)) {\n    return \"an\";\n  }\n\n  return \"a\";\n}\n/**\n * @param {Schema=} schema\n * @returns {string}\n */\n\n\nfunction getSchemaNonTypes(schema) {\n  if (!schema) {\n    return \"\";\n  }\n\n  if (!schema.type) {\n    if (likeNumber(schema) || likeInteger(schema)) {\n      return \" | should be any non-number\";\n    }\n\n    if (likeString(schema)) {\n      return \" | should be any non-string\";\n    }\n\n    if (likeArray(schema)) {\n      return \" | should be any non-array\";\n    }\n\n    if (likeObject(schema)) {\n      return \" | should be any non-object\";\n    }\n  }\n\n  return \"\";\n}\n/**\n * @param {Array<string>} hints\n * @returns {string}\n */\n\n\nfunction formatHints(hints) {\n  return hints.length > 0 ? `(${hints.join(\", \")})` : \"\";\n}\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @returns {string[]}\n */\n\n\nfunction getHints(schema, logic) {\n  if (likeNumber(schema) || likeInteger(schema)) {\n    return numberHints(schema, logic);\n  } else if (likeString(schema)) {\n    return stringHints(schema, logic);\n  }\n\n  return [];\n}\n\nclass ValidationError extends Error {\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @param {Schema} schema\n   * @param {ValidationErrorConfiguration} configuration\n   */\n  constructor(errors, schema) {\n    let configuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super();\n    /** @type {string} */\n\n    this.name = \"ValidationError\";\n    /** @type {Array<SchemaUtilErrorObject>} */\n\n    this.errors = errors;\n    /** @type {Schema} */\n\n    this.schema = schema;\n    let headerNameFromSchema;\n    let baseDataPathFromSchema;\n\n    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {\n      const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);\n\n      if (splittedTitleFromSchema) {\n        if (!configuration.name) {\n          [, headerNameFromSchema] = splittedTitleFromSchema;\n        }\n\n        if (!configuration.baseDataPath) {\n          [,, baseDataPathFromSchema] = splittedTitleFromSchema;\n        }\n      }\n    }\n    /** @type {string} */\n\n\n    this.headerName = configuration.name || headerNameFromSchema || \"Object\";\n    /** @type {string} */\n\n    this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || \"configuration\";\n    /** @type {PostFormatter | null} */\n\n    this.postFormatter = configuration.postFormatter || null;\n    const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${getArticle(this.baseDataPath)} ${this.baseDataPath} object that does not match the API schema.\\n`;\n    /** @type {string} */\n\n    this.message = `${header}${this.formatValidationErrors(errors)}`;\n    Error.captureStackTrace(this, this.constructor);\n  }\n  /**\n   * @param {string} path\n   * @returns {Schema}\n   */\n\n\n  getSchemaPart(path) {\n    const newPath = path.split(\"/\");\n    let schemaPart = this.schema;\n\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[\n      /** @type {keyof Schema} */\n      newPath[i]];\n\n      if (!inner) {\n        break;\n      }\n\n      schemaPart = inner;\n    }\n\n    return schemaPart;\n  }\n  /**\n   * @param {Schema} schema\n   * @param {boolean} logic\n   * @param {Array<Object>} prevSchemas\n   * @returns {string}\n   */\n\n\n  formatSchema(schema) {\n    let logic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let prevSchemas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let newLogic = logic;\n\n    const formatInnerSchema =\n    /**\n     *\n     * @param {Object} innerSchema\n     * @param {boolean=} addSelf\n     * @returns {string}\n     */\n    (innerSchema, addSelf) => {\n      if (!addSelf) {\n        return this.formatSchema(innerSchema, newLogic, prevSchemas);\n      }\n\n      if (prevSchemas.includes(innerSchema)) {\n        return \"(recursive)\";\n      }\n\n      return this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));\n    };\n\n    if (hasNotInSchema(schema) && !likeObject(schema)) {\n      if (canApplyNot(schema.not)) {\n        newLogic = !logic;\n        return formatInnerSchema(schema.not);\n      }\n\n      const needApplyLogicHere = !schema.not.not;\n      const prefix = logic ? \"\" : \"non \";\n      newLogic = !logic;\n      return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);\n    }\n\n    if (\n    /** @type {Schema & {instanceof: string | Array<string>}} */\n    schema.instanceof) {\n      const {\n        instanceof: value\n      } =\n      /** @type {Schema & {instanceof: string | Array<string>}} */\n      schema;\n      const values = !Array.isArray(value) ? [value] : value;\n      return values.map(\n      /**\n       * @param {string} item\n       * @returns {string}\n       */\n      item => item === \"Function\" ? \"function\" : item).join(\" | \");\n    }\n\n    if (schema.enum) {\n      return (\n        /** @type {Array<any>} */\n        schema.enum.map(item => JSON.stringify(item)).join(\" | \")\n      );\n    }\n\n    if (typeof schema.const !== \"undefined\") {\n      return JSON.stringify(schema.const);\n    }\n\n    if (schema.oneOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.oneOf.map(item => formatInnerSchema(item, true)).join(\" | \")\n      );\n    }\n\n    if (schema.anyOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.anyOf.map(item => formatInnerSchema(item, true)).join(\" | \")\n      );\n    }\n\n    if (schema.allOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.allOf.map(item => formatInnerSchema(item, true)).join(\" & \")\n      );\n    }\n\n    if (\n    /** @type {JSONSchema7} */\n    schema.if) {\n      const {\n        if: ifValue,\n        then: thenValue,\n        else: elseValue\n      } =\n      /** @type {JSONSchema7} */\n      schema;\n      return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : \"\"}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : \"\"}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : \"\"}`;\n    }\n\n    if (schema.$ref) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true);\n    }\n\n    if (likeNumber(schema) || likeInteger(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;\n    }\n\n    if (likeString(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : str === \"string\" ? \"non-string\" : `non-string | ${str}`;\n    }\n\n    if (likeBoolean(schema)) {\n      return `${logic ? \"\" : \"non-\"}boolean`;\n    }\n\n    if (likeArray(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n\n      if (typeof schema.minItems === \"number\") {\n        hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? \"s\" : \"\"}`);\n      }\n\n      if (typeof schema.maxItems === \"number\") {\n        hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? \"s\" : \"\"}`);\n      }\n\n      if (schema.uniqueItems) {\n        hints.push(\"should not have duplicate items\");\n      }\n\n      const hasAdditionalItems = typeof schema.additionalItems === \"undefined\" || Boolean(schema.additionalItems);\n      let items = \"\";\n\n      if (schema.items) {\n        if (Array.isArray(schema.items) && schema.items.length > 0) {\n          items = `${\n          /** @type {Array<Schema>} */\n          schema.items.map(item => formatInnerSchema(item)).join(\", \")}`;\n\n          if (hasAdditionalItems) {\n            if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {\n              hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);\n            }\n          }\n        } else if (schema.items && Object.keys(schema.items).length > 0) {\n          // \"additionalItems\" is ignored\n          items = `${formatInnerSchema(schema.items)}`;\n        } else {\n          // Fallback for empty `items` value\n          items = \"any\";\n        }\n      } else {\n        // \"additionalItems\" is ignored\n        items = \"any\";\n      }\n\n      if (schema.contains && Object.keys(schema.contains).length > 0) {\n        hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);\n      }\n\n      return `[${items}${hasAdditionalItems ? \", ...\" : \"\"}]${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n\n    if (likeObject(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n\n      if (typeof schema.minProperties === \"number\") {\n        hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n\n      if (typeof schema.maxProperties === \"number\") {\n        hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n\n      if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {\n        const patternProperties = Object.keys(schema.patternProperties);\n        hints.push(`additional property names should match pattern${patternProperties.length > 1 ? \"s\" : \"\"} ${patternProperties.map(pattern => JSON.stringify(pattern)).join(\" | \")}`);\n      }\n\n      const properties = schema.properties ? Object.keys(schema.properties) : [];\n      const required = schema.required ? schema.required : [];\n      const allProperties = [...new Set(\n      /** @type {Array<string>} */\n      [].concat(required).concat(properties))];\n      const objectStructure = allProperties.map(property => {\n        const isRequired = required.includes(property); // Some properties need quotes, maybe we should add check\n        // Maybe we should output type of property (`foo: string`), but it is looks very unreadable\n\n        return `${property}${isRequired ? \"\" : \"?\"}`;\n      }).concat(typeof schema.additionalProperties === \"undefined\" || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [`<key>: ${formatInnerSchema(schema.additionalProperties)}`] : [\"…\"] : []).join(\", \");\n      const {\n        dependencies,\n        propertyNames,\n        patternRequired\n      } =\n      /** @type {Schema & {patternRequired?: Array<string>;}} */\n      schema;\n\n      if (dependencies) {\n        Object.keys(dependencies).forEach(dependencyName => {\n          const dependency = dependencies[dependencyName];\n\n          if (Array.isArray(dependency)) {\n            hints.push(`should have ${dependency.length > 1 ? \"properties\" : \"property\"} ${dependency.map(dep => `'${dep}'`).join(\", \")} when property '${dependencyName}' is present`);\n          } else {\n            hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);\n          }\n        });\n      }\n\n      if (propertyNames && Object.keys(propertyNames).length > 0) {\n        hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);\n      }\n\n      if (patternRequired && patternRequired.length > 0) {\n        hints.push(`should have property matching pattern ${patternRequired.map(\n        /**\n         * @param {string} item\n         * @returns {string}\n         */\n        item => JSON.stringify(item))}`);\n      }\n\n      return `object {${objectStructure ? ` ${objectStructure} ` : \"\"}}${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n\n    if (likeNull(schema)) {\n      return `${logic ? \"\" : \"non-\"}null`;\n    }\n\n    if (Array.isArray(schema.type)) {\n      // not logic already applied in formatValidationError\n      return `${schema.type.join(\" | \")}`;\n    } // Fallback for unknown keywords\n    // not logic already applied in formatValidationError\n\n    /* istanbul ignore next */\n\n\n    return JSON.stringify(schema, null, 2);\n  }\n  /**\n   * @param {Schema=} schemaPart\n   * @param {(boolean | Array<string>)=} additionalPath\n   * @param {boolean=} needDot\n   * @param {boolean=} logic\n   * @returns {string}\n   */\n\n\n  getSchemaPartText(schemaPart, additionalPath) {\n    let needDot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let logic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n    if (!schemaPart) {\n      return \"\";\n    }\n\n    if (Array.isArray(additionalPath)) {\n      for (let i = 0; i < additionalPath.length; i++) {\n        /** @type {Schema | undefined} */\n        const inner = schemaPart[\n        /** @type {keyof Schema} */\n        additionalPath[i]];\n\n        if (inner) {\n          // eslint-disable-next-line no-param-reassign\n          schemaPart = inner;\n        } else {\n          break;\n        }\n      }\n    }\n\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n\n    let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? \".\" : \"\"}`;\n\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n\n    return schemaText;\n  }\n  /**\n   * @param {Schema=} schemaPart\n   * @returns {string}\n   */\n\n\n  getSchemaPartDescription(schemaPart) {\n    if (!schemaPart) {\n      return \"\";\n    }\n\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n\n    let schemaText = \"\";\n\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n\n    return schemaText;\n  }\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {string}\n   */\n\n\n  formatValidationError(error) {\n    const {\n      keyword,\n      dataPath: errorDataPath\n    } = error;\n    const dataPath = `${this.baseDataPath}${errorDataPath}`;\n\n    switch (keyword) {\n      case \"type\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error; // eslint-disable-next-line default-case\n\n          switch (\n          /** @type {import(\"ajv\").TypeParams} */\n          params.type) {\n            case \"number\":\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case \"integer\":\n              return `${dataPath} should be an ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case \"string\":\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case \"boolean\":\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case \"array\":\n              return `${dataPath} should be an array:\\n${this.getSchemaPartText(parentSchema)}`;\n\n            case \"object\":\n              return `${dataPath} should be an object:\\n${this.getSchemaPartText(parentSchema)}`;\n\n            case \"null\":\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            default:\n              return `${dataPath} should be:\\n${this.getSchemaPartText(parentSchema)}`;\n          }\n        }\n\n      case \"instanceof\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should be an instance of ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n\n      case \"pattern\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            pattern\n          } =\n          /** @type {import(\"ajv\").PatternParams} */\n          params;\n          return `${dataPath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"format\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            format\n          } =\n          /** @type {import(\"ajv\").FormatParams} */\n          params;\n          return `${dataPath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"formatMinimum\":\n      case \"formatMaximum\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            comparison,\n            limit\n          } =\n          /** @type {import(\"ajv\").ComparisonParams} */\n          params;\n          return `${dataPath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"minimum\":\n      case \"maximum\":\n      case \"exclusiveMinimum\":\n      case \"exclusiveMaximum\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const {\n            comparison,\n            limit\n          } =\n          /** @type {import(\"ajv\").ComparisonParams} */\n          params;\n          const [, ...hints] = getHints(\n          /** @type {Schema} */\n          parentSchema, true);\n\n          if (hints.length === 0) {\n            hints.push(`should be ${comparison} ${limit}`);\n          }\n\n          return `${dataPath} ${hints.join(\" \")}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"multipleOf\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            multipleOf\n          } =\n          /** @type {import(\"ajv\").MultipleOfParams} */\n          params;\n          return `${dataPath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"patternRequired\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            missingPattern\n          } =\n          /** @type {import(\"ajv\").PatternRequiredParams} */\n          params;\n          return `${dataPath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"minLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be a non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          const length = limit - 1;\n          return `${dataPath} should be longer than ${length} character${length > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"minItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be a non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          return `${dataPath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"minProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be a non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          return `${dataPath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"maxLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          const max = limit + 1;\n          return `${dataPath} should be shorter than ${max} character${max > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"maxItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"maxProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"uniqueItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            i\n          } =\n          /** @type {import(\"ajv\").UniqueItemsParams} */\n          params;\n          return `${dataPath} should not contain the item '${error.data[i]}' twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"additionalItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case \"contains\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should contains at least one ${this.getSchemaPartText(parentSchema, [\"contains\"])} item${getSchemaNonTypes(parentSchema)}.`;\n        }\n\n      case \"required\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const missingProperty =\n          /** @type {import(\"ajv\").DependenciesParams} */\n          params.missingProperty.replace(/^\\./, \"\");\n          const hasProperty = parentSchema && Boolean(\n          /** @type {Schema} */\n          parentSchema.properties &&\n          /** @type {Schema} */\n          parentSchema.properties[missingProperty]);\n          return `${dataPath} misses the property '${missingProperty}'${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\\n${this.getSchemaPartText(parentSchema, [\"properties\", missingProperty])}` : this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"additionalProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            additionalProperty\n          } =\n          /** @type {import(\"ajv\").AdditionalPropertiesParams} */\n          params;\n          return `${dataPath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(parentSchema)}. These properties are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case \"dependencies\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            property,\n            deps\n          } =\n          /** @type {import(\"ajv\").DependenciesParams} */\n          params;\n          const dependencies = deps.split(\",\").map(\n          /**\n           * @param {string} dep\n           * @returns {string}\n           */\n          dep => `'${dep.trim()}'`).join(\", \");\n          return `${dataPath} should have properties ${dependencies} when property '${property}' is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"propertyNames\":\n        {\n          const {\n            params,\n            parentSchema,\n            schema\n          } = error;\n          const {\n            propertyName\n          } =\n          /** @type {import(\"ajv\").PropertyNamesParams} */\n          params;\n          return `${dataPath} property name '${propertyName}' is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"enum\":\n        {\n          const {\n            parentSchema\n          } = error;\n\n          if (parentSchema &&\n          /** @type {Schema} */\n          parentSchema.enum &&\n          /** @type {Schema} */\n          parentSchema.enum.length === 1) {\n            return `${dataPath} should be ${this.getSchemaPartText(parentSchema, false, true)}`;\n          }\n\n          return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case \"const\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should be equal to constant ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n\n      case \"not\":\n        {\n          const postfix = likeObject(\n          /** @type {Schema} */\n          error.parentSchema) ? `\\n${this.getSchemaPartText(error.parentSchema)}` : \"\";\n          const schemaOutput = this.getSchemaPartText(error.schema, false, false, false);\n\n          if (canApplyNot(error.schema)) {\n            return `${dataPath} should be any ${schemaOutput}${postfix}.`;\n          }\n\n          const {\n            schema,\n            parentSchema\n          } = error;\n          return `${dataPath} should not be ${this.getSchemaPartText(schema, false, true)}${parentSchema && likeObject(parentSchema) ? `\\n${this.getSchemaPartText(parentSchema)}` : \"\"}`;\n        }\n\n      case \"oneOf\":\n      case \"anyOf\":\n        {\n          const {\n            parentSchema,\n            children\n          } = error;\n\n          if (children && children.length > 0) {\n            if (error.schema.length === 1) {\n              const lastChild = children[children.length - 1];\n              const remainingChildren = children.slice(0, children.length - 1);\n              return this.formatValidationError(Object.assign({}, lastChild, {\n                children: remainingChildren,\n                parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)\n              }));\n            }\n\n            let filteredChildren = filterChildren(children);\n\n            if (filteredChildren.length === 1) {\n              return this.formatValidationError(filteredChildren[0]);\n            }\n\n            filteredChildren = groupChildrenByFirstChild(filteredChildren);\n            return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}\\nDetails:\\n${filteredChildren.map(\n            /**\n             * @param {SchemaUtilErrorObject} nestedError\n             * @returns {string}\n             */\n            nestedError => ` * ${indent(this.formatValidationError(nestedError), \"   \")}`).join(\"\\n\")}`;\n          }\n\n          return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case \"if\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            failingKeyword\n          } =\n          /** @type {import(\"ajv\").IfParams} */\n          params;\n          return `${dataPath} should match \"${failingKeyword}\" schema:\\n${this.getSchemaPartText(parentSchema, [failingKeyword])}`;\n        }\n\n      case \"absolutePath\":\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          return `${dataPath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      /* istanbul ignore next */\n\n      default:\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          const ErrorInJSON = JSON.stringify(error, null, 2); // For `custom`, `false schema`, `$ref` keywords\n          // Fallback for unknown keywords\n\n          return `${dataPath} ${message} (${ErrorInJSON}).\\n${this.getSchemaPartText(parentSchema, false)}`;\n        }\n    }\n  }\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @returns {string}\n   */\n\n\n  formatValidationErrors(errors) {\n    return errors.map(error => {\n      let formattedError = this.formatValidationError(error);\n\n      if (this.postFormatter) {\n        formattedError = this.postFormatter(formattedError, error);\n      }\n\n      return ` - ${indent(formattedError, \"   \")}`;\n    }).join(\"\\n\");\n  }\n\n}\n\nvar _default = ValidationError;\nexports.default = _default;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","stringHints","numberHints","require","SPECIFICITY","type","not","oneOf","anyOf","if","enum","const","instanceof","required","pattern","patternRequired","format","formatMinimum","formatMaximum","minimum","exclusiveMinimum","maximum","exclusiveMaximum","multipleOf","uniqueItems","contains","minLength","maxLength","minItems","maxItems","minProperties","maxProperties","dependencies","propertyNames","additionalItems","additionalProperties","absolutePath","filterMax","array","fn","evaluatedMax","reduce","max","item","Math","filter","filterChildren","children","newChildren","error","dataPath","length","keyword","findAllChildren","schemaPaths","i","predicate","schemaPath","indexOf","every","refs","extractRefs","childrenStart","slice","concat","schema","Array","isArray","map","$ref","s","groupChildrenByFirstChild","result","child","push","assign","reverse","indent","str","prefix","replace","hasNotInSchema","findFirstTypedSchema","canApplyNot","typedSchema","likeNumber","likeInteger","likeString","likeNull","likeBoolean","isObject","maybeObj","likeArray","items","likeObject","properties","patternProperties","getArticle","test","getSchemaNonTypes","formatHints","hints","join","getHints","logic","ValidationError","Error","constructor","errors","configuration","name","headerNameFromSchema","baseDataPathFromSchema","title","baseDataPath","splittedTitleFromSchema","match","headerName","postFormatter","header","message","formatValidationErrors","captureStackTrace","getSchemaPart","path","newPath","split","schemaPart","inner","formatSchema","prevSchemas","newLogic","formatInnerSchema","innerSchema","addSelf","includes","needApplyLogicHere","values","JSON","stringify","allOf","ifValue","then","thenValue","else","elseValue","hasAdditionalItems","Boolean","keys","allProperties","Set","objectStructure","property","isRequired","forEach","dependencyName","dependency","dep","getSchemaPartText","additionalPath","needDot","schemaText","description","link","getSchemaPartDescription","formatValidationError","errorDataPath","parentSchema","params","comparison","limit","missingPattern","data","missingProperty","hasProperty","additionalProperty","deps","trim","propertyName","postfix","schemaOutput","lastChild","remainingChildren","filteredChildren","nestedError","failingKeyword","ErrorInJSON","formattedError","_default"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/schema-utils/dist/ValidationError.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nconst {\n  stringHints,\n  numberHints\n} = require(\"./util/hints\");\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n\n/** @typedef {import(\"./validate\").Schema} Schema */\n\n/** @typedef {import(\"./validate\").ValidationErrorConfiguration} ValidationErrorConfiguration */\n\n/** @typedef {import(\"./validate\").PostFormatter} PostFormatter */\n\n/** @typedef {import(\"./validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n\n/** @enum {number} */\n\n\nconst SPECIFICITY = {\n  type: 1,\n  not: 1,\n  oneOf: 1,\n  anyOf: 1,\n  if: 1,\n  enum: 1,\n  const: 1,\n  instanceof: 1,\n  required: 2,\n  pattern: 2,\n  patternRequired: 2,\n  format: 2,\n  formatMinimum: 2,\n  formatMaximum: 2,\n  minimum: 2,\n  exclusiveMinimum: 2,\n  maximum: 2,\n  exclusiveMaximum: 2,\n  multipleOf: 2,\n  uniqueItems: 2,\n  contains: 2,\n  minLength: 2,\n  maxLength: 2,\n  minItems: 2,\n  maxItems: 2,\n  minProperties: 2,\n  maxProperties: 2,\n  dependencies: 2,\n  propertyNames: 2,\n  additionalItems: 2,\n  additionalProperties: 2,\n  absolutePath: 2\n};\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} array\n * @param {(item: SchemaUtilErrorObject) => number} fn\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\nfunction filterMax(array, fn) {\n  const evaluatedMax = array.reduce((max, item) => Math.max(max, fn(item)), 0);\n  return array.filter(item => fn(item) === evaluatedMax);\n}\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} children\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction filterChildren(children) {\n  let newChildren = children;\n  newChildren = filterMax(newChildren,\n  /**\n   *\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => error.dataPath ? error.dataPath.length : 0);\n  newChildren = filterMax(newChildren,\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => SPECIFICITY[\n  /** @type {keyof typeof SPECIFICITY} */\n  error.keyword] || 2);\n  return newChildren;\n}\n/**\n * Find all children errors\n * @param {Array<SchemaUtilErrorObject>} children\n * @param {Array<string>} schemaPaths\n * @return {number} returns index of first child\n */\n\n\nfunction findAllChildren(children, schemaPaths) {\n  let i = children.length - 1;\n\n  const predicate =\n  /**\n   * @param {string} schemaPath\n   * @returns {boolean}\n   */\n  schemaPath => children[i].schemaPath.indexOf(schemaPath) !== 0;\n\n  while (i > -1 && !schemaPaths.every(predicate)) {\n    if (children[i].keyword === \"anyOf\" || children[i].keyword === \"oneOf\") {\n      const refs = extractRefs(children[i]);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));\n      i = childrenStart - 1;\n    } else {\n      i -= 1;\n    }\n  }\n\n  return i + 1;\n}\n/**\n * Extracts all refs from schema\n * @param {SchemaUtilErrorObject} error\n * @return {Array<string>}\n */\n\n\nfunction extractRefs(error) {\n  const {\n    schema\n  } = error;\n\n  if (!Array.isArray(schema)) {\n    return [];\n  }\n\n  return schema.map(({\n    $ref\n  }) => $ref).filter(s => s);\n}\n/**\n * Groups children by their first level parent (assuming that error is root)\n * @param {Array<SchemaUtilErrorObject>} children\n * @return {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction groupChildrenByFirstChild(children) {\n  const result = [];\n  let i = children.length - 1;\n\n  while (i > 0) {\n    const child = children[i];\n\n    if (child.keyword === \"anyOf\" || child.keyword === \"oneOf\") {\n      const refs = extractRefs(child);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));\n\n      if (childrenStart !== i) {\n        result.push(Object.assign({}, child, {\n          children: children.slice(childrenStart, i)\n        }));\n        i = childrenStart;\n      } else {\n        result.push(child);\n      }\n    } else {\n      result.push(child);\n    }\n\n    i -= 1;\n  }\n\n  if (i === 0) {\n    result.push(children[i]);\n  }\n\n  return result.reverse();\n}\n/**\n * @param {string} str\n * @param {string} prefix\n * @returns {string}\n */\n\n\nfunction indent(str, prefix) {\n  return str.replace(/\\n(?!$)/g, `\\n${prefix}`);\n}\n/**\n * @param {Schema} schema\n * @returns {schema is (Schema & {not: Schema})}\n */\n\n\nfunction hasNotInSchema(schema) {\n  return !!schema.not;\n}\n/**\n * @param {Schema} schema\n * @return {Schema}\n */\n\n\nfunction findFirstTypedSchema(schema) {\n  if (hasNotInSchema(schema)) {\n    return findFirstTypedSchema(schema.not);\n  }\n\n  return schema;\n}\n/**\n * @param {Schema} schema\n * @return {boolean}\n */\n\n\nfunction canApplyNot(schema) {\n  const typedSchema = findFirstTypedSchema(schema);\n  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);\n}\n/**\n * @param {any} maybeObj\n * @returns {boolean}\n */\n\n\nfunction isObject(maybeObj) {\n  return typeof maybeObj === \"object\" && maybeObj !== null;\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNumber(schema) {\n  return schema.type === \"number\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeInteger(schema) {\n  return schema.type === \"integer\" || typeof schema.minimum !== \"undefined\" || typeof schema.exclusiveMinimum !== \"undefined\" || typeof schema.maximum !== \"undefined\" || typeof schema.exclusiveMaximum !== \"undefined\" || typeof schema.multipleOf !== \"undefined\";\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeString(schema) {\n  return schema.type === \"string\" || typeof schema.minLength !== \"undefined\" || typeof schema.maxLength !== \"undefined\" || typeof schema.pattern !== \"undefined\" || typeof schema.format !== \"undefined\" || typeof schema.formatMinimum !== \"undefined\" || typeof schema.formatMaximum !== \"undefined\";\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeBoolean(schema) {\n  return schema.type === \"boolean\";\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeArray(schema) {\n  return schema.type === \"array\" || typeof schema.minItems === \"number\" || typeof schema.maxItems === \"number\" || typeof schema.uniqueItems !== \"undefined\" || typeof schema.items !== \"undefined\" || typeof schema.additionalItems !== \"undefined\" || typeof schema.contains !== \"undefined\";\n}\n/**\n * @param {Schema & {patternRequired?: Array<string>}} schema\n * @returns {boolean}\n */\n\n\nfunction likeObject(schema) {\n  return schema.type === \"object\" || typeof schema.minProperties !== \"undefined\" || typeof schema.maxProperties !== \"undefined\" || typeof schema.required !== \"undefined\" || typeof schema.properties !== \"undefined\" || typeof schema.patternProperties !== \"undefined\" || typeof schema.additionalProperties !== \"undefined\" || typeof schema.dependencies !== \"undefined\" || typeof schema.propertyNames !== \"undefined\" || typeof schema.patternRequired !== \"undefined\";\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNull(schema) {\n  return schema.type === \"null\";\n}\n/**\n * @param {string} type\n * @returns {string}\n */\n\n\nfunction getArticle(type) {\n  if (/^[aeiou]/i.test(type)) {\n    return \"an\";\n  }\n\n  return \"a\";\n}\n/**\n * @param {Schema=} schema\n * @returns {string}\n */\n\n\nfunction getSchemaNonTypes(schema) {\n  if (!schema) {\n    return \"\";\n  }\n\n  if (!schema.type) {\n    if (likeNumber(schema) || likeInteger(schema)) {\n      return \" | should be any non-number\";\n    }\n\n    if (likeString(schema)) {\n      return \" | should be any non-string\";\n    }\n\n    if (likeArray(schema)) {\n      return \" | should be any non-array\";\n    }\n\n    if (likeObject(schema)) {\n      return \" | should be any non-object\";\n    }\n  }\n\n  return \"\";\n}\n/**\n * @param {Array<string>} hints\n * @returns {string}\n */\n\n\nfunction formatHints(hints) {\n  return hints.length > 0 ? `(${hints.join(\", \")})` : \"\";\n}\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @returns {string[]}\n */\n\n\nfunction getHints(schema, logic) {\n  if (likeNumber(schema) || likeInteger(schema)) {\n    return numberHints(schema, logic);\n  } else if (likeString(schema)) {\n    return stringHints(schema, logic);\n  }\n\n  return [];\n}\n\nclass ValidationError extends Error {\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @param {Schema} schema\n   * @param {ValidationErrorConfiguration} configuration\n   */\n  constructor(errors, schema, configuration = {}) {\n    super();\n    /** @type {string} */\n\n    this.name = \"ValidationError\";\n    /** @type {Array<SchemaUtilErrorObject>} */\n\n    this.errors = errors;\n    /** @type {Schema} */\n\n    this.schema = schema;\n    let headerNameFromSchema;\n    let baseDataPathFromSchema;\n\n    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {\n      const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);\n\n      if (splittedTitleFromSchema) {\n        if (!configuration.name) {\n          [, headerNameFromSchema] = splittedTitleFromSchema;\n        }\n\n        if (!configuration.baseDataPath) {\n          [,, baseDataPathFromSchema] = splittedTitleFromSchema;\n        }\n      }\n    }\n    /** @type {string} */\n\n\n    this.headerName = configuration.name || headerNameFromSchema || \"Object\";\n    /** @type {string} */\n\n    this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || \"configuration\";\n    /** @type {PostFormatter | null} */\n\n    this.postFormatter = configuration.postFormatter || null;\n    const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${getArticle(this.baseDataPath)} ${this.baseDataPath} object that does not match the API schema.\\n`;\n    /** @type {string} */\n\n    this.message = `${header}${this.formatValidationErrors(errors)}`;\n    Error.captureStackTrace(this, this.constructor);\n  }\n  /**\n   * @param {string} path\n   * @returns {Schema}\n   */\n\n\n  getSchemaPart(path) {\n    const newPath = path.split(\"/\");\n    let schemaPart = this.schema;\n\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[\n      /** @type {keyof Schema} */\n      newPath[i]];\n\n      if (!inner) {\n        break;\n      }\n\n      schemaPart = inner;\n    }\n\n    return schemaPart;\n  }\n  /**\n   * @param {Schema} schema\n   * @param {boolean} logic\n   * @param {Array<Object>} prevSchemas\n   * @returns {string}\n   */\n\n\n  formatSchema(schema, logic = true, prevSchemas = []) {\n    let newLogic = logic;\n\n    const formatInnerSchema =\n    /**\n     *\n     * @param {Object} innerSchema\n     * @param {boolean=} addSelf\n     * @returns {string}\n     */\n    (innerSchema, addSelf) => {\n      if (!addSelf) {\n        return this.formatSchema(innerSchema, newLogic, prevSchemas);\n      }\n\n      if (prevSchemas.includes(innerSchema)) {\n        return \"(recursive)\";\n      }\n\n      return this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));\n    };\n\n    if (hasNotInSchema(schema) && !likeObject(schema)) {\n      if (canApplyNot(schema.not)) {\n        newLogic = !logic;\n        return formatInnerSchema(schema.not);\n      }\n\n      const needApplyLogicHere = !schema.not.not;\n      const prefix = logic ? \"\" : \"non \";\n      newLogic = !logic;\n      return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);\n    }\n\n    if (\n    /** @type {Schema & {instanceof: string | Array<string>}} */\n    schema.instanceof) {\n      const {\n        instanceof: value\n      } =\n      /** @type {Schema & {instanceof: string | Array<string>}} */\n      schema;\n      const values = !Array.isArray(value) ? [value] : value;\n      return values.map(\n      /**\n       * @param {string} item\n       * @returns {string}\n       */\n      item => item === \"Function\" ? \"function\" : item).join(\" | \");\n    }\n\n    if (schema.enum) {\n      return (\n        /** @type {Array<any>} */\n        schema.enum.map(item => JSON.stringify(item)).join(\" | \")\n      );\n    }\n\n    if (typeof schema.const !== \"undefined\") {\n      return JSON.stringify(schema.const);\n    }\n\n    if (schema.oneOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.oneOf.map(item => formatInnerSchema(item, true)).join(\" | \")\n      );\n    }\n\n    if (schema.anyOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.anyOf.map(item => formatInnerSchema(item, true)).join(\" | \")\n      );\n    }\n\n    if (schema.allOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.allOf.map(item => formatInnerSchema(item, true)).join(\" & \")\n      );\n    }\n\n    if (\n    /** @type {JSONSchema7} */\n    schema.if) {\n      const {\n        if: ifValue,\n        then: thenValue,\n        else: elseValue\n      } =\n      /** @type {JSONSchema7} */\n      schema;\n      return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : \"\"}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : \"\"}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : \"\"}`;\n    }\n\n    if (schema.$ref) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true);\n    }\n\n    if (likeNumber(schema) || likeInteger(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;\n    }\n\n    if (likeString(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : \"\"}`;\n      return logic ? str : str === \"string\" ? \"non-string\" : `non-string | ${str}`;\n    }\n\n    if (likeBoolean(schema)) {\n      return `${logic ? \"\" : \"non-\"}boolean`;\n    }\n\n    if (likeArray(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n\n      if (typeof schema.minItems === \"number\") {\n        hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? \"s\" : \"\"}`);\n      }\n\n      if (typeof schema.maxItems === \"number\") {\n        hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? \"s\" : \"\"}`);\n      }\n\n      if (schema.uniqueItems) {\n        hints.push(\"should not have duplicate items\");\n      }\n\n      const hasAdditionalItems = typeof schema.additionalItems === \"undefined\" || Boolean(schema.additionalItems);\n      let items = \"\";\n\n      if (schema.items) {\n        if (Array.isArray(schema.items) && schema.items.length > 0) {\n          items = `${\n          /** @type {Array<Schema>} */\n          schema.items.map(item => formatInnerSchema(item)).join(\", \")}`;\n\n          if (hasAdditionalItems) {\n            if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {\n              hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);\n            }\n          }\n        } else if (schema.items && Object.keys(schema.items).length > 0) {\n          // \"additionalItems\" is ignored\n          items = `${formatInnerSchema(schema.items)}`;\n        } else {\n          // Fallback for empty `items` value\n          items = \"any\";\n        }\n      } else {\n        // \"additionalItems\" is ignored\n        items = \"any\";\n      }\n\n      if (schema.contains && Object.keys(schema.contains).length > 0) {\n        hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);\n      }\n\n      return `[${items}${hasAdditionalItems ? \", ...\" : \"\"}]${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n\n    if (likeObject(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n\n      if (typeof schema.minProperties === \"number\") {\n        hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n\n      if (typeof schema.maxProperties === \"number\") {\n        hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? \"properties\" : \"property\"}`);\n      }\n\n      if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {\n        const patternProperties = Object.keys(schema.patternProperties);\n        hints.push(`additional property names should match pattern${patternProperties.length > 1 ? \"s\" : \"\"} ${patternProperties.map(pattern => JSON.stringify(pattern)).join(\" | \")}`);\n      }\n\n      const properties = schema.properties ? Object.keys(schema.properties) : [];\n      const required = schema.required ? schema.required : [];\n      const allProperties = [...new Set(\n      /** @type {Array<string>} */\n      [].concat(required).concat(properties))];\n      const objectStructure = allProperties.map(property => {\n        const isRequired = required.includes(property); // Some properties need quotes, maybe we should add check\n        // Maybe we should output type of property (`foo: string`), but it is looks very unreadable\n\n        return `${property}${isRequired ? \"\" : \"?\"}`;\n      }).concat(typeof schema.additionalProperties === \"undefined\" || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [`<key>: ${formatInnerSchema(schema.additionalProperties)}`] : [\"…\"] : []).join(\", \");\n      const {\n        dependencies,\n        propertyNames,\n        patternRequired\n      } =\n      /** @type {Schema & {patternRequired?: Array<string>;}} */\n      schema;\n\n      if (dependencies) {\n        Object.keys(dependencies).forEach(dependencyName => {\n          const dependency = dependencies[dependencyName];\n\n          if (Array.isArray(dependency)) {\n            hints.push(`should have ${dependency.length > 1 ? \"properties\" : \"property\"} ${dependency.map(dep => `'${dep}'`).join(\", \")} when property '${dependencyName}' is present`);\n          } else {\n            hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);\n          }\n        });\n      }\n\n      if (propertyNames && Object.keys(propertyNames).length > 0) {\n        hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);\n      }\n\n      if (patternRequired && patternRequired.length > 0) {\n        hints.push(`should have property matching pattern ${patternRequired.map(\n        /**\n         * @param {string} item\n         * @returns {string}\n         */\n        item => JSON.stringify(item))}`);\n      }\n\n      return `object {${objectStructure ? ` ${objectStructure} ` : \"\"}}${hints.length > 0 ? ` (${hints.join(\", \")})` : \"\"}`;\n    }\n\n    if (likeNull(schema)) {\n      return `${logic ? \"\" : \"non-\"}null`;\n    }\n\n    if (Array.isArray(schema.type)) {\n      // not logic already applied in formatValidationError\n      return `${schema.type.join(\" | \")}`;\n    } // Fallback for unknown keywords\n    // not logic already applied in formatValidationError\n\n    /* istanbul ignore next */\n\n\n    return JSON.stringify(schema, null, 2);\n  }\n  /**\n   * @param {Schema=} schemaPart\n   * @param {(boolean | Array<string>)=} additionalPath\n   * @param {boolean=} needDot\n   * @param {boolean=} logic\n   * @returns {string}\n   */\n\n\n  getSchemaPartText(schemaPart, additionalPath, needDot = false, logic = true) {\n    if (!schemaPart) {\n      return \"\";\n    }\n\n    if (Array.isArray(additionalPath)) {\n      for (let i = 0; i < additionalPath.length; i++) {\n        /** @type {Schema | undefined} */\n        const inner = schemaPart[\n        /** @type {keyof Schema} */\n        additionalPath[i]];\n\n        if (inner) {\n          // eslint-disable-next-line no-param-reassign\n          schemaPart = inner;\n        } else {\n          break;\n        }\n      }\n    }\n\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n\n    let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? \".\" : \"\"}`;\n\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n\n    return schemaText;\n  }\n  /**\n   * @param {Schema=} schemaPart\n   * @returns {string}\n   */\n\n\n  getSchemaPartDescription(schemaPart) {\n    if (!schemaPart) {\n      return \"\";\n    }\n\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n\n    let schemaText = \"\";\n\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n\n    if (schemaPart.link) {\n      schemaText += `\\n-> Read more at ${schemaPart.link}`;\n    }\n\n    return schemaText;\n  }\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {string}\n   */\n\n\n  formatValidationError(error) {\n    const {\n      keyword,\n      dataPath: errorDataPath\n    } = error;\n    const dataPath = `${this.baseDataPath}${errorDataPath}`;\n\n    switch (keyword) {\n      case \"type\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error; // eslint-disable-next-line default-case\n\n          switch (\n          /** @type {import(\"ajv\").TypeParams} */\n          params.type) {\n            case \"number\":\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case \"integer\":\n              return `${dataPath} should be an ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case \"string\":\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case \"boolean\":\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case \"array\":\n              return `${dataPath} should be an array:\\n${this.getSchemaPartText(parentSchema)}`;\n\n            case \"object\":\n              return `${dataPath} should be an object:\\n${this.getSchemaPartText(parentSchema)}`;\n\n            case \"null\":\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            default:\n              return `${dataPath} should be:\\n${this.getSchemaPartText(parentSchema)}`;\n          }\n        }\n\n      case \"instanceof\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should be an instance of ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n\n      case \"pattern\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            pattern\n          } =\n          /** @type {import(\"ajv\").PatternParams} */\n          params;\n          return `${dataPath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"format\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            format\n          } =\n          /** @type {import(\"ajv\").FormatParams} */\n          params;\n          return `${dataPath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"formatMinimum\":\n      case \"formatMaximum\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            comparison,\n            limit\n          } =\n          /** @type {import(\"ajv\").ComparisonParams} */\n          params;\n          return `${dataPath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"minimum\":\n      case \"maximum\":\n      case \"exclusiveMinimum\":\n      case \"exclusiveMaximum\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const {\n            comparison,\n            limit\n          } =\n          /** @type {import(\"ajv\").ComparisonParams} */\n          params;\n          const [, ...hints] = getHints(\n          /** @type {Schema} */\n          parentSchema, true);\n\n          if (hints.length === 0) {\n            hints.push(`should be ${comparison} ${limit}`);\n          }\n\n          return `${dataPath} ${hints.join(\" \")}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"multipleOf\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            multipleOf\n          } =\n          /** @type {import(\"ajv\").MultipleOfParams} */\n          params;\n          return `${dataPath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"patternRequired\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            missingPattern\n          } =\n          /** @type {import(\"ajv\").PatternRequiredParams} */\n          params;\n          return `${dataPath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"minLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be a non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          const length = limit - 1;\n          return `${dataPath} should be longer than ${length} character${length > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"minItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be a non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          return `${dataPath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"minProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be a non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          return `${dataPath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"maxLength\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          const max = limit + 1;\n          return `${dataPath} should be shorter than ${max} character${max > 1 ? \"s\" : \"\"}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"maxItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"maxProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"uniqueItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            i\n          } =\n          /** @type {import(\"ajv\").UniqueItemsParams} */\n          params;\n          return `${dataPath} should not contain the item '${error.data[i]}' twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"additionalItems\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case \"contains\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should contains at least one ${this.getSchemaPartText(parentSchema, [\"contains\"])} item${getSchemaNonTypes(parentSchema)}.`;\n        }\n\n      case \"required\":\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const missingProperty =\n          /** @type {import(\"ajv\").DependenciesParams} */\n          params.missingProperty.replace(/^\\./, \"\");\n          const hasProperty = parentSchema && Boolean(\n          /** @type {Schema} */\n          parentSchema.properties &&\n          /** @type {Schema} */\n          parentSchema.properties[missingProperty]);\n          return `${dataPath} misses the property '${missingProperty}'${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\\n${this.getSchemaPartText(parentSchema, [\"properties\", missingProperty])}` : this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"additionalProperties\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            additionalProperty\n          } =\n          /** @type {import(\"ajv\").AdditionalPropertiesParams} */\n          params;\n          return `${dataPath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(parentSchema)}. These properties are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case \"dependencies\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            property,\n            deps\n          } =\n          /** @type {import(\"ajv\").DependenciesParams} */\n          params;\n          const dependencies = deps.split(\",\").map(\n          /**\n           * @param {string} dep\n           * @returns {string}\n           */\n          dep => `'${dep.trim()}'`).join(\", \");\n          return `${dataPath} should have properties ${dependencies} when property '${property}' is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"propertyNames\":\n        {\n          const {\n            params,\n            parentSchema,\n            schema\n          } = error;\n          const {\n            propertyName\n          } =\n          /** @type {import(\"ajv\").PropertyNamesParams} */\n          params;\n          return `${dataPath} property name '${propertyName}' is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case \"enum\":\n        {\n          const {\n            parentSchema\n          } = error;\n\n          if (parentSchema &&\n          /** @type {Schema} */\n          parentSchema.enum &&\n          /** @type {Schema} */\n          parentSchema.enum.length === 1) {\n            return `${dataPath} should be ${this.getSchemaPartText(parentSchema, false, true)}`;\n          }\n\n          return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case \"const\":\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should be equal to constant ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n\n      case \"not\":\n        {\n          const postfix = likeObject(\n          /** @type {Schema} */\n          error.parentSchema) ? `\\n${this.getSchemaPartText(error.parentSchema)}` : \"\";\n          const schemaOutput = this.getSchemaPartText(error.schema, false, false, false);\n\n          if (canApplyNot(error.schema)) {\n            return `${dataPath} should be any ${schemaOutput}${postfix}.`;\n          }\n\n          const {\n            schema,\n            parentSchema\n          } = error;\n          return `${dataPath} should not be ${this.getSchemaPartText(schema, false, true)}${parentSchema && likeObject(parentSchema) ? `\\n${this.getSchemaPartText(parentSchema)}` : \"\"}`;\n        }\n\n      case \"oneOf\":\n      case \"anyOf\":\n        {\n          const {\n            parentSchema,\n            children\n          } = error;\n\n          if (children && children.length > 0) {\n            if (error.schema.length === 1) {\n              const lastChild = children[children.length - 1];\n              const remainingChildren = children.slice(0, children.length - 1);\n              return this.formatValidationError(Object.assign({}, lastChild, {\n                children: remainingChildren,\n                parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)\n              }));\n            }\n\n            let filteredChildren = filterChildren(children);\n\n            if (filteredChildren.length === 1) {\n              return this.formatValidationError(filteredChildren[0]);\n            }\n\n            filteredChildren = groupChildrenByFirstChild(filteredChildren);\n            return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}\\nDetails:\\n${filteredChildren.map(\n            /**\n             * @param {SchemaUtilErrorObject} nestedError\n             * @returns {string}\n             */\n            nestedError => ` * ${indent(this.formatValidationError(nestedError), \"   \")}`).join(\"\\n\")}`;\n          }\n\n          return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case \"if\":\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            failingKeyword\n          } =\n          /** @type {import(\"ajv\").IfParams} */\n          params;\n          return `${dataPath} should match \"${failingKeyword}\" schema:\\n${this.getSchemaPartText(parentSchema, [failingKeyword])}`;\n        }\n\n      case \"absolutePath\":\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          return `${dataPath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      /* istanbul ignore next */\n\n      default:\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          const ErrorInJSON = JSON.stringify(error, null, 2); // For `custom`, `false schema`, `$ref` keywords\n          // Fallback for unknown keywords\n\n          return `${dataPath} ${message} (${ErrorInJSON}).\\n${this.getSchemaPartText(parentSchema, false)}`;\n        }\n    }\n  }\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @returns {string}\n   */\n\n\n  formatValidationErrors(errors) {\n    return errors.map(error => {\n      let formattedError = this.formatValidationError(error);\n\n      if (this.postFormatter) {\n        formattedError = this.postFormatter(formattedError, error);\n      }\n\n      return ` - ${indent(formattedError, \"   \")}`;\n    }).join(\"\\n\");\n  }\n\n}\n\nvar _default = ValidationError;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}