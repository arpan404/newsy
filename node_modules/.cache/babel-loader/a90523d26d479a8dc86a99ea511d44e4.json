{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  forEachBail\n} = require(\"enhanced-resolve\");\n\nconst asyncLib = require(\"neo-async\");\n\nconst getLazyHashedEtag = require(\"./cache/getLazyHashedEtag\");\n\nconst mergeEtags = require(\"./cache/mergeEtags\");\n/** @typedef {import(\"./Cache\")} Cache */\n\n/** @typedef {import(\"./Cache\").Etag} Etag */\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/** @typedef {import(\"./cache/getLazyHashedEtag\").HashableObject} HashableObject */\n\n/** @typedef {typeof import(\"./util/Hash\")} HashConstructor */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @template T\n * @callback CallbackNormalErrorCache\n * @param {(Error | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n\nclass MultiItemCache {\n  /**\n   * @param {ItemCacheFacade[]} items item caches\n   */\n  constructor(items) {\n    this._items = items;\n    if (items.length === 1) return (\n      /** @type {any} */\n      items[0]\n    );\n  }\n  /**\n   * @template T\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  get(callback) {\n    forEachBail(this._items, (item, callback) => item.get(callback), callback);\n  }\n  /**\n   * @template T\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  getPromise() {\n    const next = i => {\n      return this._items[i].getPromise().then(result => {\n        if (result !== undefined) return result;\n        if (++i < this._items.length) return next(i);\n      });\n    };\n\n    return next(0);\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @param {CallbackCache<void>} callback signals when the value is stored\n   * @returns {void}\n   */\n\n\n  store(data, callback) {\n    asyncLib.each(this._items, (item, callback) => item.store(data, callback), callback);\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @returns {Promise<void>} promise signals when the value is stored\n   */\n\n\n  storePromise(data) {\n    return Promise.all(this._items.map(item => item.storePromise(data))).then(() => {});\n  }\n\n}\n\nclass ItemCacheFacade {\n  /**\n   * @param {Cache} cache the root cache\n   * @param {string} name the child cache item name\n   * @param {Etag | null} etag the etag\n   */\n  constructor(cache, name, etag) {\n    this._cache = cache;\n    this._name = name;\n    this._etag = etag;\n  }\n  /**\n   * @template T\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  get(callback) {\n    this._cache.get(this._name, this._etag, callback);\n  }\n  /**\n   * @template T\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  getPromise() {\n    return new Promise((resolve, reject) => {\n      this._cache.get(this._name, this._etag, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @param {CallbackCache<void>} callback signals when the value is stored\n   * @returns {void}\n   */\n\n\n  store(data, callback) {\n    this._cache.store(this._name, this._etag, data, callback);\n  }\n  /**\n   * @template T\n   * @param {T} data the value to store\n   * @returns {Promise<void>} promise signals when the value is stored\n   */\n\n\n  storePromise(data) {\n    return new Promise((resolve, reject) => {\n      this._cache.store(this._name, this._etag, data, err => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n   * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  provide(computer, callback) {\n    this.get((err, cacheEntry) => {\n      if (err) return callback(err);\n      if (cacheEntry !== undefined) return cacheEntry;\n      computer((err, result) => {\n        if (err) return callback(err);\n        this.store(result, err => {\n          if (err) return callback(err);\n          callback(null, result);\n        });\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  async providePromise(computer) {\n    const cacheEntry = await this.getPromise();\n    if (cacheEntry !== undefined) return cacheEntry;\n    const result = await computer();\n    await this.storePromise(result);\n    return result;\n  }\n\n}\n\nclass CacheFacade {\n  /**\n   * @param {Cache} cache the root cache\n   * @param {string} name the child cache name\n   * @param {string | HashConstructor} hashFunction the hash function to use\n   */\n  constructor(cache, name, hashFunction) {\n    this._cache = cache;\n    this._name = name;\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {string} name the child cache name#\n   * @returns {CacheFacade} child cache\n   */\n\n\n  getChildCache(name) {\n    return new CacheFacade(this._cache, `${this._name}|${name}`, this._hashFunction);\n  }\n  /**\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @returns {ItemCacheFacade} item cache\n   */\n\n\n  getItemCache(identifier, etag) {\n    return new ItemCacheFacade(this._cache, `${this._name}|${identifier}`, etag);\n  }\n  /**\n   * @param {HashableObject} obj an hashable object\n   * @returns {Etag} an etag that is lazy hashed\n   */\n\n\n  getLazyHashedEtag(obj) {\n    return getLazyHashedEtag(obj, this._hashFunction);\n  }\n  /**\n   * @param {Etag} a an etag\n   * @param {Etag} b another etag\n   * @returns {Etag} an etag that represents both\n   */\n\n\n  mergeEtags(a, b) {\n    return mergeEtags(a, b);\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {CallbackCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  get(identifier, etag, callback) {\n    this._cache.get(`${this._name}|${identifier}`, etag, callback);\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  getPromise(identifier, etag) {\n    return new Promise((resolve, reject) => {\n      this._cache.get(`${this._name}|${identifier}`, etag, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {T} data the value to store\n   * @param {CallbackCache<void>} callback signals when the value is stored\n   * @returns {void}\n   */\n\n\n  store(identifier, etag, data, callback) {\n    this._cache.store(`${this._name}|${identifier}`, etag, data, callback);\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {T} data the value to store\n   * @returns {Promise<void>} promise signals when the value is stored\n   */\n\n\n  storePromise(identifier, etag, data) {\n    return new Promise((resolve, reject) => {\n      this._cache.store(`${this._name}|${identifier}`, etag, data, err => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n   * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n   * @returns {void}\n   */\n\n\n  provide(identifier, etag, computer, callback) {\n    this.get(identifier, etag, (err, cacheEntry) => {\n      if (err) return callback(err);\n      if (cacheEntry !== undefined) return cacheEntry;\n      computer((err, result) => {\n        if (err) return callback(err);\n        this.store(identifier, etag, result, err => {\n          if (err) return callback(err);\n          callback(null, result);\n        });\n      });\n    });\n  }\n  /**\n   * @template T\n   * @param {string} identifier the cache identifier\n   * @param {Etag | null} etag the etag\n   * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n   * @returns {Promise<T>} promise with the data\n   */\n\n\n  async providePromise(identifier, etag, computer) {\n    const cacheEntry = await this.getPromise(identifier, etag);\n    if (cacheEntry !== undefined) return cacheEntry;\n    const result = await computer();\n    await this.storePromise(identifier, etag, result);\n    return result;\n  }\n\n}\n\nmodule.exports = CacheFacade;\nmodule.exports.ItemCacheFacade = ItemCacheFacade;\nmodule.exports.MultiItemCache = MultiItemCache;","map":{"version":3,"names":["forEachBail","require","asyncLib","getLazyHashedEtag","mergeEtags","MultiItemCache","constructor","items","_items","length","get","callback","item","getPromise","next","i","then","result","undefined","store","data","each","storePromise","Promise","all","map","ItemCacheFacade","cache","name","etag","_cache","_name","_etag","resolve","reject","err","provide","computer","cacheEntry","providePromise","CacheFacade","hashFunction","_hashFunction","getChildCache","getItemCache","identifier","obj","a","b","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/CacheFacade.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { forEachBail } = require(\"enhanced-resolve\");\nconst asyncLib = require(\"neo-async\");\nconst getLazyHashedEtag = require(\"./cache/getLazyHashedEtag\");\nconst mergeEtags = require(\"./cache/mergeEtags\");\n\n/** @typedef {import(\"./Cache\")} Cache */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./cache/getLazyHashedEtag\").HashableObject} HashableObject */\n/** @typedef {typeof import(\"./util/Hash\")} HashConstructor */\n\n/**\n * @template T\n * @callback CallbackCache\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\n/**\n * @template T\n * @callback CallbackNormalErrorCache\n * @param {(Error | null)=} err\n * @param {T=} result\n * @returns {void}\n */\n\nclass MultiItemCache {\n\t/**\n\t * @param {ItemCacheFacade[]} items item caches\n\t */\n\tconstructor(items) {\n\t\tthis._items = items;\n\t\tif (items.length === 1) return /** @type {any} */ (items[0]);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(callback) {\n\t\tforEachBail(this._items, (item, callback) => item.get(callback), callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise() {\n\t\tconst next = i => {\n\t\t\treturn this._items[i].getPromise().then(result => {\n\t\t\t\tif (result !== undefined) return result;\n\t\t\t\tif (++i < this._items.length) return next(i);\n\t\t\t});\n\t\t};\n\t\treturn next(0);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(data, callback) {\n\t\tasyncLib.each(\n\t\t\tthis._items,\n\t\t\t(item, callback) => item.store(data, callback),\n\t\t\tcallback\n\t\t);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(data) {\n\t\treturn Promise.all(this._items.map(item => item.storePromise(data))).then(\n\t\t\t() => {}\n\t\t);\n\t}\n}\n\nclass ItemCacheFacade {\n\t/**\n\t * @param {Cache} cache the root cache\n\t * @param {string} name the child cache item name\n\t * @param {Etag | null} etag the etag\n\t */\n\tconstructor(cache, name, etag) {\n\t\tthis._cache = cache;\n\t\tthis._name = name;\n\t\tthis._etag = etag;\n\t}\n\n\t/**\n\t * @template T\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(callback) {\n\t\tthis._cache.get(this._name, this._etag, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.get(this._name, this._etag, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(data, callback) {\n\t\tthis._cache.store(this._name, this._etag, data, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.store(this._name, this._etag, data, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n\t * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tprovide(computer, callback) {\n\t\tthis.get((err, cacheEntry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tcomputer((err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.store(result, err => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tasync providePromise(computer) {\n\t\tconst cacheEntry = await this.getPromise();\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst result = await computer();\n\t\tawait this.storePromise(result);\n\t\treturn result;\n\t}\n}\n\nclass CacheFacade {\n\t/**\n\t * @param {Cache} cache the root cache\n\t * @param {string} name the child cache name\n\t * @param {string | HashConstructor} hashFunction the hash function to use\n\t */\n\tconstructor(cache, name, hashFunction) {\n\t\tthis._cache = cache;\n\t\tthis._name = name;\n\t\tthis._hashFunction = hashFunction;\n\t}\n\n\t/**\n\t * @param {string} name the child cache name#\n\t * @returns {CacheFacade} child cache\n\t */\n\tgetChildCache(name) {\n\t\treturn new CacheFacade(\n\t\t\tthis._cache,\n\t\t\t`${this._name}|${name}`,\n\t\t\tthis._hashFunction\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @returns {ItemCacheFacade} item cache\n\t */\n\tgetItemCache(identifier, etag) {\n\t\treturn new ItemCacheFacade(\n\t\t\tthis._cache,\n\t\t\t`${this._name}|${identifier}`,\n\t\t\tetag\n\t\t);\n\t}\n\n\t/**\n\t * @param {HashableObject} obj an hashable object\n\t * @returns {Etag} an etag that is lazy hashed\n\t */\n\tgetLazyHashedEtag(obj) {\n\t\treturn getLazyHashedEtag(obj, this._hashFunction);\n\t}\n\n\t/**\n\t * @param {Etag} a an etag\n\t * @param {Etag} b another etag\n\t * @returns {Etag} an etag that represents both\n\t */\n\tmergeEtags(a, b) {\n\t\treturn mergeEtags(a, b);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {CallbackCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tget(identifier, etag, callback) {\n\t\tthis._cache.get(`${this._name}|${identifier}`, etag, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tgetPromise(identifier, etag) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.get(`${this._name}|${identifier}`, etag, (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(data);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @param {CallbackCache<void>} callback signals when the value is stored\n\t * @returns {void}\n\t */\n\tstore(identifier, etag, data, callback) {\n\t\tthis._cache.store(`${this._name}|${identifier}`, etag, data, callback);\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {T} data the value to store\n\t * @returns {Promise<void>} promise signals when the value is stored\n\t */\n\tstorePromise(identifier, etag, data) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis._cache.store(`${this._name}|${identifier}`, etag, data, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {function(CallbackNormalErrorCache<T>): void} computer function to compute the value if not cached\n\t * @param {CallbackNormalErrorCache<T>} callback signals when the value is retrieved\n\t * @returns {void}\n\t */\n\tprovide(identifier, etag, computer, callback) {\n\t\tthis.get(identifier, etag, (err, cacheEntry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tcomputer((err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.store(identifier, etag, result, err => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @template T\n\t * @param {string} identifier the cache identifier\n\t * @param {Etag | null} etag the etag\n\t * @param {function(): Promise<T> | T} computer function to compute the value if not cached\n\t * @returns {Promise<T>} promise with the data\n\t */\n\tasync providePromise(identifier, etag, computer) {\n\t\tconst cacheEntry = await this.getPromise(identifier, etag);\n\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\tconst result = await computer();\n\t\tawait this.storePromise(identifier, etag, result);\n\t\treturn result;\n\t}\n}\n\nmodule.exports = CacheFacade;\nmodule.exports.ItemCacheFacade = ItemCacheFacade;\nmodule.exports.MultiItemCache = MultiItemCache;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}