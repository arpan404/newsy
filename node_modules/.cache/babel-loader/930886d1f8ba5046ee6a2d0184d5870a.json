{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst fs = require(\"graceful-fs\");\n\nconst path = require(\"path\");\n\nconst watchEventSource = require(\"./watchEventSource\");\n\nconst EXISTANCE_ONLY_TIME_ENTRY = Object.freeze({});\nlet FS_ACCURACY = 2000;\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst WATCHPACK_POLLING = process.env.WATCHPACK_POLLING;\nconst FORCE_POLLING = `${+WATCHPACK_POLLING}` === WATCHPACK_POLLING ? +WATCHPACK_POLLING : !!WATCHPACK_POLLING && WATCHPACK_POLLING !== \"false\";\n\nfunction withoutCase(str) {\n  return str.toLowerCase();\n}\n\nfunction needCalls(times, callback) {\n  return function () {\n    if (--times === 0) {\n      return callback();\n    }\n  };\n}\n\nclass Watcher extends EventEmitter {\n  constructor(directoryWatcher, filePath, startTime) {\n    super();\n    this.directoryWatcher = directoryWatcher;\n    this.path = filePath;\n    this.startTime = startTime && +startTime;\n  }\n\n  checkStartTime(mtime, initial) {\n    const startTime = this.startTime;\n    if (typeof startTime !== \"number\") return !initial;\n    return startTime <= mtime;\n  }\n\n  close() {\n    this.emit(\"closed\");\n  }\n\n}\n\nclass DirectoryWatcher extends EventEmitter {\n  constructor(watcherManager, directoryPath, options) {\n    super();\n\n    if (FORCE_POLLING) {\n      options.poll = FORCE_POLLING;\n    }\n\n    this.watcherManager = watcherManager;\n    this.options = options;\n    this.path = directoryPath; // safeTime is the point in time after which reading is safe to be unchanged\n    // timestamp is a value that should be compared with another timestamp (mtime)\n\n    /** @type {Map<string, { safeTime: number, timestamp: number }} */\n\n    this.files = new Map();\n    /** @type {Map<string, number>} */\n\n    this.filesWithoutCase = new Map();\n    this.directories = new Map();\n    this.lastWatchEvent = 0;\n    this.initialScan = true;\n\n    this.ignored = options.ignored || (() => false);\n\n    this.nestedWatching = false;\n    this.polledWatching = typeof options.poll === \"number\" ? options.poll : options.poll ? 5007 : false;\n    this.timeout = undefined;\n    this.initialScanRemoved = new Set();\n    this.initialScanFinished = undefined;\n    /** @type {Map<string, Set<Watcher>>} */\n\n    this.watchers = new Map();\n    this.parentWatcher = null;\n    this.refs = 0;\n    this._activeEvents = new Map();\n    this.closed = false;\n    this.scanning = false;\n    this.scanAgain = false;\n    this.scanAgainInitial = false;\n    this.createWatcher();\n    this.doScan(true);\n  }\n\n  createWatcher() {\n    try {\n      if (this.polledWatching) {\n        this.watcher = {\n          close: () => {\n            if (this.timeout) {\n              clearTimeout(this.timeout);\n              this.timeout = undefined;\n            }\n          }\n        };\n      } else {\n        if (IS_OSX) {\n          this.watchInParentDirectory();\n        }\n\n        this.watcher = watchEventSource.watch(this.path);\n        this.watcher.on(\"change\", this.onWatchEvent.bind(this));\n        this.watcher.on(\"error\", this.onWatcherError.bind(this));\n      }\n    } catch (err) {\n      this.onWatcherError(err);\n    }\n  }\n\n  forEachWatcher(path, fn) {\n    const watchers = this.watchers.get(withoutCase(path));\n\n    if (watchers !== undefined) {\n      for (const w of watchers) {\n        fn(w);\n      }\n    }\n  }\n\n  setMissing(itemPath, initial, type) {\n    if (this.initialScan) {\n      this.initialScanRemoved.add(itemPath);\n    }\n\n    const oldDirectory = this.directories.get(itemPath);\n\n    if (oldDirectory) {\n      if (this.nestedWatching) oldDirectory.close();\n      this.directories.delete(itemPath);\n      this.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n\n      if (!initial) {\n        this.forEachWatcher(this.path, w => w.emit(\"change\", itemPath, null, type, initial));\n      }\n    }\n\n    const oldFile = this.files.get(itemPath);\n\n    if (oldFile) {\n      this.files.delete(itemPath);\n      const key = withoutCase(itemPath);\n      const count = this.filesWithoutCase.get(key) - 1;\n\n      if (count <= 0) {\n        this.filesWithoutCase.delete(key);\n        this.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n      } else {\n        this.filesWithoutCase.set(key, count);\n      }\n\n      if (!initial) {\n        this.forEachWatcher(this.path, w => w.emit(\"change\", itemPath, null, type, initial));\n      }\n    }\n  }\n\n  setFileTime(filePath, mtime, initial, ignoreWhenEqual, type) {\n    const now = Date.now();\n    if (this.ignored(filePath)) return;\n    const old = this.files.get(filePath);\n    let safeTime, accuracy;\n\n    if (initial) {\n      safeTime = Math.min(now, mtime) + FS_ACCURACY;\n      accuracy = FS_ACCURACY;\n    } else {\n      safeTime = now;\n      accuracy = 0;\n\n      if (old && old.timestamp === mtime && mtime + FS_ACCURACY < now) {\n        // We are sure that mtime is untouched\n        // This can be caused by some file attribute change\n        // e. g. when access time has been changed\n        // but the file content is untouched\n        return;\n      }\n    }\n\n    if (ignoreWhenEqual && old && old.timestamp === mtime) return;\n    this.files.set(filePath, {\n      safeTime,\n      accuracy,\n      timestamp: mtime\n    });\n\n    if (!old) {\n      const key = withoutCase(filePath);\n      const count = this.filesWithoutCase.get(key);\n      this.filesWithoutCase.set(key, (count || 0) + 1);\n\n      if (count !== undefined) {\n        // There is already a file with case-insensitive-equal name\n        // On a case-insensitive filesystem we may miss the renaming\n        // when only casing is changed.\n        // To be sure that our information is correct\n        // we trigger a rescan here\n        this.doScan(false);\n      }\n\n      this.forEachWatcher(filePath, w => {\n        if (!initial || w.checkStartTime(safeTime, initial)) {\n          w.emit(\"change\", mtime, type);\n        }\n      });\n    } else if (!initial) {\n      this.forEachWatcher(filePath, w => w.emit(\"change\", mtime, type));\n    }\n\n    this.forEachWatcher(this.path, w => {\n      if (!initial || w.checkStartTime(safeTime, initial)) {\n        w.emit(\"change\", filePath, safeTime, type, initial);\n      }\n    });\n  }\n\n  setDirectory(directoryPath, birthtime, initial, type) {\n    if (this.ignored(directoryPath)) return;\n\n    if (directoryPath === this.path) {\n      if (!initial) {\n        this.forEachWatcher(this.path, w => w.emit(\"change\", directoryPath, birthtime, type, initial));\n      }\n    } else {\n      const old = this.directories.get(directoryPath);\n\n      if (!old) {\n        const now = Date.now();\n\n        if (this.nestedWatching) {\n          this.createNestedWatcher(directoryPath);\n        } else {\n          this.directories.set(directoryPath, true);\n        }\n\n        let safeTime;\n\n        if (initial) {\n          safeTime = Math.min(now, birthtime) + FS_ACCURACY;\n        } else {\n          safeTime = now;\n        }\n\n        this.forEachWatcher(directoryPath, w => {\n          if (!initial || w.checkStartTime(safeTime, false)) {\n            w.emit(\"change\", birthtime, type);\n          }\n        });\n        this.forEachWatcher(this.path, w => {\n          if (!initial || w.checkStartTime(safeTime, initial)) {\n            w.emit(\"change\", directoryPath, safeTime, type, initial);\n          }\n        });\n      }\n    }\n  }\n\n  createNestedWatcher(directoryPath) {\n    const watcher = this.watcherManager.watchDirectory(directoryPath, 1);\n    watcher.on(\"change\", (filePath, mtime, type, initial) => {\n      this.forEachWatcher(this.path, w => {\n        if (!initial || w.checkStartTime(mtime, initial)) {\n          w.emit(\"change\", filePath, mtime, type, initial);\n        }\n      });\n    });\n    this.directories.set(directoryPath, watcher);\n  }\n\n  setNestedWatching(flag) {\n    if (this.nestedWatching !== !!flag) {\n      this.nestedWatching = !!flag;\n\n      if (this.nestedWatching) {\n        for (const directory of this.directories.keys()) {\n          this.createNestedWatcher(directory);\n        }\n      } else {\n        for (const [directory, watcher] of this.directories) {\n          watcher.close();\n          this.directories.set(directory, true);\n        }\n      }\n    }\n  }\n\n  watch(filePath, startTime) {\n    const key = withoutCase(filePath);\n    let watchers = this.watchers.get(key);\n\n    if (watchers === undefined) {\n      watchers = new Set();\n      this.watchers.set(key, watchers);\n    }\n\n    this.refs++;\n    const watcher = new Watcher(this, filePath, startTime);\n    watcher.on(\"closed\", () => {\n      if (--this.refs <= 0) {\n        this.close();\n        return;\n      }\n\n      watchers.delete(watcher);\n\n      if (watchers.size === 0) {\n        this.watchers.delete(key);\n        if (this.path === filePath) this.setNestedWatching(false);\n      }\n    });\n    watchers.add(watcher);\n    let safeTime;\n\n    if (filePath === this.path) {\n      this.setNestedWatching(true);\n      safeTime = this.lastWatchEvent;\n\n      for (const entry of this.files.values()) {\n        fixupEntryAccuracy(entry);\n        safeTime = Math.max(safeTime, entry.safeTime);\n      }\n    } else {\n      const entry = this.files.get(filePath);\n\n      if (entry) {\n        fixupEntryAccuracy(entry);\n        safeTime = entry.safeTime;\n      } else {\n        safeTime = 0;\n      }\n    }\n\n    if (safeTime) {\n      if (safeTime >= startTime) {\n        process.nextTick(() => {\n          if (this.closed) return;\n\n          if (filePath === this.path) {\n            watcher.emit(\"change\", filePath, safeTime, \"watch (outdated on attach)\", true);\n          } else {\n            watcher.emit(\"change\", safeTime, \"watch (outdated on attach)\", true);\n          }\n        });\n      }\n    } else if (this.initialScan) {\n      if (this.initialScanRemoved.has(filePath)) {\n        process.nextTick(() => {\n          if (this.closed) return;\n          watcher.emit(\"remove\");\n        });\n      }\n    } else if (!this.directories.has(filePath) && watcher.checkStartTime(this.initialScanFinished, false)) {\n      process.nextTick(() => {\n        if (this.closed) return;\n        watcher.emit(\"initial-missing\", \"watch (missing on attach)\");\n      });\n    }\n\n    return watcher;\n  }\n\n  onWatchEvent(eventType, filename) {\n    if (this.closed) return;\n\n    if (!filename) {\n      // In some cases no filename is provided\n      // This seem to happen on windows\n      // So some event happened but we don't know which file is affected\n      // We have to do a full scan of the directory\n      this.doScan(false);\n      return;\n    }\n\n    const filePath = path.join(this.path, filename);\n    if (this.ignored(filePath)) return;\n\n    if (this._activeEvents.get(filename) === undefined) {\n      this._activeEvents.set(filename, false);\n\n      const checkStats = () => {\n        if (this.closed) return;\n\n        this._activeEvents.set(filename, false);\n\n        fs.lstat(filePath, (err, stats) => {\n          if (this.closed) return;\n\n          if (this._activeEvents.get(filename) === true) {\n            process.nextTick(checkStats);\n            return;\n          }\n\n          this._activeEvents.delete(filename); // ENOENT happens when the file/directory doesn't exist\n          // EPERM happens when the containing directory doesn't exist\n\n\n          if (err) {\n            if (err.code !== \"ENOENT\" && err.code !== \"EPERM\" && err.code !== \"EBUSY\") {\n              this.onStatsError(err);\n            } else {\n              if (filename === path.basename(this.path)) {\n                // This may indicate that the directory itself was removed\n                if (!fs.existsSync(this.path)) {\n                  this.onDirectoryRemoved(\"stat failed\");\n                }\n              }\n            }\n          }\n\n          this.lastWatchEvent = Date.now();\n\n          if (!stats) {\n            this.setMissing(filePath, false, eventType);\n          } else if (stats.isDirectory()) {\n            this.setDirectory(filePath, +stats.birthtime || 1, false, eventType);\n          } else if (stats.isFile() || stats.isSymbolicLink()) {\n            if (stats.mtime) {\n              ensureFsAccuracy(stats.mtime);\n            }\n\n            this.setFileTime(filePath, +stats.mtime || +stats.ctime || 1, false, false, eventType);\n          }\n        });\n      };\n\n      process.nextTick(checkStats);\n    } else {\n      this._activeEvents.set(filename, true);\n    }\n  }\n\n  onWatcherError(err) {\n    if (this.closed) return;\n\n    if (err) {\n      if (err.code !== \"EPERM\" && err.code !== \"ENOENT\") {\n        console.error(\"Watchpack Error (watcher): \" + err);\n      }\n\n      this.onDirectoryRemoved(\"watch error\");\n    }\n  }\n\n  onStatsError(err) {\n    if (err) {\n      console.error(\"Watchpack Error (stats): \" + err);\n    }\n  }\n\n  onScanError(err) {\n    if (err) {\n      console.error(\"Watchpack Error (initial scan): \" + err);\n    }\n\n    this.onScanFinished();\n  }\n\n  onScanFinished() {\n    if (this.polledWatching) {\n      this.timeout = setTimeout(() => {\n        if (this.closed) return;\n        this.doScan(false);\n      }, this.polledWatching);\n    }\n  }\n\n  onDirectoryRemoved(reason) {\n    if (this.watcher) {\n      this.watcher.close();\n      this.watcher = null;\n    }\n\n    this.watchInParentDirectory();\n    const type = `directory-removed (${reason})`;\n\n    for (const directory of this.directories.keys()) {\n      this.setMissing(directory, null, type);\n    }\n\n    for (const file of this.files.keys()) {\n      this.setMissing(file, null, type);\n    }\n  }\n\n  watchInParentDirectory() {\n    if (!this.parentWatcher) {\n      const parentDir = path.dirname(this.path); // avoid watching in the root directory\n      // removing directories in the root directory is not supported\n\n      if (path.dirname(parentDir) === parentDir) return;\n      this.parentWatcher = this.watcherManager.watchFile(this.path, 1);\n      this.parentWatcher.on(\"change\", (mtime, type) => {\n        if (this.closed) return; // On non-osx platforms we don't need this watcher to detect\n        // directory removal, as an EPERM error indicates that\n\n        if ((!IS_OSX || this.polledWatching) && this.parentWatcher) {\n          this.parentWatcher.close();\n          this.parentWatcher = null;\n        } // Try to create the watcher when parent directory is found\n\n\n        if (!this.watcher) {\n          this.createWatcher();\n          this.doScan(false); // directory was created so we emit an event\n\n          this.forEachWatcher(this.path, w => w.emit(\"change\", this.path, mtime, type, false));\n        }\n      });\n      this.parentWatcher.on(\"remove\", () => {\n        this.onDirectoryRemoved(\"parent directory removed\");\n      });\n    }\n  }\n\n  doScan(initial) {\n    if (this.scanning) {\n      if (this.scanAgain) {\n        if (!initial) this.scanAgainInitial = false;\n      } else {\n        this.scanAgain = true;\n        this.scanAgainInitial = initial;\n      }\n\n      return;\n    }\n\n    this.scanning = true;\n\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = undefined;\n    }\n\n    process.nextTick(() => {\n      if (this.closed) return;\n      fs.readdir(this.path, (err, items) => {\n        if (this.closed) return;\n\n        if (err) {\n          if (err.code === \"ENOENT\" || err.code === \"EPERM\") {\n            this.onDirectoryRemoved(\"scan readdir failed\");\n          } else {\n            this.onScanError(err);\n          }\n\n          this.initialScan = false;\n          this.initialScanFinished = Date.now();\n\n          if (initial) {\n            for (const watchers of this.watchers.values()) {\n              for (const watcher of watchers) {\n                if (watcher.checkStartTime(this.initialScanFinished, false)) {\n                  watcher.emit(\"initial-missing\", \"scan (parent directory missing in initial scan)\");\n                }\n              }\n            }\n          }\n\n          if (this.scanAgain) {\n            this.scanAgain = false;\n            this.doScan(this.scanAgainInitial);\n          } else {\n            this.scanning = false;\n          }\n\n          return;\n        }\n\n        const itemPaths = new Set(items.map(item => path.join(this.path, item.normalize(\"NFC\"))));\n\n        for (const file of this.files.keys()) {\n          if (!itemPaths.has(file)) {\n            this.setMissing(file, initial, \"scan (missing)\");\n          }\n        }\n\n        for (const directory of this.directories.keys()) {\n          if (!itemPaths.has(directory)) {\n            this.setMissing(directory, initial, \"scan (missing)\");\n          }\n        }\n\n        if (this.scanAgain) {\n          // Early repeat of scan\n          this.scanAgain = false;\n          this.doScan(initial);\n          return;\n        }\n\n        const itemFinished = needCalls(itemPaths.size + 1, () => {\n          if (this.closed) return;\n          this.initialScan = false;\n          this.initialScanRemoved = null;\n          this.initialScanFinished = Date.now();\n\n          if (initial) {\n            const missingWatchers = new Map(this.watchers);\n            missingWatchers.delete(withoutCase(this.path));\n\n            for (const item of itemPaths) {\n              missingWatchers.delete(withoutCase(item));\n            }\n\n            for (const watchers of missingWatchers.values()) {\n              for (const watcher of watchers) {\n                if (watcher.checkStartTime(this.initialScanFinished, false)) {\n                  watcher.emit(\"initial-missing\", \"scan (missing in initial scan)\");\n                }\n              }\n            }\n          }\n\n          if (this.scanAgain) {\n            this.scanAgain = false;\n            this.doScan(this.scanAgainInitial);\n          } else {\n            this.scanning = false;\n            this.onScanFinished();\n          }\n        });\n\n        for (const itemPath of itemPaths) {\n          fs.lstat(itemPath, (err2, stats) => {\n            if (this.closed) return;\n\n            if (err2) {\n              if (err2.code === \"ENOENT\" || err2.code === \"EPERM\" || err2.code === \"EACCES\" || err2.code === \"EBUSY\") {\n                this.setMissing(itemPath, initial, \"scan (\" + err2.code + \")\");\n              } else {\n                this.onScanError(err2);\n              }\n\n              itemFinished();\n              return;\n            }\n\n            if (stats.isFile() || stats.isSymbolicLink()) {\n              if (stats.mtime) {\n                ensureFsAccuracy(stats.mtime);\n              }\n\n              this.setFileTime(itemPath, +stats.mtime || +stats.ctime || 1, initial, true, \"scan (file)\");\n            } else if (stats.isDirectory()) {\n              if (!initial || !this.directories.has(itemPath)) this.setDirectory(itemPath, +stats.birthtime || 1, initial, \"scan (dir)\");\n            }\n\n            itemFinished();\n          });\n        }\n\n        itemFinished();\n      });\n    });\n  }\n\n  getTimes() {\n    const obj = Object.create(null);\n    let safeTime = this.lastWatchEvent;\n\n    for (const [file, entry] of this.files) {\n      fixupEntryAccuracy(entry);\n      safeTime = Math.max(safeTime, entry.safeTime);\n      obj[file] = Math.max(entry.safeTime, entry.timestamp);\n    }\n\n    if (this.nestedWatching) {\n      for (const w of this.directories.values()) {\n        const times = w.directoryWatcher.getTimes();\n\n        for (const file of Object.keys(times)) {\n          const time = times[file];\n          safeTime = Math.max(safeTime, time);\n          obj[file] = time;\n        }\n      }\n\n      obj[this.path] = safeTime;\n    }\n\n    if (!this.initialScan) {\n      for (const watchers of this.watchers.values()) {\n        for (const watcher of watchers) {\n          const path = watcher.path;\n\n          if (!Object.prototype.hasOwnProperty.call(obj, path)) {\n            obj[path] = null;\n          }\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  collectTimeInfoEntries(fileTimestamps, directoryTimestamps) {\n    let safeTime = this.lastWatchEvent;\n\n    for (const [file, entry] of this.files) {\n      fixupEntryAccuracy(entry);\n      safeTime = Math.max(safeTime, entry.safeTime);\n      fileTimestamps.set(file, entry);\n    }\n\n    if (this.nestedWatching) {\n      for (const w of this.directories.values()) {\n        safeTime = Math.max(safeTime, w.directoryWatcher.collectTimeInfoEntries(fileTimestamps, directoryTimestamps));\n      }\n\n      fileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n      directoryTimestamps.set(this.path, {\n        safeTime\n      });\n    } else {\n      for (const dir of this.directories.keys()) {\n        // No additional info about this directory\n        // but maybe another DirectoryWatcher has info\n        fileTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n        if (!directoryTimestamps.has(dir)) directoryTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n      }\n\n      fileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n      directoryTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n    }\n\n    if (!this.initialScan) {\n      for (const watchers of this.watchers.values()) {\n        for (const watcher of watchers) {\n          const path = watcher.path;\n\n          if (!fileTimestamps.has(path)) {\n            fileTimestamps.set(path, null);\n          }\n        }\n      }\n    }\n\n    return safeTime;\n  }\n\n  close() {\n    this.closed = true;\n    this.initialScan = false;\n\n    if (this.watcher) {\n      this.watcher.close();\n      this.watcher = null;\n    }\n\n    if (this.nestedWatching) {\n      for (const w of this.directories.values()) {\n        w.close();\n      }\n\n      this.directories.clear();\n    }\n\n    if (this.parentWatcher) {\n      this.parentWatcher.close();\n      this.parentWatcher = null;\n    }\n\n    this.emit(\"closed\");\n  }\n\n}\n\nmodule.exports = DirectoryWatcher;\nmodule.exports.EXISTANCE_ONLY_TIME_ENTRY = EXISTANCE_ONLY_TIME_ENTRY;\n\nfunction fixupEntryAccuracy(entry) {\n  if (entry.accuracy > FS_ACCURACY) {\n    entry.safeTime = entry.safeTime - entry.accuracy + FS_ACCURACY;\n    entry.accuracy = FS_ACCURACY;\n  }\n}\n\nfunction ensureFsAccuracy(mtime) {\n  if (!mtime) return;\n  if (FS_ACCURACY > 1 && mtime % 1 !== 0) FS_ACCURACY = 1;else if (FS_ACCURACY > 10 && mtime % 10 !== 0) FS_ACCURACY = 10;else if (FS_ACCURACY > 100 && mtime % 100 !== 0) FS_ACCURACY = 100;else if (FS_ACCURACY > 1000 && mtime % 1000 !== 0) FS_ACCURACY = 1000;\n}","map":{"version":3,"names":["EventEmitter","require","fs","path","watchEventSource","EXISTANCE_ONLY_TIME_ENTRY","Object","freeze","FS_ACCURACY","IS_OSX","platform","WATCHPACK_POLLING","process","env","FORCE_POLLING","withoutCase","str","toLowerCase","needCalls","times","callback","Watcher","constructor","directoryWatcher","filePath","startTime","checkStartTime","mtime","initial","close","emit","DirectoryWatcher","watcherManager","directoryPath","options","poll","files","Map","filesWithoutCase","directories","lastWatchEvent","initialScan","ignored","nestedWatching","polledWatching","timeout","undefined","initialScanRemoved","Set","initialScanFinished","watchers","parentWatcher","refs","_activeEvents","closed","scanning","scanAgain","scanAgainInitial","createWatcher","doScan","watcher","clearTimeout","watchInParentDirectory","watch","on","onWatchEvent","bind","onWatcherError","err","forEachWatcher","fn","get","w","setMissing","itemPath","type","add","oldDirectory","delete","oldFile","key","count","set","setFileTime","ignoreWhenEqual","now","Date","old","safeTime","accuracy","Math","min","timestamp","setDirectory","birthtime","createNestedWatcher","watchDirectory","setNestedWatching","flag","directory","keys","size","entry","values","fixupEntryAccuracy","max","nextTick","has","eventType","filename","join","checkStats","lstat","stats","code","onStatsError","basename","existsSync","onDirectoryRemoved","isDirectory","isFile","isSymbolicLink","ensureFsAccuracy","ctime","console","error","onScanError","onScanFinished","setTimeout","reason","file","parentDir","dirname","watchFile","readdir","items","itemPaths","map","item","normalize","itemFinished","missingWatchers","err2","getTimes","obj","create","time","prototype","hasOwnProperty","call","collectTimeInfoEntries","fileTimestamps","directoryTimestamps","dir","clear","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/watchpack/lib/DirectoryWatcher.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\nconst fs = require(\"graceful-fs\");\nconst path = require(\"path\");\n\nconst watchEventSource = require(\"./watchEventSource\");\n\nconst EXISTANCE_ONLY_TIME_ENTRY = Object.freeze({});\n\nlet FS_ACCURACY = 2000;\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst WATCHPACK_POLLING = process.env.WATCHPACK_POLLING;\nconst FORCE_POLLING =\n\t`${+WATCHPACK_POLLING}` === WATCHPACK_POLLING\n\t\t? +WATCHPACK_POLLING\n\t\t: !!WATCHPACK_POLLING && WATCHPACK_POLLING !== \"false\";\n\nfunction withoutCase(str) {\n\treturn str.toLowerCase();\n}\n\nfunction needCalls(times, callback) {\n\treturn function() {\n\t\tif (--times === 0) {\n\t\t\treturn callback();\n\t\t}\n\t};\n}\n\nclass Watcher extends EventEmitter {\n\tconstructor(directoryWatcher, filePath, startTime) {\n\t\tsuper();\n\t\tthis.directoryWatcher = directoryWatcher;\n\t\tthis.path = filePath;\n\t\tthis.startTime = startTime && +startTime;\n\t}\n\n\tcheckStartTime(mtime, initial) {\n\t\tconst startTime = this.startTime;\n\t\tif (typeof startTime !== \"number\") return !initial;\n\t\treturn startTime <= mtime;\n\t}\n\n\tclose() {\n\t\tthis.emit(\"closed\");\n\t}\n}\n\nclass DirectoryWatcher extends EventEmitter {\n\tconstructor(watcherManager, directoryPath, options) {\n\t\tsuper();\n\t\tif (FORCE_POLLING) {\n\t\t\toptions.poll = FORCE_POLLING;\n\t\t}\n\t\tthis.watcherManager = watcherManager;\n\t\tthis.options = options;\n\t\tthis.path = directoryPath;\n\t\t// safeTime is the point in time after which reading is safe to be unchanged\n\t\t// timestamp is a value that should be compared with another timestamp (mtime)\n\t\t/** @type {Map<string, { safeTime: number, timestamp: number }} */\n\t\tthis.files = new Map();\n\t\t/** @type {Map<string, number>} */\n\t\tthis.filesWithoutCase = new Map();\n\t\tthis.directories = new Map();\n\t\tthis.lastWatchEvent = 0;\n\t\tthis.initialScan = true;\n\t\tthis.ignored = options.ignored || (() => false);\n\t\tthis.nestedWatching = false;\n\t\tthis.polledWatching =\n\t\t\ttypeof options.poll === \"number\"\n\t\t\t\t? options.poll\n\t\t\t\t: options.poll\n\t\t\t\t? 5007\n\t\t\t\t: false;\n\t\tthis.timeout = undefined;\n\t\tthis.initialScanRemoved = new Set();\n\t\tthis.initialScanFinished = undefined;\n\t\t/** @type {Map<string, Set<Watcher>>} */\n\t\tthis.watchers = new Map();\n\t\tthis.parentWatcher = null;\n\t\tthis.refs = 0;\n\t\tthis._activeEvents = new Map();\n\t\tthis.closed = false;\n\t\tthis.scanning = false;\n\t\tthis.scanAgain = false;\n\t\tthis.scanAgainInitial = false;\n\n\t\tthis.createWatcher();\n\t\tthis.doScan(true);\n\t}\n\n\tcreateWatcher() {\n\t\ttry {\n\t\t\tif (this.polledWatching) {\n\t\t\t\tthis.watcher = {\n\t\t\t\t\tclose: () => {\n\t\t\t\t\t\tif (this.timeout) {\n\t\t\t\t\t\t\tclearTimeout(this.timeout);\n\t\t\t\t\t\t\tthis.timeout = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tif (IS_OSX) {\n\t\t\t\t\tthis.watchInParentDirectory();\n\t\t\t\t}\n\t\t\t\tthis.watcher = watchEventSource.watch(this.path);\n\t\t\t\tthis.watcher.on(\"change\", this.onWatchEvent.bind(this));\n\t\t\t\tthis.watcher.on(\"error\", this.onWatcherError.bind(this));\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthis.onWatcherError(err);\n\t\t}\n\t}\n\n\tforEachWatcher(path, fn) {\n\t\tconst watchers = this.watchers.get(withoutCase(path));\n\t\tif (watchers !== undefined) {\n\t\t\tfor (const w of watchers) {\n\t\t\t\tfn(w);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetMissing(itemPath, initial, type) {\n\t\tif (this.initialScan) {\n\t\t\tthis.initialScanRemoved.add(itemPath);\n\t\t}\n\n\t\tconst oldDirectory = this.directories.get(itemPath);\n\t\tif (oldDirectory) {\n\t\t\tif (this.nestedWatching) oldDirectory.close();\n\t\t\tthis.directories.delete(itemPath);\n\n\t\t\tthis.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", itemPath, null, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tconst oldFile = this.files.get(itemPath);\n\t\tif (oldFile) {\n\t\t\tthis.files.delete(itemPath);\n\t\t\tconst key = withoutCase(itemPath);\n\t\t\tconst count = this.filesWithoutCase.get(key) - 1;\n\t\t\tif (count <= 0) {\n\t\t\t\tthis.filesWithoutCase.delete(key);\n\t\t\t\tthis.forEachWatcher(itemPath, w => w.emit(\"remove\", type));\n\t\t\t} else {\n\t\t\t\tthis.filesWithoutCase.set(key, count);\n\t\t\t}\n\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", itemPath, null, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tsetFileTime(filePath, mtime, initial, ignoreWhenEqual, type) {\n\t\tconst now = Date.now();\n\n\t\tif (this.ignored(filePath)) return;\n\n\t\tconst old = this.files.get(filePath);\n\n\t\tlet safeTime, accuracy;\n\t\tif (initial) {\n\t\t\tsafeTime = Math.min(now, mtime) + FS_ACCURACY;\n\t\t\taccuracy = FS_ACCURACY;\n\t\t} else {\n\t\t\tsafeTime = now;\n\t\t\taccuracy = 0;\n\n\t\t\tif (old && old.timestamp === mtime && mtime + FS_ACCURACY < now) {\n\t\t\t\t// We are sure that mtime is untouched\n\t\t\t\t// This can be caused by some file attribute change\n\t\t\t\t// e. g. when access time has been changed\n\t\t\t\t// but the file content is untouched\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (ignoreWhenEqual && old && old.timestamp === mtime) return;\n\n\t\tthis.files.set(filePath, {\n\t\t\tsafeTime,\n\t\t\taccuracy,\n\t\t\ttimestamp: mtime\n\t\t});\n\n\t\tif (!old) {\n\t\t\tconst key = withoutCase(filePath);\n\t\t\tconst count = this.filesWithoutCase.get(key);\n\t\t\tthis.filesWithoutCase.set(key, (count || 0) + 1);\n\t\t\tif (count !== undefined) {\n\t\t\t\t// There is already a file with case-insensitive-equal name\n\t\t\t\t// On a case-insensitive filesystem we may miss the renaming\n\t\t\t\t// when only casing is changed.\n\t\t\t\t// To be sure that our information is correct\n\t\t\t\t// we trigger a rescan here\n\t\t\t\tthis.doScan(false);\n\t\t\t}\n\n\t\t\tthis.forEachWatcher(filePath, w => {\n\t\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\t\tw.emit(\"change\", mtime, type);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (!initial) {\n\t\t\tthis.forEachWatcher(filePath, w => w.emit(\"change\", mtime, type));\n\t\t}\n\t\tthis.forEachWatcher(this.path, w => {\n\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\tw.emit(\"change\", filePath, safeTime, type, initial);\n\t\t\t}\n\t\t});\n\t}\n\n\tsetDirectory(directoryPath, birthtime, initial, type) {\n\t\tif (this.ignored(directoryPath)) return;\n\t\tif (directoryPath === this.path) {\n\t\t\tif (!initial) {\n\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\tw.emit(\"change\", directoryPath, birthtime, type, initial)\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tconst old = this.directories.get(directoryPath);\n\t\t\tif (!old) {\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tif (this.nestedWatching) {\n\t\t\t\t\tthis.createNestedWatcher(directoryPath);\n\t\t\t\t} else {\n\t\t\t\t\tthis.directories.set(directoryPath, true);\n\t\t\t\t}\n\n\t\t\t\tlet safeTime;\n\t\t\t\tif (initial) {\n\t\t\t\t\tsafeTime = Math.min(now, birthtime) + FS_ACCURACY;\n\t\t\t\t} else {\n\t\t\t\t\tsafeTime = now;\n\t\t\t\t}\n\n\t\t\t\tthis.forEachWatcher(directoryPath, w => {\n\t\t\t\t\tif (!initial || w.checkStartTime(safeTime, false)) {\n\t\t\t\t\t\tw.emit(\"change\", birthtime, type);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tthis.forEachWatcher(this.path, w => {\n\t\t\t\t\tif (!initial || w.checkStartTime(safeTime, initial)) {\n\t\t\t\t\t\tw.emit(\"change\", directoryPath, safeTime, type, initial);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateNestedWatcher(directoryPath) {\n\t\tconst watcher = this.watcherManager.watchDirectory(directoryPath, 1);\n\t\twatcher.on(\"change\", (filePath, mtime, type, initial) => {\n\t\t\tthis.forEachWatcher(this.path, w => {\n\t\t\t\tif (!initial || w.checkStartTime(mtime, initial)) {\n\t\t\t\t\tw.emit(\"change\", filePath, mtime, type, initial);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tthis.directories.set(directoryPath, watcher);\n\t}\n\n\tsetNestedWatching(flag) {\n\t\tif (this.nestedWatching !== !!flag) {\n\t\t\tthis.nestedWatching = !!flag;\n\t\t\tif (this.nestedWatching) {\n\t\t\t\tfor (const directory of this.directories.keys()) {\n\t\t\t\t\tthis.createNestedWatcher(directory);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const [directory, watcher] of this.directories) {\n\t\t\t\t\twatcher.close();\n\t\t\t\t\tthis.directories.set(directory, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twatch(filePath, startTime) {\n\t\tconst key = withoutCase(filePath);\n\t\tlet watchers = this.watchers.get(key);\n\t\tif (watchers === undefined) {\n\t\t\twatchers = new Set();\n\t\t\tthis.watchers.set(key, watchers);\n\t\t}\n\t\tthis.refs++;\n\t\tconst watcher = new Watcher(this, filePath, startTime);\n\t\twatcher.on(\"closed\", () => {\n\t\t\tif (--this.refs <= 0) {\n\t\t\t\tthis.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\twatchers.delete(watcher);\n\t\t\tif (watchers.size === 0) {\n\t\t\t\tthis.watchers.delete(key);\n\t\t\t\tif (this.path === filePath) this.setNestedWatching(false);\n\t\t\t}\n\t\t});\n\t\twatchers.add(watcher);\n\t\tlet safeTime;\n\t\tif (filePath === this.path) {\n\t\t\tthis.setNestedWatching(true);\n\t\t\tsafeTime = this.lastWatchEvent;\n\t\t\tfor (const entry of this.files.values()) {\n\t\t\t\tfixupEntryAccuracy(entry);\n\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t}\n\t\t} else {\n\t\t\tconst entry = this.files.get(filePath);\n\t\t\tif (entry) {\n\t\t\t\tfixupEntryAccuracy(entry);\n\t\t\t\tsafeTime = entry.safeTime;\n\t\t\t} else {\n\t\t\t\tsafeTime = 0;\n\t\t\t}\n\t\t}\n\t\tif (safeTime) {\n\t\t\tif (safeTime >= startTime) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tif (filePath === this.path) {\n\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\"change\",\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\t\t\"watch (outdated on attach)\",\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\"change\",\n\t\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\t\t\"watch (outdated on attach)\",\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (this.initialScan) {\n\t\t\tif (this.initialScanRemoved.has(filePath)) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\twatcher.emit(\"remove\");\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (\n\t\t\t!this.directories.has(filePath) &&\n\t\t\twatcher.checkStartTime(this.initialScanFinished, false)\n\t\t) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\twatcher.emit(\"initial-missing\", \"watch (missing on attach)\");\n\t\t\t});\n\t\t}\n\t\treturn watcher;\n\t}\n\n\tonWatchEvent(eventType, filename) {\n\t\tif (this.closed) return;\n\t\tif (!filename) {\n\t\t\t// In some cases no filename is provided\n\t\t\t// This seem to happen on windows\n\t\t\t// So some event happened but we don't know which file is affected\n\t\t\t// We have to do a full scan of the directory\n\t\t\tthis.doScan(false);\n\t\t\treturn;\n\t\t}\n\n\t\tconst filePath = path.join(this.path, filename);\n\t\tif (this.ignored(filePath)) return;\n\n\t\tif (this._activeEvents.get(filename) === undefined) {\n\t\t\tthis._activeEvents.set(filename, false);\n\t\t\tconst checkStats = () => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tthis._activeEvents.set(filename, false);\n\t\t\t\tfs.lstat(filePath, (err, stats) => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tif (this._activeEvents.get(filename) === true) {\n\t\t\t\t\t\tprocess.nextTick(checkStats);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis._activeEvents.delete(filename);\n\t\t\t\t\t// ENOENT happens when the file/directory doesn't exist\n\t\t\t\t\t// EPERM happens when the containing directory doesn't exist\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\terr.code !== \"ENOENT\" &&\n\t\t\t\t\t\t\terr.code !== \"EPERM\" &&\n\t\t\t\t\t\t\terr.code !== \"EBUSY\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.onStatsError(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (filename === path.basename(this.path)) {\n\t\t\t\t\t\t\t\t// This may indicate that the directory itself was removed\n\t\t\t\t\t\t\t\tif (!fs.existsSync(this.path)) {\n\t\t\t\t\t\t\t\t\tthis.onDirectoryRemoved(\"stat failed\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastWatchEvent = Date.now();\n\t\t\t\t\tif (!stats) {\n\t\t\t\t\t\tthis.setMissing(filePath, false, eventType);\n\t\t\t\t\t} else if (stats.isDirectory()) {\n\t\t\t\t\t\tthis.setDirectory(\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t+stats.birthtime || 1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\teventType\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (stats.isFile() || stats.isSymbolicLink()) {\n\t\t\t\t\t\tif (stats.mtime) {\n\t\t\t\t\t\t\tensureFsAccuracy(stats.mtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.setFileTime(\n\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t+stats.mtime || +stats.ctime || 1,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\tfalse,\n\t\t\t\t\t\t\teventType\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\tprocess.nextTick(checkStats);\n\t\t} else {\n\t\t\tthis._activeEvents.set(filename, true);\n\t\t}\n\t}\n\n\tonWatcherError(err) {\n\t\tif (this.closed) return;\n\t\tif (err) {\n\t\t\tif (err.code !== \"EPERM\" && err.code !== \"ENOENT\") {\n\t\t\t\tconsole.error(\"Watchpack Error (watcher): \" + err);\n\t\t\t}\n\t\t\tthis.onDirectoryRemoved(\"watch error\");\n\t\t}\n\t}\n\n\tonStatsError(err) {\n\t\tif (err) {\n\t\t\tconsole.error(\"Watchpack Error (stats): \" + err);\n\t\t}\n\t}\n\n\tonScanError(err) {\n\t\tif (err) {\n\t\t\tconsole.error(\"Watchpack Error (initial scan): \" + err);\n\t\t}\n\t\tthis.onScanFinished();\n\t}\n\n\tonScanFinished() {\n\t\tif (this.polledWatching) {\n\t\t\tthis.timeout = setTimeout(() => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tthis.doScan(false);\n\t\t\t}, this.polledWatching);\n\t\t}\n\t}\n\n\tonDirectoryRemoved(reason) {\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.close();\n\t\t\tthis.watcher = null;\n\t\t}\n\t\tthis.watchInParentDirectory();\n\t\tconst type = `directory-removed (${reason})`;\n\t\tfor (const directory of this.directories.keys()) {\n\t\t\tthis.setMissing(directory, null, type);\n\t\t}\n\t\tfor (const file of this.files.keys()) {\n\t\t\tthis.setMissing(file, null, type);\n\t\t}\n\t}\n\n\twatchInParentDirectory() {\n\t\tif (!this.parentWatcher) {\n\t\t\tconst parentDir = path.dirname(this.path);\n\t\t\t// avoid watching in the root directory\n\t\t\t// removing directories in the root directory is not supported\n\t\t\tif (path.dirname(parentDir) === parentDir) return;\n\n\t\t\tthis.parentWatcher = this.watcherManager.watchFile(this.path, 1);\n\t\t\tthis.parentWatcher.on(\"change\", (mtime, type) => {\n\t\t\t\tif (this.closed) return;\n\n\t\t\t\t// On non-osx platforms we don't need this watcher to detect\n\t\t\t\t// directory removal, as an EPERM error indicates that\n\t\t\t\tif ((!IS_OSX || this.polledWatching) && this.parentWatcher) {\n\t\t\t\t\tthis.parentWatcher.close();\n\t\t\t\t\tthis.parentWatcher = null;\n\t\t\t\t}\n\t\t\t\t// Try to create the watcher when parent directory is found\n\t\t\t\tif (!this.watcher) {\n\t\t\t\t\tthis.createWatcher();\n\t\t\t\t\tthis.doScan(false);\n\n\t\t\t\t\t// directory was created so we emit an event\n\t\t\t\t\tthis.forEachWatcher(this.path, w =>\n\t\t\t\t\t\tw.emit(\"change\", this.path, mtime, type, false)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tthis.parentWatcher.on(\"remove\", () => {\n\t\t\t\tthis.onDirectoryRemoved(\"parent directory removed\");\n\t\t\t});\n\t\t}\n\t}\n\n\tdoScan(initial) {\n\t\tif (this.scanning) {\n\t\t\tif (this.scanAgain) {\n\t\t\t\tif (!initial) this.scanAgainInitial = false;\n\t\t\t} else {\n\t\t\t\tthis.scanAgain = true;\n\t\t\t\tthis.scanAgainInitial = initial;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.scanning = true;\n\t\tif (this.timeout) {\n\t\t\tclearTimeout(this.timeout);\n\t\t\tthis.timeout = undefined;\n\t\t}\n\t\tprocess.nextTick(() => {\n\t\t\tif (this.closed) return;\n\t\t\tfs.readdir(this.path, (err, items) => {\n\t\t\t\tif (this.closed) return;\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === \"ENOENT\" || err.code === \"EPERM\") {\n\t\t\t\t\t\tthis.onDirectoryRemoved(\"scan readdir failed\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.onScanError(err);\n\t\t\t\t\t}\n\t\t\t\t\tthis.initialScan = false;\n\t\t\t\t\tthis.initialScanFinished = Date.now();\n\t\t\t\t\tif (initial) {\n\t\t\t\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\t\t\t\tif (watcher.checkStartTime(this.initialScanFinished, false)) {\n\t\t\t\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\t\t\t\"initial-missing\",\n\t\t\t\t\t\t\t\t\t\t\"scan (parent directory missing in initial scan)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\t\tthis.doScan(this.scanAgainInitial);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.scanning = false;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst itemPaths = new Set(\n\t\t\t\t\titems.map(item => path.join(this.path, item.normalize(\"NFC\")))\n\t\t\t\t);\n\t\t\t\tfor (const file of this.files.keys()) {\n\t\t\t\t\tif (!itemPaths.has(file)) {\n\t\t\t\t\t\tthis.setMissing(file, initial, \"scan (missing)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const directory of this.directories.keys()) {\n\t\t\t\t\tif (!itemPaths.has(directory)) {\n\t\t\t\t\t\tthis.setMissing(directory, initial, \"scan (missing)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t// Early repeat of scan\n\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\tthis.doScan(initial);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst itemFinished = needCalls(itemPaths.size + 1, () => {\n\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\tthis.initialScan = false;\n\t\t\t\t\tthis.initialScanRemoved = null;\n\t\t\t\t\tthis.initialScanFinished = Date.now();\n\t\t\t\t\tif (initial) {\n\t\t\t\t\t\tconst missingWatchers = new Map(this.watchers);\n\t\t\t\t\t\tmissingWatchers.delete(withoutCase(this.path));\n\t\t\t\t\t\tfor (const item of itemPaths) {\n\t\t\t\t\t\t\tmissingWatchers.delete(withoutCase(item));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const watchers of missingWatchers.values()) {\n\t\t\t\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\t\t\t\tif (watcher.checkStartTime(this.initialScanFinished, false)) {\n\t\t\t\t\t\t\t\t\twatcher.emit(\n\t\t\t\t\t\t\t\t\t\t\"initial-missing\",\n\t\t\t\t\t\t\t\t\t\t\"scan (missing in initial scan)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.scanAgain) {\n\t\t\t\t\t\tthis.scanAgain = false;\n\t\t\t\t\t\tthis.doScan(this.scanAgainInitial);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.scanning = false;\n\t\t\t\t\t\tthis.onScanFinished();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor (const itemPath of itemPaths) {\n\t\t\t\t\tfs.lstat(itemPath, (err2, stats) => {\n\t\t\t\t\t\tif (this.closed) return;\n\t\t\t\t\t\tif (err2) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\terr2.code === \"ENOENT\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EPERM\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EACCES\" ||\n\t\t\t\t\t\t\t\terr2.code === \"EBUSY\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tthis.setMissing(itemPath, initial, \"scan (\" + err2.code + \")\");\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.onScanError(err2);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titemFinished();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (stats.isFile() || stats.isSymbolicLink()) {\n\t\t\t\t\t\t\tif (stats.mtime) {\n\t\t\t\t\t\t\t\tensureFsAccuracy(stats.mtime);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.setFileTime(\n\t\t\t\t\t\t\t\titemPath,\n\t\t\t\t\t\t\t\t+stats.mtime || +stats.ctime || 1,\n\t\t\t\t\t\t\t\tinitial,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\t\"scan (file)\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (stats.isDirectory()) {\n\t\t\t\t\t\t\tif (!initial || !this.directories.has(itemPath))\n\t\t\t\t\t\t\t\tthis.setDirectory(\n\t\t\t\t\t\t\t\t\titemPath,\n\t\t\t\t\t\t\t\t\t+stats.birthtime || 1,\n\t\t\t\t\t\t\t\t\tinitial,\n\t\t\t\t\t\t\t\t\t\"scan (dir)\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\titemFinished();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\titemFinished();\n\t\t\t});\n\t\t});\n\t}\n\n\tgetTimes() {\n\t\tconst obj = Object.create(null);\n\t\tlet safeTime = this.lastWatchEvent;\n\t\tfor (const [file, entry] of this.files) {\n\t\t\tfixupEntryAccuracy(entry);\n\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\tobj[file] = Math.max(entry.safeTime, entry.timestamp);\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tconst times = w.directoryWatcher.getTimes();\n\t\t\t\tfor (const file of Object.keys(times)) {\n\t\t\t\t\tconst time = times[file];\n\t\t\t\t\tsafeTime = Math.max(safeTime, time);\n\t\t\t\t\tobj[file] = time;\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj[this.path] = safeTime;\n\t\t}\n\t\tif (!this.initialScan) {\n\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\tconst path = watcher.path;\n\t\t\t\t\tif (!Object.prototype.hasOwnProperty.call(obj, path)) {\n\t\t\t\t\t\tobj[path] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t}\n\n\tcollectTimeInfoEntries(fileTimestamps, directoryTimestamps) {\n\t\tlet safeTime = this.lastWatchEvent;\n\t\tfor (const [file, entry] of this.files) {\n\t\t\tfixupEntryAccuracy(entry);\n\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\tfileTimestamps.set(file, entry);\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tsafeTime = Math.max(\n\t\t\t\t\tsafeTime,\n\t\t\t\t\tw.directoryWatcher.collectTimeInfoEntries(\n\t\t\t\t\t\tfileTimestamps,\n\t\t\t\t\t\tdirectoryTimestamps\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tfileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\tdirectoryTimestamps.set(this.path, {\n\t\t\t\tsafeTime\n\t\t\t});\n\t\t} else {\n\t\t\tfor (const dir of this.directories.keys()) {\n\t\t\t\t// No additional info about this directory\n\t\t\t\t// but maybe another DirectoryWatcher has info\n\t\t\t\tfileTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\t\tif (!directoryTimestamps.has(dir))\n\t\t\t\t\tdirectoryTimestamps.set(dir, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\t}\n\t\t\tfileTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t\tdirectoryTimestamps.set(this.path, EXISTANCE_ONLY_TIME_ENTRY);\n\t\t}\n\t\tif (!this.initialScan) {\n\t\t\tfor (const watchers of this.watchers.values()) {\n\t\t\t\tfor (const watcher of watchers) {\n\t\t\t\t\tconst path = watcher.path;\n\t\t\t\t\tif (!fileTimestamps.has(path)) {\n\t\t\t\t\t\tfileTimestamps.set(path, null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn safeTime;\n\t}\n\n\tclose() {\n\t\tthis.closed = true;\n\t\tthis.initialScan = false;\n\t\tif (this.watcher) {\n\t\t\tthis.watcher.close();\n\t\t\tthis.watcher = null;\n\t\t}\n\t\tif (this.nestedWatching) {\n\t\t\tfor (const w of this.directories.values()) {\n\t\t\t\tw.close();\n\t\t\t}\n\t\t\tthis.directories.clear();\n\t\t}\n\t\tif (this.parentWatcher) {\n\t\t\tthis.parentWatcher.close();\n\t\t\tthis.parentWatcher = null;\n\t\t}\n\t\tthis.emit(\"closed\");\n\t}\n}\n\nmodule.exports = DirectoryWatcher;\nmodule.exports.EXISTANCE_ONLY_TIME_ENTRY = EXISTANCE_ONLY_TIME_ENTRY;\n\nfunction fixupEntryAccuracy(entry) {\n\tif (entry.accuracy > FS_ACCURACY) {\n\t\tentry.safeTime = entry.safeTime - entry.accuracy + FS_ACCURACY;\n\t\tentry.accuracy = FS_ACCURACY;\n\t}\n}\n\nfunction ensureFsAccuracy(mtime) {\n\tif (!mtime) return;\n\tif (FS_ACCURACY > 1 && mtime % 1 !== 0) FS_ACCURACY = 1;\n\telse if (FS_ACCURACY > 10 && mtime % 10 !== 0) FS_ACCURACY = 10;\n\telse if (FS_ACCURACY > 100 && mtime % 100 !== 0) FS_ACCURACY = 100;\n\telse if (FS_ACCURACY > 1000 && mtime % 1000 !== 0) FS_ACCURACY = 1000;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}