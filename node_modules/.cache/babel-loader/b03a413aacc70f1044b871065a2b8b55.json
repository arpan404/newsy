{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\n\nconst {\n  connectChunkGroupParentAndChild\n} = require(\"./GraphHelpers\");\n\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\n\nconst {\n  getEntryRuntime,\n  mergeRuntime\n} = require(\"./util/runtime\");\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\n\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n * @property {ChunkGroupInfo} chunkGroupInfo\n */\n\n/** @typedef {Set<Module> & { plus: Set<Module> }} ModuleSetPlus */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {RuntimeSpec} runtime the runtimes\n * @property {ModuleSetPlus} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {ModuleSetPlus[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<[Module, ConnectionState]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\n * @property {ModuleSetPlus} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroupInfo>} children set of children chunk groups, that will be revisited when availableModules shrink\n * @property {Set<ChunkGroupInfo>} availableSources set of chunk groups that are the source for minAvailableModules\n * @property {Set<ChunkGroupInfo>} availableChildren set of chunk groups which depend on the this chunk group as availableSource\n * @property {number} preOrderIndex next pre order index\n * @property {number} postOrderIndex next post order index\n * @property {boolean} chunkLoading has a chunk loading mechanism\n * @property {boolean} asyncChunks create async chunks\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n\nconst EMPTY_SET =\n/** @type {ModuleSetPlus} */\nnew Set();\nEMPTY_SET.plus = EMPTY_SET;\n/**\n * @param {ModuleSetPlus} a first set\n * @param {ModuleSetPlus} b second set\n * @returns {number} cmp\n */\n\nconst bySetSize = (a, b) => {\n  return b.size + b.plus.size - a.size - a.plus.size;\n};\n\nconst extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {\n  let blockCache;\n  let modules;\n  const arrays = [];\n  const queue = [module];\n\n  while (queue.length > 0) {\n    const block = queue.pop();\n    const arr = [];\n    arrays.push(arr);\n    blockModulesMap.set(block, arr);\n\n    for (const b of block.blocks) {\n      queue.push(b);\n    }\n  }\n\n  for (const connection of moduleGraph.getOutgoingConnections(module)) {\n    const d = connection.dependency; // We skip connections without dependency\n\n    if (!d) continue;\n    const m = connection.module; // We skip connections without Module pointer\n\n    if (!m) continue; // We skip weak connections\n\n    if (connection.weak) continue;\n    const state = connection.getActiveState(runtime); // We skip inactive connections\n\n    if (state === false) continue;\n    const block = moduleGraph.getParentBlock(d);\n    let index = moduleGraph.getParentBlockIndex(d); // deprecated fallback\n\n    if (index < 0) {\n      index = block.dependencies.indexOf(d);\n    }\n\n    if (blockCache !== block) {\n      modules = blockModulesMap.get(blockCache = block);\n    }\n\n    const i = index << 2;\n    modules[i] = m;\n    modules[i + 1] = state;\n  }\n\n  for (const modules of arrays) {\n    if (modules.length === 0) continue;\n    let indexMap;\n    let length = 0;\n\n    outer: for (let j = 0; j < modules.length; j += 2) {\n      const m = modules[j];\n      if (m === undefined) continue;\n      const state = modules[j + 1];\n\n      if (indexMap === undefined) {\n        let i = 0;\n\n        for (; i < length; i += 2) {\n          if (modules[i] === m) {\n            const merged = modules[i + 1];\n            if (merged === true) continue outer;\n            modules[i + 1] = ModuleGraphConnection.addConnectionStates(merged, state);\n          }\n        }\n\n        modules[length] = m;\n        length++;\n        modules[length] = state;\n        length++;\n\n        if (length > 30) {\n          // To avoid worse case performance, we will use an index map for\n          // linear cost access, which allows to maintain O(n) complexity\n          // while keeping allocations down to a minimum\n          indexMap = new Map();\n\n          for (let i = 0; i < length; i += 2) {\n            indexMap.set(modules[i], i + 1);\n          }\n        }\n      } else {\n        const idx = indexMap.get(m);\n\n        if (idx !== undefined) {\n          const merged = modules[idx];\n          if (merged === true) continue outer;\n          modules[idx] = ModuleGraphConnection.addConnectionStates(merged, state);\n        } else {\n          modules[length] = m;\n          length++;\n          modules[length] = state;\n          indexMap.set(m, length);\n          length++;\n        }\n      }\n    }\n\n    modules.length = length;\n  }\n};\n/**\n *\n * @param {Logger} logger a logger\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\n\n\nconst visitModules = (logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) => {\n  const {\n    moduleGraph,\n    chunkGraph,\n    moduleMemCaches\n  } = compilation;\n  const blockModulesRuntimeMap = new Map();\n  /** @type {RuntimeSpec | false} */\n\n  let blockModulesMapRuntime = false;\n  let blockModulesMap;\n  /**\n   *\n   * @param {DependenciesBlock} block block\n   * @param {RuntimeSpec} runtime runtime\n   * @returns {(Module | ConnectionState)[]} block modules in flatten tuples\n   */\n\n  const getBlockModules = (block, runtime) => {\n    if (blockModulesMapRuntime !== runtime) {\n      blockModulesMap = blockModulesRuntimeMap.get(runtime);\n\n      if (blockModulesMap === undefined) {\n        blockModulesMap = new Map();\n        blockModulesRuntimeMap.set(runtime, blockModulesMap);\n      }\n    }\n\n    let blockModules = blockModulesMap.get(block);\n    if (blockModules !== undefined) return blockModules;\n    const module =\n    /** @type {Module} */\n    block.getRootBlock();\n    const memCache = moduleMemCaches && moduleMemCaches.get(module);\n\n    if (memCache !== undefined) {\n      const map = memCache.provide(\"bundleChunkGraph.blockModules\", runtime, () => {\n        logger.time(\"visitModules: prepare\");\n        const map = new Map();\n        extractBlockModules(module, moduleGraph, runtime, map);\n        logger.timeAggregate(\"visitModules: prepare\");\n        return map;\n      });\n\n      for (const [block, blockModules] of map) blockModulesMap.set(block, blockModules);\n\n      return map.get(block);\n    } else {\n      logger.time(\"visitModules: prepare\");\n      extractBlockModules(module, moduleGraph, runtime, blockModulesMap);\n      blockModules = blockModulesMap.get(block);\n      logger.timeAggregate(\"visitModules: prepare\");\n      return blockModules;\n    }\n  };\n\n  let statProcessedQueueItems = 0;\n  let statProcessedBlocks = 0;\n  let statConnectedChunkGroups = 0;\n  let statProcessedChunkGroupsForMerging = 0;\n  let statMergedAvailableModuleSets = 0;\n  let statForkedAvailableModules = 0;\n  let statForkedAvailableModulesCount = 0;\n  let statForkedAvailableModulesCountPlus = 0;\n  let statForkedMergedModulesCount = 0;\n  let statForkedMergedModulesCountPlus = 0;\n  let statForkedResultModulesCount = 0;\n  let statChunkGroupInfoUpdated = 0;\n  let statChildChunkGroupsReconnected = 0;\n  let nextChunkGroupIndex = 0;\n  let nextFreeModulePreOrderIndex = 0;\n  let nextFreeModulePostOrderIndex = 0;\n  /** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\n\n  const blockChunkGroups = new Map();\n  /** @type {Map<string, ChunkGroupInfo>} */\n\n  const namedChunkGroups = new Map();\n  /** @type {Map<string, ChunkGroupInfo>} */\n\n  const namedAsyncEntrypoints = new Map();\n  const ADD_AND_ENTER_ENTRY_MODULE = 0;\n  const ADD_AND_ENTER_MODULE = 1;\n  const ENTER_MODULE = 2;\n  const PROCESS_BLOCK = 3;\n  const PROCESS_ENTRY_BLOCK = 4;\n  const LEAVE_MODULE = 5;\n  /** @type {QueueItem[]} */\n\n  let queue = [];\n  /** @type {Map<ChunkGroupInfo, Set<ChunkGroupInfo>>} */\n\n  const queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n\n  const chunkGroupsForCombining = new Set(); // Fill queue with entrypoint modules\n  // Create ChunkGroupInfo for entrypoints\n\n  for (const [chunkGroup, modules] of inputEntrypointsAndModules) {\n    const runtime = getEntryRuntime(compilation, chunkGroup.name, chunkGroup.options);\n    /** @type {ChunkGroupInfo} */\n\n    const chunkGroupInfo = {\n      chunkGroup,\n      runtime,\n      minAvailableModules: undefined,\n      minAvailableModulesOwned: false,\n      availableModulesToBeMerged: [],\n      skippedItems: undefined,\n      resultingAvailableModules: undefined,\n      children: undefined,\n      availableSources: undefined,\n      availableChildren: undefined,\n      preOrderIndex: 0,\n      postOrderIndex: 0,\n      chunkLoading: chunkGroup.options.chunkLoading !== undefined ? chunkGroup.options.chunkLoading !== false : compilation.outputOptions.chunkLoading !== false,\n      asyncChunks: chunkGroup.options.asyncChunks !== undefined ? chunkGroup.options.asyncChunks : compilation.outputOptions.asyncChunks !== false\n    };\n    chunkGroup.index = nextChunkGroupIndex++;\n\n    if (chunkGroup.getNumberOfParents() > 0) {\n      // minAvailableModules for child entrypoints are unknown yet, set to undefined.\n      // This means no module is added until other sets are merged into\n      // this minAvailableModules (by the parent entrypoints)\n      const skippedItems = new Set();\n\n      for (const module of modules) {\n        skippedItems.add(module);\n      }\n\n      chunkGroupInfo.skippedItems = skippedItems;\n      chunkGroupsForCombining.add(chunkGroupInfo);\n    } else {\n      // The application may start here: We start with an empty list of available modules\n      chunkGroupInfo.minAvailableModules = EMPTY_SET;\n      const chunk = chunkGroup.getEntrypointChunk();\n\n      for (const module of modules) {\n        queue.push({\n          action: ADD_AND_ENTER_MODULE,\n          block: module,\n          module,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      }\n    }\n\n    chunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);\n\n    if (chunkGroup.name) {\n      namedChunkGroups.set(chunkGroup.name, chunkGroupInfo);\n    }\n  } // Fill availableSources with parent-child dependencies between entrypoints\n\n\n  for (const chunkGroupInfo of chunkGroupsForCombining) {\n    const {\n      chunkGroup\n    } = chunkGroupInfo;\n    chunkGroupInfo.availableSources = new Set();\n\n    for (const parent of chunkGroup.parentsIterable) {\n      const parentChunkGroupInfo = chunkGroupInfoMap.get(parent);\n      chunkGroupInfo.availableSources.add(parentChunkGroupInfo);\n\n      if (parentChunkGroupInfo.availableChildren === undefined) {\n        parentChunkGroupInfo.availableChildren = new Set();\n      }\n\n      parentChunkGroupInfo.availableChildren.add(chunkGroupInfo);\n    }\n  } // pop() is used to read from the queue\n  // so it need to be reversed to be iterated in\n  // correct order\n\n\n  queue.reverse();\n  /** @type {Set<ChunkGroupInfo>} */\n\n  const outdatedChunkGroupInfo = new Set();\n  /** @type {Set<ChunkGroupInfo>} */\n\n  const chunkGroupsForMerging = new Set();\n  /** @type {QueueItem[]} */\n\n  let queueDelayed = [];\n  /** @type {[Module, ConnectionState][]} */\n\n  const skipConnectionBuffer = [];\n  /** @type {Module[]} */\n\n  const skipBuffer = [];\n  /** @type {QueueItem[]} */\n\n  const queueBuffer = [];\n  /** @type {Module} */\n\n  let module;\n  /** @type {Chunk} */\n\n  let chunk;\n  /** @type {ChunkGroup} */\n\n  let chunkGroup;\n  /** @type {DependenciesBlock} */\n\n  let block;\n  /** @type {ChunkGroupInfo} */\n\n  let chunkGroupInfo; // For each async Block in graph\n\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n\n  const iteratorBlock = b => {\n    // 1. We create a chunk group with single chunk in it for this Block\n    // but only once (blockChunkGroups map)\n    let cgi = blockChunkGroups.get(b);\n    /** @type {ChunkGroup} */\n\n    let c;\n    /** @type {Entrypoint} */\n\n    let entrypoint;\n    const entryOptions = b.groupOptions && b.groupOptions.entryOptions;\n\n    if (cgi === undefined) {\n      const chunkName = b.groupOptions && b.groupOptions.name || b.chunkName;\n\n      if (entryOptions) {\n        cgi = namedAsyncEntrypoints.get(chunkName);\n\n        if (!cgi) {\n          entrypoint = compilation.addAsyncEntrypoint(entryOptions, module, b.loc, b.request);\n          entrypoint.index = nextChunkGroupIndex++;\n          cgi = {\n            chunkGroup: entrypoint,\n            runtime: entrypoint.options.runtime || entrypoint.name,\n            minAvailableModules: EMPTY_SET,\n            minAvailableModulesOwned: false,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: entryOptions.chunkLoading !== undefined ? entryOptions.chunkLoading !== false : chunkGroupInfo.chunkLoading,\n            asyncChunks: entryOptions.asyncChunks !== undefined ? entryOptions.asyncChunks : chunkGroupInfo.asyncChunks\n          };\n          chunkGroupInfoMap.set(entrypoint, cgi);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\n          if (chunkName) {\n            namedAsyncEntrypoints.set(chunkName, cgi);\n          }\n        } else {\n          entrypoint =\n          /** @type {Entrypoint} */\n          cgi.chunkGroup; // TODO merge entryOptions\n\n          entrypoint.addOrigin(module, b.loc, b.request);\n          chunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n        } // 2. We enqueue the DependenciesBlock for traversal\n\n\n        queueDelayed.push({\n          action: PROCESS_ENTRY_BLOCK,\n          block: b,\n          module: module,\n          chunk: entrypoint.chunks[0],\n          chunkGroup: entrypoint,\n          chunkGroupInfo: cgi\n        });\n      } else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\n        // Just queue the block into the current chunk group\n        queue.push({\n          action: PROCESS_BLOCK,\n          block: b,\n          module: module,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      } else {\n        cgi = chunkName && namedChunkGroups.get(chunkName);\n\n        if (!cgi) {\n          c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n          c.index = nextChunkGroupIndex++;\n          cgi = {\n            chunkGroup: c,\n            runtime: chunkGroupInfo.runtime,\n            minAvailableModules: undefined,\n            minAvailableModulesOwned: undefined,\n            availableModulesToBeMerged: [],\n            skippedItems: undefined,\n            resultingAvailableModules: undefined,\n            children: undefined,\n            availableSources: undefined,\n            availableChildren: undefined,\n            preOrderIndex: 0,\n            postOrderIndex: 0,\n            chunkLoading: chunkGroupInfo.chunkLoading,\n            asyncChunks: chunkGroupInfo.asyncChunks\n          };\n          allCreatedChunkGroups.add(c);\n          chunkGroupInfoMap.set(c, cgi);\n\n          if (chunkName) {\n            namedChunkGroups.set(chunkName, cgi);\n          }\n        } else {\n          c = cgi.chunkGroup;\n\n          if (c.isInitial()) {\n            compilation.errors.push(new AsyncDependencyToInitialChunkError(chunkName, module, b.loc));\n            c = chunkGroup;\n          }\n\n          c.addOptions(b.groupOptions);\n          c.addOrigin(module, b.loc, b.request);\n        }\n\n        blockConnections.set(b, []);\n      }\n\n      blockChunkGroups.set(b, cgi);\n    } else if (entryOptions) {\n      entrypoint =\n      /** @type {Entrypoint} */\n      cgi.chunkGroup;\n    } else {\n      c = cgi.chunkGroup;\n    }\n\n    if (c !== undefined) {\n      // 2. We store the connection for the block\n      // to connect it later if needed\n      blockConnections.get(b).push({\n        originChunkGroupInfo: chunkGroupInfo,\n        chunkGroup: c\n      }); // 3. We enqueue the chunk group info creation/updating\n\n      let connectList = queueConnect.get(chunkGroupInfo);\n\n      if (connectList === undefined) {\n        connectList = new Set();\n        queueConnect.set(chunkGroupInfo, connectList);\n      }\n\n      connectList.add(cgi); // TODO check if this really need to be done for each traversal\n      // or if it is enough when it's queued when created\n      // 4. We enqueue the DependenciesBlock for traversal\n\n      queueDelayed.push({\n        action: PROCESS_BLOCK,\n        block: b,\n        module: module,\n        chunk: c.chunks[0],\n        chunkGroup: c,\n        chunkGroupInfo: cgi\n      });\n    } else if (entrypoint !== undefined) {\n      chunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\n    }\n  };\n  /**\n   * @param {DependenciesBlock} block the block\n   * @returns {void}\n   */\n\n\n  const processBlock = block => {\n    statProcessedBlocks++; // get prepared block info\n\n    const blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n    if (blockModules !== undefined) {\n      const {\n        minAvailableModules\n      } = chunkGroupInfo; // Buffer items because order need to be reversed to get indices correct\n      // Traverse all referenced modules\n\n      for (let i = 0; i < blockModules.length; i += 2) {\n        const refModule =\n        /** @type {Module} */\n        blockModules[i];\n\n        if (chunkGraph.isModuleInChunk(refModule, chunk)) {\n          // skip early if already connected\n          continue;\n        }\n\n        const activeState =\n        /** @type {ConnectionState} */\n        blockModules[i + 1];\n\n        if (activeState !== true) {\n          skipConnectionBuffer.push([refModule, activeState]);\n          if (activeState === false) continue;\n        }\n\n        if (activeState === true && (minAvailableModules.has(refModule) || minAvailableModules.plus.has(refModule))) {\n          // already in parent chunks, skip it for now\n          skipBuffer.push(refModule);\n          continue;\n        } // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n\n\n        queueBuffer.push({\n          action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      } // Add buffered items in reverse order\n\n\n      if (skipConnectionBuffer.length > 0) {\n        let {\n          skippedModuleConnections\n        } = chunkGroupInfo;\n\n        if (skippedModuleConnections === undefined) {\n          chunkGroupInfo.skippedModuleConnections = skippedModuleConnections = new Set();\n        }\n\n        for (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {\n          skippedModuleConnections.add(skipConnectionBuffer[i]);\n        }\n\n        skipConnectionBuffer.length = 0;\n      }\n\n      if (skipBuffer.length > 0) {\n        let {\n          skippedItems\n        } = chunkGroupInfo;\n\n        if (skippedItems === undefined) {\n          chunkGroupInfo.skippedItems = skippedItems = new Set();\n        }\n\n        for (let i = skipBuffer.length - 1; i >= 0; i--) {\n          skippedItems.add(skipBuffer[i]);\n        }\n\n        skipBuffer.length = 0;\n      }\n\n      if (queueBuffer.length > 0) {\n        for (let i = queueBuffer.length - 1; i >= 0; i--) {\n          queue.push(queueBuffer[i]);\n        }\n\n        queueBuffer.length = 0;\n      }\n    } // Traverse all Blocks\n\n\n    for (const b of block.blocks) {\n      iteratorBlock(b);\n    }\n\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n  /**\n   * @param {DependenciesBlock} block the block\n   * @returns {void}\n   */\n\n\n  const processEntryBlock = block => {\n    statProcessedBlocks++; // get prepared block info\n\n    const blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n    if (blockModules !== undefined) {\n      // Traverse all referenced modules\n      for (let i = 0; i < blockModules.length; i += 2) {\n        const refModule =\n        /** @type {Module} */\n        blockModules[i];\n        const activeState =\n        /** @type {ConnectionState} */\n        blockModules[i + 1]; // enqueue, then add and enter to be in the correct order\n        // this is relevant with circular dependencies\n\n        queueBuffer.push({\n          action: activeState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\n          block: refModule,\n          module: refModule,\n          chunk,\n          chunkGroup,\n          chunkGroupInfo\n        });\n      } // Add buffered items in reverse order\n\n\n      if (queueBuffer.length > 0) {\n        for (let i = queueBuffer.length - 1; i >= 0; i--) {\n          queue.push(queueBuffer[i]);\n        }\n\n        queueBuffer.length = 0;\n      }\n    } // Traverse all Blocks\n\n\n    for (const b of block.blocks) {\n      iteratorBlock(b);\n    }\n\n    if (block.blocks.length > 0 && module !== block) {\n      blocksWithNestedBlocks.add(block);\n    }\n  };\n\n  const processQueue = () => {\n    while (queue.length) {\n      statProcessedQueueItems++;\n      const queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n      chunkGroup = queueItem.chunkGroup;\n      chunkGroupInfo = queueItem.chunkGroupInfo;\n\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_ENTRY_MODULE:\n          chunkGraph.connectChunkAndEntryModule(chunk, module,\n          /** @type {Entrypoint} */\n          chunkGroup);\n        // fallthrough\n\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (chunkGraph.isModuleInChunk(module, chunk)) {\n              // already connected, skip it\n              break;\n            } // We connect Module and Chunk\n\n\n            chunkGraph.connectChunkAndModule(chunk, module);\n          }\n        // fallthrough\n\n        case ENTER_MODULE:\n          {\n            const index = chunkGroup.getModulePreOrderIndex(module);\n\n            if (index === undefined) {\n              chunkGroup.setModulePreOrderIndex(module, chunkGroupInfo.preOrderIndex++);\n            }\n\n            if (moduleGraph.setPreOrderIndexIfUnset(module, nextFreeModulePreOrderIndex)) {\n              nextFreeModulePreOrderIndex++;\n            } // reuse queueItem\n\n\n            queueItem.action = LEAVE_MODULE;\n            queue.push(queueItem);\n          }\n        // fallthrough\n\n        case PROCESS_BLOCK:\n          {\n            processBlock(block);\n            break;\n          }\n\n        case PROCESS_ENTRY_BLOCK:\n          {\n            processEntryBlock(block);\n            break;\n          }\n\n        case LEAVE_MODULE:\n          {\n            const index = chunkGroup.getModulePostOrderIndex(module);\n\n            if (index === undefined) {\n              chunkGroup.setModulePostOrderIndex(module, chunkGroupInfo.postOrderIndex++);\n            }\n\n            if (moduleGraph.setPostOrderIndexIfUnset(module, nextFreeModulePostOrderIndex)) {\n              nextFreeModulePostOrderIndex++;\n            }\n\n            break;\n          }\n      }\n    }\n  };\n\n  const calculateResultingAvailableModules = chunkGroupInfo => {\n    if (chunkGroupInfo.resultingAvailableModules) return chunkGroupInfo.resultingAvailableModules;\n    const minAvailableModules = chunkGroupInfo.minAvailableModules; // Create a new Set of available modules at this point\n    // We want to be as lazy as possible. There are multiple ways doing this:\n    // Note that resultingAvailableModules is stored as \"(a) + (b)\" as it's a ModuleSetPlus\n    // - resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n    // - resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n    // We choose one depending on the size of minAvailableModules vs minAvailableModules.plus\n\n    let resultingAvailableModules;\n\n    if (minAvailableModules.size > minAvailableModules.plus.size) {\n      // resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n      resultingAvailableModules =\n      /** @type {Set<Module> & {plus: Set<Module>}} */\n      new Set();\n\n      for (const module of minAvailableModules.plus) minAvailableModules.add(module);\n\n      minAvailableModules.plus = EMPTY_SET;\n      resultingAvailableModules.plus = minAvailableModules;\n      chunkGroupInfo.minAvailableModulesOwned = false;\n    } else {\n      // resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n      resultingAvailableModules =\n      /** @type {Set<Module> & {plus: Set<Module>}} */\n      new Set(minAvailableModules);\n      resultingAvailableModules.plus = minAvailableModules.plus;\n    } // add the modules from the chunk group to the set\n\n\n    for (const chunk of chunkGroupInfo.chunkGroup.chunks) {\n      for (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n        resultingAvailableModules.add(m);\n      }\n    }\n\n    return chunkGroupInfo.resultingAvailableModules = resultingAvailableModules;\n  };\n\n  const processConnectQueue = () => {\n    // Figure out new parents for chunk groups\n    // to get new available modules for these children\n    for (const [chunkGroupInfo, targets] of queueConnect) {\n      // 1. Add new targets to the list of children\n      if (chunkGroupInfo.children === undefined) {\n        chunkGroupInfo.children = targets;\n      } else {\n        for (const target of targets) {\n          chunkGroupInfo.children.add(target);\n        }\n      } // 2. Calculate resulting available modules\n\n\n      const resultingAvailableModules = calculateResultingAvailableModules(chunkGroupInfo);\n      const runtime = chunkGroupInfo.runtime; // 3. Update chunk group info\n\n      for (const target of targets) {\n        target.availableModulesToBeMerged.push(resultingAvailableModules);\n        chunkGroupsForMerging.add(target);\n        const oldRuntime = target.runtime;\n        const newRuntime = mergeRuntime(oldRuntime, runtime);\n\n        if (oldRuntime !== newRuntime) {\n          target.runtime = newRuntime;\n          outdatedChunkGroupInfo.add(target);\n        }\n      }\n\n      statConnectedChunkGroups += targets.size;\n    }\n\n    queueConnect.clear();\n  };\n\n  const processChunkGroupsForMerging = () => {\n    statProcessedChunkGroupsForMerging += chunkGroupsForMerging.size; // Execute the merge\n\n    for (const info of chunkGroupsForMerging) {\n      const availableModulesToBeMerged = info.availableModulesToBeMerged;\n      let cachedMinAvailableModules = info.minAvailableModules;\n      statMergedAvailableModuleSets += availableModulesToBeMerged.length; // 1. Get minimal available modules\n      // It doesn't make sense to traverse a chunk again with more available modules.\n      // This step calculates the minimal available modules and skips traversal when\n      // the list didn't shrink.\n\n      if (availableModulesToBeMerged.length > 1) {\n        availableModulesToBeMerged.sort(bySetSize);\n      }\n\n      let changed = false;\n\n      merge: for (const availableModules of availableModulesToBeMerged) {\n        if (cachedMinAvailableModules === undefined) {\n          cachedMinAvailableModules = availableModules;\n          info.minAvailableModules = cachedMinAvailableModules;\n          info.minAvailableModulesOwned = false;\n          changed = true;\n        } else {\n          if (info.minAvailableModulesOwned) {\n            // We own it and can modify it\n            if (cachedMinAvailableModules.plus === availableModules.plus) {\n              for (const m of cachedMinAvailableModules) {\n                if (!availableModules.has(m)) {\n                  cachedMinAvailableModules.delete(m);\n                  changed = true;\n                }\n              }\n            } else {\n              for (const m of cachedMinAvailableModules) {\n                if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                  cachedMinAvailableModules.delete(m);\n                  changed = true;\n                }\n              }\n\n              for (const m of cachedMinAvailableModules.plus) {\n                if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                  // We can't remove modules from the plus part\n                  // so we need to merge plus into the normal part to allow modifying it\n                  const iterator = cachedMinAvailableModules.plus[Symbol.iterator](); // fast forward add all modules until m\n\n                  /** @type {IteratorResult<Module>} */\n\n                  let it;\n\n                  while (!(it = iterator.next()).done) {\n                    const module = it.value;\n                    if (module === m) break;\n                    cachedMinAvailableModules.add(module);\n                  } // check the remaining modules before adding\n\n\n                  while (!(it = iterator.next()).done) {\n                    const module = it.value;\n\n                    if (availableModules.has(module) || availableModules.plus.has(module)) {\n                      cachedMinAvailableModules.add(module);\n                    }\n                  }\n\n                  cachedMinAvailableModules.plus = EMPTY_SET;\n                  changed = true;\n                  continue merge;\n                }\n              }\n            }\n          } else if (cachedMinAvailableModules.plus === availableModules.plus) {\n            // Common and fast case when the plus part is shared\n            // We only need to care about the normal part\n            if (availableModules.size < cachedMinAvailableModules.size) {\n              // the new availableModules is smaller so it's faster to\n              // fork from the new availableModules\n              statForkedAvailableModules++;\n              statForkedAvailableModulesCount += availableModules.size;\n              statForkedMergedModulesCount += cachedMinAvailableModules.size; // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\n              const newSet =\n              /** @type {ModuleSetPlus} */\n              new Set();\n              newSet.plus = availableModules.plus;\n\n              for (const m of availableModules) {\n                if (cachedMinAvailableModules.has(m)) {\n                  newSet.add(m);\n                }\n              }\n\n              statForkedResultModulesCount += newSet.size;\n              cachedMinAvailableModules = newSet;\n              info.minAvailableModulesOwned = true;\n              info.minAvailableModules = newSet;\n              changed = true;\n              continue merge;\n            }\n\n            for (const m of cachedMinAvailableModules) {\n              if (!availableModules.has(m)) {\n                // cachedMinAvailableModules need to be modified\n                // but we don't own it\n                statForkedAvailableModules++;\n                statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                statForkedMergedModulesCount += availableModules.size; // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                // as the plus part is equal we can just take over this one\n\n                const newSet =\n                /** @type {ModuleSetPlus} */\n                new Set();\n                newSet.plus = availableModules.plus;\n                const iterator = cachedMinAvailableModules[Symbol.iterator](); // fast forward add all modules until m\n\n                /** @type {IteratorResult<Module>} */\n\n                let it;\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (module === m) break;\n                  newSet.add(module);\n                } // check the remaining modules before adding\n\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n\n                  if (availableModules.has(module)) {\n                    newSet.add(module);\n                  }\n                }\n\n                statForkedResultModulesCount += newSet.size;\n                cachedMinAvailableModules = newSet;\n                info.minAvailableModulesOwned = true;\n                info.minAvailableModules = newSet;\n                changed = true;\n                continue merge;\n              }\n            }\n          } else {\n            for (const m of cachedMinAvailableModules) {\n              if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                // cachedMinAvailableModules need to be modified\n                // but we don't own it\n                statForkedAvailableModules++;\n                statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                statForkedAvailableModulesCountPlus += cachedMinAvailableModules.plus.size;\n                statForkedMergedModulesCount += availableModules.size;\n                statForkedMergedModulesCountPlus += availableModules.plus.size; // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\n                const newSet =\n                /** @type {ModuleSetPlus} */\n                new Set();\n                newSet.plus = EMPTY_SET;\n                const iterator = cachedMinAvailableModules[Symbol.iterator](); // fast forward add all modules until m\n\n                /** @type {IteratorResult<Module>} */\n\n                let it;\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (module === m) break;\n                  newSet.add(module);\n                } // check the remaining modules before adding\n\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n\n                  if (availableModules.has(module) || availableModules.plus.has(module)) {\n                    newSet.add(module);\n                  }\n                } // also check all modules in cachedMinAvailableModules.plus\n\n\n                for (const module of cachedMinAvailableModules.plus) {\n                  if (availableModules.has(module) || availableModules.plus.has(module)) {\n                    newSet.add(module);\n                  }\n                }\n\n                statForkedResultModulesCount += newSet.size;\n                cachedMinAvailableModules = newSet;\n                info.minAvailableModulesOwned = true;\n                info.minAvailableModules = newSet;\n                changed = true;\n                continue merge;\n              }\n            }\n\n            for (const m of cachedMinAvailableModules.plus) {\n              if (!availableModules.has(m) && !availableModules.plus.has(m)) {\n                // cachedMinAvailableModules need to be modified\n                // but we don't own it\n                statForkedAvailableModules++;\n                statForkedAvailableModulesCount += cachedMinAvailableModules.size;\n                statForkedAvailableModulesCountPlus += cachedMinAvailableModules.plus.size;\n                statForkedMergedModulesCount += availableModules.size;\n                statForkedMergedModulesCountPlus += availableModules.plus.size; // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n                // we already know that all modules directly from cachedMinAvailableModules are in availableModules too\n\n                const newSet =\n                /** @type {ModuleSetPlus} */\n                new Set(cachedMinAvailableModules);\n                newSet.plus = EMPTY_SET;\n                const iterator = cachedMinAvailableModules.plus[Symbol.iterator](); // fast forward add all modules until m\n\n                /** @type {IteratorResult<Module>} */\n\n                let it;\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n                  if (module === m) break;\n                  newSet.add(module);\n                } // check the remaining modules before adding\n\n\n                while (!(it = iterator.next()).done) {\n                  const module = it.value;\n\n                  if (availableModules.has(module) || availableModules.plus.has(module)) {\n                    newSet.add(module);\n                  }\n                }\n\n                statForkedResultModulesCount += newSet.size;\n                cachedMinAvailableModules = newSet;\n                info.minAvailableModulesOwned = true;\n                info.minAvailableModules = newSet;\n                changed = true;\n                continue merge;\n              }\n            }\n          }\n        }\n      }\n\n      availableModulesToBeMerged.length = 0;\n\n      if (changed) {\n        info.resultingAvailableModules = undefined;\n        outdatedChunkGroupInfo.add(info);\n      }\n    }\n\n    chunkGroupsForMerging.clear();\n  };\n\n  const processChunkGroupsForCombining = () => {\n    for (const info of chunkGroupsForCombining) {\n      for (const source of info.availableSources) {\n        if (!source.minAvailableModules) {\n          chunkGroupsForCombining.delete(info);\n          break;\n        }\n      }\n    }\n\n    for (const info of chunkGroupsForCombining) {\n      const availableModules =\n      /** @type {ModuleSetPlus} */\n      new Set();\n      availableModules.plus = EMPTY_SET;\n\n      const mergeSet = set => {\n        if (set.size > availableModules.plus.size) {\n          for (const item of availableModules.plus) availableModules.add(item);\n\n          availableModules.plus = set;\n        } else {\n          for (const item of set) availableModules.add(item);\n        }\n      }; // combine minAvailableModules from all resultingAvailableModules\n\n\n      for (const source of info.availableSources) {\n        const resultingAvailableModules = calculateResultingAvailableModules(source);\n        mergeSet(resultingAvailableModules);\n        mergeSet(resultingAvailableModules.plus);\n      }\n\n      info.minAvailableModules = availableModules;\n      info.minAvailableModulesOwned = false;\n      info.resultingAvailableModules = undefined;\n      outdatedChunkGroupInfo.add(info);\n    }\n\n    chunkGroupsForCombining.clear();\n  };\n\n  const processOutdatedChunkGroupInfo = () => {\n    statChunkGroupInfoUpdated += outdatedChunkGroupInfo.size; // Revisit skipped elements\n\n    for (const info of outdatedChunkGroupInfo) {\n      // 1. Reconsider skipped items\n      if (info.skippedItems !== undefined) {\n        const {\n          minAvailableModules\n        } = info;\n\n        for (const module of info.skippedItems) {\n          if (!minAvailableModules.has(module) && !minAvailableModules.plus.has(module)) {\n            queue.push({\n              action: ADD_AND_ENTER_MODULE,\n              block: module,\n              module,\n              chunk: info.chunkGroup.chunks[0],\n              chunkGroup: info.chunkGroup,\n              chunkGroupInfo: info\n            });\n            info.skippedItems.delete(module);\n          }\n        }\n      } // 2. Reconsider skipped connections\n\n\n      if (info.skippedModuleConnections !== undefined) {\n        const {\n          minAvailableModules\n        } = info;\n\n        for (const entry of info.skippedModuleConnections) {\n          const [module, activeState] = entry;\n          if (activeState === false) continue;\n\n          if (activeState === true) {\n            info.skippedModuleConnections.delete(entry);\n          }\n\n          if (activeState === true && (minAvailableModules.has(module) || minAvailableModules.plus.has(module))) {\n            info.skippedItems.add(module);\n            continue;\n          }\n\n          queue.push({\n            action: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n            block: module,\n            module,\n            chunk: info.chunkGroup.chunks[0],\n            chunkGroup: info.chunkGroup,\n            chunkGroupInfo: info\n          });\n        }\n      } // 2. Reconsider children chunk groups\n\n\n      if (info.children !== undefined) {\n        statChildChunkGroupsReconnected += info.children.size;\n\n        for (const cgi of info.children) {\n          let connectList = queueConnect.get(info);\n\n          if (connectList === undefined) {\n            connectList = new Set();\n            queueConnect.set(info, connectList);\n          }\n\n          connectList.add(cgi);\n        }\n      } // 3. Reconsider chunk groups for combining\n\n\n      if (info.availableChildren !== undefined) {\n        for (const cgi of info.availableChildren) {\n          chunkGroupsForCombining.add(cgi);\n        }\n      }\n    }\n\n    outdatedChunkGroupInfo.clear();\n  }; // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n\n\n  while (queue.length || queueConnect.size) {\n    logger.time(\"visitModules: visiting\");\n    processQueue();\n    logger.timeAggregateEnd(\"visitModules: prepare\");\n    logger.timeEnd(\"visitModules: visiting\");\n\n    if (chunkGroupsForCombining.size > 0) {\n      logger.time(\"visitModules: combine available modules\");\n      processChunkGroupsForCombining();\n      logger.timeEnd(\"visitModules: combine available modules\");\n    }\n\n    if (queueConnect.size > 0) {\n      logger.time(\"visitModules: calculating available modules\");\n      processConnectQueue();\n      logger.timeEnd(\"visitModules: calculating available modules\");\n\n      if (chunkGroupsForMerging.size > 0) {\n        logger.time(\"visitModules: merging available modules\");\n        processChunkGroupsForMerging();\n        logger.timeEnd(\"visitModules: merging available modules\");\n      }\n    }\n\n    if (outdatedChunkGroupInfo.size > 0) {\n      logger.time(\"visitModules: check modules for revisit\");\n      processOutdatedChunkGroupInfo();\n      logger.timeEnd(\"visitModules: check modules for revisit\");\n    } // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indexing correct\n    // Async blocks should be processed after all sync blocks are processed\n\n\n    if (queue.length === 0) {\n      const tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n\n  logger.log(`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`);\n  logger.log(`${statConnectedChunkGroups} chunk groups connected`);\n  logger.log(`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`);\n  logger.log(`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`);\n};\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\n\n\nconst connectChunkGroups = (compilation, blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) => {\n  const {\n    chunkGraph\n  } = compilation;\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {ModuleSetPlus} availableModules the comparator set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n\n  const areModulesAvailable = (chunkGroup, availableModules) => {\n    for (const chunk of chunkGroup.chunks) {\n      for (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n        if (!availableModules.has(module) && !availableModules.plus.has(module)) return false;\n      }\n    }\n\n    return true;\n  }; // For each edge in the basic chunk graph\n\n\n  for (const [block, connections] of blockConnections) {\n    // 1. Check if connection is needed\n    // When none of the dependencies need to be connected\n    // we can skip all of them\n    // It's not possible to filter each item so it doesn't create inconsistent\n    // connections and modules can only create one version\n    // TODO maybe decide this per runtime\n    if ( // TODO is this needed?\n    !blocksWithNestedBlocks.has(block) && connections.every(_ref => {\n      let {\n        chunkGroup,\n        originChunkGroupInfo\n      } = _ref;\n      return areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules);\n    })) {\n      continue;\n    } // 2. Foreach edge\n\n\n    for (let i = 0; i < connections.length; i++) {\n      const {\n        chunkGroup,\n        originChunkGroupInfo\n      } = connections[i]; // 3. Connect block with chunk\n\n      chunkGraph.connectBlockAndChunkGroup(block, chunkGroup); // 4. Connect chunk with parent\n\n      connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n    }\n  }\n};\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\n\n\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n  const {\n    chunkGraph\n  } = compilation;\n\n  for (const chunkGroup of allCreatedChunkGroups) {\n    if (chunkGroup.getNumberOfParents() === 0) {\n      for (const chunk of chunkGroup.chunks) {\n        compilation.chunks.delete(chunk);\n        chunkGraph.disconnectChunk(chunk);\n      }\n\n      chunkGraph.disconnectChunkGroup(chunkGroup);\n      chunkGroup.remove();\n    }\n  }\n};\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @returns {void}\n */\n\n\nconst buildChunkGraph = (compilation, inputEntrypointsAndModules) => {\n  const logger = compilation.getLogger(\"webpack.buildChunkGraph\"); // SHARED STATE\n\n  /** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n\n  const blockConnections = new Map();\n  /** @type {Set<ChunkGroup>} */\n\n  const allCreatedChunkGroups = new Set();\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\n  const chunkGroupInfoMap = new Map();\n  /** @type {Set<DependenciesBlock>} */\n\n  const blocksWithNestedBlocks = new Set(); // PART ONE\n\n  logger.time(\"visitModules\");\n  visitModules(logger, compilation, inputEntrypointsAndModules, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups);\n  logger.timeEnd(\"visitModules\"); // PART TWO\n\n  logger.time(\"connectChunkGroups\");\n  connectChunkGroups(compilation, blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap);\n  logger.timeEnd(\"connectChunkGroups\");\n\n  for (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) {\n    for (const chunk of chunkGroup.chunks) chunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\n  } // Cleanup work\n\n\n  logger.time(\"cleanup\");\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n  logger.timeEnd(\"cleanup\");\n};\n\nmodule.exports = buildChunkGraph;","map":{"version":3,"names":["AsyncDependencyToInitialChunkError","require","connectChunkGroupParentAndChild","ModuleGraphConnection","getEntryRuntime","mergeRuntime","EMPTY_SET","Set","plus","bySetSize","a","b","size","extractBlockModules","module","moduleGraph","runtime","blockModulesMap","blockCache","modules","arrays","queue","length","block","pop","arr","push","set","blocks","connection","getOutgoingConnections","d","dependency","m","weak","state","getActiveState","getParentBlock","index","getParentBlockIndex","dependencies","indexOf","get","i","indexMap","outer","j","undefined","merged","addConnectionStates","Map","idx","visitModules","logger","compilation","inputEntrypointsAndModules","chunkGroupInfoMap","blockConnections","blocksWithNestedBlocks","allCreatedChunkGroups","chunkGraph","moduleMemCaches","blockModulesRuntimeMap","blockModulesMapRuntime","getBlockModules","blockModules","getRootBlock","memCache","map","provide","time","timeAggregate","statProcessedQueueItems","statProcessedBlocks","statConnectedChunkGroups","statProcessedChunkGroupsForMerging","statMergedAvailableModuleSets","statForkedAvailableModules","statForkedAvailableModulesCount","statForkedAvailableModulesCountPlus","statForkedMergedModulesCount","statForkedMergedModulesCountPlus","statForkedResultModulesCount","statChunkGroupInfoUpdated","statChildChunkGroupsReconnected","nextChunkGroupIndex","nextFreeModulePreOrderIndex","nextFreeModulePostOrderIndex","blockChunkGroups","namedChunkGroups","namedAsyncEntrypoints","ADD_AND_ENTER_ENTRY_MODULE","ADD_AND_ENTER_MODULE","ENTER_MODULE","PROCESS_BLOCK","PROCESS_ENTRY_BLOCK","LEAVE_MODULE","queueConnect","chunkGroupsForCombining","chunkGroup","name","options","chunkGroupInfo","minAvailableModules","minAvailableModulesOwned","availableModulesToBeMerged","skippedItems","resultingAvailableModules","children","availableSources","availableChildren","preOrderIndex","postOrderIndex","chunkLoading","outputOptions","asyncChunks","getNumberOfParents","add","chunk","getEntrypointChunk","action","parent","parentsIterable","parentChunkGroupInfo","reverse","outdatedChunkGroupInfo","chunkGroupsForMerging","queueDelayed","skipConnectionBuffer","skipBuffer","queueBuffer","iteratorBlock","cgi","c","entrypoint","entryOptions","groupOptions","chunkName","addAsyncEntrypoint","loc","request","connectBlockAndChunkGroup","addOrigin","chunks","addChunkInGroup","isInitial","errors","addOptions","originChunkGroupInfo","connectList","processBlock","refModule","isModuleInChunk","activeState","has","skippedModuleConnections","processEntryBlock","processQueue","queueItem","connectChunkAndEntryModule","connectChunkAndModule","getModulePreOrderIndex","setModulePreOrderIndex","setPreOrderIndexIfUnset","getModulePostOrderIndex","setModulePostOrderIndex","setPostOrderIndexIfUnset","calculateResultingAvailableModules","getChunkModulesIterable","processConnectQueue","targets","target","oldRuntime","newRuntime","clear","processChunkGroupsForMerging","info","cachedMinAvailableModules","sort","changed","merge","availableModules","delete","iterator","Symbol","it","next","done","value","newSet","processChunkGroupsForCombining","source","mergeSet","item","processOutdatedChunkGroupInfo","entry","timeAggregateEnd","timeEnd","tempQueue","log","connectChunkGroups","areModulesAvailable","connections","every","cleanupUnconnectedGroups","disconnectChunk","disconnectChunkGroup","remove","buildChunkGraph","getLogger","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/buildChunkGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst { connectChunkGroupParentAndChild } = require(\"./GraphHelpers\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { getEntryRuntime, mergeRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n * @property {ChunkGroupInfo} chunkGroupInfo\n */\n\n/** @typedef {Set<Module> & { plus: Set<Module> }} ModuleSetPlus */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {RuntimeSpec} runtime the runtimes\n * @property {ModuleSetPlus} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {ModuleSetPlus[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {Set<Module>=} skippedItems modules that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<[Module, ConnectionState]>=} skippedModuleConnections referenced modules that where skipped because they were not active in this runtime\n * @property {ModuleSetPlus} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroupInfo>} children set of children chunk groups, that will be revisited when availableModules shrink\n * @property {Set<ChunkGroupInfo>} availableSources set of chunk groups that are the source for minAvailableModules\n * @property {Set<ChunkGroupInfo>} availableChildren set of chunk groups which depend on the this chunk group as availableSource\n * @property {number} preOrderIndex next pre order index\n * @property {number} postOrderIndex next post order index\n * @property {boolean} chunkLoading has a chunk loading mechanism\n * @property {boolean} asyncChunks create async chunks\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\nconst EMPTY_SET = /** @type {ModuleSetPlus} */ (new Set());\nEMPTY_SET.plus = EMPTY_SET;\n\n/**\n * @param {ModuleSetPlus} a first set\n * @param {ModuleSetPlus} b second set\n * @returns {number} cmp\n */\nconst bySetSize = (a, b) => {\n\treturn b.size + b.plus.size - a.size - a.plus.size;\n};\n\nconst extractBlockModules = (module, moduleGraph, runtime, blockModulesMap) => {\n\tlet blockCache;\n\tlet modules;\n\n\tconst arrays = [];\n\n\tconst queue = [module];\n\twhile (queue.length > 0) {\n\t\tconst block = queue.pop();\n\t\tconst arr = [];\n\t\tarrays.push(arr);\n\t\tblockModulesMap.set(block, arr);\n\t\tfor (const b of block.blocks) {\n\t\t\tqueue.push(b);\n\t\t}\n\t}\n\n\tfor (const connection of moduleGraph.getOutgoingConnections(module)) {\n\t\tconst d = connection.dependency;\n\t\t// We skip connections without dependency\n\t\tif (!d) continue;\n\t\tconst m = connection.module;\n\t\t// We skip connections without Module pointer\n\t\tif (!m) continue;\n\t\t// We skip weak connections\n\t\tif (connection.weak) continue;\n\t\tconst state = connection.getActiveState(runtime);\n\t\t// We skip inactive connections\n\t\tif (state === false) continue;\n\n\t\tconst block = moduleGraph.getParentBlock(d);\n\t\tlet index = moduleGraph.getParentBlockIndex(d);\n\n\t\t// deprecated fallback\n\t\tif (index < 0) {\n\t\t\tindex = block.dependencies.indexOf(d);\n\t\t}\n\n\t\tif (blockCache !== block) {\n\t\t\tmodules = blockModulesMap.get((blockCache = block));\n\t\t}\n\n\t\tconst i = index << 2;\n\t\tmodules[i] = m;\n\t\tmodules[i + 1] = state;\n\t}\n\n\tfor (const modules of arrays) {\n\t\tif (modules.length === 0) continue;\n\t\tlet indexMap;\n\t\tlet length = 0;\n\t\touter: for (let j = 0; j < modules.length; j += 2) {\n\t\t\tconst m = modules[j];\n\t\t\tif (m === undefined) continue;\n\t\t\tconst state = modules[j + 1];\n\t\t\tif (indexMap === undefined) {\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\tif (modules[i] === m) {\n\t\t\t\t\t\tconst merged = modules[i + 1];\n\t\t\t\t\t\tif (merged === true) continue outer;\n\t\t\t\t\t\tmodules[i + 1] = ModuleGraphConnection.addConnectionStates(\n\t\t\t\t\t\t\tmerged,\n\t\t\t\t\t\t\tstate\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmodules[length] = m;\n\t\t\t\tlength++;\n\t\t\t\tmodules[length] = state;\n\t\t\t\tlength++;\n\t\t\t\tif (length > 30) {\n\t\t\t\t\t// To avoid worse case performance, we will use an index map for\n\t\t\t\t\t// linear cost access, which allows to maintain O(n) complexity\n\t\t\t\t\t// while keeping allocations down to a minimum\n\t\t\t\t\tindexMap = new Map();\n\t\t\t\t\tfor (let i = 0; i < length; i += 2) {\n\t\t\t\t\t\tindexMap.set(modules[i], i + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst idx = indexMap.get(m);\n\t\t\t\tif (idx !== undefined) {\n\t\t\t\t\tconst merged = modules[idx];\n\t\t\t\t\tif (merged === true) continue outer;\n\t\t\t\t\tmodules[idx] = ModuleGraphConnection.addConnectionStates(\n\t\t\t\t\t\tmerged,\n\t\t\t\t\t\tstate\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tmodules[length] = m;\n\t\t\t\t\tlength++;\n\t\t\t\t\tmodules[length] = state;\n\t\t\t\t\tindexMap.set(m, length);\n\t\t\t\t\tlength++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmodules.length = length;\n\t}\n};\n\n/**\n *\n * @param {Logger} logger a logger\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nconst visitModules = (\n\tlogger,\n\tcompilation,\n\tinputEntrypointsAndModules,\n\tchunkGroupInfoMap,\n\tblockConnections,\n\tblocksWithNestedBlocks,\n\tallCreatedChunkGroups\n) => {\n\tconst { moduleGraph, chunkGraph, moduleMemCaches } = compilation;\n\n\tconst blockModulesRuntimeMap = new Map();\n\n\t/** @type {RuntimeSpec | false} */\n\tlet blockModulesMapRuntime = false;\n\tlet blockModulesMap;\n\n\t/**\n\t *\n\t * @param {DependenciesBlock} block block\n\t * @param {RuntimeSpec} runtime runtime\n\t * @returns {(Module | ConnectionState)[]} block modules in flatten tuples\n\t */\n\tconst getBlockModules = (block, runtime) => {\n\t\tif (blockModulesMapRuntime !== runtime) {\n\t\t\tblockModulesMap = blockModulesRuntimeMap.get(runtime);\n\t\t\tif (blockModulesMap === undefined) {\n\t\t\t\tblockModulesMap = new Map();\n\t\t\t\tblockModulesRuntimeMap.set(runtime, blockModulesMap);\n\t\t\t}\n\t\t}\n\t\tlet blockModules = blockModulesMap.get(block);\n\t\tif (blockModules !== undefined) return blockModules;\n\t\tconst module = /** @type {Module} */ (block.getRootBlock());\n\t\tconst memCache = moduleMemCaches && moduleMemCaches.get(module);\n\t\tif (memCache !== undefined) {\n\t\t\tconst map = memCache.provide(\n\t\t\t\t\"bundleChunkGraph.blockModules\",\n\t\t\t\truntime,\n\t\t\t\t() => {\n\t\t\t\t\tlogger.time(\"visitModules: prepare\");\n\t\t\t\t\tconst map = new Map();\n\t\t\t\t\textractBlockModules(module, moduleGraph, runtime, map);\n\t\t\t\t\tlogger.timeAggregate(\"visitModules: prepare\");\n\t\t\t\t\treturn map;\n\t\t\t\t}\n\t\t\t);\n\t\t\tfor (const [block, blockModules] of map)\n\t\t\t\tblockModulesMap.set(block, blockModules);\n\t\t\treturn map.get(block);\n\t\t} else {\n\t\t\tlogger.time(\"visitModules: prepare\");\n\t\t\textractBlockModules(module, moduleGraph, runtime, blockModulesMap);\n\t\t\tblockModules = blockModulesMap.get(block);\n\t\t\tlogger.timeAggregate(\"visitModules: prepare\");\n\t\t\treturn blockModules;\n\t\t}\n\t};\n\n\tlet statProcessedQueueItems = 0;\n\tlet statProcessedBlocks = 0;\n\tlet statConnectedChunkGroups = 0;\n\tlet statProcessedChunkGroupsForMerging = 0;\n\tlet statMergedAvailableModuleSets = 0;\n\tlet statForkedAvailableModules = 0;\n\tlet statForkedAvailableModulesCount = 0;\n\tlet statForkedAvailableModulesCountPlus = 0;\n\tlet statForkedMergedModulesCount = 0;\n\tlet statForkedMergedModulesCountPlus = 0;\n\tlet statForkedResultModulesCount = 0;\n\tlet statChunkGroupInfoUpdated = 0;\n\tlet statChildChunkGroupsReconnected = 0;\n\n\tlet nextChunkGroupIndex = 0;\n\tlet nextFreeModulePreOrderIndex = 0;\n\tlet nextFreeModulePostOrderIndex = 0;\n\n\t/** @type {Map<DependenciesBlock, ChunkGroupInfo>} */\n\tconst blockChunkGroups = new Map();\n\n\t/** @type {Map<string, ChunkGroupInfo>} */\n\tconst namedChunkGroups = new Map();\n\n\t/** @type {Map<string, ChunkGroupInfo>} */\n\tconst namedAsyncEntrypoints = new Map();\n\n\tconst ADD_AND_ENTER_ENTRY_MODULE = 0;\n\tconst ADD_AND_ENTER_MODULE = 1;\n\tconst ENTER_MODULE = 2;\n\tconst PROCESS_BLOCK = 3;\n\tconst PROCESS_ENTRY_BLOCK = 4;\n\tconst LEAVE_MODULE = 5;\n\n\t/** @type {QueueItem[]} */\n\tlet queue = [];\n\n\t/** @type {Map<ChunkGroupInfo, Set<ChunkGroupInfo>>} */\n\tconst queueConnect = new Map();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst chunkGroupsForCombining = new Set();\n\n\t// Fill queue with entrypoint modules\n\t// Create ChunkGroupInfo for entrypoints\n\tfor (const [chunkGroup, modules] of inputEntrypointsAndModules) {\n\t\tconst runtime = getEntryRuntime(\n\t\t\tcompilation,\n\t\t\tchunkGroup.name,\n\t\t\tchunkGroup.options\n\t\t);\n\t\t/** @type {ChunkGroupInfo} */\n\t\tconst chunkGroupInfo = {\n\t\t\tchunkGroup,\n\t\t\truntime,\n\t\t\tminAvailableModules: undefined,\n\t\t\tminAvailableModulesOwned: false,\n\t\t\tavailableModulesToBeMerged: [],\n\t\t\tskippedItems: undefined,\n\t\t\tresultingAvailableModules: undefined,\n\t\t\tchildren: undefined,\n\t\t\tavailableSources: undefined,\n\t\t\tavailableChildren: undefined,\n\t\t\tpreOrderIndex: 0,\n\t\t\tpostOrderIndex: 0,\n\t\t\tchunkLoading:\n\t\t\t\tchunkGroup.options.chunkLoading !== undefined\n\t\t\t\t\t? chunkGroup.options.chunkLoading !== false\n\t\t\t\t\t: compilation.outputOptions.chunkLoading !== false,\n\t\t\tasyncChunks:\n\t\t\t\tchunkGroup.options.asyncChunks !== undefined\n\t\t\t\t\t? chunkGroup.options.asyncChunks\n\t\t\t\t\t: compilation.outputOptions.asyncChunks !== false\n\t\t};\n\t\tchunkGroup.index = nextChunkGroupIndex++;\n\t\tif (chunkGroup.getNumberOfParents() > 0) {\n\t\t\t// minAvailableModules for child entrypoints are unknown yet, set to undefined.\n\t\t\t// This means no module is added until other sets are merged into\n\t\t\t// this minAvailableModules (by the parent entrypoints)\n\t\t\tconst skippedItems = new Set();\n\t\t\tfor (const module of modules) {\n\t\t\t\tskippedItems.add(module);\n\t\t\t}\n\t\t\tchunkGroupInfo.skippedItems = skippedItems;\n\t\t\tchunkGroupsForCombining.add(chunkGroupInfo);\n\t\t} else {\n\t\t\t// The application may start here: We start with an empty list of available modules\n\t\t\tchunkGroupInfo.minAvailableModules = EMPTY_SET;\n\t\t\tconst chunk = chunkGroup.getEntrypointChunk();\n\t\t\tfor (const module of modules) {\n\t\t\t\tqueue.push({\n\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\tblock: module,\n\t\t\t\t\tmodule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tchunkGroupInfoMap.set(chunkGroup, chunkGroupInfo);\n\t\tif (chunkGroup.name) {\n\t\t\tnamedChunkGroups.set(chunkGroup.name, chunkGroupInfo);\n\t\t}\n\t}\n\t// Fill availableSources with parent-child dependencies between entrypoints\n\tfor (const chunkGroupInfo of chunkGroupsForCombining) {\n\t\tconst { chunkGroup } = chunkGroupInfo;\n\t\tchunkGroupInfo.availableSources = new Set();\n\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\tconst parentChunkGroupInfo = chunkGroupInfoMap.get(parent);\n\t\t\tchunkGroupInfo.availableSources.add(parentChunkGroupInfo);\n\t\t\tif (parentChunkGroupInfo.availableChildren === undefined) {\n\t\t\t\tparentChunkGroupInfo.availableChildren = new Set();\n\t\t\t}\n\t\t\tparentChunkGroupInfo.availableChildren.add(chunkGroupInfo);\n\t\t}\n\t}\n\t// pop() is used to read from the queue\n\t// so it need to be reversed to be iterated in\n\t// correct order\n\tqueue.reverse();\n\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedChunkGroupInfo = new Set();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst chunkGroupsForMerging = new Set();\n\t/** @type {QueueItem[]} */\n\tlet queueDelayed = [];\n\n\t/** @type {[Module, ConnectionState][]} */\n\tconst skipConnectionBuffer = [];\n\t/** @type {Module[]} */\n\tconst skipBuffer = [];\n\t/** @type {QueueItem[]} */\n\tconst queueBuffer = [];\n\n\t/** @type {Module} */\n\tlet module;\n\t/** @type {Chunk} */\n\tlet chunk;\n\t/** @type {ChunkGroup} */\n\tlet chunkGroup;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {ChunkGroupInfo} */\n\tlet chunkGroupInfo;\n\n\t// For each async Block in graph\n\t/**\n\t * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n\t * @returns {void}\n\t */\n\tconst iteratorBlock = b => {\n\t\t// 1. We create a chunk group with single chunk in it for this Block\n\t\t// but only once (blockChunkGroups map)\n\t\tlet cgi = blockChunkGroups.get(b);\n\t\t/** @type {ChunkGroup} */\n\t\tlet c;\n\t\t/** @type {Entrypoint} */\n\t\tlet entrypoint;\n\t\tconst entryOptions = b.groupOptions && b.groupOptions.entryOptions;\n\t\tif (cgi === undefined) {\n\t\t\tconst chunkName = (b.groupOptions && b.groupOptions.name) || b.chunkName;\n\t\t\tif (entryOptions) {\n\t\t\t\tcgi = namedAsyncEntrypoints.get(chunkName);\n\t\t\t\tif (!cgi) {\n\t\t\t\t\tentrypoint = compilation.addAsyncEntrypoint(\n\t\t\t\t\t\tentryOptions,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tb.loc,\n\t\t\t\t\t\tb.request\n\t\t\t\t\t);\n\t\t\t\t\tentrypoint.index = nextChunkGroupIndex++;\n\t\t\t\t\tcgi = {\n\t\t\t\t\t\tchunkGroup: entrypoint,\n\t\t\t\t\t\truntime: entrypoint.options.runtime || entrypoint.name,\n\t\t\t\t\t\tminAvailableModules: EMPTY_SET,\n\t\t\t\t\t\tminAvailableModulesOwned: false,\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\tskippedItems: undefined,\n\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\tchildren: undefined,\n\t\t\t\t\t\tavailableSources: undefined,\n\t\t\t\t\t\tavailableChildren: undefined,\n\t\t\t\t\t\tpreOrderIndex: 0,\n\t\t\t\t\t\tpostOrderIndex: 0,\n\t\t\t\t\t\tchunkLoading:\n\t\t\t\t\t\t\tentryOptions.chunkLoading !== undefined\n\t\t\t\t\t\t\t\t? entryOptions.chunkLoading !== false\n\t\t\t\t\t\t\t\t: chunkGroupInfo.chunkLoading,\n\t\t\t\t\t\tasyncChunks:\n\t\t\t\t\t\t\tentryOptions.asyncChunks !== undefined\n\t\t\t\t\t\t\t\t? entryOptions.asyncChunks\n\t\t\t\t\t\t\t\t: chunkGroupInfo.asyncChunks\n\t\t\t\t\t};\n\t\t\t\t\tchunkGroupInfoMap.set(entrypoint, cgi);\n\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\tnamedAsyncEntrypoints.set(chunkName, cgi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\n\t\t\t\t\t// TODO merge entryOptions\n\t\t\t\t\tentrypoint.addOrigin(module, b.loc, b.request);\n\t\t\t\t\tchunkGraph.connectBlockAndChunkGroup(b, entrypoint);\n\t\t\t\t}\n\n\t\t\t\t// 2. We enqueue the DependenciesBlock for traversal\n\t\t\t\tqueueDelayed.push({\n\t\t\t\t\taction: PROCESS_ENTRY_BLOCK,\n\t\t\t\t\tblock: b,\n\t\t\t\t\tmodule: module,\n\t\t\t\t\tchunk: entrypoint.chunks[0],\n\t\t\t\t\tchunkGroup: entrypoint,\n\t\t\t\t\tchunkGroupInfo: cgi\n\t\t\t\t});\n\t\t\t} else if (!chunkGroupInfo.asyncChunks || !chunkGroupInfo.chunkLoading) {\n\t\t\t\t// Just queue the block into the current chunk group\n\t\t\t\tqueue.push({\n\t\t\t\t\taction: PROCESS_BLOCK,\n\t\t\t\t\tblock: b,\n\t\t\t\t\tmodule: module,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcgi = chunkName && namedChunkGroups.get(chunkName);\n\t\t\t\tif (!cgi) {\n\t\t\t\t\tc = compilation.addChunkInGroup(\n\t\t\t\t\t\tb.groupOptions || b.chunkName,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tb.loc,\n\t\t\t\t\t\tb.request\n\t\t\t\t\t);\n\t\t\t\t\tc.index = nextChunkGroupIndex++;\n\t\t\t\t\tcgi = {\n\t\t\t\t\t\tchunkGroup: c,\n\t\t\t\t\t\truntime: chunkGroupInfo.runtime,\n\t\t\t\t\t\tminAvailableModules: undefined,\n\t\t\t\t\t\tminAvailableModulesOwned: undefined,\n\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\tskippedItems: undefined,\n\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\tchildren: undefined,\n\t\t\t\t\t\tavailableSources: undefined,\n\t\t\t\t\t\tavailableChildren: undefined,\n\t\t\t\t\t\tpreOrderIndex: 0,\n\t\t\t\t\t\tpostOrderIndex: 0,\n\t\t\t\t\t\tchunkLoading: chunkGroupInfo.chunkLoading,\n\t\t\t\t\t\tasyncChunks: chunkGroupInfo.asyncChunks\n\t\t\t\t\t};\n\t\t\t\t\tallCreatedChunkGroups.add(c);\n\t\t\t\t\tchunkGroupInfoMap.set(c, cgi);\n\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\tnamedChunkGroups.set(chunkName, cgi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tc = cgi.chunkGroup;\n\t\t\t\t\tif (c.isInitial()) {\n\t\t\t\t\t\tcompilation.errors.push(\n\t\t\t\t\t\t\tnew AsyncDependencyToInitialChunkError(chunkName, module, b.loc)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tc = chunkGroup;\n\t\t\t\t\t}\n\t\t\t\t\tc.addOptions(b.groupOptions);\n\t\t\t\t\tc.addOrigin(module, b.loc, b.request);\n\t\t\t\t}\n\t\t\t\tblockConnections.set(b, []);\n\t\t\t}\n\t\t\tblockChunkGroups.set(b, cgi);\n\t\t} else if (entryOptions) {\n\t\t\tentrypoint = /** @type {Entrypoint} */ (cgi.chunkGroup);\n\t\t} else {\n\t\t\tc = cgi.chunkGroup;\n\t\t}\n\n\t\tif (c !== undefined) {\n\t\t\t// 2. We store the connection for the block\n\t\t\t// to connect it later if needed\n\t\t\tblockConnections.get(b).push({\n\t\t\t\toriginChunkGroupInfo: chunkGroupInfo,\n\t\t\t\tchunkGroup: c\n\t\t\t});\n\n\t\t\t// 3. We enqueue the chunk group info creation/updating\n\t\t\tlet connectList = queueConnect.get(chunkGroupInfo);\n\t\t\tif (connectList === undefined) {\n\t\t\t\tconnectList = new Set();\n\t\t\t\tqueueConnect.set(chunkGroupInfo, connectList);\n\t\t\t}\n\t\t\tconnectList.add(cgi);\n\n\t\t\t// TODO check if this really need to be done for each traversal\n\t\t\t// or if it is enough when it's queued when created\n\t\t\t// 4. We enqueue the DependenciesBlock for traversal\n\t\t\tqueueDelayed.push({\n\t\t\t\taction: PROCESS_BLOCK,\n\t\t\t\tblock: b,\n\t\t\t\tmodule: module,\n\t\t\t\tchunk: c.chunks[0],\n\t\t\t\tchunkGroup: c,\n\t\t\t\tchunkGroupInfo: cgi\n\t\t\t});\n\t\t} else if (entrypoint !== undefined) {\n\t\t\tchunkGroupInfo.chunkGroup.addAsyncEntrypoint(entrypoint);\n\t\t}\n\t};\n\n\t/**\n\t * @param {DependenciesBlock} block the block\n\t * @returns {void}\n\t */\n\tconst processBlock = block => {\n\t\tstatProcessedBlocks++;\n\t\t// get prepared block info\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n\t\tif (blockModules !== undefined) {\n\t\t\tconst { minAvailableModules } = chunkGroupInfo;\n\t\t\t// Buffer items because order need to be reversed to get indices correct\n\t\t\t// Traverse all referenced modules\n\t\t\tfor (let i = 0; i < blockModules.length; i += 2) {\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\tif (chunkGraph.isModuleInChunk(refModule, chunk)) {\n\t\t\t\t\t// skip early if already connected\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t);\n\t\t\t\tif (activeState !== true) {\n\t\t\t\t\tskipConnectionBuffer.push([refModule, activeState]);\n\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tactiveState === true &&\n\t\t\t\t\t(minAvailableModules.has(refModule) ||\n\t\t\t\t\t\tminAvailableModules.plus.has(refModule))\n\t\t\t\t) {\n\t\t\t\t\t// already in parent chunks, skip it for now\n\t\t\t\t\tskipBuffer.push(refModule);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// enqueue, then add and enter to be in the correct order\n\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\tqueueBuffer.push({\n\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n\t\t\t\t\tblock: refModule,\n\t\t\t\t\tmodule: refModule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Add buffered items in reverse order\n\t\t\tif (skipConnectionBuffer.length > 0) {\n\t\t\t\tlet { skippedModuleConnections } = chunkGroupInfo;\n\t\t\t\tif (skippedModuleConnections === undefined) {\n\t\t\t\t\tchunkGroupInfo.skippedModuleConnections = skippedModuleConnections =\n\t\t\t\t\t\tnew Set();\n\t\t\t\t}\n\t\t\t\tfor (let i = skipConnectionBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tskippedModuleConnections.add(skipConnectionBuffer[i]);\n\t\t\t\t}\n\t\t\t\tskipConnectionBuffer.length = 0;\n\t\t\t}\n\t\t\tif (skipBuffer.length > 0) {\n\t\t\t\tlet { skippedItems } = chunkGroupInfo;\n\t\t\t\tif (skippedItems === undefined) {\n\t\t\t\t\tchunkGroupInfo.skippedItems = skippedItems = new Set();\n\t\t\t\t}\n\t\t\t\tfor (let i = skipBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tskippedItems.add(skipBuffer[i]);\n\t\t\t\t}\n\t\t\t\tskipBuffer.length = 0;\n\t\t\t}\n\t\t\tif (queueBuffer.length > 0) {\n\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t}\n\t\t\t\tqueueBuffer.length = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Traverse all Blocks\n\t\tfor (const b of block.blocks) {\n\t\t\titeratorBlock(b);\n\t\t}\n\n\t\tif (block.blocks.length > 0 && module !== block) {\n\t\t\tblocksWithNestedBlocks.add(block);\n\t\t}\n\t};\n\n\t/**\n\t * @param {DependenciesBlock} block the block\n\t * @returns {void}\n\t */\n\tconst processEntryBlock = block => {\n\t\tstatProcessedBlocks++;\n\t\t// get prepared block info\n\t\tconst blockModules = getBlockModules(block, chunkGroupInfo.runtime);\n\n\t\tif (blockModules !== undefined) {\n\t\t\t// Traverse all referenced modules\n\t\t\tfor (let i = 0; i < blockModules.length; i += 2) {\n\t\t\t\tconst refModule = /** @type {Module} */ (blockModules[i]);\n\t\t\t\tconst activeState = /** @type {ConnectionState} */ (\n\t\t\t\t\tblockModules[i + 1]\n\t\t\t\t);\n\t\t\t\t// enqueue, then add and enter to be in the correct order\n\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\tqueueBuffer.push({\n\t\t\t\t\taction:\n\t\t\t\t\t\tactiveState === true ? ADD_AND_ENTER_ENTRY_MODULE : PROCESS_BLOCK,\n\t\t\t\t\tblock: refModule,\n\t\t\t\t\tmodule: refModule,\n\t\t\t\t\tchunk,\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\tchunkGroupInfo\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Add buffered items in reverse order\n\t\t\tif (queueBuffer.length > 0) {\n\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t}\n\t\t\t\tqueueBuffer.length = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Traverse all Blocks\n\t\tfor (const b of block.blocks) {\n\t\t\titeratorBlock(b);\n\t\t}\n\n\t\tif (block.blocks.length > 0 && module !== block) {\n\t\t\tblocksWithNestedBlocks.add(block);\n\t\t}\n\t};\n\n\tconst processQueue = () => {\n\t\twhile (queue.length) {\n\t\t\tstatProcessedQueueItems++;\n\t\t\tconst queueItem = queue.pop();\n\t\t\tmodule = queueItem.module;\n\t\t\tblock = queueItem.block;\n\t\t\tchunk = queueItem.chunk;\n\t\t\tchunkGroup = queueItem.chunkGroup;\n\t\t\tchunkGroupInfo = queueItem.chunkGroupInfo;\n\n\t\t\tswitch (queueItem.action) {\n\t\t\t\tcase ADD_AND_ENTER_ENTRY_MODULE:\n\t\t\t\t\tchunkGraph.connectChunkAndEntryModule(\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t/** @type {Entrypoint} */ (chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t// fallthrough\n\t\t\t\tcase ADD_AND_ENTER_MODULE: {\n\t\t\t\t\tif (chunkGraph.isModuleInChunk(module, chunk)) {\n\t\t\t\t\t\t// already connected, skip it\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// We connect Module and Chunk\n\t\t\t\t\tchunkGraph.connectChunkAndModule(chunk, module);\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase ENTER_MODULE: {\n\t\t\t\t\tconst index = chunkGroup.getModulePreOrderIndex(module);\n\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\tchunkGroup.setModulePreOrderIndex(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunkGroupInfo.preOrderIndex++\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tmoduleGraph.setPreOrderIndexIfUnset(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tnextFreeModulePreOrderIndex\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tnextFreeModulePreOrderIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\t// reuse queueItem\n\t\t\t\t\tqueueItem.action = LEAVE_MODULE;\n\t\t\t\t\tqueue.push(queueItem);\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase PROCESS_BLOCK: {\n\t\t\t\t\tprocessBlock(block);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase PROCESS_ENTRY_BLOCK: {\n\t\t\t\t\tprocessEntryBlock(block);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase LEAVE_MODULE: {\n\t\t\t\t\tconst index = chunkGroup.getModulePostOrderIndex(module);\n\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\tchunkGroup.setModulePostOrderIndex(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunkGroupInfo.postOrderIndex++\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tmoduleGraph.setPostOrderIndexIfUnset(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tnextFreeModulePostOrderIndex\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tnextFreeModulePostOrderIndex++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tconst calculateResultingAvailableModules = chunkGroupInfo => {\n\t\tif (chunkGroupInfo.resultingAvailableModules)\n\t\t\treturn chunkGroupInfo.resultingAvailableModules;\n\n\t\tconst minAvailableModules = chunkGroupInfo.minAvailableModules;\n\n\t\t// Create a new Set of available modules at this point\n\t\t// We want to be as lazy as possible. There are multiple ways doing this:\n\t\t// Note that resultingAvailableModules is stored as \"(a) + (b)\" as it's a ModuleSetPlus\n\t\t// - resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n\t\t// - resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n\t\t// We choose one depending on the size of minAvailableModules vs minAvailableModules.plus\n\n\t\tlet resultingAvailableModules;\n\t\tif (minAvailableModules.size > minAvailableModules.plus.size) {\n\t\t\t// resultingAvailableModules = (modules of chunk) + (minAvailableModules + minAvailableModules.plus)\n\t\t\tresultingAvailableModules =\n\t\t\t\t/** @type {Set<Module> & {plus: Set<Module>}} */ (new Set());\n\t\t\tfor (const module of minAvailableModules.plus)\n\t\t\t\tminAvailableModules.add(module);\n\t\t\tminAvailableModules.plus = EMPTY_SET;\n\t\t\tresultingAvailableModules.plus = minAvailableModules;\n\t\t\tchunkGroupInfo.minAvailableModulesOwned = false;\n\t\t} else {\n\t\t\t// resultingAvailableModules = (minAvailableModules + modules of chunk) + (minAvailableModules.plus)\n\t\t\tresultingAvailableModules =\n\t\t\t\t/** @type {Set<Module> & {plus: Set<Module>}} */ (\n\t\t\t\t\tnew Set(minAvailableModules)\n\t\t\t\t);\n\t\t\tresultingAvailableModules.plus = minAvailableModules.plus;\n\t\t}\n\n\t\t// add the modules from the chunk group to the set\n\t\tfor (const chunk of chunkGroupInfo.chunkGroup.chunks) {\n\t\t\tfor (const m of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\tresultingAvailableModules.add(m);\n\t\t\t}\n\t\t}\n\t\treturn (chunkGroupInfo.resultingAvailableModules =\n\t\t\tresultingAvailableModules);\n\t};\n\n\tconst processConnectQueue = () => {\n\t\t// Figure out new parents for chunk groups\n\t\t// to get new available modules for these children\n\t\tfor (const [chunkGroupInfo, targets] of queueConnect) {\n\t\t\t// 1. Add new targets to the list of children\n\t\t\tif (chunkGroupInfo.children === undefined) {\n\t\t\t\tchunkGroupInfo.children = targets;\n\t\t\t} else {\n\t\t\t\tfor (const target of targets) {\n\t\t\t\t\tchunkGroupInfo.children.add(target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Calculate resulting available modules\n\t\t\tconst resultingAvailableModules =\n\t\t\t\tcalculateResultingAvailableModules(chunkGroupInfo);\n\n\t\t\tconst runtime = chunkGroupInfo.runtime;\n\n\t\t\t// 3. Update chunk group info\n\t\t\tfor (const target of targets) {\n\t\t\t\ttarget.availableModulesToBeMerged.push(resultingAvailableModules);\n\t\t\t\tchunkGroupsForMerging.add(target);\n\t\t\t\tconst oldRuntime = target.runtime;\n\t\t\t\tconst newRuntime = mergeRuntime(oldRuntime, runtime);\n\t\t\t\tif (oldRuntime !== newRuntime) {\n\t\t\t\t\ttarget.runtime = newRuntime;\n\t\t\t\t\toutdatedChunkGroupInfo.add(target);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstatConnectedChunkGroups += targets.size;\n\t\t}\n\t\tqueueConnect.clear();\n\t};\n\n\tconst processChunkGroupsForMerging = () => {\n\t\tstatProcessedChunkGroupsForMerging += chunkGroupsForMerging.size;\n\n\t\t// Execute the merge\n\t\tfor (const info of chunkGroupsForMerging) {\n\t\t\tconst availableModulesToBeMerged = info.availableModulesToBeMerged;\n\t\t\tlet cachedMinAvailableModules = info.minAvailableModules;\n\n\t\t\tstatMergedAvailableModuleSets += availableModulesToBeMerged.length;\n\n\t\t\t// 1. Get minimal available modules\n\t\t\t// It doesn't make sense to traverse a chunk again with more available modules.\n\t\t\t// This step calculates the minimal available modules and skips traversal when\n\t\t\t// the list didn't shrink.\n\t\t\tif (availableModulesToBeMerged.length > 1) {\n\t\t\t\tavailableModulesToBeMerged.sort(bySetSize);\n\t\t\t}\n\t\t\tlet changed = false;\n\t\t\tmerge: for (const availableModules of availableModulesToBeMerged) {\n\t\t\t\tif (cachedMinAvailableModules === undefined) {\n\t\t\t\t\tcachedMinAvailableModules = availableModules;\n\t\t\t\t\tinfo.minAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\tinfo.minAvailableModulesOwned = false;\n\t\t\t\t\tchanged = true;\n\t\t\t\t} else {\n\t\t\t\t\tif (info.minAvailableModulesOwned) {\n\t\t\t\t\t\t// We own it and can modify it\n\t\t\t\t\t\tif (cachedMinAvailableModules.plus === availableModules.plus) {\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules.plus) {\n\t\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t\t// We can't remove modules from the plus part\n\t\t\t\t\t\t\t\t\t// so we need to merge plus into the normal part to allow modifying it\n\t\t\t\t\t\t\t\t\tconst iterator =\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus[Symbol.iterator]();\n\t\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.add(module);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus = EMPTY_SET;\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (cachedMinAvailableModules.plus === availableModules.plus) {\n\t\t\t\t\t\t// Common and fast case when the plus part is shared\n\t\t\t\t\t\t// We only need to care about the normal part\n\t\t\t\t\t\tif (availableModules.size < cachedMinAvailableModules.size) {\n\t\t\t\t\t\t\t// the new availableModules is smaller so it's faster to\n\t\t\t\t\t\t\t// fork from the new availableModules\n\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\tstatForkedAvailableModulesCount += availableModules.size;\n\t\t\t\t\t\t\tstatForkedMergedModulesCount += cachedMinAvailableModules.size;\n\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\t\t\t\t\tnewSet.plus = availableModules.plus;\n\t\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\t\tif (cachedMinAvailableModules.has(m)) {\n\t\t\t\t\t\t\t\t\tnewSet.add(m);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\t// as the plus part is equal we can just take over this one\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\t\t\t\t\t\tnewSet.plus = availableModules.plus;\n\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[Symbol.iterator]();\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (availableModules.has(module)) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCountPlus +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCountPlus += availableModules.plus.size;\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\t\t\t\t\t\tnewSet.plus = EMPTY_SET;\n\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[Symbol.iterator]();\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// also check all modules in cachedMinAvailableModules.plus\n\t\t\t\t\t\t\t\tfor (const module of cachedMinAvailableModules.plus) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const m of cachedMinAvailableModules.plus) {\n\t\t\t\t\t\t\tif (!availableModules.has(m) && !availableModules.plus.has(m)) {\n\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\tstatForkedAvailableModules++;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCount +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.size;\n\t\t\t\t\t\t\t\tstatForkedAvailableModulesCountPlus +=\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCount += availableModules.size;\n\t\t\t\t\t\t\t\tstatForkedMergedModulesCountPlus += availableModules.plus.size;\n\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\t// we already know that all modules directly from cachedMinAvailableModules are in availableModules too\n\t\t\t\t\t\t\t\tconst newSet = /** @type {ModuleSetPlus} */ (\n\t\t\t\t\t\t\t\t\tnew Set(cachedMinAvailableModules)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tnewSet.plus = EMPTY_SET;\n\t\t\t\t\t\t\t\tconst iterator =\n\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.plus[Symbol.iterator]();\n\t\t\t\t\t\t\t\t// fast forward add all modules until m\n\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// check the remaining modules before adding\n\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tavailableModules.has(module) ||\n\t\t\t\t\t\t\t\t\t\tavailableModules.plus.has(module)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstatForkedResultModulesCount += newSet.size;\n\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\tcontinue merge;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tavailableModulesToBeMerged.length = 0;\n\t\t\tif (changed) {\n\t\t\t\tinfo.resultingAvailableModules = undefined;\n\t\t\t\toutdatedChunkGroupInfo.add(info);\n\t\t\t}\n\t\t}\n\t\tchunkGroupsForMerging.clear();\n\t};\n\n\tconst processChunkGroupsForCombining = () => {\n\t\tfor (const info of chunkGroupsForCombining) {\n\t\t\tfor (const source of info.availableSources) {\n\t\t\t\tif (!source.minAvailableModules) {\n\t\t\t\t\tchunkGroupsForCombining.delete(info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const info of chunkGroupsForCombining) {\n\t\t\tconst availableModules = /** @type {ModuleSetPlus} */ (new Set());\n\t\t\tavailableModules.plus = EMPTY_SET;\n\t\t\tconst mergeSet = set => {\n\t\t\t\tif (set.size > availableModules.plus.size) {\n\t\t\t\t\tfor (const item of availableModules.plus) availableModules.add(item);\n\t\t\t\t\tavailableModules.plus = set;\n\t\t\t\t} else {\n\t\t\t\t\tfor (const item of set) availableModules.add(item);\n\t\t\t\t}\n\t\t\t};\n\t\t\t// combine minAvailableModules from all resultingAvailableModules\n\t\t\tfor (const source of info.availableSources) {\n\t\t\t\tconst resultingAvailableModules =\n\t\t\t\t\tcalculateResultingAvailableModules(source);\n\t\t\t\tmergeSet(resultingAvailableModules);\n\t\t\t\tmergeSet(resultingAvailableModules.plus);\n\t\t\t}\n\t\t\tinfo.minAvailableModules = availableModules;\n\t\t\tinfo.minAvailableModulesOwned = false;\n\t\t\tinfo.resultingAvailableModules = undefined;\n\t\t\toutdatedChunkGroupInfo.add(info);\n\t\t}\n\t\tchunkGroupsForCombining.clear();\n\t};\n\n\tconst processOutdatedChunkGroupInfo = () => {\n\t\tstatChunkGroupInfoUpdated += outdatedChunkGroupInfo.size;\n\t\t// Revisit skipped elements\n\t\tfor (const info of outdatedChunkGroupInfo) {\n\t\t\t// 1. Reconsider skipped items\n\t\t\tif (info.skippedItems !== undefined) {\n\t\t\t\tconst { minAvailableModules } = info;\n\t\t\t\tfor (const module of info.skippedItems) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!minAvailableModules.has(module) &&\n\t\t\t\t\t\t!minAvailableModules.plus.has(module)\n\t\t\t\t\t) {\n\t\t\t\t\t\tqueue.push({\n\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\tblock: module,\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\n\t\t\t\t\t\t\tchunkGroup: info.chunkGroup,\n\t\t\t\t\t\t\tchunkGroupInfo: info\n\t\t\t\t\t\t});\n\t\t\t\t\t\tinfo.skippedItems.delete(module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Reconsider skipped connections\n\t\t\tif (info.skippedModuleConnections !== undefined) {\n\t\t\t\tconst { minAvailableModules } = info;\n\t\t\t\tfor (const entry of info.skippedModuleConnections) {\n\t\t\t\t\tconst [module, activeState] = entry;\n\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\tif (activeState === true) {\n\t\t\t\t\t\tinfo.skippedModuleConnections.delete(entry);\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tactiveState === true &&\n\t\t\t\t\t\t(minAvailableModules.has(module) ||\n\t\t\t\t\t\t\tminAvailableModules.plus.has(module))\n\t\t\t\t\t) {\n\t\t\t\t\t\tinfo.skippedItems.add(module);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\taction: activeState === true ? ADD_AND_ENTER_MODULE : PROCESS_BLOCK,\n\t\t\t\t\t\tblock: module,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tchunk: info.chunkGroup.chunks[0],\n\t\t\t\t\t\tchunkGroup: info.chunkGroup,\n\t\t\t\t\t\tchunkGroupInfo: info\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 2. Reconsider children chunk groups\n\t\t\tif (info.children !== undefined) {\n\t\t\t\tstatChildChunkGroupsReconnected += info.children.size;\n\t\t\t\tfor (const cgi of info.children) {\n\t\t\t\t\tlet connectList = queueConnect.get(info);\n\t\t\t\t\tif (connectList === undefined) {\n\t\t\t\t\t\tconnectList = new Set();\n\t\t\t\t\t\tqueueConnect.set(info, connectList);\n\t\t\t\t\t}\n\t\t\t\t\tconnectList.add(cgi);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 3. Reconsider chunk groups for combining\n\t\t\tif (info.availableChildren !== undefined) {\n\t\t\t\tfor (const cgi of info.availableChildren) {\n\t\t\t\t\tchunkGroupsForCombining.add(cgi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\toutdatedChunkGroupInfo.clear();\n\t};\n\n\t// Iterative traversal of the Module graph\n\t// Recursive would be simpler to write but could result in Stack Overflows\n\twhile (queue.length || queueConnect.size) {\n\t\tlogger.time(\"visitModules: visiting\");\n\t\tprocessQueue();\n\t\tlogger.timeAggregateEnd(\"visitModules: prepare\");\n\t\tlogger.timeEnd(\"visitModules: visiting\");\n\n\t\tif (chunkGroupsForCombining.size > 0) {\n\t\t\tlogger.time(\"visitModules: combine available modules\");\n\t\t\tprocessChunkGroupsForCombining();\n\t\t\tlogger.timeEnd(\"visitModules: combine available modules\");\n\t\t}\n\n\t\tif (queueConnect.size > 0) {\n\t\t\tlogger.time(\"visitModules: calculating available modules\");\n\t\t\tprocessConnectQueue();\n\t\t\tlogger.timeEnd(\"visitModules: calculating available modules\");\n\n\t\t\tif (chunkGroupsForMerging.size > 0) {\n\t\t\t\tlogger.time(\"visitModules: merging available modules\");\n\t\t\t\tprocessChunkGroupsForMerging();\n\t\t\t\tlogger.timeEnd(\"visitModules: merging available modules\");\n\t\t\t}\n\t\t}\n\n\t\tif (outdatedChunkGroupInfo.size > 0) {\n\t\t\tlogger.time(\"visitModules: check modules for revisit\");\n\t\t\tprocessOutdatedChunkGroupInfo();\n\t\t\tlogger.timeEnd(\"visitModules: check modules for revisit\");\n\t\t}\n\n\t\t// Run queueDelayed when all items of the queue are processed\n\t\t// This is important to get the global indexing correct\n\t\t// Async blocks should be processed after all sync blocks are processed\n\t\tif (queue.length === 0) {\n\t\t\tconst tempQueue = queue;\n\t\t\tqueue = queueDelayed.reverse();\n\t\t\tqueueDelayed = tempQueue;\n\t\t}\n\t}\n\n\tlogger.log(\n\t\t`${statProcessedQueueItems} queue items processed (${statProcessedBlocks} blocks)`\n\t);\n\tlogger.log(`${statConnectedChunkGroups} chunk groups connected`);\n\tlogger.log(\n\t\t`${statProcessedChunkGroupsForMerging} chunk groups processed for merging (${statMergedAvailableModuleSets} module sets, ${statForkedAvailableModules} forked, ${statForkedAvailableModulesCount} + ${statForkedAvailableModulesCountPlus} modules forked, ${statForkedMergedModulesCount} + ${statForkedMergedModulesCountPlus} modules merged into fork, ${statForkedResultModulesCount} resulting modules)`\n\t);\n\tlogger.log(\n\t\t`${statChunkGroupInfoUpdated} chunk group info updated (${statChildChunkGroupsReconnected} already connected chunk groups reconnected)`\n\t);\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nconst connectChunkGroups = (\n\tcompilation,\n\tblocksWithNestedBlocks,\n\tblockConnections,\n\tchunkGroupInfoMap\n) => {\n\tconst { chunkGraph } = compilation;\n\n\t/**\n\t * Helper function to check if all modules of a chunk are available\n\t *\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n\t * @param {ModuleSetPlus} availableModules the comparator set\n\t * @returns {boolean} return true if all modules of a chunk are available\n\t */\n\tconst areModulesAvailable = (chunkGroup, availableModules) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tfor (const module of chunkGraph.getChunkModulesIterable(chunk)) {\n\t\t\t\tif (!availableModules.has(module) && !availableModules.plus.has(module))\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t// For each edge in the basic chunk graph\n\tfor (const [block, connections] of blockConnections) {\n\t\t// 1. Check if connection is needed\n\t\t// When none of the dependencies need to be connected\n\t\t// we can skip all of them\n\t\t// It's not possible to filter each item so it doesn't create inconsistent\n\t\t// connections and modules can only create one version\n\t\t// TODO maybe decide this per runtime\n\t\tif (\n\t\t\t// TODO is this needed?\n\t\t\t!blocksWithNestedBlocks.has(block) &&\n\t\t\tconnections.every(({ chunkGroup, originChunkGroupInfo }) =>\n\t\t\t\tareModulesAvailable(\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\toriginChunkGroupInfo.resultingAvailableModules\n\t\t\t\t)\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 2. Foreach edge\n\t\tfor (let i = 0; i < connections.length; i++) {\n\t\t\tconst { chunkGroup, originChunkGroupInfo } = connections[i];\n\n\t\t\t// 3. Connect block with chunk\n\t\t\tchunkGraph.connectBlockAndChunkGroup(block, chunkGroup);\n\n\t\t\t// 4. Connect chunk with parent\n\t\t\tconnectChunkGroupParentAndChild(\n\t\t\t\toriginChunkGroupInfo.chunkGroup,\n\t\t\t\tchunkGroup\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n\tconst { chunkGraph } = compilation;\n\n\tfor (const chunkGroup of allCreatedChunkGroups) {\n\t\tif (chunkGroup.getNumberOfParents() === 0) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tcompilation.chunks.delete(chunk);\n\t\t\t\tchunkGraph.disconnectChunk(chunk);\n\t\t\t}\n\t\t\tchunkGraph.disconnectChunkGroup(chunkGroup);\n\t\t\tchunkGroup.remove();\n\t\t}\n\t}\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Map<Entrypoint, Module[]>} inputEntrypointsAndModules chunk groups which are processed with the modules\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputEntrypointsAndModules) => {\n\tconst logger = compilation.getLogger(\"webpack.buildChunkGraph\");\n\n\t// SHARED STATE\n\n\t/** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n\tconst blockConnections = new Map();\n\n\t/** @type {Set<ChunkGroup>} */\n\tconst allCreatedChunkGroups = new Set();\n\n\t/** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\tconst chunkGroupInfoMap = new Map();\n\n\t/** @type {Set<DependenciesBlock>} */\n\tconst blocksWithNestedBlocks = new Set();\n\n\t// PART ONE\n\n\tlogger.time(\"visitModules\");\n\tvisitModules(\n\t\tlogger,\n\t\tcompilation,\n\t\tinputEntrypointsAndModules,\n\t\tchunkGroupInfoMap,\n\t\tblockConnections,\n\t\tblocksWithNestedBlocks,\n\t\tallCreatedChunkGroups\n\t);\n\tlogger.timeEnd(\"visitModules\");\n\n\t// PART TWO\n\n\tlogger.time(\"connectChunkGroups\");\n\tconnectChunkGroups(\n\t\tcompilation,\n\t\tblocksWithNestedBlocks,\n\t\tblockConnections,\n\t\tchunkGroupInfoMap\n\t);\n\tlogger.timeEnd(\"connectChunkGroups\");\n\n\tfor (const [chunkGroup, chunkGroupInfo] of chunkGroupInfoMap) {\n\t\tfor (const chunk of chunkGroup.chunks)\n\t\t\tchunk.runtime = mergeRuntime(chunk.runtime, chunkGroupInfo.runtime);\n\t}\n\n\t// Cleanup work\n\n\tlogger.time(\"cleanup\");\n\tcleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n\tlogger.timeEnd(\"cleanup\");\n};\n\nmodule.exports = buildChunkGraph;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}