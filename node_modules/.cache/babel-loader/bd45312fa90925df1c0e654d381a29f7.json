{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst {\n  SyncHook,\n  MultiHook\n} = require(\"tapable\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nconst MultiStats = require(\"./MultiStats\");\n\nconst MultiWatching = require(\"./MultiWatching\");\n\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Stats\")} Stats */\n\n/** @typedef {import(\"./Watching\")} Watching */\n\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {Object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\n\nmodule.exports = class MultiCompiler {\n  /**\n   * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n   * @param {MultiCompilerOptions} options options\n   */\n  constructor(compilers, options) {\n    if (!Array.isArray(compilers)) {\n      compilers = Object.keys(compilers).map(name => {\n        compilers[name].name = name;\n        return compilers[name];\n      });\n    }\n\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[MultiStats]>} */\n      done: new SyncHook([\"stats\"]),\n\n      /** @type {MultiHook<SyncHook<[string | null, number]>>} */\n      invalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      run: new MultiHook(compilers.map(c => c.hooks.run)),\n\n      /** @type {SyncHook<[]>} */\n      watchClose: new SyncHook([]),\n\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      watchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n\n      /** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n      infrastructureLog: new MultiHook(compilers.map(c => c.hooks.infrastructureLog))\n    });\n    this.compilers = compilers;\n    /** @type {MultiCompilerOptions} */\n\n    this._options = {\n      parallelism: options.parallelism || Infinity\n    };\n    /** @type {WeakMap<Compiler, string[]>} */\n\n    this.dependencies = new WeakMap();\n    this.running = false;\n    /** @type {Stats[]} */\n\n    const compilerStats = this.compilers.map(() => null);\n    let doneCompilers = 0;\n\n    for (let index = 0; index < this.compilers.length; index++) {\n      const compiler = this.compilers[index];\n      const compilerIndex = index;\n      let compilerDone = false;\n      compiler.hooks.done.tap(\"MultiCompiler\", stats => {\n        if (!compilerDone) {\n          compilerDone = true;\n          doneCompilers++;\n        }\n\n        compilerStats[compilerIndex] = stats;\n\n        if (doneCompilers === this.compilers.length) {\n          this.hooks.done.call(new MultiStats(compilerStats));\n        }\n      });\n      compiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n        if (compilerDone) {\n          compilerDone = false;\n          doneCompilers--;\n        }\n      });\n    }\n  }\n\n  get options() {\n    return Object.assign(this.compilers.map(c => c.options), this._options);\n  }\n\n  get outputPath() {\n    let commonPath = this.compilers[0].outputPath;\n\n    for (const compiler of this.compilers) {\n      while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n        commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n      }\n    }\n\n    if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n    return commonPath;\n  }\n\n  get inputFileSystem() {\n    throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n  }\n\n  get outputFileSystem() {\n    throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n  }\n\n  get watchFileSystem() {\n    throw new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n  }\n\n  get intermediateFileSystem() {\n    throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n  }\n  /**\n   * @param {InputFileSystem} value the new input file system\n   */\n\n\n  set inputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.inputFileSystem = value;\n    }\n  }\n  /**\n   * @param {OutputFileSystem} value the new output file system\n   */\n\n\n  set outputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.outputFileSystem = value;\n    }\n  }\n  /**\n   * @param {WatchFileSystem} value the new watch file system\n   */\n\n\n  set watchFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.watchFileSystem = value;\n    }\n  }\n  /**\n   * @param {IntermediateFileSystem} value the new intermediate file system\n   */\n\n\n  set intermediateFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.intermediateFileSystem = value;\n    }\n  }\n\n  getInfrastructureLogger(name) {\n    return this.compilers[0].getInfrastructureLogger(name);\n  }\n  /**\n   * @param {Compiler} compiler the child compiler\n   * @param {string[]} dependencies its dependencies\n   * @returns {void}\n   */\n\n\n  setDependencies(compiler, dependencies) {\n    this.dependencies.set(compiler, dependencies);\n  }\n  /**\n   * @param {Callback<MultiStats>} callback signals when the validation is complete\n   * @returns {boolean} true if the dependencies are valid\n   */\n\n\n  validateDependencies(callback) {\n    /** @type {Set<{source: Compiler, target: Compiler}>} */\n    const edges = new Set();\n    /** @type {string[]} */\n\n    const missing = [];\n\n    const targetFound = compiler => {\n      for (const edge of edges) {\n        if (edge.target === compiler) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const sortEdges = (e1, e2) => {\n      return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);\n    };\n\n    for (const source of this.compilers) {\n      const dependencies = this.dependencies.get(source);\n\n      if (dependencies) {\n        for (const dep of dependencies) {\n          const target = this.compilers.find(c => c.name === dep);\n\n          if (!target) {\n            missing.push(dep);\n          } else {\n            edges.add({\n              source,\n              target\n            });\n          }\n        }\n      }\n    }\n    /** @type {string[]} */\n\n\n    const errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n    const stack = this.compilers.filter(c => !targetFound(c));\n\n    while (stack.length > 0) {\n      const current = stack.pop();\n\n      for (const edge of edges) {\n        if (edge.source === current) {\n          edges.delete(edge);\n          const target = edge.target;\n\n          if (!targetFound(target)) {\n            stack.push(target);\n          }\n        }\n      }\n    }\n\n    if (edges.size > 0) {\n      /** @type {string[]} */\n      const lines = Array.from(edges).sort(sortEdges).map(edge => `${edge.source.name} -> ${edge.target.name}`);\n      lines.unshift(\"Circular dependency found in compiler dependencies.\");\n      errors.unshift(lines.join(\"\\n\"));\n    }\n\n    if (errors.length > 0) {\n      const message = errors.join(\"\\n\");\n      callback(new Error(message));\n      return false;\n    }\n\n    return true;\n  } // TODO webpack 6 remove\n\n  /**\n   * @deprecated This method should have been private\n   * @param {Compiler[]} compilers the child compilers\n   * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n   * @param {Callback<MultiStats>} callback the compiler's handler\n   * @returns {void}\n   */\n\n\n  runWithDependencies(compilers, fn, callback) {\n    const fulfilledNames = new Set();\n    let remainingCompilers = compilers;\n\n    const isDependencyFulfilled = d => fulfilledNames.has(d);\n\n    const getReadyCompilers = () => {\n      let readyCompilers = [];\n      let list = remainingCompilers;\n      remainingCompilers = [];\n\n      for (const c of list) {\n        const dependencies = this.dependencies.get(c);\n        const ready = !dependencies || dependencies.every(isDependencyFulfilled);\n\n        if (ready) {\n          readyCompilers.push(c);\n        } else {\n          remainingCompilers.push(c);\n        }\n      }\n\n      return readyCompilers;\n    };\n\n    const runCompilers = callback => {\n      if (remainingCompilers.length === 0) return callback();\n      asyncLib.map(getReadyCompilers(), (compiler, callback) => {\n        fn(compiler, err => {\n          if (err) return callback(err);\n          fulfilledNames.add(compiler.name);\n          runCompilers(callback);\n        });\n      }, callback);\n    };\n\n    runCompilers(callback);\n  }\n  /**\n   * @template SetupResult\n   * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n   * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n   * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n   * @returns {SetupResult[]} result of setup\n   */\n\n\n  _runGraph(setup, run, callback) {\n    /** @typedef {{ compiler: Compiler, setupResult: SetupResult, result: Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n    // State transitions for nodes:\n    // -> blocked (initial)\n    // blocked -> starting [running++] (when all parents done)\n    // queued -> starting [running++] (when processing the queue)\n    // starting -> running (when run has been called)\n    // running -> done [running--] (when compilation is done)\n    // done -> pending (when invalidated from file change)\n    // pending -> blocked [add to queue] (when invalidated from aggregated changes)\n    // done -> blocked [add to queue] (when invalidated, from parent invalidation)\n    // running -> running-outdated (when invalidated, either from change or parent invalidation)\n    // running-outdated -> blocked [running--] (when compilation is done)\n\n    /** @type {Node[]} */\n    const nodes = this.compilers.map(compiler => ({\n      compiler,\n      setupResult: undefined,\n      result: undefined,\n      state: \"blocked\",\n      children: [],\n      parents: []\n    }));\n    /** @type {Map<string, Node>} */\n\n    const compilerToNode = new Map();\n\n    for (const node of nodes) compilerToNode.set(node.compiler.name, node);\n\n    for (const node of nodes) {\n      const dependencies = this.dependencies.get(node.compiler);\n      if (!dependencies) continue;\n\n      for (const dep of dependencies) {\n        const parent = compilerToNode.get(dep);\n        node.parents.push(parent);\n        parent.children.push(node);\n      }\n    }\n    /** @type {ArrayQueue<Node>} */\n\n\n    const queue = new ArrayQueue();\n\n    for (const node of nodes) {\n      if (node.parents.length === 0) {\n        node.state = \"queued\";\n        queue.enqueue(node);\n      }\n    }\n\n    let errored = false;\n    let running = 0;\n    const parallelism = this._options.parallelism;\n    /**\n     * @param {Node} node node\n     * @param {Error=} err error\n     * @param {Stats=} stats result\n     * @returns {void}\n     */\n\n    const nodeDone = (node, err, stats) => {\n      if (errored) return;\n\n      if (err) {\n        errored = true;\n        return asyncLib.each(nodes, (node, callback) => {\n          if (node.compiler.watching) {\n            node.compiler.watching.close(callback);\n          } else {\n            callback();\n          }\n        }, () => callback(err));\n      }\n\n      node.result = stats;\n      running--;\n\n      if (node.state === \"running\") {\n        node.state = \"done\";\n\n        for (const child of node.children) {\n          if (child.state === \"blocked\") queue.enqueue(child);\n        }\n      } else if (node.state === \"running-outdated\") {\n        node.state = \"blocked\";\n        queue.enqueue(node);\n      }\n\n      processQueue();\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n\n\n    const nodeInvalidFromParent = node => {\n      if (node.state === \"done\") {\n        node.state = \"blocked\";\n      } else if (node.state === \"running\") {\n        node.state = \"running-outdated\";\n      }\n\n      for (const child of node.children) {\n        nodeInvalidFromParent(child);\n      }\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n\n\n    const nodeInvalid = node => {\n      if (node.state === \"done\") {\n        node.state = \"pending\";\n      } else if (node.state === \"running\") {\n        node.state = \"running-outdated\";\n      }\n\n      for (const child of node.children) {\n        nodeInvalidFromParent(child);\n      }\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n\n\n    const nodeChange = node => {\n      nodeInvalid(node);\n\n      if (node.state === \"pending\") {\n        node.state = \"blocked\";\n      }\n\n      if (node.state === \"blocked\") {\n        queue.enqueue(node);\n        processQueue();\n      }\n    };\n\n    const setupResults = [];\n    nodes.forEach((node, i) => {\n      setupResults.push(node.setupResult = setup(node.compiler, i, nodeDone.bind(null, node), () => node.state !== \"starting\" && node.state !== \"running\", () => nodeChange(node), () => nodeInvalid(node)));\n    });\n    let processing = true;\n\n    const processQueue = () => {\n      if (processing) return;\n      processing = true;\n      process.nextTick(processQueueWorker);\n    };\n\n    const processQueueWorker = () => {\n      while (running < parallelism && queue.length > 0 && !errored) {\n        const node = queue.dequeue();\n\n        if (node.state === \"queued\" || node.state === \"blocked\" && node.parents.every(p => p.state === \"done\")) {\n          running++;\n          node.state = \"starting\";\n          run(node.compiler, node.setupResult, nodeDone.bind(null, node));\n          node.state = \"running\";\n        }\n      }\n\n      processing = false;\n\n      if (!errored && running === 0 && nodes.every(node => node.state === \"done\")) {\n        const stats = [];\n\n        for (const node of nodes) {\n          const result = node.result;\n\n          if (result) {\n            node.result = undefined;\n            stats.push(result);\n          }\n        }\n\n        if (stats.length > 0) {\n          callback(null, new MultiStats(stats));\n        }\n      }\n    };\n\n    processQueueWorker();\n    return setupResults;\n  }\n  /**\n   * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n   * @param {Callback<MultiStats>} handler signals when the call finishes\n   * @returns {MultiWatching} a compiler watcher\n   */\n\n\n  watch(watchOptions, handler) {\n    if (this.running) {\n      return handler(new ConcurrentCompilationError());\n    }\n\n    this.running = true;\n\n    if (this.validateDependencies(handler)) {\n      const watchings = this._runGraph((compiler, idx, callback, isBlocked, setChanged, setInvalid) => {\n        const watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[idx] : watchOptions, callback);\n\n        if (watching) {\n          watching._onInvalid = setInvalid;\n          watching._onChange = setChanged;\n          watching._isBlocked = isBlocked;\n        }\n\n        return watching;\n      }, (compiler, watching, callback) => {\n        if (compiler.watching !== watching) return;\n        if (!watching.running) watching.invalidate();\n      }, handler);\n\n      return new MultiWatching(watchings, this);\n    }\n\n    return new MultiWatching([], this);\n  }\n  /**\n   * @param {Callback<MultiStats>} callback signals when the call finishes\n   * @returns {void}\n   */\n\n\n  run(callback) {\n    if (this.running) {\n      return callback(new ConcurrentCompilationError());\n    }\n\n    this.running = true;\n\n    if (this.validateDependencies(callback)) {\n      this._runGraph(() => {}, (compiler, setupResult, callback) => compiler.run(callback), (err, stats) => {\n        this.running = false;\n\n        if (callback !== undefined) {\n          return callback(err, stats);\n        }\n      });\n    }\n  }\n\n  purgeInputFileSystem() {\n    for (const compiler of this.compilers) {\n      if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n        compiler.inputFileSystem.purge();\n      }\n    }\n  }\n  /**\n   * @param {Callback<void>} callback signals when the compiler closes\n   * @returns {void}\n   */\n\n\n  close(callback) {\n    asyncLib.each(this.compilers, (compiler, callback) => {\n      compiler.close(callback);\n    }, callback);\n  }\n\n};","map":{"version":3,"names":["asyncLib","require","SyncHook","MultiHook","ConcurrentCompilationError","MultiStats","MultiWatching","ArrayQueue","module","exports","MultiCompiler","constructor","compilers","options","Array","isArray","Object","keys","map","name","hooks","freeze","done","invalid","c","run","watchClose","watchRun","infrastructureLog","_options","parallelism","Infinity","dependencies","WeakMap","running","compilerStats","doneCompilers","index","length","compiler","compilerIndex","compilerDone","tap","stats","call","assign","outputPath","commonPath","indexOf","test","replace","inputFileSystem","Error","outputFileSystem","watchFileSystem","intermediateFileSystem","value","getInfrastructureLogger","setDependencies","set","validateDependencies","callback","edges","Set","missing","targetFound","edge","target","sortEdges","e1","e2","source","localeCompare","get","dep","find","push","add","errors","m","stack","filter","current","pop","delete","size","lines","from","sort","unshift","join","message","runWithDependencies","fn","fulfilledNames","remainingCompilers","isDependencyFulfilled","d","has","getReadyCompilers","readyCompilers","list","ready","every","runCompilers","err","_runGraph","setup","nodes","setupResult","undefined","result","state","children","parents","compilerToNode","Map","node","parent","queue","enqueue","errored","nodeDone","each","watching","close","child","processQueue","nodeInvalidFromParent","nodeInvalid","nodeChange","setupResults","forEach","i","bind","processing","process","nextTick","processQueueWorker","dequeue","p","watch","watchOptions","handler","watchings","idx","isBlocked","setChanged","setInvalid","_onInvalid","_onChange","_isBlocked","invalidate","purgeInputFileSystem","purge"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/MultiCompiler.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { SyncHook, MultiHook } = require(\"tapable\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst MultiStats = require(\"./MultiStats\");\nconst MultiWatching = require(\"./MultiWatching\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Stats\")} Stats */\n/** @typedef {import(\"./Watching\")} Watching */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {Object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\nmodule.exports = class MultiCompiler {\n\t/**\n\t * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n\t * @param {MultiCompilerOptions} options options\n\t */\n\tconstructor(compilers, options) {\n\t\tif (!Array.isArray(compilers)) {\n\t\t\tcompilers = Object.keys(compilers).map(name => {\n\t\t\t\tcompilers[name].name = name;\n\t\t\t\treturn compilers[name];\n\t\t\t});\n\t\t}\n\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[MultiStats]>} */\n\t\t\tdone: new SyncHook([\"stats\"]),\n\t\t\t/** @type {MultiHook<SyncHook<[string | null, number]>>} */\n\t\t\tinvalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\trun: new MultiHook(compilers.map(c => c.hooks.run)),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\twatchClose: new SyncHook([]),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\twatchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n\t\t\t/** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n\t\t\tinfrastructureLog: new MultiHook(\n\t\t\t\tcompilers.map(c => c.hooks.infrastructureLog)\n\t\t\t)\n\t\t});\n\t\tthis.compilers = compilers;\n\t\t/** @type {MultiCompilerOptions} */\n\t\tthis._options = {\n\t\t\tparallelism: options.parallelism || Infinity\n\t\t};\n\t\t/** @type {WeakMap<Compiler, string[]>} */\n\t\tthis.dependencies = new WeakMap();\n\t\tthis.running = false;\n\n\t\t/** @type {Stats[]} */\n\t\tconst compilerStats = this.compilers.map(() => null);\n\t\tlet doneCompilers = 0;\n\t\tfor (let index = 0; index < this.compilers.length; index++) {\n\t\t\tconst compiler = this.compilers[index];\n\t\t\tconst compilerIndex = index;\n\t\t\tlet compilerDone = false;\n\t\t\tcompiler.hooks.done.tap(\"MultiCompiler\", stats => {\n\t\t\t\tif (!compilerDone) {\n\t\t\t\t\tcompilerDone = true;\n\t\t\t\t\tdoneCompilers++;\n\t\t\t\t}\n\t\t\t\tcompilerStats[compilerIndex] = stats;\n\t\t\t\tif (doneCompilers === this.compilers.length) {\n\t\t\t\t\tthis.hooks.done.call(new MultiStats(compilerStats));\n\t\t\t\t}\n\t\t\t});\n\t\t\tcompiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n\t\t\t\tif (compilerDone) {\n\t\t\t\t\tcompilerDone = false;\n\t\t\t\t\tdoneCompilers--;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tget options() {\n\t\treturn Object.assign(\n\t\t\tthis.compilers.map(c => c.options),\n\t\t\tthis._options\n\t\t);\n\t}\n\n\tget outputPath() {\n\t\tlet commonPath = this.compilers[0].outputPath;\n\t\tfor (const compiler of this.compilers) {\n\t\t\twhile (\n\t\t\t\tcompiler.outputPath.indexOf(commonPath) !== 0 &&\n\t\t\t\t/[/\\\\]/.test(commonPath)\n\t\t\t) {\n\t\t\t\tcommonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n\t\treturn commonPath;\n\t}\n\n\tget inputFileSystem() {\n\t\tthrow new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n\t}\n\n\tget outputFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\tget watchFileSystem() {\n\t\tthrow new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n\t}\n\n\tget intermediateFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\t/**\n\t * @param {InputFileSystem} value the new input file system\n\t */\n\tset inputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.inputFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {OutputFileSystem} value the new output file system\n\t */\n\tset outputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.outputFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {WatchFileSystem} value the new watch file system\n\t */\n\tset watchFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.watchFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {IntermediateFileSystem} value the new intermediate file system\n\t */\n\tset intermediateFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.intermediateFileSystem = value;\n\t\t}\n\t}\n\n\tgetInfrastructureLogger(name) {\n\t\treturn this.compilers[0].getInfrastructureLogger(name);\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the child compiler\n\t * @param {string[]} dependencies its dependencies\n\t * @returns {void}\n\t */\n\tsetDependencies(compiler, dependencies) {\n\t\tthis.dependencies.set(compiler, dependencies);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the validation is complete\n\t * @returns {boolean} true if the dependencies are valid\n\t */\n\tvalidateDependencies(callback) {\n\t\t/** @type {Set<{source: Compiler, target: Compiler}>} */\n\t\tconst edges = new Set();\n\t\t/** @type {string[]} */\n\t\tconst missing = [];\n\t\tconst targetFound = compiler => {\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.target === compiler) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tconst sortEdges = (e1, e2) => {\n\t\t\treturn (\n\t\t\t\te1.source.name.localeCompare(e2.source.name) ||\n\t\t\t\te1.target.name.localeCompare(e2.target.name)\n\t\t\t);\n\t\t};\n\t\tfor (const source of this.compilers) {\n\t\t\tconst dependencies = this.dependencies.get(source);\n\t\t\tif (dependencies) {\n\t\t\t\tfor (const dep of dependencies) {\n\t\t\t\t\tconst target = this.compilers.find(c => c.name === dep);\n\t\t\t\t\tif (!target) {\n\t\t\t\t\t\tmissing.push(dep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedges.add({\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {string[]} */\n\t\tconst errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n\t\tconst stack = this.compilers.filter(c => !targetFound(c));\n\t\twhile (stack.length > 0) {\n\t\t\tconst current = stack.pop();\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.source === current) {\n\t\t\t\t\tedges.delete(edge);\n\t\t\t\t\tconst target = edge.target;\n\t\t\t\t\tif (!targetFound(target)) {\n\t\t\t\t\t\tstack.push(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (edges.size > 0) {\n\t\t\t/** @type {string[]} */\n\t\t\tconst lines = Array.from(edges)\n\t\t\t\t.sort(sortEdges)\n\t\t\t\t.map(edge => `${edge.source.name} -> ${edge.target.name}`);\n\t\t\tlines.unshift(\"Circular dependency found in compiler dependencies.\");\n\t\t\terrors.unshift(lines.join(\"\\n\"));\n\t\t}\n\t\tif (errors.length > 0) {\n\t\t\tconst message = errors.join(\"\\n\");\n\t\t\tcallback(new Error(message));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// TODO webpack 6 remove\n\t/**\n\t * @deprecated This method should have been private\n\t * @param {Compiler[]} compilers the child compilers\n\t * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n\t * @param {Callback<MultiStats>} callback the compiler's handler\n\t * @returns {void}\n\t */\n\trunWithDependencies(compilers, fn, callback) {\n\t\tconst fulfilledNames = new Set();\n\t\tlet remainingCompilers = compilers;\n\t\tconst isDependencyFulfilled = d => fulfilledNames.has(d);\n\t\tconst getReadyCompilers = () => {\n\t\t\tlet readyCompilers = [];\n\t\t\tlet list = remainingCompilers;\n\t\t\tremainingCompilers = [];\n\t\t\tfor (const c of list) {\n\t\t\t\tconst dependencies = this.dependencies.get(c);\n\t\t\t\tconst ready =\n\t\t\t\t\t!dependencies || dependencies.every(isDependencyFulfilled);\n\t\t\t\tif (ready) {\n\t\t\t\t\treadyCompilers.push(c);\n\t\t\t\t} else {\n\t\t\t\t\tremainingCompilers.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn readyCompilers;\n\t\t};\n\t\tconst runCompilers = callback => {\n\t\t\tif (remainingCompilers.length === 0) return callback();\n\t\t\tasyncLib.map(\n\t\t\t\tgetReadyCompilers(),\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tfn(compiler, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tfulfilledNames.add(compiler.name);\n\t\t\t\t\t\trunCompilers(callback);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\t\trunCompilers(callback);\n\t}\n\n\t/**\n\t * @template SetupResult\n\t * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n\t * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n\t * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n\t * @returns {SetupResult[]} result of setup\n\t */\n\t_runGraph(setup, run, callback) {\n\t\t/** @typedef {{ compiler: Compiler, setupResult: SetupResult, result: Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n\n\t\t// State transitions for nodes:\n\t\t// -> blocked (initial)\n\t\t// blocked -> starting [running++] (when all parents done)\n\t\t// queued -> starting [running++] (when processing the queue)\n\t\t// starting -> running (when run has been called)\n\t\t// running -> done [running--] (when compilation is done)\n\t\t// done -> pending (when invalidated from file change)\n\t\t// pending -> blocked [add to queue] (when invalidated from aggregated changes)\n\t\t// done -> blocked [add to queue] (when invalidated, from parent invalidation)\n\t\t// running -> running-outdated (when invalidated, either from change or parent invalidation)\n\t\t// running-outdated -> blocked [running--] (when compilation is done)\n\n\t\t/** @type {Node[]} */\n\t\tconst nodes = this.compilers.map(compiler => ({\n\t\t\tcompiler,\n\t\t\tsetupResult: undefined,\n\t\t\tresult: undefined,\n\t\t\tstate: \"blocked\",\n\t\t\tchildren: [],\n\t\t\tparents: []\n\t\t}));\n\t\t/** @type {Map<string, Node>} */\n\t\tconst compilerToNode = new Map();\n\t\tfor (const node of nodes) compilerToNode.set(node.compiler.name, node);\n\t\tfor (const node of nodes) {\n\t\t\tconst dependencies = this.dependencies.get(node.compiler);\n\t\t\tif (!dependencies) continue;\n\t\t\tfor (const dep of dependencies) {\n\t\t\t\tconst parent = compilerToNode.get(dep);\n\t\t\t\tnode.parents.push(parent);\n\t\t\t\tparent.children.push(node);\n\t\t\t}\n\t\t}\n\t\t/** @type {ArrayQueue<Node>} */\n\t\tconst queue = new ArrayQueue();\n\t\tfor (const node of nodes) {\n\t\t\tif (node.parents.length === 0) {\n\t\t\t\tnode.state = \"queued\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t}\n\t\tlet errored = false;\n\t\tlet running = 0;\n\t\tconst parallelism = this._options.parallelism;\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @param {Error=} err error\n\t\t * @param {Stats=} stats result\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeDone = (node, err, stats) => {\n\t\t\tif (errored) return;\n\t\t\tif (err) {\n\t\t\t\terrored = true;\n\t\t\t\treturn asyncLib.each(\n\t\t\t\t\tnodes,\n\t\t\t\t\t(node, callback) => {\n\t\t\t\t\t\tif (node.compiler.watching) {\n\t\t\t\t\t\t\tnode.compiler.watching.close(callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => callback(err)\n\t\t\t\t);\n\t\t\t}\n\t\t\tnode.result = stats;\n\t\t\trunning--;\n\t\t\tif (node.state === \"running\") {\n\t\t\t\tnode.state = \"done\";\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tif (child.state === \"blocked\") queue.enqueue(child);\n\t\t\t\t}\n\t\t\t} else if (node.state === \"running-outdated\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t\tprocessQueue();\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalidFromParent = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalid = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"pending\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeChange = node => {\n\t\t\tnodeInvalid(node);\n\t\t\tif (node.state === \"pending\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t}\n\t\t\tif (node.state === \"blocked\") {\n\t\t\t\tqueue.enqueue(node);\n\t\t\t\tprocessQueue();\n\t\t\t}\n\t\t};\n\n\t\tconst setupResults = [];\n\t\tnodes.forEach((node, i) => {\n\t\t\tsetupResults.push(\n\t\t\t\t(node.setupResult = setup(\n\t\t\t\t\tnode.compiler,\n\t\t\t\t\ti,\n\t\t\t\t\tnodeDone.bind(null, node),\n\t\t\t\t\t() => node.state !== \"starting\" && node.state !== \"running\",\n\t\t\t\t\t() => nodeChange(node),\n\t\t\t\t\t() => nodeInvalid(node)\n\t\t\t\t))\n\t\t\t);\n\t\t});\n\t\tlet processing = true;\n\t\tconst processQueue = () => {\n\t\t\tif (processing) return;\n\t\t\tprocessing = true;\n\t\t\tprocess.nextTick(processQueueWorker);\n\t\t};\n\t\tconst processQueueWorker = () => {\n\t\t\twhile (running < parallelism && queue.length > 0 && !errored) {\n\t\t\t\tconst node = queue.dequeue();\n\t\t\t\tif (\n\t\t\t\t\tnode.state === \"queued\" ||\n\t\t\t\t\t(node.state === \"blocked\" &&\n\t\t\t\t\t\tnode.parents.every(p => p.state === \"done\"))\n\t\t\t\t) {\n\t\t\t\t\trunning++;\n\t\t\t\t\tnode.state = \"starting\";\n\t\t\t\t\trun(node.compiler, node.setupResult, nodeDone.bind(null, node));\n\t\t\t\t\tnode.state = \"running\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessing = false;\n\t\t\tif (\n\t\t\t\t!errored &&\n\t\t\t\trunning === 0 &&\n\t\t\t\tnodes.every(node => node.state === \"done\")\n\t\t\t) {\n\t\t\t\tconst stats = [];\n\t\t\t\tfor (const node of nodes) {\n\t\t\t\t\tconst result = node.result;\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tnode.result = undefined;\n\t\t\t\t\t\tstats.push(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (stats.length > 0) {\n\t\t\t\t\tcallback(null, new MultiStats(stats));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tprocessQueueWorker();\n\t\treturn setupResults;\n\t}\n\n\t/**\n\t * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n\t * @param {Callback<MultiStats>} handler signals when the call finishes\n\t * @returns {MultiWatching} a compiler watcher\n\t */\n\twatch(watchOptions, handler) {\n\t\tif (this.running) {\n\t\t\treturn handler(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(handler)) {\n\t\t\tconst watchings = this._runGraph(\n\t\t\t\t(compiler, idx, callback, isBlocked, setChanged, setInvalid) => {\n\t\t\t\t\tconst watching = compiler.watch(\n\t\t\t\t\t\tArray.isArray(watchOptions) ? watchOptions[idx] : watchOptions,\n\t\t\t\t\t\tcallback\n\t\t\t\t\t);\n\t\t\t\t\tif (watching) {\n\t\t\t\t\t\twatching._onInvalid = setInvalid;\n\t\t\t\t\t\twatching._onChange = setChanged;\n\t\t\t\t\t\twatching._isBlocked = isBlocked;\n\t\t\t\t\t}\n\t\t\t\t\treturn watching;\n\t\t\t\t},\n\t\t\t\t(compiler, watching, callback) => {\n\t\t\t\t\tif (compiler.watching !== watching) return;\n\t\t\t\t\tif (!watching.running) watching.invalidate();\n\t\t\t\t},\n\t\t\t\thandler\n\t\t\t);\n\t\t\treturn new MultiWatching(watchings, this);\n\t\t}\n\n\t\treturn new MultiWatching([], this);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(callback)) {\n\t\t\tthis._runGraph(\n\t\t\t\t() => {},\n\t\t\t\t(compiler, setupResult, callback) => compiler.run(callback),\n\t\t\t\t(err, stats) => {\n\t\t\t\t\tthis.running = false;\n\n\t\t\t\t\tif (callback !== undefined) {\n\t\t\t\t\t\treturn callback(err, stats);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tif (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n\t\t\t\tcompiler.inputFileSystem.purge();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the compiler closes\n\t * @returns {void}\n\t */\n\tclose(callback) {\n\t\tasyncLib.each(\n\t\t\tthis.compilers,\n\t\t\t(compiler, callback) => {\n\t\t\t\tcompiler.close(callback);\n\t\t\t},\n\t\t\tcallback\n\t\t);\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}