{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\"use strict\";\n\nconst {\n  UsageState\n} = require(\"../ExportsInfo\");\n/** @typedef {import(\"estree\").Node} AnyNode */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {Map<TopLevelSymbol | null, Set<string | TopLevelSymbol> | true>} InnerGraph */\n\n/** @typedef {function(boolean | Set<string> | undefined): void} UsageCallback */\n\n/**\n * @typedef {Object} StateObject\n * @property {InnerGraph} innerGraph\n * @property {TopLevelSymbol=} currentTopLevelSymbol\n * @property {Map<TopLevelSymbol, Set<UsageCallback>>} usageCallbackMap\n */\n\n/** @typedef {false|StateObject} State */\n\n/** @type {WeakMap<ParserState, State>} */\n\n\nconst parserStateMap = new WeakMap();\nconst topLevelSymbolTag = Symbol(\"top level symbol\");\n/**\n * @param {ParserState} parserState parser state\n * @returns {State} state\n */\n\nfunction getState(parserState) {\n  return parserStateMap.get(parserState);\n}\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\n\n\nexports.bailout = parserState => {\n  parserStateMap.set(parserState, false);\n};\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\n\n\nexports.enable = parserState => {\n  const state = parserStateMap.get(parserState);\n\n  if (state === false) {\n    return;\n  }\n\n  parserStateMap.set(parserState, {\n    innerGraph: new Map(),\n    currentTopLevelSymbol: undefined,\n    usageCallbackMap: new Map()\n  });\n};\n/**\n * @param {ParserState} parserState parser state\n * @returns {boolean} true, when enabled\n */\n\n\nexports.isEnabled = parserState => {\n  const state = parserStateMap.get(parserState);\n  return !!state;\n};\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol | null} symbol the symbol, or null for all symbols\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\n\n\nexports.addUsage = (state, symbol, usage) => {\n  const innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    const {\n      innerGraph\n    } = innerGraphState;\n    const info = innerGraph.get(symbol);\n\n    if (usage === true) {\n      innerGraph.set(symbol, true);\n    } else if (info === undefined) {\n      innerGraph.set(symbol, new Set([usage]));\n    } else if (info !== true) {\n      info.add(usage);\n    }\n  }\n};\n/**\n * @param {JavascriptParser} parser the parser\n * @param {string} name name of variable\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\n\n\nexports.addVariableUsage = (parser, name, usage) => {\n  const symbol =\n  /** @type {TopLevelSymbol} */\n  parser.getTagData(name, topLevelSymbolTag) || exports.tagTopLevelSymbol(parser, name);\n\n  if (symbol) {\n    exports.addUsage(parser.state, symbol, usage);\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @returns {void}\n */\n\n\nexports.inferDependencyUsage = state => {\n  const innerGraphState = getState(state);\n\n  if (!innerGraphState) {\n    return;\n  }\n\n  const {\n    innerGraph,\n    usageCallbackMap\n  } = innerGraphState;\n  const processed = new Map(); // flatten graph to terminal nodes (string, undefined or true)\n\n  const nonTerminal = new Set(innerGraph.keys());\n\n  while (nonTerminal.size > 0) {\n    for (const key of nonTerminal) {\n      /** @type {Set<string|TopLevelSymbol> | true} */\n      let newSet = new Set();\n      let isTerminal = true;\n      const value = innerGraph.get(key);\n      let alreadyProcessed = processed.get(key);\n\n      if (alreadyProcessed === undefined) {\n        alreadyProcessed = new Set();\n        processed.set(key, alreadyProcessed);\n      }\n\n      if (value !== true && value !== undefined) {\n        for (const item of value) {\n          alreadyProcessed.add(item);\n        }\n\n        for (const item of value) {\n          if (typeof item === \"string\") {\n            newSet.add(item);\n          } else {\n            const itemValue = innerGraph.get(item);\n\n            if (itemValue === true) {\n              newSet = true;\n              break;\n            }\n\n            if (itemValue !== undefined) {\n              for (const i of itemValue) {\n                if (i === key) continue;\n                if (alreadyProcessed.has(i)) continue;\n                newSet.add(i);\n\n                if (typeof i !== \"string\") {\n                  isTerminal = false;\n                }\n              }\n            }\n          }\n        }\n\n        if (newSet === true) {\n          innerGraph.set(key, true);\n        } else if (newSet.size === 0) {\n          innerGraph.set(key, undefined);\n        } else {\n          innerGraph.set(key, newSet);\n        }\n      }\n\n      if (isTerminal) {\n        nonTerminal.delete(key); // For the global key, merge with all other keys\n\n        if (key === null) {\n          const globalValue = innerGraph.get(null);\n\n          if (globalValue) {\n            for (const [key, value] of innerGraph) {\n              if (key !== null && value !== true) {\n                if (globalValue === true) {\n                  innerGraph.set(key, true);\n                } else {\n                  const newSet = new Set(value);\n\n                  for (const item of globalValue) {\n                    newSet.add(item);\n                  }\n\n                  innerGraph.set(key, newSet);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  /** @type {Map<Dependency, true | Set<string>>} */\n\n\n  for (const [symbol, callbacks] of usageCallbackMap) {\n    const usage =\n    /** @type {true | Set<string> | undefined} */\n    innerGraph.get(symbol);\n\n    for (const callback of callbacks) {\n      callback(usage === undefined ? false : usage);\n    }\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @param {UsageCallback} onUsageCallback on usage callback\n */\n\n\nexports.onUsage = (state, onUsageCallback) => {\n  const innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    const {\n      usageCallbackMap,\n      currentTopLevelSymbol\n    } = innerGraphState;\n\n    if (currentTopLevelSymbol) {\n      let callbacks = usageCallbackMap.get(currentTopLevelSymbol);\n\n      if (callbacks === undefined) {\n        callbacks = new Set();\n        usageCallbackMap.set(currentTopLevelSymbol, callbacks);\n      }\n\n      callbacks.add(onUsageCallback);\n    } else {\n      onUsageCallback(true);\n    }\n  } else {\n    onUsageCallback(undefined);\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol} symbol the symbol\n */\n\n\nexports.setTopLevelSymbol = (state, symbol) => {\n  const innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    innerGraphState.currentTopLevelSymbol = symbol;\n  }\n};\n/**\n * @param {ParserState} state parser state\n * @returns {TopLevelSymbol|void} usage data\n */\n\n\nexports.getTopLevelSymbol = state => {\n  const innerGraphState = getState(state);\n\n  if (innerGraphState) {\n    return innerGraphState.currentTopLevelSymbol;\n  }\n};\n/**\n * @param {JavascriptParser} parser parser\n * @param {string} name name of variable\n * @returns {TopLevelSymbol} symbol\n */\n\n\nexports.tagTopLevelSymbol = (parser, name) => {\n  const innerGraphState = getState(parser.state);\n  if (!innerGraphState) return;\n  parser.defineVariable(name);\n  const existingTag =\n  /** @type {TopLevelSymbol} */\n  parser.getTagData(name, topLevelSymbolTag);\n\n  if (existingTag) {\n    return existingTag;\n  }\n\n  const fn = new TopLevelSymbol(name);\n  parser.tagVariable(name, topLevelSymbolTag, fn);\n  return fn;\n};\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {RuntimeSpec} runtime runtime\n * @returns {boolean} false, when unused. Otherwise true\n */\n\n\nexports.isDependencyUsedByExports = (dependency, usedByExports, moduleGraph, runtime) => {\n  if (usedByExports === false) return false;\n\n  if (usedByExports !== true && usedByExports !== undefined) {\n    const selfModule = moduleGraph.getParentModule(dependency);\n    const exportsInfo = moduleGraph.getExportsInfo(selfModule);\n    let used = false;\n\n    for (const exportName of usedByExports) {\n      if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) used = true;\n    }\n\n    if (!used) return false;\n  }\n\n  return true;\n};\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @returns {null | false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState} function to determine if the connection is active\n */\n\n\nexports.getDependencyUsedByExportsCondition = (dependency, usedByExports, moduleGraph) => {\n  if (usedByExports === false) return false;\n\n  if (usedByExports !== true && usedByExports !== undefined) {\n    const selfModule = moduleGraph.getParentModule(dependency);\n    const exportsInfo = moduleGraph.getExportsInfo(selfModule);\n    return (connections, runtime) => {\n      for (const exportName of usedByExports) {\n        if (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused) return true;\n      }\n\n      return false;\n    };\n  }\n\n  return null;\n};\n\nclass TopLevelSymbol {\n  /**\n   * @param {string} name name of the variable\n   */\n  constructor(name) {\n    this.name = name;\n  }\n\n}\n\nexports.TopLevelSymbol = TopLevelSymbol;\nexports.topLevelSymbolTag = topLevelSymbolTag;","map":{"version":3,"names":["UsageState","require","parserStateMap","WeakMap","topLevelSymbolTag","Symbol","getState","parserState","get","exports","bailout","set","enable","state","innerGraph","Map","currentTopLevelSymbol","undefined","usageCallbackMap","isEnabled","addUsage","symbol","usage","innerGraphState","info","Set","add","addVariableUsage","parser","name","getTagData","tagTopLevelSymbol","inferDependencyUsage","processed","nonTerminal","keys","size","key","newSet","isTerminal","value","alreadyProcessed","item","itemValue","i","has","delete","globalValue","callbacks","callback","onUsage","onUsageCallback","setTopLevelSymbol","getTopLevelSymbol","defineVariable","existingTag","fn","TopLevelSymbol","tagVariable","isDependencyUsedByExports","dependency","usedByExports","moduleGraph","runtime","selfModule","getParentModule","exportsInfo","getExportsInfo","used","exportName","getUsed","Unused","getDependencyUsedByExportsCondition","connections","constructor"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/optimize/InnerGraph.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Sergey Melyukov @smelukov\n*/\n\n\"use strict\";\n\nconst { UsageState } = require(\"../ExportsInfo\");\n\n/** @typedef {import(\"estree\").Node} AnyNode */\n/** @typedef {import(\"../Dependency\")} Dependency */\n/** @typedef {import(\"../ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"../ModuleGraphConnection\")} ModuleGraphConnection */\n/** @typedef {import(\"../ModuleGraphConnection\").ConnectionState} ConnectionState */\n/** @typedef {import(\"../Parser\").ParserState} ParserState */\n/** @typedef {import(\"../javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/** @typedef {Map<TopLevelSymbol | null, Set<string | TopLevelSymbol> | true>} InnerGraph */\n/** @typedef {function(boolean | Set<string> | undefined): void} UsageCallback */\n\n/**\n * @typedef {Object} StateObject\n * @property {InnerGraph} innerGraph\n * @property {TopLevelSymbol=} currentTopLevelSymbol\n * @property {Map<TopLevelSymbol, Set<UsageCallback>>} usageCallbackMap\n */\n\n/** @typedef {false|StateObject} State */\n\n/** @type {WeakMap<ParserState, State>} */\nconst parserStateMap = new WeakMap();\nconst topLevelSymbolTag = Symbol(\"top level symbol\");\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {State} state\n */\nfunction getState(parserState) {\n\treturn parserStateMap.get(parserState);\n}\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.bailout = parserState => {\n\tparserStateMap.set(parserState, false);\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {void}\n */\nexports.enable = parserState => {\n\tconst state = parserStateMap.get(parserState);\n\tif (state === false) {\n\t\treturn;\n\t}\n\tparserStateMap.set(parserState, {\n\t\tinnerGraph: new Map(),\n\t\tcurrentTopLevelSymbol: undefined,\n\t\tusageCallbackMap: new Map()\n\t});\n};\n\n/**\n * @param {ParserState} parserState parser state\n * @returns {boolean} true, when enabled\n */\nexports.isEnabled = parserState => {\n\tconst state = parserStateMap.get(parserState);\n\treturn !!state;\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol | null} symbol the symbol, or null for all symbols\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addUsage = (state, symbol, usage) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tconst { innerGraph } = innerGraphState;\n\t\tconst info = innerGraph.get(symbol);\n\t\tif (usage === true) {\n\t\t\tinnerGraph.set(symbol, true);\n\t\t} else if (info === undefined) {\n\t\t\tinnerGraph.set(symbol, new Set([usage]));\n\t\t} else if (info !== true) {\n\t\t\tinfo.add(usage);\n\t\t}\n\t}\n};\n\n/**\n * @param {JavascriptParser} parser the parser\n * @param {string} name name of variable\n * @param {string | TopLevelSymbol | true} usage usage data\n * @returns {void}\n */\nexports.addVariableUsage = (parser, name, usage) => {\n\tconst symbol =\n\t\t/** @type {TopLevelSymbol} */ (\n\t\t\tparser.getTagData(name, topLevelSymbolTag)\n\t\t) || exports.tagTopLevelSymbol(parser, name);\n\tif (symbol) {\n\t\texports.addUsage(parser.state, symbol, usage);\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {void}\n */\nexports.inferDependencyUsage = state => {\n\tconst innerGraphState = getState(state);\n\n\tif (!innerGraphState) {\n\t\treturn;\n\t}\n\n\tconst { innerGraph, usageCallbackMap } = innerGraphState;\n\tconst processed = new Map();\n\t// flatten graph to terminal nodes (string, undefined or true)\n\tconst nonTerminal = new Set(innerGraph.keys());\n\twhile (nonTerminal.size > 0) {\n\t\tfor (const key of nonTerminal) {\n\t\t\t/** @type {Set<string|TopLevelSymbol> | true} */\n\t\t\tlet newSet = new Set();\n\t\t\tlet isTerminal = true;\n\t\t\tconst value = innerGraph.get(key);\n\t\t\tlet alreadyProcessed = processed.get(key);\n\t\t\tif (alreadyProcessed === undefined) {\n\t\t\t\talreadyProcessed = new Set();\n\t\t\t\tprocessed.set(key, alreadyProcessed);\n\t\t\t}\n\t\t\tif (value !== true && value !== undefined) {\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\talreadyProcessed.add(item);\n\t\t\t\t}\n\t\t\t\tfor (const item of value) {\n\t\t\t\t\tif (typeof item === \"string\") {\n\t\t\t\t\t\tnewSet.add(item);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst itemValue = innerGraph.get(item);\n\t\t\t\t\t\tif (itemValue === true) {\n\t\t\t\t\t\t\tnewSet = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (itemValue !== undefined) {\n\t\t\t\t\t\t\tfor (const i of itemValue) {\n\t\t\t\t\t\t\t\tif (i === key) continue;\n\t\t\t\t\t\t\t\tif (alreadyProcessed.has(i)) continue;\n\t\t\t\t\t\t\t\tnewSet.add(i);\n\t\t\t\t\t\t\t\tif (typeof i !== \"string\") {\n\t\t\t\t\t\t\t\t\tisTerminal = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (newSet === true) {\n\t\t\t\t\tinnerGraph.set(key, true);\n\t\t\t\t} else if (newSet.size === 0) {\n\t\t\t\t\tinnerGraph.set(key, undefined);\n\t\t\t\t} else {\n\t\t\t\t\tinnerGraph.set(key, newSet);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isTerminal) {\n\t\t\t\tnonTerminal.delete(key);\n\n\t\t\t\t// For the global key, merge with all other keys\n\t\t\t\tif (key === null) {\n\t\t\t\t\tconst globalValue = innerGraph.get(null);\n\t\t\t\t\tif (globalValue) {\n\t\t\t\t\t\tfor (const [key, value] of innerGraph) {\n\t\t\t\t\t\t\tif (key !== null && value !== true) {\n\t\t\t\t\t\t\t\tif (globalValue === true) {\n\t\t\t\t\t\t\t\t\tinnerGraph.set(key, true);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst newSet = new Set(value);\n\t\t\t\t\t\t\t\t\tfor (const item of globalValue) {\n\t\t\t\t\t\t\t\t\t\tnewSet.add(item);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinnerGraph.set(key, newSet);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** @type {Map<Dependency, true | Set<string>>} */\n\tfor (const [symbol, callbacks] of usageCallbackMap) {\n\t\tconst usage = /** @type {true | Set<string> | undefined} */ (\n\t\t\tinnerGraph.get(symbol)\n\t\t);\n\t\tfor (const callback of callbacks) {\n\t\t\tcallback(usage === undefined ? false : usage);\n\t\t}\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {UsageCallback} onUsageCallback on usage callback\n */\nexports.onUsage = (state, onUsageCallback) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tconst { usageCallbackMap, currentTopLevelSymbol } = innerGraphState;\n\t\tif (currentTopLevelSymbol) {\n\t\t\tlet callbacks = usageCallbackMap.get(currentTopLevelSymbol);\n\n\t\t\tif (callbacks === undefined) {\n\t\t\t\tcallbacks = new Set();\n\t\t\t\tusageCallbackMap.set(currentTopLevelSymbol, callbacks);\n\t\t\t}\n\n\t\t\tcallbacks.add(onUsageCallback);\n\t\t} else {\n\t\t\tonUsageCallback(true);\n\t\t}\n\t} else {\n\t\tonUsageCallback(undefined);\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @param {TopLevelSymbol} symbol the symbol\n */\nexports.setTopLevelSymbol = (state, symbol) => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\tinnerGraphState.currentTopLevelSymbol = symbol;\n\t}\n};\n\n/**\n * @param {ParserState} state parser state\n * @returns {TopLevelSymbol|void} usage data\n */\nexports.getTopLevelSymbol = state => {\n\tconst innerGraphState = getState(state);\n\n\tif (innerGraphState) {\n\t\treturn innerGraphState.currentTopLevelSymbol;\n\t}\n};\n\n/**\n * @param {JavascriptParser} parser parser\n * @param {string} name name of variable\n * @returns {TopLevelSymbol} symbol\n */\nexports.tagTopLevelSymbol = (parser, name) => {\n\tconst innerGraphState = getState(parser.state);\n\tif (!innerGraphState) return;\n\n\tparser.defineVariable(name);\n\n\tconst existingTag = /** @type {TopLevelSymbol} */ (\n\t\tparser.getTagData(name, topLevelSymbolTag)\n\t);\n\tif (existingTag) {\n\t\treturn existingTag;\n\t}\n\n\tconst fn = new TopLevelSymbol(name);\n\tparser.tagVariable(name, topLevelSymbolTag, fn);\n\treturn fn;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @param {RuntimeSpec} runtime runtime\n * @returns {boolean} false, when unused. Otherwise true\n */\nexports.isDependencyUsedByExports = (\n\tdependency,\n\tusedByExports,\n\tmoduleGraph,\n\truntime\n) => {\n\tif (usedByExports === false) return false;\n\tif (usedByExports !== true && usedByExports !== undefined) {\n\t\tconst selfModule = moduleGraph.getParentModule(dependency);\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(selfModule);\n\t\tlet used = false;\n\t\tfor (const exportName of usedByExports) {\n\t\t\tif (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused)\n\t\t\t\tused = true;\n\t\t}\n\t\tif (!used) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {Dependency} dependency the dependency\n * @param {Set<string> | boolean} usedByExports usedByExports info\n * @param {ModuleGraph} moduleGraph moduleGraph\n * @returns {null | false | function(ModuleGraphConnection, RuntimeSpec): ConnectionState} function to determine if the connection is active\n */\nexports.getDependencyUsedByExportsCondition = (\n\tdependency,\n\tusedByExports,\n\tmoduleGraph\n) => {\n\tif (usedByExports === false) return false;\n\tif (usedByExports !== true && usedByExports !== undefined) {\n\t\tconst selfModule = moduleGraph.getParentModule(dependency);\n\t\tconst exportsInfo = moduleGraph.getExportsInfo(selfModule);\n\t\treturn (connections, runtime) => {\n\t\t\tfor (const exportName of usedByExports) {\n\t\t\t\tif (exportsInfo.getUsed(exportName, runtime) !== UsageState.Unused)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t}\n\treturn null;\n};\n\nclass TopLevelSymbol {\n\t/**\n\t * @param {string} name name of the variable\n\t */\n\tconstructor(name) {\n\t\tthis.name = name;\n\t}\n}\n\nexports.TopLevelSymbol = TopLevelSymbol;\nexports.topLevelSymbolTag = topLevelSymbolTag;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}