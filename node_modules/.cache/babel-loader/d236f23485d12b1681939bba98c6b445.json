{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst NO_MARKER = 0;\nconst IN_PROGRESS_MARKER = 1;\nconst DONE_MARKER = 2;\nconst DONE_MAYBE_ROOT_CYCLE_MARKER = 3;\nconst DONE_AND_ROOT_MARKER = 4;\n/**\n * @template T\n */\n\nclass Node {\n  /**\n   * @param {T} item the value of the node\n   */\n  constructor(item) {\n    this.item = item;\n    /** @type {Set<Node<T>>} */\n\n    this.dependencies = new Set();\n    this.marker = NO_MARKER;\n    /** @type {Cycle<T> | undefined} */\n\n    this.cycle = undefined;\n    this.incoming = 0;\n  }\n\n}\n/**\n * @template T\n */\n\n\nclass Cycle {\n  constructor() {\n    /** @type {Set<Node<T>>} */\n    this.nodes = new Set();\n  }\n\n}\n/**\n * @template T\n * @typedef {Object} StackEntry\n * @property {Node<T>} node\n * @property {Node<T>[]} openEdges\n */\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items\n * @param {function(T): Iterable<T>} getDependencies function to get dependencies of an item (items that are not in list are ignored)\n * @returns {Iterable<T>} graph roots of the items\n */\n\n\nmodule.exports = (items, getDependencies) => {\n  /** @type {Map<T, Node<T>>} */\n  const itemToNode = new Map();\n\n  for (const item of items) {\n    const node = new Node(item);\n    itemToNode.set(item, node);\n  } // early exit when there is only a single item\n\n\n  if (itemToNode.size <= 1) return items; // grab all the dependencies\n\n  for (const node of itemToNode.values()) {\n    for (const dep of getDependencies(node.item)) {\n      const depNode = itemToNode.get(dep);\n\n      if (depNode !== undefined) {\n        node.dependencies.add(depNode);\n      }\n    }\n  } // Set of current root modules\n  // items will be removed if a new reference to it has been found\n\n  /** @type {Set<Node<T>>} */\n\n\n  const roots = new Set(); // Set of current cycles without references to it\n  // cycles will be removed if a new reference to it has been found\n  // that is not part of the cycle\n\n  /** @type {Set<Cycle<T>>} */\n\n  const rootCycles = new Set(); // For all non-marked nodes\n\n  for (const selectedNode of itemToNode.values()) {\n    if (selectedNode.marker === NO_MARKER) {\n      // deep-walk all referenced modules\n      // in a non-recursive way\n      // start by entering the selected node\n      selectedNode.marker = IN_PROGRESS_MARKER; // keep a stack to avoid recursive walk\n\n      /** @type {StackEntry<T>[]} */\n\n      const stack = [{\n        node: selectedNode,\n        openEdges: Array.from(selectedNode.dependencies)\n      }]; // process the top item until stack is empty\n\n      while (stack.length > 0) {\n        const topOfStack = stack[stack.length - 1]; // Are there still edges unprocessed in the current node?\n\n        if (topOfStack.openEdges.length > 0) {\n          // Process one dependency\n          const dependency = topOfStack.openEdges.pop();\n\n          switch (dependency.marker) {\n            case NO_MARKER:\n              // dependency has not be visited yet\n              // mark it as in-progress and recurse\n              stack.push({\n                node: dependency,\n                openEdges: Array.from(dependency.dependencies)\n              });\n              dependency.marker = IN_PROGRESS_MARKER;\n              break;\n\n            case IN_PROGRESS_MARKER:\n              {\n                // It's a in-progress cycle\n                let cycle = dependency.cycle;\n\n                if (!cycle) {\n                  cycle = new Cycle();\n                  cycle.nodes.add(dependency);\n                  dependency.cycle = cycle;\n                } // set cycle property for each node in the cycle\n                // if nodes are already part of a cycle\n                // we merge the cycles to a shared cycle\n\n\n                for (let i = stack.length - 1; stack[i].node !== dependency; i--) {\n                  const node = stack[i].node;\n\n                  if (node.cycle) {\n                    if (node.cycle !== cycle) {\n                      // merge cycles\n                      for (const cycleNode of node.cycle.nodes) {\n                        cycleNode.cycle = cycle;\n                        cycle.nodes.add(cycleNode);\n                      }\n                    }\n                  } else {\n                    node.cycle = cycle;\n                    cycle.nodes.add(node);\n                  }\n                } // don't recurse into dependencies\n                // these are already on the stack\n\n\n                break;\n              }\n\n            case DONE_AND_ROOT_MARKER:\n              // This node has be visited yet and is currently a root node\n              // But as this is a new reference to the node\n              // it's not really a root\n              // so we have to convert it to a normal node\n              dependency.marker = DONE_MARKER;\n              roots.delete(dependency);\n              break;\n\n            case DONE_MAYBE_ROOT_CYCLE_MARKER:\n              // This node has be visited yet and\n              // is maybe currently part of a completed root cycle\n              // we found a new reference to the cycle\n              // so it's not really a root cycle\n              // remove the cycle from the root cycles\n              // and convert it to a normal node\n              rootCycles.delete(dependency.cycle);\n              dependency.marker = DONE_MARKER;\n              break;\n            // DONE_MARKER: nothing to do, don't recurse into dependencies\n          }\n        } else {\n          // All dependencies of the current node has been visited\n          // we leave the node\n          stack.pop();\n          topOfStack.node.marker = DONE_MARKER;\n        }\n      }\n\n      const cycle = selectedNode.cycle;\n\n      if (cycle) {\n        for (const node of cycle.nodes) {\n          node.marker = DONE_MAYBE_ROOT_CYCLE_MARKER;\n        }\n\n        rootCycles.add(cycle);\n      } else {\n        selectedNode.marker = DONE_AND_ROOT_MARKER;\n        roots.add(selectedNode);\n      }\n    }\n  } // Extract roots from root cycles\n  // We take the nodes with most incoming edges\n  // inside of the cycle\n\n\n  for (const cycle of rootCycles) {\n    let max = 0;\n    /** @type {Set<Node<T>>} */\n\n    const cycleRoots = new Set();\n    const nodes = cycle.nodes;\n\n    for (const node of nodes) {\n      for (const dep of node.dependencies) {\n        if (nodes.has(dep)) {\n          dep.incoming++;\n          if (dep.incoming < max) continue;\n\n          if (dep.incoming > max) {\n            cycleRoots.clear();\n            max = dep.incoming;\n          }\n\n          cycleRoots.add(dep);\n        }\n      }\n    }\n\n    for (const cycleRoot of cycleRoots) {\n      roots.add(cycleRoot);\n    }\n  } // When roots were found, return them\n\n\n  if (roots.size > 0) {\n    return Array.from(roots, r => r.item);\n  } else {\n    throw new Error(\"Implementation of findGraphRoots is broken\");\n  }\n};","map":{"version":3,"names":["NO_MARKER","IN_PROGRESS_MARKER","DONE_MARKER","DONE_MAYBE_ROOT_CYCLE_MARKER","DONE_AND_ROOT_MARKER","Node","constructor","item","dependencies","Set","marker","cycle","undefined","incoming","Cycle","nodes","module","exports","items","getDependencies","itemToNode","Map","node","set","size","values","dep","depNode","get","add","roots","rootCycles","selectedNode","stack","openEdges","Array","from","length","topOfStack","dependency","pop","push","i","cycleNode","delete","max","cycleRoots","has","clear","cycleRoot","r","Error"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/util/findGraphRoots.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NO_MARKER = 0;\nconst IN_PROGRESS_MARKER = 1;\nconst DONE_MARKER = 2;\nconst DONE_MAYBE_ROOT_CYCLE_MARKER = 3;\nconst DONE_AND_ROOT_MARKER = 4;\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item the value of the node\n\t */\n\tconstructor(item) {\n\t\tthis.item = item;\n\t\t/** @type {Set<Node<T>>} */\n\t\tthis.dependencies = new Set();\n\t\tthis.marker = NO_MARKER;\n\t\t/** @type {Cycle<T> | undefined} */\n\t\tthis.cycle = undefined;\n\t\tthis.incoming = 0;\n\t}\n}\n\n/**\n * @template T\n */\nclass Cycle {\n\tconstructor() {\n\t\t/** @type {Set<Node<T>>} */\n\t\tthis.nodes = new Set();\n\t}\n}\n\n/**\n * @template T\n * @typedef {Object} StackEntry\n * @property {Node<T>} node\n * @property {Node<T>[]} openEdges\n */\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items\n * @param {function(T): Iterable<T>} getDependencies function to get dependencies of an item (items that are not in list are ignored)\n * @returns {Iterable<T>} graph roots of the items\n */\nmodule.exports = (items, getDependencies) => {\n\t/** @type {Map<T, Node<T>>} */\n\tconst itemToNode = new Map();\n\tfor (const item of items) {\n\t\tconst node = new Node(item);\n\t\titemToNode.set(item, node);\n\t}\n\n\t// early exit when there is only a single item\n\tif (itemToNode.size <= 1) return items;\n\n\t// grab all the dependencies\n\tfor (const node of itemToNode.values()) {\n\t\tfor (const dep of getDependencies(node.item)) {\n\t\t\tconst depNode = itemToNode.get(dep);\n\t\t\tif (depNode !== undefined) {\n\t\t\t\tnode.dependencies.add(depNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set of current root modules\n\t// items will be removed if a new reference to it has been found\n\t/** @type {Set<Node<T>>} */\n\tconst roots = new Set();\n\n\t// Set of current cycles without references to it\n\t// cycles will be removed if a new reference to it has been found\n\t// that is not part of the cycle\n\t/** @type {Set<Cycle<T>>} */\n\tconst rootCycles = new Set();\n\n\t// For all non-marked nodes\n\tfor (const selectedNode of itemToNode.values()) {\n\t\tif (selectedNode.marker === NO_MARKER) {\n\t\t\t// deep-walk all referenced modules\n\t\t\t// in a non-recursive way\n\n\t\t\t// start by entering the selected node\n\t\t\tselectedNode.marker = IN_PROGRESS_MARKER;\n\n\t\t\t// keep a stack to avoid recursive walk\n\t\t\t/** @type {StackEntry<T>[]} */\n\t\t\tconst stack = [\n\t\t\t\t{\n\t\t\t\t\tnode: selectedNode,\n\t\t\t\t\topenEdges: Array.from(selectedNode.dependencies)\n\t\t\t\t}\n\t\t\t];\n\n\t\t\t// process the top item until stack is empty\n\t\t\twhile (stack.length > 0) {\n\t\t\t\tconst topOfStack = stack[stack.length - 1];\n\n\t\t\t\t// Are there still edges unprocessed in the current node?\n\t\t\t\tif (topOfStack.openEdges.length > 0) {\n\t\t\t\t\t// Process one dependency\n\t\t\t\t\tconst dependency = topOfStack.openEdges.pop();\n\t\t\t\t\tswitch (dependency.marker) {\n\t\t\t\t\t\tcase NO_MARKER:\n\t\t\t\t\t\t\t// dependency has not be visited yet\n\t\t\t\t\t\t\t// mark it as in-progress and recurse\n\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\tnode: dependency,\n\t\t\t\t\t\t\t\topenEdges: Array.from(dependency.dependencies)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdependency.marker = IN_PROGRESS_MARKER;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_PROGRESS_MARKER: {\n\t\t\t\t\t\t\t// It's a in-progress cycle\n\t\t\t\t\t\t\tlet cycle = dependency.cycle;\n\t\t\t\t\t\t\tif (!cycle) {\n\t\t\t\t\t\t\t\tcycle = new Cycle();\n\t\t\t\t\t\t\t\tcycle.nodes.add(dependency);\n\t\t\t\t\t\t\t\tdependency.cycle = cycle;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// set cycle property for each node in the cycle\n\t\t\t\t\t\t\t// if nodes are already part of a cycle\n\t\t\t\t\t\t\t// we merge the cycles to a shared cycle\n\t\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\t\tlet i = stack.length - 1;\n\t\t\t\t\t\t\t\tstack[i].node !== dependency;\n\t\t\t\t\t\t\t\ti--\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst node = stack[i].node;\n\t\t\t\t\t\t\t\tif (node.cycle) {\n\t\t\t\t\t\t\t\t\tif (node.cycle !== cycle) {\n\t\t\t\t\t\t\t\t\t\t// merge cycles\n\t\t\t\t\t\t\t\t\t\tfor (const cycleNode of node.cycle.nodes) {\n\t\t\t\t\t\t\t\t\t\t\tcycleNode.cycle = cycle;\n\t\t\t\t\t\t\t\t\t\t\tcycle.nodes.add(cycleNode);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnode.cycle = cycle;\n\t\t\t\t\t\t\t\t\tcycle.nodes.add(node);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// don't recurse into dependencies\n\t\t\t\t\t\t\t// these are already on the stack\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcase DONE_AND_ROOT_MARKER:\n\t\t\t\t\t\t\t// This node has be visited yet and is currently a root node\n\t\t\t\t\t\t\t// But as this is a new reference to the node\n\t\t\t\t\t\t\t// it's not really a root\n\t\t\t\t\t\t\t// so we have to convert it to a normal node\n\t\t\t\t\t\t\tdependency.marker = DONE_MARKER;\n\t\t\t\t\t\t\troots.delete(dependency);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase DONE_MAYBE_ROOT_CYCLE_MARKER:\n\t\t\t\t\t\t\t// This node has be visited yet and\n\t\t\t\t\t\t\t// is maybe currently part of a completed root cycle\n\t\t\t\t\t\t\t// we found a new reference to the cycle\n\t\t\t\t\t\t\t// so it's not really a root cycle\n\t\t\t\t\t\t\t// remove the cycle from the root cycles\n\t\t\t\t\t\t\t// and convert it to a normal node\n\t\t\t\t\t\t\trootCycles.delete(dependency.cycle);\n\t\t\t\t\t\t\tdependency.marker = DONE_MARKER;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// DONE_MARKER: nothing to do, don't recurse into dependencies\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// All dependencies of the current node has been visited\n\t\t\t\t\t// we leave the node\n\t\t\t\t\tstack.pop();\n\t\t\t\t\ttopOfStack.node.marker = DONE_MARKER;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst cycle = selectedNode.cycle;\n\t\t\tif (cycle) {\n\t\t\t\tfor (const node of cycle.nodes) {\n\t\t\t\t\tnode.marker = DONE_MAYBE_ROOT_CYCLE_MARKER;\n\t\t\t\t}\n\t\t\t\trootCycles.add(cycle);\n\t\t\t} else {\n\t\t\t\tselectedNode.marker = DONE_AND_ROOT_MARKER;\n\t\t\t\troots.add(selectedNode);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Extract roots from root cycles\n\t// We take the nodes with most incoming edges\n\t// inside of the cycle\n\tfor (const cycle of rootCycles) {\n\t\tlet max = 0;\n\t\t/** @type {Set<Node<T>>} */\n\t\tconst cycleRoots = new Set();\n\t\tconst nodes = cycle.nodes;\n\t\tfor (const node of nodes) {\n\t\t\tfor (const dep of node.dependencies) {\n\t\t\t\tif (nodes.has(dep)) {\n\t\t\t\t\tdep.incoming++;\n\t\t\t\t\tif (dep.incoming < max) continue;\n\t\t\t\t\tif (dep.incoming > max) {\n\t\t\t\t\t\tcycleRoots.clear();\n\t\t\t\t\t\tmax = dep.incoming;\n\t\t\t\t\t}\n\t\t\t\t\tcycleRoots.add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const cycleRoot of cycleRoots) {\n\t\t\troots.add(cycleRoot);\n\t\t}\n\t}\n\n\t// When roots were found, return them\n\tif (roots.size > 0) {\n\t\treturn Array.from(roots, r => r.item);\n\t} else {\n\t\tthrow new Error(\"Implementation of findGraphRoots is broken\");\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}