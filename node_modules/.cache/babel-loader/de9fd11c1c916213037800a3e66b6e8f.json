{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.resolveURI = factory());\n})(this, function () {\n  'use strict'; // Matches the scheme of a URL, eg \"http://\"\n\n  const schemeRegex = /^[\\w+.-]+:\\/\\//;\n  /**\n   * Matches the parts of a URL:\n   * 1. Scheme, including \":\", guaranteed.\n   * 2. User/password, including \"@\", optional.\n   * 3. Host, guaranteed.\n   * 4. Port, including \":\", optional.\n   * 5. Path, including \"/\", optional.\n   */\n\n  const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?/;\n  /**\n   * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n   * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n   *\n   * 1. Host, optional.\n   * 2. Path, which may inclue \"/\", guaranteed.\n   */\n\n  const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/]*)?)?(\\/?.*)/i;\n\n  function isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n  }\n\n  function isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n  }\n\n  function isAbsolutePath(input) {\n    return input.startsWith('/');\n  }\n\n  function isFileUrl(input) {\n    return input.startsWith('file:');\n  }\n\n  function parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/');\n  }\n\n  function parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path);\n  }\n\n  function makeUrl(scheme, user, host, port, path) {\n    return {\n      scheme,\n      user,\n      host,\n      port,\n      path,\n      relativePath: false\n    };\n  }\n\n  function parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n      const url = parseAbsoluteUrl('http:' + input);\n      url.scheme = '';\n      return url;\n    }\n\n    if (isAbsolutePath(input)) {\n      const url = parseAbsoluteUrl('http://foo.com' + input);\n      url.scheme = '';\n      url.host = '';\n      return url;\n    }\n\n    if (isFileUrl(input)) return parseFileUrl(input);\n    if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.relativePath = true;\n    return url;\n  }\n\n  function stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..')) return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n\n  function mergePaths(url, base) {\n    // If we're not a relative path, then we're an absolute path, and it doesn't matter what base is.\n    if (!url.relativePath) return;\n    normalizePath(base); // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n\n    if (url.path === '/') {\n      url.path = base.path;\n    } else {\n      // Resolution happens relative to the base path's directory, not the file.\n      url.path = stripPathFilename(base.path) + url.path;\n    } // If the base path is absolute, then our path is now absolute too.\n\n\n    url.relativePath = base.relativePath;\n  }\n  /**\n   * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n   * \"foo/.\". We need to normalize to a standard representation.\n   */\n\n\n  function normalizePath(url) {\n    const {\n      relativePath\n    } = url;\n    const pieces = url.path.split('/'); // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n\n    let pointer = 1; // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n\n    let positive = 0; // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n\n    let addTrailingSlash = false;\n\n    for (let i = 1; i < pieces.length; i++) {\n      const piece = pieces[i]; // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n\n      if (!piece) {\n        addTrailingSlash = true;\n        continue;\n      } // If we encounter a real directory, then we don't need to append anymore.\n\n\n      addTrailingSlash = false; // A current directory, which we can always drop.\n\n      if (piece === '.') continue; // A parent directory, we need to see if there are any real directories we can pop. Else, we\n      // have an excess of parents, and we'll need to keep the \"..\".\n\n      if (piece === '..') {\n        if (positive) {\n          addTrailingSlash = true;\n          positive--;\n          pointer--;\n        } else if (relativePath) {\n          // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n          // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n          pieces[pointer++] = piece;\n        }\n\n        continue;\n      } // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n      // any popped or dropped directories.\n\n\n      pieces[pointer++] = piece;\n      positive++;\n    }\n\n    let path = '';\n\n    for (let i = 1; i < pointer; i++) {\n      path += '/' + pieces[i];\n    }\n\n    if (!path || addTrailingSlash && !path.endsWith('/..')) {\n      path += '/';\n    }\n\n    url.path = path;\n  }\n  /**\n   * Attempts to resolve `input` URL/path relative to `base`.\n   */\n\n\n  function resolve(input, base) {\n    if (!input && !base) return '';\n    const url = parseUrl(input); // If we have a base, and the input isn't already an absolute URL, then we need to merge.\n\n    if (base && !url.scheme) {\n      const baseUrl = parseUrl(base);\n      url.scheme = baseUrl.scheme; // If there's no host, then we were just a path.\n\n      if (!url.host) {\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      }\n\n      mergePaths(url, baseUrl);\n    }\n\n    normalizePath(url); // If the input (and base, if there was one) are both relative, then we need to output a relative.\n\n    if (url.relativePath) {\n      // The first char is always a \"/\".\n      const path = url.path.slice(1);\n      if (!path) return '.'; // If base started with a leading \".\", or there is no base and input started with a \".\", then we\n      // need to ensure that the relative path starts with a \".\". We don't know if relative starts\n      // with a \"..\", though, so check before prepending.\n\n      const keepRelative = (base || input).startsWith('.');\n      return !keepRelative || path.startsWith('.') ? path : './' + path;\n    } // If there's no host (and no scheme/user/port), then we need to output an absolute path.\n\n\n    if (!url.scheme && !url.host) return url.path; // We're outputting either an absolute URL, or a protocol relative one.\n\n    return `${url.scheme}//${url.user}${url.host}${url.port}${url.path}`;\n  }\n\n  return resolve;\n});","map":{"version":3,"mappings":"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","names":["schemeRegex","urlRegex","fileRegex","isAbsoluteUrl","input","test","isSchemeRelativeUrl","startsWith","isAbsolutePath","isFileUrl","parseAbsoluteUrl","match","exec","makeUrl","parseFileUrl","path","scheme","user","host","port","relativePath","parseUrl","url","stripPathFilename","endsWith","index","lastIndexOf","slice","mergePaths","base","normalizePath","pieces","split","pointer","positive","addTrailingSlash","i","length","piece","resolve","baseUrl","keepRelative"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/@jridgewell/src/resolve-uri.ts"],"sourcesContent":["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may inclue \"/\", guaranteed.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/]*)?)?(\\/?.*)/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  relativePath: boolean;\n};\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/');\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path);\n}\n\nfunction makeUrl(scheme: string, user: string, host: string, port: string, path: string): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    relativePath: false,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.relativePath = true;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  // If we're not a relative path, then we're an absolute path, and it doesn't matter what base is.\n  if (!url.relativePath) return;\n\n  normalizePath(base);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n\n  // If the base path is absolute, then our path is now absolute too.\n  url.relativePath = base.relativePath;\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url) {\n  const { relativePath } = url;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (relativePath) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n\n  // If we have a base, and the input isn't already an absolute URL, then we need to merge.\n  if (base && !url.scheme) {\n    const baseUrl = parseUrl(base);\n    url.scheme = baseUrl.scheme;\n    // If there's no host, then we were just a path.\n    if (!url.host) {\n      // The host, user, and port are joined, you can't copy one without the others.\n      url.user = baseUrl.user;\n      url.host = baseUrl.host;\n      url.port = baseUrl.port;\n    }\n    mergePaths(url, baseUrl);\n  }\n\n  normalizePath(url);\n\n  // If the input (and base, if there was one) are both relative, then we need to output a relative.\n  if (url.relativePath) {\n    // The first char is always a \"/\".\n    const path = url.path.slice(1);\n    if (!path) return '.';\n\n    // If base started with a leading \".\", or there is no base and input started with a \".\", then we\n    // need to ensure that the relative path starts with a \".\". We don't know if relative starts\n    // with a \"..\", though, so check before prepending.\n    const keepRelative = (base || input).startsWith('.');\n    return !keepRelative || path.startsWith('.') ? path : './' + path;\n  }\n  // If there's no host (and no scheme/user/port), then we need to output an absolute path.\n  if (!url.scheme && !url.host) return url.path;\n  // We're outputting either an absolute URL, or a protocol relative one.\n  return `${url.scheme}//${url.user}${url.host}${url.port}${url.path}`;\n}\n"]},"metadata":{},"sourceType":"script"}