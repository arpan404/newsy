{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst Queue = require(\"./util/Queue\");\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Dependency\").ExportSpec} ExportSpec */\n\n/** @typedef {import(\"./Dependency\").ExportsSpec} ExportsSpec */\n\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n\n/** @typedef {import(\"./Module\")} Module */\n\n\nclass FlagDependencyExportsPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"FlagDependencyExportsPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      const cache = compilation.getCache(\"FlagDependencyExportsPlugin\");\n      compilation.hooks.finishModules.tapAsync(\"FlagDependencyExportsPlugin\", (modules, callback) => {\n        const logger = compilation.getLogger(\"webpack.FlagDependencyExportsPlugin\");\n        let statRestoredFromMemCache = 0;\n        let statRestoredFromCache = 0;\n        let statNoExports = 0;\n        let statFlaggedUncached = 0;\n        let statNotCached = 0;\n        let statQueueItemsProcessed = 0;\n        const {\n          moduleMemCaches\n        } = compilation;\n        /** @type {Queue<Module>} */\n\n        const queue = new Queue(); // Step 1: Try to restore cached provided export info from cache\n\n        logger.time(\"restore cached provided exports\");\n        asyncLib.each(modules, (module, callback) => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n\n          if (!module.buildMeta || !module.buildMeta.exportsType) {\n            if (exportsInfo.otherExportsInfo.provided !== null) {\n              // It's a module without declared exports\n              statNoExports++;\n              exportsInfo.setHasProvideInfo();\n              exportsInfo.setUnknownExportsProvided();\n              return callback();\n            }\n          }\n\n          if (typeof module.buildInfo.hash !== \"string\") {\n            statFlaggedUncached++; // Enqueue uncacheable module for determining the exports\n\n            queue.enqueue(module);\n            exportsInfo.setHasProvideInfo();\n            return callback();\n          }\n\n          const memCache = moduleMemCaches && moduleMemCaches.get(module);\n          const memCacheValue = memCache && memCache.get(this);\n\n          if (memCacheValue !== undefined) {\n            statRestoredFromMemCache++;\n            exportsInfo.restoreProvided(memCacheValue);\n            return callback();\n          }\n\n          cache.get(module.identifier(), module.buildInfo.hash, (err, result) => {\n            if (err) return callback(err);\n\n            if (result !== undefined) {\n              statRestoredFromCache++;\n              exportsInfo.restoreProvided(result);\n            } else {\n              statNotCached++; // Without cached info enqueue module for determining the exports\n\n              queue.enqueue(module);\n              exportsInfo.setHasProvideInfo();\n            }\n\n            callback();\n          });\n        }, err => {\n          logger.timeEnd(\"restore cached provided exports\");\n          if (err) return callback(err);\n          /** @type {Set<Module>} */\n\n          const modulesToStore = new Set();\n          /** @type {Map<Module, Set<Module>>} */\n\n          const dependencies = new Map();\n          /** @type {Module} */\n\n          let module;\n          /** @type {ExportsInfo} */\n\n          let exportsInfo;\n          /** @type {Map<Dependency, ExportsSpec>} */\n\n          const exportsSpecsFromDependencies = new Map();\n          let cacheable = true;\n          let changed = false;\n          /**\n           * @param {DependenciesBlock} depBlock the dependencies block\n           * @returns {void}\n           */\n\n          const processDependenciesBlock = depBlock => {\n            for (const dep of depBlock.dependencies) {\n              processDependency(dep);\n            }\n\n            for (const block of depBlock.blocks) {\n              processDependenciesBlock(block);\n            }\n          };\n          /**\n           * @param {Dependency} dep the dependency\n           * @returns {void}\n           */\n\n\n          const processDependency = dep => {\n            const exportDesc = dep.getExports(moduleGraph);\n            if (!exportDesc) return;\n            exportsSpecsFromDependencies.set(dep, exportDesc);\n          };\n          /**\n           * @param {Dependency} dep dependency\n           * @param {ExportsSpec} exportDesc info\n           * @returns {void}\n           */\n\n\n          const processExportsSpec = (dep, exportDesc) => {\n            const exports = exportDesc.exports;\n            const globalCanMangle = exportDesc.canMangle;\n            const globalFrom = exportDesc.from;\n            const globalPriority = exportDesc.priority;\n            const globalTerminalBinding = exportDesc.terminalBinding || false;\n            const exportDeps = exportDesc.dependencies;\n\n            if (exportDesc.hideExports) {\n              for (const name of exportDesc.hideExports) {\n                const exportInfo = exportsInfo.getExportInfo(name);\n                exportInfo.unsetTarget(dep);\n              }\n            }\n\n            if (exports === true) {\n              // unknown exports\n              if (exportsInfo.setUnknownExportsProvided(globalCanMangle, exportDesc.excludeExports, globalFrom && dep, globalFrom, globalPriority)) {\n                changed = true;\n              }\n            } else if (Array.isArray(exports)) {\n              /**\n               * merge in new exports\n               * @param {ExportsInfo} exportsInfo own exports info\n               * @param {(ExportSpec | string)[]} exports list of exports\n               */\n              const mergeExports = (exportsInfo, exports) => {\n                for (const exportNameOrSpec of exports) {\n                  let name;\n                  let canMangle = globalCanMangle;\n                  let terminalBinding = globalTerminalBinding;\n                  let exports = undefined;\n                  let from = globalFrom;\n                  let fromExport = undefined;\n                  let priority = globalPriority;\n                  let hidden = false;\n\n                  if (typeof exportNameOrSpec === \"string\") {\n                    name = exportNameOrSpec;\n                  } else {\n                    name = exportNameOrSpec.name;\n                    if (exportNameOrSpec.canMangle !== undefined) canMangle = exportNameOrSpec.canMangle;\n                    if (exportNameOrSpec.export !== undefined) fromExport = exportNameOrSpec.export;\n                    if (exportNameOrSpec.exports !== undefined) exports = exportNameOrSpec.exports;\n                    if (exportNameOrSpec.from !== undefined) from = exportNameOrSpec.from;\n                    if (exportNameOrSpec.priority !== undefined) priority = exportNameOrSpec.priority;\n                    if (exportNameOrSpec.terminalBinding !== undefined) terminalBinding = exportNameOrSpec.terminalBinding;\n                    if (exportNameOrSpec.hidden !== undefined) hidden = exportNameOrSpec.hidden;\n                  }\n\n                  const exportInfo = exportsInfo.getExportInfo(name);\n\n                  if (exportInfo.provided === false || exportInfo.provided === null) {\n                    exportInfo.provided = true;\n                    changed = true;\n                  }\n\n                  if (exportInfo.canMangleProvide !== false && canMangle === false) {\n                    exportInfo.canMangleProvide = false;\n                    changed = true;\n                  }\n\n                  if (terminalBinding && !exportInfo.terminalBinding) {\n                    exportInfo.terminalBinding = true;\n                    changed = true;\n                  }\n\n                  if (exports) {\n                    const nestedExportsInfo = exportInfo.createNestedExportsInfo();\n                    mergeExports(nestedExportsInfo, exports);\n                  }\n\n                  if (from && (hidden ? exportInfo.unsetTarget(dep) : exportInfo.setTarget(dep, from, fromExport === undefined ? [name] : fromExport, priority))) {\n                    changed = true;\n                  } // Recalculate target exportsInfo\n\n\n                  const target = exportInfo.getTarget(moduleGraph);\n                  let targetExportsInfo = undefined;\n\n                  if (target) {\n                    const targetModuleExportsInfo = moduleGraph.getExportsInfo(target.module);\n                    targetExportsInfo = targetModuleExportsInfo.getNestedExportsInfo(target.export); // add dependency for this module\n\n                    const set = dependencies.get(target.module);\n\n                    if (set === undefined) {\n                      dependencies.set(target.module, new Set([module]));\n                    } else {\n                      set.add(module);\n                    }\n                  }\n\n                  if (exportInfo.exportsInfoOwned) {\n                    if (exportInfo.exportsInfo.setRedirectNamedTo(targetExportsInfo)) {\n                      changed = true;\n                    }\n                  } else if (exportInfo.exportsInfo !== targetExportsInfo) {\n                    exportInfo.exportsInfo = targetExportsInfo;\n                    changed = true;\n                  }\n                }\n              };\n\n              mergeExports(exportsInfo, exports);\n            } // store dependencies\n\n\n            if (exportDeps) {\n              cacheable = false;\n\n              for (const exportDependency of exportDeps) {\n                // add dependency for this module\n                const set = dependencies.get(exportDependency);\n\n                if (set === undefined) {\n                  dependencies.set(exportDependency, new Set([module]));\n                } else {\n                  set.add(module);\n                }\n              }\n            }\n          };\n\n          const notifyDependencies = () => {\n            const deps = dependencies.get(module);\n\n            if (deps !== undefined) {\n              for (const dep of deps) {\n                queue.enqueue(dep);\n              }\n            }\n          };\n\n          logger.time(\"figure out provided exports\");\n\n          while (queue.length > 0) {\n            module = queue.dequeue();\n            statQueueItemsProcessed++;\n            exportsInfo = moduleGraph.getExportsInfo(module);\n            cacheable = true;\n            changed = false;\n            exportsSpecsFromDependencies.clear();\n            moduleGraph.freeze();\n            processDependenciesBlock(module);\n            moduleGraph.unfreeze();\n\n            for (const [dep, exportsSpec] of exportsSpecsFromDependencies) {\n              processExportsSpec(dep, exportsSpec);\n            }\n\n            if (cacheable) {\n              modulesToStore.add(module);\n            }\n\n            if (changed) {\n              notifyDependencies();\n            }\n          }\n\n          logger.timeEnd(\"figure out provided exports\");\n          logger.log(`${Math.round(100 * (statFlaggedUncached + statNotCached) / (statRestoredFromMemCache + statRestoredFromCache + statNotCached + statFlaggedUncached + statNoExports))}% of exports of modules have been determined (${statNoExports} no declared exports, ${statNotCached} not cached, ${statFlaggedUncached} flagged uncacheable, ${statRestoredFromCache} from cache, ${statRestoredFromMemCache} from mem cache, ${statQueueItemsProcessed - statNotCached - statFlaggedUncached} additional calculations due to dependencies)`);\n          logger.time(\"store provided exports into cache\");\n          asyncLib.each(modulesToStore, (module, callback) => {\n            if (typeof module.buildInfo.hash !== \"string\") {\n              // not cacheable\n              return callback();\n            }\n\n            const cachedData = moduleGraph.getExportsInfo(module).getRestoreProvidedData();\n            const memCache = moduleMemCaches && moduleMemCaches.get(module);\n\n            if (memCache) {\n              memCache.set(this, cachedData);\n            }\n\n            cache.store(module.identifier(), module.buildInfo.hash, cachedData, callback);\n          }, err => {\n            logger.timeEnd(\"store provided exports into cache\");\n            callback(err);\n          });\n        });\n      });\n      /** @type {WeakMap<Module, any>} */\n\n      const providedExportsCache = new WeakMap();\n      compilation.hooks.rebuildModule.tap(\"FlagDependencyExportsPlugin\", module => {\n        providedExportsCache.set(module, moduleGraph.getExportsInfo(module).getRestoreProvidedData());\n      });\n      compilation.hooks.finishRebuildingModule.tap(\"FlagDependencyExportsPlugin\", module => {\n        moduleGraph.getExportsInfo(module).restoreProvided(providedExportsCache.get(module));\n      });\n    });\n  }\n\n}\n\nmodule.exports = FlagDependencyExportsPlugin;","map":{"version":3,"names":["asyncLib","require","Queue","FlagDependencyExportsPlugin","apply","compiler","hooks","compilation","tap","moduleGraph","cache","getCache","finishModules","tapAsync","modules","callback","logger","getLogger","statRestoredFromMemCache","statRestoredFromCache","statNoExports","statFlaggedUncached","statNotCached","statQueueItemsProcessed","moduleMemCaches","queue","time","each","module","exportsInfo","getExportsInfo","buildMeta","exportsType","otherExportsInfo","provided","setHasProvideInfo","setUnknownExportsProvided","buildInfo","hash","enqueue","memCache","get","memCacheValue","undefined","restoreProvided","identifier","err","result","timeEnd","modulesToStore","Set","dependencies","Map","exportsSpecsFromDependencies","cacheable","changed","processDependenciesBlock","depBlock","dep","processDependency","block","blocks","exportDesc","getExports","set","processExportsSpec","exports","globalCanMangle","canMangle","globalFrom","from","globalPriority","priority","globalTerminalBinding","terminalBinding","exportDeps","hideExports","name","exportInfo","getExportInfo","unsetTarget","excludeExports","Array","isArray","mergeExports","exportNameOrSpec","fromExport","hidden","export","canMangleProvide","nestedExportsInfo","createNestedExportsInfo","setTarget","target","getTarget","targetExportsInfo","targetModuleExportsInfo","getNestedExportsInfo","add","exportsInfoOwned","setRedirectNamedTo","exportDependency","notifyDependencies","deps","length","dequeue","clear","freeze","unfreeze","exportsSpec","log","Math","round","cachedData","getRestoreProvidedData","store","providedExportsCache","WeakMap","rebuildModule","finishRebuildingModule"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/FlagDependencyExportsPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst Queue = require(\"./util/Queue\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").ExportSpec} ExportSpec */\n/** @typedef {import(\"./Dependency\").ExportsSpec} ExportsSpec */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n\nclass FlagDependencyExportsPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t\tconst cache = compilation.getCache(\"FlagDependencyExportsPlugin\");\n\t\t\t\tcompilation.hooks.finishModules.tapAsync(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\t(modules, callback) => {\n\t\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\t\"webpack.FlagDependencyExportsPlugin\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tlet statRestoredFromMemCache = 0;\n\t\t\t\t\t\tlet statRestoredFromCache = 0;\n\t\t\t\t\t\tlet statNoExports = 0;\n\t\t\t\t\t\tlet statFlaggedUncached = 0;\n\t\t\t\t\t\tlet statNotCached = 0;\n\t\t\t\t\t\tlet statQueueItemsProcessed = 0;\n\n\t\t\t\t\t\tconst { moduleMemCaches } = compilation;\n\n\t\t\t\t\t\t/** @type {Queue<Module>} */\n\t\t\t\t\t\tconst queue = new Queue();\n\n\t\t\t\t\t\t// Step 1: Try to restore cached provided export info from cache\n\t\t\t\t\t\tlogger.time(\"restore cached provided exports\");\n\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t(module, callback) => {\n\t\t\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\t\t\tif (!module.buildMeta || !module.buildMeta.exportsType) {\n\t\t\t\t\t\t\t\t\tif (exportsInfo.otherExportsInfo.provided !== null) {\n\t\t\t\t\t\t\t\t\t\t// It's a module without declared exports\n\t\t\t\t\t\t\t\t\t\tstatNoExports++;\n\t\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\t\t\texportsInfo.setUnknownExportsProvided();\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (typeof module.buildInfo.hash !== \"string\") {\n\t\t\t\t\t\t\t\t\tstatFlaggedUncached++;\n\t\t\t\t\t\t\t\t\t// Enqueue uncacheable module for determining the exports\n\t\t\t\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst memCache = moduleMemCaches && moduleMemCaches.get(module);\n\t\t\t\t\t\t\t\tconst memCacheValue = memCache && memCache.get(this);\n\t\t\t\t\t\t\t\tif (memCacheValue !== undefined) {\n\t\t\t\t\t\t\t\t\tstatRestoredFromMemCache++;\n\t\t\t\t\t\t\t\t\texportsInfo.restoreProvided(memCacheValue);\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcache.get(\n\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\tmodule.buildInfo.hash,\n\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\t\t\t\t\t\tstatRestoredFromCache++;\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.restoreProvided(result);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tstatNotCached++;\n\t\t\t\t\t\t\t\t\t\t\t// Without cached info enqueue module for determining the exports\n\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.setHasProvideInfo();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"restore cached provided exports\");\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\t\t\tconst modulesToStore = new Set();\n\n\t\t\t\t\t\t\t\t/** @type {Map<Module, Set<Module>>} */\n\t\t\t\t\t\t\t\tconst dependencies = new Map();\n\n\t\t\t\t\t\t\t\t/** @type {Module} */\n\t\t\t\t\t\t\t\tlet module;\n\n\t\t\t\t\t\t\t\t/** @type {ExportsInfo} */\n\t\t\t\t\t\t\t\tlet exportsInfo;\n\n\t\t\t\t\t\t\t\t/** @type {Map<Dependency, ExportsSpec>} */\n\t\t\t\t\t\t\t\tconst exportsSpecsFromDependencies = new Map();\n\n\t\t\t\t\t\t\t\tlet cacheable = true;\n\t\t\t\t\t\t\t\tlet changed = false;\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {DependenciesBlock} depBlock the dependencies block\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processDependenciesBlock = depBlock => {\n\t\t\t\t\t\t\t\t\tfor (const dep of depBlock.dependencies) {\n\t\t\t\t\t\t\t\t\t\tprocessDependency(dep);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor (const block of depBlock.blocks) {\n\t\t\t\t\t\t\t\t\t\tprocessDependenciesBlock(block);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Dependency} dep the dependency\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processDependency = dep => {\n\t\t\t\t\t\t\t\t\tconst exportDesc = dep.getExports(moduleGraph);\n\t\t\t\t\t\t\t\t\tif (!exportDesc) return;\n\t\t\t\t\t\t\t\t\texportsSpecsFromDependencies.set(dep, exportDesc);\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Dependency} dep dependency\n\t\t\t\t\t\t\t\t * @param {ExportsSpec} exportDesc info\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processExportsSpec = (dep, exportDesc) => {\n\t\t\t\t\t\t\t\t\tconst exports = exportDesc.exports;\n\t\t\t\t\t\t\t\t\tconst globalCanMangle = exportDesc.canMangle;\n\t\t\t\t\t\t\t\t\tconst globalFrom = exportDesc.from;\n\t\t\t\t\t\t\t\t\tconst globalPriority = exportDesc.priority;\n\t\t\t\t\t\t\t\t\tconst globalTerminalBinding =\n\t\t\t\t\t\t\t\t\t\texportDesc.terminalBinding || false;\n\t\t\t\t\t\t\t\t\tconst exportDeps = exportDesc.dependencies;\n\t\t\t\t\t\t\t\t\tif (exportDesc.hideExports) {\n\t\t\t\t\t\t\t\t\t\tfor (const name of exportDesc.hideExports) {\n\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(name);\n\t\t\t\t\t\t\t\t\t\t\texportInfo.unsetTarget(dep);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (exports === true) {\n\t\t\t\t\t\t\t\t\t\t// unknown exports\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\texportsInfo.setUnknownExportsProvided(\n\t\t\t\t\t\t\t\t\t\t\t\tglobalCanMangle,\n\t\t\t\t\t\t\t\t\t\t\t\texportDesc.excludeExports,\n\t\t\t\t\t\t\t\t\t\t\t\tglobalFrom && dep,\n\t\t\t\t\t\t\t\t\t\t\t\tglobalFrom,\n\t\t\t\t\t\t\t\t\t\t\t\tglobalPriority\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (Array.isArray(exports)) {\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * merge in new exports\n\t\t\t\t\t\t\t\t\t\t * @param {ExportsInfo} exportsInfo own exports info\n\t\t\t\t\t\t\t\t\t\t * @param {(ExportSpec | string)[]} exports list of exports\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tconst mergeExports = (exportsInfo, exports) => {\n\t\t\t\t\t\t\t\t\t\t\tfor (const exportNameOrSpec of exports) {\n\t\t\t\t\t\t\t\t\t\t\t\tlet name;\n\t\t\t\t\t\t\t\t\t\t\t\tlet canMangle = globalCanMangle;\n\t\t\t\t\t\t\t\t\t\t\t\tlet terminalBinding = globalTerminalBinding;\n\t\t\t\t\t\t\t\t\t\t\t\tlet exports = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tlet from = globalFrom;\n\t\t\t\t\t\t\t\t\t\t\t\tlet fromExport = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tlet priority = globalPriority;\n\t\t\t\t\t\t\t\t\t\t\t\tlet hidden = false;\n\t\t\t\t\t\t\t\t\t\t\t\tif (typeof exportNameOrSpec === \"string\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname = exportNameOrSpec;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname = exportNameOrSpec.name;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.canMangle !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle = exportNameOrSpec.canMangle;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.export !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfromExport = exportNameOrSpec.export;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.exports !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texports = exportNameOrSpec.exports;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.from !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom = exportNameOrSpec.from;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.priority !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpriority = exportNameOrSpec.priority;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.terminalBinding !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tterminalBinding = exportNameOrSpec.terminalBinding;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (exportNameOrSpec.hidden !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thidden = exportNameOrSpec.hidden;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tconst exportInfo = exportsInfo.getExportInfo(name);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided === false ||\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided === null\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.provided = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleProvide !== false &&\n\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle === false\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleProvide = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (terminalBinding && !exportInfo.terminalBinding) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.terminalBinding = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (exports) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst nestedExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.createNestedExportsInfo();\n\t\t\t\t\t\t\t\t\t\t\t\t\tmergeExports(nestedExportsInfo, exports);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\tfrom &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t(hidden\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t? exportInfo.unsetTarget(dep)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfo.setTarget(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfrom,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfromExport === undefined ? [name] : fromExport,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpriority\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  ))\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Recalculate target exportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\tconst target = exportInfo.getTarget(moduleGraph);\n\t\t\t\t\t\t\t\t\t\t\t\tlet targetExportsInfo = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tif (target) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst targetModuleExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleGraph.getExportsInfo(target.module);\n\t\t\t\t\t\t\t\t\t\t\t\t\ttargetExportsInfo =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetModuleExportsInfo.getNestedExportsInfo(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttarget.export\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t// add dependency for this module\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst set = dependencies.get(target.module);\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (set === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdependencies.set(target.module, new Set([module]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tset.add(module);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (exportInfo.exportsInfoOwned) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo.setRedirectNamedTo(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetExportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo !== targetExportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.exportsInfo = targetExportsInfo;\n\t\t\t\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tmergeExports(exportsInfo, exports);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// store dependencies\n\t\t\t\t\t\t\t\t\tif (exportDeps) {\n\t\t\t\t\t\t\t\t\t\tcacheable = false;\n\t\t\t\t\t\t\t\t\t\tfor (const exportDependency of exportDeps) {\n\t\t\t\t\t\t\t\t\t\t\t// add dependency for this module\n\t\t\t\t\t\t\t\t\t\t\tconst set = dependencies.get(exportDependency);\n\t\t\t\t\t\t\t\t\t\t\tif (set === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tdependencies.set(exportDependency, new Set([module]));\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tset.add(module);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tconst notifyDependencies = () => {\n\t\t\t\t\t\t\t\t\tconst deps = dependencies.get(module);\n\t\t\t\t\t\t\t\t\tif (deps !== undefined) {\n\t\t\t\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(dep);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tlogger.time(\"figure out provided exports\");\n\t\t\t\t\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\t\t\t\t\tmodule = queue.dequeue();\n\n\t\t\t\t\t\t\t\t\tstatQueueItemsProcessed++;\n\n\t\t\t\t\t\t\t\t\texportsInfo = moduleGraph.getExportsInfo(module);\n\n\t\t\t\t\t\t\t\t\tcacheable = true;\n\t\t\t\t\t\t\t\t\tchanged = false;\n\n\t\t\t\t\t\t\t\t\texportsSpecsFromDependencies.clear();\n\t\t\t\t\t\t\t\t\tmoduleGraph.freeze();\n\t\t\t\t\t\t\t\t\tprocessDependenciesBlock(module);\n\t\t\t\t\t\t\t\t\tmoduleGraph.unfreeze();\n\t\t\t\t\t\t\t\t\tfor (const [\n\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\texportsSpec\n\t\t\t\t\t\t\t\t\t] of exportsSpecsFromDependencies) {\n\t\t\t\t\t\t\t\t\t\tprocessExportsSpec(dep, exportsSpec);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (cacheable) {\n\t\t\t\t\t\t\t\t\t\tmodulesToStore.add(module);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t\t\t\t\tnotifyDependencies();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"figure out provided exports\");\n\n\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t`${Math.round(\n\t\t\t\t\t\t\t\t\t\t(100 * (statFlaggedUncached + statNotCached)) /\n\t\t\t\t\t\t\t\t\t\t\t(statRestoredFromMemCache +\n\t\t\t\t\t\t\t\t\t\t\t\tstatRestoredFromCache +\n\t\t\t\t\t\t\t\t\t\t\t\tstatNotCached +\n\t\t\t\t\t\t\t\t\t\t\t\tstatFlaggedUncached +\n\t\t\t\t\t\t\t\t\t\t\t\tstatNoExports)\n\t\t\t\t\t\t\t\t\t)}% of exports of modules have been determined (${statNoExports} no declared exports, ${statNotCached} not cached, ${statFlaggedUncached} flagged uncacheable, ${statRestoredFromCache} from cache, ${statRestoredFromMemCache} from mem cache, ${\n\t\t\t\t\t\t\t\t\t\tstatQueueItemsProcessed -\n\t\t\t\t\t\t\t\t\t\tstatNotCached -\n\t\t\t\t\t\t\t\t\t\tstatFlaggedUncached\n\t\t\t\t\t\t\t\t\t} additional calculations due to dependencies)`\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tlogger.time(\"store provided exports into cache\");\n\t\t\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\t\t\tmodulesToStore,\n\t\t\t\t\t\t\t\t\t(module, callback) => {\n\t\t\t\t\t\t\t\t\t\tif (typeof module.buildInfo.hash !== \"string\") {\n\t\t\t\t\t\t\t\t\t\t\t// not cacheable\n\t\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst cachedData = moduleGraph\n\t\t\t\t\t\t\t\t\t\t\t.getExportsInfo(module)\n\t\t\t\t\t\t\t\t\t\t\t.getRestoreProvidedData();\n\t\t\t\t\t\t\t\t\t\tconst memCache =\n\t\t\t\t\t\t\t\t\t\t\tmoduleMemCaches && moduleMemCaches.get(module);\n\t\t\t\t\t\t\t\t\t\tif (memCache) {\n\t\t\t\t\t\t\t\t\t\t\tmemCache.set(this, cachedData);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcache.store(\n\t\t\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\t\t\tmodule.buildInfo.hash,\n\t\t\t\t\t\t\t\t\t\t\tcachedData,\n\t\t\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\tlogger.timeEnd(\"store provided exports into cache\");\n\t\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t/** @type {WeakMap<Module, any>} */\n\t\t\t\tconst providedExportsCache = new WeakMap();\n\t\t\t\tcompilation.hooks.rebuildModule.tap(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\tmodule => {\n\t\t\t\t\t\tprovidedExportsCache.set(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tmoduleGraph.getExportsInfo(module).getRestoreProvidedData()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.finishRebuildingModule.tap(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\tmodule => {\n\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t\t\t.getExportsInfo(module)\n\t\t\t\t\t\t\t.restoreProvided(providedExportsCache.get(module));\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = FlagDependencyExportsPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}