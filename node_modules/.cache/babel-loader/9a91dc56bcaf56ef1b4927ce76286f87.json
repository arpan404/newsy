{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst {\n  AsyncSeriesWaterfallHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\n\nconst ContextModule = require(\"./ContextModule\");\n\nconst ModuleFactory = require(\"./ModuleFactory\");\n\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\n\nconst LazySet = require(\"./util/LazySet\");\n\nconst {\n  cachedSetProperty\n} = require(\"./util/cleverMerge\");\n\nconst {\n  createFakeHook\n} = require(\"./util/deprecation\");\n\nconst {\n  join\n} = require(\"./util/fs\");\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n\n/** @template T @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T> */\n\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\n\nconst EMPTY_RESOLVE_OPTIONS = {};\nmodule.exports = class ContextModuleFactory extends ModuleFactory {\n  /**\n   * @param {ResolverFactory} resolverFactory resolverFactory\n   */\n  constructor(resolverFactory) {\n    super();\n    /** @type {AsyncSeriesWaterfallHook<[TODO[], ContextModuleOptions]>} */\n\n    const alternativeRequests = new AsyncSeriesWaterfallHook([\"modules\", \"options\"]);\n    this.hooks = Object.freeze({\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {SyncWaterfallHook<[string[]]>} */\n      contextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\n      /** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n      alternatives: createFakeHook({\n        name: \"alternatives\",\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"intercept\"]} */\n        intercept: interceptor => {\n          throw new Error(\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\");\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tap\"]} */\n        tap: (options, fn) => {\n          alternativeRequests.tap(options, fn);\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapAsync\"]} */\n        tapAsync: (options, fn) => {\n          alternativeRequests.tapAsync(options, (items, _options, callback) => fn(items, callback));\n        },\n\n        /** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapPromise\"]} */\n        tapPromise: (options, fn) => {\n          alternativeRequests.tapPromise(options, fn);\n        }\n      }, \"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\", \"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"),\n      alternativeRequests\n    });\n    this.resolverFactory = resolverFactory;\n  }\n  /**\n   * @param {ModuleFactoryCreateData} data data object\n   * @param {function(Error=, ModuleFactoryResult=): void} callback callback\n   * @returns {void}\n   */\n\n\n  create(data, callback) {\n    const context = data.context;\n    const dependencies = data.dependencies;\n    const resolveOptions = data.resolveOptions;\n    const dependency =\n    /** @type {ContextDependency} */\n    dependencies[0];\n    const fileDependencies = new LazySet();\n    const missingDependencies = new LazySet();\n    const contextDependencies = new LazySet();\n    this.hooks.beforeResolve.callAsync({\n      context: context,\n      dependencies: dependencies,\n      resolveOptions,\n      fileDependencies,\n      missingDependencies,\n      contextDependencies,\n      ...dependency.options\n    }, (err, beforeResolveResult) => {\n      if (err) {\n        return callback(err, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies\n        });\n      } // Ignored\n\n\n      if (!beforeResolveResult) {\n        return callback(null, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies\n        });\n      }\n\n      const context = beforeResolveResult.context;\n      const request = beforeResolveResult.request;\n      const resolveOptions = beforeResolveResult.resolveOptions;\n      let loaders,\n          resource,\n          loadersPrefix = \"\";\n      const idx = request.lastIndexOf(\"!\");\n\n      if (idx >= 0) {\n        let loadersRequest = request.slice(0, idx + 1);\n        let i;\n\n        for (i = 0; i < loadersRequest.length && loadersRequest[i] === \"!\"; i++) {\n          loadersPrefix += \"!\";\n        }\n\n        loadersRequest = loadersRequest.slice(i).replace(/!+$/, \"\").replace(/!!+/g, \"!\");\n\n        if (loadersRequest === \"\") {\n          loaders = [];\n        } else {\n          loaders = loadersRequest.split(\"!\");\n        }\n\n        resource = request.slice(idx + 1);\n      } else {\n        loaders = [];\n        resource = request;\n      }\n\n      const contextResolver = this.resolverFactory.get(\"context\", dependencies.length > 0 ? cachedSetProperty(resolveOptions || EMPTY_RESOLVE_OPTIONS, \"dependencyType\", dependencies[0].category) : resolveOptions);\n      const loaderResolver = this.resolverFactory.get(\"loader\");\n      asyncLib.parallel([callback => {\n        const results = [];\n\n        const yield_ = obj => results.push(obj);\n\n        contextResolver.resolve({}, context, resource, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies,\n          yield: yield_\n        }, err => {\n          if (err) return callback(err);\n          callback(null, results);\n        });\n      }, callback => {\n        asyncLib.map(loaders, (loader, callback) => {\n          loaderResolver.resolve({}, context, loader, {\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          }, (err, result) => {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        }, callback);\n      }], (err, result) => {\n        if (err) {\n          return callback(err, {\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          });\n        }\n\n        let [contextResult, loaderResult] = result;\n\n        if (contextResult.length > 1) {\n          const first = contextResult[0];\n          contextResult = contextResult.filter(r => r.path);\n          if (contextResult.length === 0) contextResult.push(first);\n        }\n\n        this.hooks.afterResolve.callAsync({\n          addon: loadersPrefix + loaderResult.join(\"!\") + (loaderResult.length > 0 ? \"!\" : \"\"),\n          resource: contextResult.length > 1 ? contextResult.map(r => r.path) : contextResult[0].path,\n          resolveDependencies: this.resolveDependencies.bind(this),\n          resourceQuery: contextResult[0].query,\n          resourceFragment: contextResult[0].fragment,\n          ...beforeResolveResult\n        }, (err, result) => {\n          if (err) {\n            return callback(err, {\n              fileDependencies,\n              missingDependencies,\n              contextDependencies\n            });\n          } // Ignored\n\n\n          if (!result) {\n            return callback(null, {\n              fileDependencies,\n              missingDependencies,\n              contextDependencies\n            });\n          }\n\n          return callback(null, {\n            module: new ContextModule(result.resolveDependencies, result),\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          });\n        });\n      });\n    });\n  }\n  /**\n   * @param {InputFileSystem} fs file system\n   * @param {ContextModuleOptions} options options\n   * @param {ResolveDependenciesCallback} callback callback function\n   * @returns {void}\n   */\n\n\n  resolveDependencies(fs, options, callback) {\n    const cmf = this;\n    const {\n      resource,\n      resourceQuery,\n      resourceFragment,\n      recursive,\n      regExp,\n      include,\n      exclude,\n      referencedExports,\n      category,\n      typePrefix\n    } = options;\n    if (!regExp || !resource) return callback(null, []);\n\n    const addDirectoryChecked = (ctx, directory, visited, callback) => {\n      fs.realpath(directory, (err, realPath) => {\n        if (err) return callback(err);\n        if (visited.has(realPath)) return callback(null, []);\n        let recursionStack;\n        addDirectory(ctx, directory, (_, dir, callback) => {\n          if (recursionStack === undefined) {\n            recursionStack = new Set(visited);\n            recursionStack.add(realPath);\n          }\n\n          addDirectoryChecked(ctx, dir, recursionStack, callback);\n        }, callback);\n      });\n    };\n\n    const addDirectory = (ctx, directory, addSubDirectory, callback) => {\n      fs.readdir(directory, (err, files) => {\n        if (err) return callback(err);\n        const processedFiles = cmf.hooks.contextModuleFiles.call(\n        /** @type {string[]} */\n        files.map(file => file.normalize(\"NFC\")));\n        if (!processedFiles || processedFiles.length === 0) return callback(null, []);\n        asyncLib.map(processedFiles.filter(p => p.indexOf(\".\") !== 0), (segment, callback) => {\n          const subResource = join(fs, directory, segment);\n\n          if (!exclude || !subResource.match(exclude)) {\n            fs.stat(subResource, (err, stat) => {\n              if (err) {\n                if (err.code === \"ENOENT\") {\n                  // ENOENT is ok here because the file may have been deleted between\n                  // the readdir and stat calls.\n                  return callback();\n                } else {\n                  return callback(err);\n                }\n              }\n\n              if (stat.isDirectory()) {\n                if (!recursive) return callback();\n                addSubDirectory(ctx, subResource, callback);\n              } else if (stat.isFile() && (!include || subResource.match(include))) {\n                const obj = {\n                  context: ctx,\n                  request: \".\" + subResource.slice(ctx.length).replace(/\\\\/g, \"/\")\n                };\n                this.hooks.alternativeRequests.callAsync([obj], options, (err, alternatives) => {\n                  if (err) return callback(err);\n                  alternatives = alternatives.filter(obj => regExp.test(obj.request)).map(obj => {\n                    const dep = new ContextElementDependency(`${obj.request}${resourceQuery}${resourceFragment}`, obj.request, typePrefix, category, referencedExports, obj.context);\n                    dep.optional = true;\n                    return dep;\n                  });\n                  callback(null, alternatives);\n                });\n              } else {\n                callback();\n              }\n            });\n          } else {\n            callback();\n          }\n        }, (err, result) => {\n          if (err) return callback(err);\n          if (!result) return callback(null, []);\n          const flattenedResult = [];\n\n          for (const item of result) {\n            if (item) flattenedResult.push(...item);\n          }\n\n          callback(null, flattenedResult);\n        });\n      });\n    };\n\n    const addSubDirectory = (ctx, dir, callback) => addDirectory(ctx, dir, addSubDirectory, callback);\n\n    const visitResource = (resource, callback) => {\n      if (typeof fs.realpath === \"function\") {\n        addDirectoryChecked(resource, resource, new Set(), callback);\n      } else {\n        addDirectory(resource, resource, addSubDirectory, callback);\n      }\n    };\n\n    if (typeof resource === \"string\") {\n      visitResource(resource, callback);\n    } else {\n      asyncLib.map(resource, visitResource, (err, result) => {\n        if (err) return callback(err); // result dependencies should have unique userRequest\n        // ordered by resolve result\n\n        const temp = new Set();\n        const res = [];\n\n        for (let i = 0; i < result.length; i++) {\n          const inner = result[i];\n\n          for (const el of inner) {\n            if (temp.has(el.userRequest)) continue;\n            res.push(el);\n            temp.add(el.userRequest);\n          }\n        }\n\n        callback(null, res);\n      });\n    }\n  }\n\n};","map":{"version":3,"names":["asyncLib","require","AsyncSeriesWaterfallHook","SyncWaterfallHook","ContextModule","ModuleFactory","ContextElementDependency","LazySet","cachedSetProperty","createFakeHook","join","EMPTY_RESOLVE_OPTIONS","module","exports","ContextModuleFactory","constructor","resolverFactory","alternativeRequests","hooks","Object","freeze","beforeResolve","afterResolve","contextModuleFiles","alternatives","name","intercept","interceptor","Error","tap","options","fn","tapAsync","items","_options","callback","tapPromise","create","data","context","dependencies","resolveOptions","dependency","fileDependencies","missingDependencies","contextDependencies","callAsync","err","beforeResolveResult","request","loaders","resource","loadersPrefix","idx","lastIndexOf","loadersRequest","slice","i","length","replace","split","contextResolver","get","category","loaderResolver","parallel","results","yield_","obj","push","resolve","yield","map","loader","result","contextResult","loaderResult","first","filter","r","path","addon","resolveDependencies","bind","resourceQuery","query","resourceFragment","fragment","fs","cmf","recursive","regExp","include","exclude","referencedExports","typePrefix","addDirectoryChecked","ctx","directory","visited","realpath","realPath","has","recursionStack","addDirectory","_","dir","undefined","Set","add","addSubDirectory","readdir","files","processedFiles","call","file","normalize","p","indexOf","segment","subResource","match","stat","code","isDirectory","isFile","test","dep","optional","flattenedResult","item","visitResource","temp","res","inner","el","userRequest"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/ContextModuleFactory.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { AsyncSeriesWaterfallHook, SyncWaterfallHook } = require(\"tapable\");\nconst ContextModule = require(\"./ContextModule\");\nconst ModuleFactory = require(\"./ModuleFactory\");\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\nconst LazySet = require(\"./util/LazySet\");\nconst { cachedSetProperty } = require(\"./util/cleverMerge\");\nconst { createFakeHook } = require(\"./util/deprecation\");\nconst { join } = require(\"./util/fs\");\n\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n/** @template T @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T> */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n\nconst EMPTY_RESOLVE_OPTIONS = {};\n\nmodule.exports = class ContextModuleFactory extends ModuleFactory {\n\t/**\n\t * @param {ResolverFactory} resolverFactory resolverFactory\n\t */\n\tconstructor(resolverFactory) {\n\t\tsuper();\n\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[], ContextModuleOptions]>} */\n\t\tconst alternativeRequests = new AsyncSeriesWaterfallHook([\n\t\t\t\"modules\",\n\t\t\t\"options\"\n\t\t]);\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tbeforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tafterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {SyncWaterfallHook<[string[]]>} */\n\t\t\tcontextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\t\t\t/** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[TODO[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n\t\t\talternatives: createFakeHook(\n\t\t\t\t{\n\t\t\t\t\tname: \"alternatives\",\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"intercept\"]} */\n\t\t\t\t\tintercept: interceptor => {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\"\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tap\"]} */\n\t\t\t\t\ttap: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tap(options, fn);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapAsync\"]} */\n\t\t\t\t\ttapAsync: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapAsync(options, (items, _options, callback) =>\n\t\t\t\t\t\t\tfn(items, callback)\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO[]]>[\"tapPromise\"]} */\n\t\t\t\t\ttapPromise: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapPromise(options, fn);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\",\n\t\t\t\t\"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"\n\t\t\t),\n\t\t\talternativeRequests\n\t\t});\n\t\tthis.resolverFactory = resolverFactory;\n\t}\n\n\t/**\n\t * @param {ModuleFactoryCreateData} data data object\n\t * @param {function(Error=, ModuleFactoryResult=): void} callback callback\n\t * @returns {void}\n\t */\n\tcreate(data, callback) {\n\t\tconst context = data.context;\n\t\tconst dependencies = data.dependencies;\n\t\tconst resolveOptions = data.resolveOptions;\n\t\tconst dependency = /** @type {ContextDependency} */ (dependencies[0]);\n\t\tconst fileDependencies = new LazySet();\n\t\tconst missingDependencies = new LazySet();\n\t\tconst contextDependencies = new LazySet();\n\t\tthis.hooks.beforeResolve.callAsync(\n\t\t\t{\n\t\t\t\tcontext: context,\n\t\t\t\tdependencies: dependencies,\n\t\t\t\tresolveOptions,\n\t\t\t\tfileDependencies,\n\t\t\t\tmissingDependencies,\n\t\t\t\tcontextDependencies,\n\t\t\t\t...dependency.options\n\t\t\t},\n\t\t\t(err, beforeResolveResult) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Ignored\n\t\t\t\tif (!beforeResolveResult) {\n\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst context = beforeResolveResult.context;\n\t\t\t\tconst request = beforeResolveResult.request;\n\t\t\t\tconst resolveOptions = beforeResolveResult.resolveOptions;\n\n\t\t\t\tlet loaders,\n\t\t\t\t\tresource,\n\t\t\t\t\tloadersPrefix = \"\";\n\t\t\t\tconst idx = request.lastIndexOf(\"!\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tlet loadersRequest = request.slice(0, idx + 1);\n\t\t\t\t\tlet i;\n\t\t\t\t\tfor (\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\ti < loadersRequest.length && loadersRequest[i] === \"!\";\n\t\t\t\t\t\ti++\n\t\t\t\t\t) {\n\t\t\t\t\t\tloadersPrefix += \"!\";\n\t\t\t\t\t}\n\t\t\t\t\tloadersRequest = loadersRequest\n\t\t\t\t\t\t.slice(i)\n\t\t\t\t\t\t.replace(/!+$/, \"\")\n\t\t\t\t\t\t.replace(/!!+/g, \"!\");\n\t\t\t\t\tif (loadersRequest === \"\") {\n\t\t\t\t\t\tloaders = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tloaders = loadersRequest.split(\"!\");\n\t\t\t\t\t}\n\t\t\t\t\tresource = request.slice(idx + 1);\n\t\t\t\t} else {\n\t\t\t\t\tloaders = [];\n\t\t\t\t\tresource = request;\n\t\t\t\t}\n\n\t\t\t\tconst contextResolver = this.resolverFactory.get(\n\t\t\t\t\t\"context\",\n\t\t\t\t\tdependencies.length > 0\n\t\t\t\t\t\t? cachedSetProperty(\n\t\t\t\t\t\t\t\tresolveOptions || EMPTY_RESOLVE_OPTIONS,\n\t\t\t\t\t\t\t\t\"dependencyType\",\n\t\t\t\t\t\t\t\tdependencies[0].category\n\t\t\t\t\t\t  )\n\t\t\t\t\t\t: resolveOptions\n\t\t\t\t);\n\t\t\t\tconst loaderResolver = this.resolverFactory.get(\"loader\");\n\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tconst results = [];\n\t\t\t\t\t\t\tconst yield_ = obj => results.push(obj);\n\n\t\t\t\t\t\t\tcontextResolver.resolve(\n\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\t\t\t\tyield: yield_\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tcallback(null, results);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tasyncLib.map(\n\t\t\t\t\t\t\t\tloaders,\n\t\t\t\t\t\t\t\t(loader, callback) => {\n\t\t\t\t\t\t\t\t\tloaderResolver.resolve(\n\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\tloader,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet [contextResult, loaderResult] = result;\n\t\t\t\t\t\tif (contextResult.length > 1) {\n\t\t\t\t\t\t\tconst first = contextResult[0];\n\t\t\t\t\t\t\tcontextResult = contextResult.filter(r => r.path);\n\t\t\t\t\t\t\tif (contextResult.length === 0) contextResult.push(first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.hooks.afterResolve.callAsync(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taddon:\n\t\t\t\t\t\t\t\t\tloadersPrefix +\n\t\t\t\t\t\t\t\t\tloaderResult.join(\"!\") +\n\t\t\t\t\t\t\t\t\t(loaderResult.length > 0 ? \"!\" : \"\"),\n\t\t\t\t\t\t\t\tresource:\n\t\t\t\t\t\t\t\t\tcontextResult.length > 1\n\t\t\t\t\t\t\t\t\t\t? contextResult.map(r => r.path)\n\t\t\t\t\t\t\t\t\t\t: contextResult[0].path,\n\t\t\t\t\t\t\t\tresolveDependencies: this.resolveDependencies.bind(this),\n\t\t\t\t\t\t\t\tresourceQuery: contextResult[0].query,\n\t\t\t\t\t\t\t\tresourceFragment: contextResult[0].fragment,\n\t\t\t\t\t\t\t\t...beforeResolveResult\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Ignored\n\t\t\t\t\t\t\t\tif (!result) {\n\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\tmodule: new ContextModule(result.resolveDependencies, result),\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {InputFileSystem} fs file system\n\t * @param {ContextModuleOptions} options options\n\t * @param {ResolveDependenciesCallback} callback callback function\n\t * @returns {void}\n\t */\n\tresolveDependencies(fs, options, callback) {\n\t\tconst cmf = this;\n\t\tconst {\n\t\t\tresource,\n\t\t\tresourceQuery,\n\t\t\tresourceFragment,\n\t\t\trecursive,\n\t\t\tregExp,\n\t\t\tinclude,\n\t\t\texclude,\n\t\t\treferencedExports,\n\t\t\tcategory,\n\t\t\ttypePrefix\n\t\t} = options;\n\t\tif (!regExp || !resource) return callback(null, []);\n\n\t\tconst addDirectoryChecked = (ctx, directory, visited, callback) => {\n\t\t\tfs.realpath(directory, (err, realPath) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (visited.has(realPath)) return callback(null, []);\n\t\t\t\tlet recursionStack;\n\t\t\t\taddDirectory(\n\t\t\t\t\tctx,\n\t\t\t\t\tdirectory,\n\t\t\t\t\t(_, dir, callback) => {\n\t\t\t\t\t\tif (recursionStack === undefined) {\n\t\t\t\t\t\t\trecursionStack = new Set(visited);\n\t\t\t\t\t\t\trecursionStack.add(realPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddDirectoryChecked(ctx, dir, recursionStack, callback);\n\t\t\t\t\t},\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tconst addDirectory = (ctx, directory, addSubDirectory, callback) => {\n\t\t\tfs.readdir(directory, (err, files) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst processedFiles = cmf.hooks.contextModuleFiles.call(\n\t\t\t\t\t/** @type {string[]} */ (files).map(file => file.normalize(\"NFC\"))\n\t\t\t\t);\n\t\t\t\tif (!processedFiles || processedFiles.length === 0)\n\t\t\t\t\treturn callback(null, []);\n\t\t\t\tasyncLib.map(\n\t\t\t\t\tprocessedFiles.filter(p => p.indexOf(\".\") !== 0),\n\t\t\t\t\t(segment, callback) => {\n\t\t\t\t\t\tconst subResource = join(fs, directory, segment);\n\n\t\t\t\t\t\tif (!exclude || !subResource.match(exclude)) {\n\t\t\t\t\t\t\tfs.stat(subResource, (err, stat) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\t\t\t\t\t\t// ENOENT is ok here because the file may have been deleted between\n\t\t\t\t\t\t\t\t\t\t// the readdir and stat calls.\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\t\t\t\tif (!recursive) return callback();\n\t\t\t\t\t\t\t\t\taddSubDirectory(ctx, subResource, callback);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tstat.isFile() &&\n\t\t\t\t\t\t\t\t\t(!include || subResource.match(include))\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t\tcontext: ctx,\n\t\t\t\t\t\t\t\t\t\trequest:\n\t\t\t\t\t\t\t\t\t\t\t\".\" + subResource.slice(ctx.length).replace(/\\\\/g, \"/\")\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tthis.hooks.alternativeRequests.callAsync(\n\t\t\t\t\t\t\t\t\t\t[obj],\n\t\t\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\t\t\t(err, alternatives) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\talternatives = alternatives\n\t\t\t\t\t\t\t\t\t\t\t\t.filter(obj => regExp.test(obj.request))\n\t\t\t\t\t\t\t\t\t\t\t\t.map(obj => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new ContextElementDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${obj.request}${resourceQuery}${resourceFragment}`,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.request,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttypePrefix,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcategory,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treferencedExports,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.context\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tdep.optional = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn dep;\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, alternatives);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tif (!result) return callback(null, []);\n\n\t\t\t\t\t\tconst flattenedResult = [];\n\n\t\t\t\t\t\tfor (const item of result) {\n\t\t\t\t\t\t\tif (item) flattenedResult.push(...item);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcallback(null, flattenedResult);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tconst addSubDirectory = (ctx, dir, callback) =>\n\t\t\taddDirectory(ctx, dir, addSubDirectory, callback);\n\n\t\tconst visitResource = (resource, callback) => {\n\t\t\tif (typeof fs.realpath === \"function\") {\n\t\t\t\taddDirectoryChecked(resource, resource, new Set(), callback);\n\t\t\t} else {\n\t\t\t\taddDirectory(resource, resource, addSubDirectory, callback);\n\t\t\t}\n\t\t};\n\n\t\tif (typeof resource === \"string\") {\n\t\t\tvisitResource(resource, callback);\n\t\t} else {\n\t\t\tasyncLib.map(resource, visitResource, (err, result) => {\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t// result dependencies should have unique userRequest\n\t\t\t\t// ordered by resolve result\n\t\t\t\tconst temp = new Set();\n\t\t\t\tconst res = [];\n\t\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\t\tconst inner = result[i];\n\t\t\t\t\tfor (const el of inner) {\n\t\t\t\t\t\tif (temp.has(el.userRequest)) continue;\n\t\t\t\t\t\tres.push(el);\n\t\t\t\t\t\ttemp.add(el.userRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, res);\n\t\t\t});\n\t\t}\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}