{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst {\n  EventEmitter\n} = require(\"events\");\n\nconst reducePlan = require(\"./reducePlan\");\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst IS_WIN = require(\"os\").platform() === \"win32\";\nconst SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\nconst watcherLimit = +process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\nconst recursiveWatcherLogging = !!process.env.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\nlet isBatch = false;\nlet watcherCount = 0;\n/** @type {Map<Watcher, string>} */\n\nconst pendingWatchers = new Map();\n/** @type {Map<string, RecursiveWatcher>} */\n\nconst recursiveWatchers = new Map();\n/** @type {Map<string, DirectWatcher>} */\n\nconst directWatchers = new Map();\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\n\nconst underlyingWatcher = new Map();\n\nclass DirectWatcher {\n  constructor(filePath) {\n    this.filePath = filePath;\n    this.watchers = new Set();\n    this.watcher = undefined;\n\n    try {\n      const watcher = fs.watch(filePath);\n      this.watcher = watcher;\n      watcher.on(\"change\", (type, filename) => {\n        for (const w of this.watchers) {\n          w.emit(\"change\", type, filename);\n        }\n      });\n      watcher.on(\"error\", error => {\n        for (const w of this.watchers) {\n          w.emit(\"error\", error);\n        }\n      });\n    } catch (err) {\n      process.nextTick(() => {\n        for (const w of this.watchers) {\n          w.emit(\"error\", err);\n        }\n      });\n    }\n\n    watcherCount++;\n  }\n\n  add(watcher) {\n    underlyingWatcher.set(watcher, this);\n    this.watchers.add(watcher);\n  }\n\n  remove(watcher) {\n    this.watchers.delete(watcher);\n\n    if (this.watchers.size === 0) {\n      directWatchers.delete(this.filePath);\n      watcherCount--;\n      if (this.watcher) this.watcher.close();\n    }\n  }\n\n  getWatchers() {\n    return this.watchers;\n  }\n\n}\n\nclass RecursiveWatcher {\n  constructor(rootPath) {\n    this.rootPath = rootPath;\n    /** @type {Map<Watcher, string>} */\n\n    this.mapWatcherToPath = new Map();\n    /** @type {Map<string, Set<Watcher>>} */\n\n    this.mapPathToWatchers = new Map();\n    this.watcher = undefined;\n\n    try {\n      const watcher = fs.watch(rootPath, {\n        recursive: true\n      });\n      this.watcher = watcher;\n      watcher.on(\"change\", (type, filename) => {\n        if (!filename) {\n          if (recursiveWatcherLogging) {\n            process.stderr.write(`[watchpack] dispatch ${type} event in recursive watcher (${this.rootPath}) to all watchers\\n`);\n          }\n\n          for (const w of this.mapWatcherToPath.keys()) {\n            w.emit(\"change\", type);\n          }\n        } else {\n          const dir = path.dirname(filename);\n          const watchers = this.mapPathToWatchers.get(dir);\n\n          if (recursiveWatcherLogging) {\n            process.stderr.write(`[watchpack] dispatch ${type} event in recursive watcher (${this.rootPath}) for '${filename}' to ${watchers ? watchers.size : 0} watchers\\n`);\n          }\n\n          if (watchers === undefined) return;\n\n          for (const w of watchers) {\n            w.emit(\"change\", type, path.basename(filename));\n          }\n        }\n      });\n      watcher.on(\"error\", error => {\n        for (const w of this.mapWatcherToPath.keys()) {\n          w.emit(\"error\", error);\n        }\n      });\n    } catch (err) {\n      process.nextTick(() => {\n        for (const w of this.mapWatcherToPath.keys()) {\n          w.emit(\"error\", err);\n        }\n      });\n    }\n\n    watcherCount++;\n\n    if (recursiveWatcherLogging) {\n      process.stderr.write(`[watchpack] created recursive watcher at ${rootPath}\\n`);\n    }\n  }\n\n  add(filePath, watcher) {\n    underlyingWatcher.set(watcher, this);\n    const subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n    this.mapWatcherToPath.set(watcher, subpath);\n    const set = this.mapPathToWatchers.get(subpath);\n\n    if (set === undefined) {\n      const newSet = new Set();\n      newSet.add(watcher);\n      this.mapPathToWatchers.set(subpath, newSet);\n    } else {\n      set.add(watcher);\n    }\n  }\n\n  remove(watcher) {\n    const subpath = this.mapWatcherToPath.get(watcher);\n    if (!subpath) return;\n    this.mapWatcherToPath.delete(watcher);\n    const set = this.mapPathToWatchers.get(subpath);\n    set.delete(watcher);\n\n    if (set.size === 0) {\n      this.mapPathToWatchers.delete(subpath);\n    }\n\n    if (this.mapWatcherToPath.size === 0) {\n      recursiveWatchers.delete(this.rootPath);\n      watcherCount--;\n      if (this.watcher) this.watcher.close();\n\n      if (recursiveWatcherLogging) {\n        process.stderr.write(`[watchpack] closed recursive watcher at ${this.rootPath}\\n`);\n      }\n    }\n  }\n\n  getWatchers() {\n    return this.mapWatcherToPath;\n  }\n\n}\n\nclass Watcher extends EventEmitter {\n  close() {\n    if (pendingWatchers.has(this)) {\n      pendingWatchers.delete(this);\n      return;\n    }\n\n    const watcher = underlyingWatcher.get(this);\n    watcher.remove(this);\n    underlyingWatcher.delete(this);\n  }\n\n}\n\nconst createDirectWatcher = filePath => {\n  const existing = directWatchers.get(filePath);\n  if (existing !== undefined) return existing;\n  const w = new DirectWatcher(filePath);\n  directWatchers.set(filePath, w);\n  return w;\n};\n\nconst createRecursiveWatcher = rootPath => {\n  const existing = recursiveWatchers.get(rootPath);\n  if (existing !== undefined) return existing;\n  const w = new RecursiveWatcher(rootPath);\n  recursiveWatchers.set(rootPath, w);\n  return w;\n};\n\nconst execute = () => {\n  /** @type {Map<string, Watcher[] | Watcher>} */\n  const map = new Map();\n\n  const addWatcher = (watcher, filePath) => {\n    const entry = map.get(filePath);\n\n    if (entry === undefined) {\n      map.set(filePath, watcher);\n    } else if (Array.isArray(entry)) {\n      entry.push(watcher);\n    } else {\n      map.set(filePath, [entry, watcher]);\n    }\n  };\n\n  for (const [watcher, filePath] of pendingWatchers) {\n    addWatcher(watcher, filePath);\n  }\n\n  pendingWatchers.clear(); // Fast case when we are not reaching the limit\n\n  if (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n    // Create watchers for all entries in the map\n    for (const [filePath, entry] of map) {\n      const w = createDirectWatcher(filePath);\n\n      if (Array.isArray(entry)) {\n        for (const item of entry) w.add(item);\n      } else {\n        w.add(entry);\n      }\n    }\n\n    return;\n  } // Reconsider existing watchers to improving watch plan\n\n\n  for (const watcher of recursiveWatchers.values()) {\n    for (const [w, subpath] of watcher.getWatchers()) {\n      addWatcher(w, path.join(watcher.rootPath, subpath));\n    }\n  }\n\n  for (const watcher of directWatchers.values()) {\n    for (const w of watcher.getWatchers()) {\n      addWatcher(w, watcher.filePath);\n    }\n  } // Merge map entries to keep watcher limit\n  // Create a 10% buffer to be able to enter fast case more often\n\n\n  const plan = reducePlan(map, watcherLimit * 0.9); // Update watchers for all entries in the map\n\n  for (const [filePath, entry] of plan) {\n    if (entry.size === 1) {\n      for (const [watcher, filePath] of entry) {\n        const w = createDirectWatcher(filePath);\n        const old = underlyingWatcher.get(watcher);\n        if (old === w) continue;\n        w.add(watcher);\n        if (old !== undefined) old.remove(watcher);\n      }\n    } else {\n      const filePaths = new Set(entry.values());\n\n      if (filePaths.size > 1) {\n        const w = createRecursiveWatcher(filePath);\n\n        for (const [watcher, watcherPath] of entry) {\n          const old = underlyingWatcher.get(watcher);\n          if (old === w) continue;\n          w.add(watcherPath, watcher);\n          if (old !== undefined) old.remove(watcher);\n        }\n      } else {\n        for (const filePath of filePaths) {\n          const w = createDirectWatcher(filePath);\n\n          for (const watcher of entry.keys()) {\n            const old = underlyingWatcher.get(watcher);\n            if (old === w) continue;\n            w.add(watcher);\n            if (old !== undefined) old.remove(watcher);\n          }\n        }\n      }\n    }\n  }\n};\n\nexports.watch = filePath => {\n  const watcher = new Watcher(); // Find an existing watcher\n\n  const directWatcher = directWatchers.get(filePath);\n\n  if (directWatcher !== undefined) {\n    directWatcher.add(watcher);\n    return watcher;\n  }\n\n  let current = filePath;\n\n  for (;;) {\n    const recursiveWatcher = recursiveWatchers.get(current);\n\n    if (recursiveWatcher !== undefined) {\n      recursiveWatcher.add(filePath, watcher);\n      return watcher;\n    }\n\n    const parent = path.dirname(current);\n    if (parent === current) break;\n    current = parent;\n  } // Queue up watcher for creation\n\n\n  pendingWatchers.set(watcher, filePath);\n  if (!isBatch) execute();\n  return watcher;\n};\n\nexports.batch = fn => {\n  isBatch = true;\n\n  try {\n    fn();\n  } finally {\n    isBatch = false;\n    execute();\n  }\n};\n\nexports.getNumberOfWatchers = () => {\n  return watcherCount;\n};","map":{"version":3,"names":["fs","require","path","EventEmitter","reducePlan","IS_OSX","platform","IS_WIN","SUPPORTS_RECURSIVE_WATCHING","watcherLimit","process","env","WATCHPACK_WATCHER_LIMIT","recursiveWatcherLogging","WATCHPACK_RECURSIVE_WATCHER_LOGGING","isBatch","watcherCount","pendingWatchers","Map","recursiveWatchers","directWatchers","underlyingWatcher","DirectWatcher","constructor","filePath","watchers","Set","watcher","undefined","watch","on","type","filename","w","emit","error","err","nextTick","add","set","remove","delete","size","close","getWatchers","RecursiveWatcher","rootPath","mapWatcherToPath","mapPathToWatchers","recursive","stderr","write","keys","dir","dirname","get","basename","subpath","slice","length","newSet","Watcher","has","createDirectWatcher","existing","createRecursiveWatcher","execute","map","addWatcher","entry","Array","isArray","push","clear","item","values","join","plan","old","filePaths","watcherPath","exports","directWatcher","current","recursiveWatcher","parent","batch","fn","getNumberOfWatchers"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/watchpack/lib/watchEventSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst { EventEmitter } = require(\"events\");\nconst reducePlan = require(\"./reducePlan\");\n\nconst IS_OSX = require(\"os\").platform() === \"darwin\";\nconst IS_WIN = require(\"os\").platform() === \"win32\";\nconst SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;\n\nconst watcherLimit =\n\t+process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);\n\nconst recursiveWatcherLogging = !!process.env\n\t.WATCHPACK_RECURSIVE_WATCHER_LOGGING;\n\nlet isBatch = false;\nlet watcherCount = 0;\n\n/** @type {Map<Watcher, string>} */\nconst pendingWatchers = new Map();\n\n/** @type {Map<string, RecursiveWatcher>} */\nconst recursiveWatchers = new Map();\n\n/** @type {Map<string, DirectWatcher>} */\nconst directWatchers = new Map();\n\n/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>} */\nconst underlyingWatcher = new Map();\n\nclass DirectWatcher {\n\tconstructor(filePath) {\n\t\tthis.filePath = filePath;\n\t\tthis.watchers = new Set();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(filePath);\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"change\", type, filename);\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.watchers) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t}\n\n\tadd(watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tthis.watchers.add(watcher);\n\t}\n\n\tremove(watcher) {\n\t\tthis.watchers.delete(watcher);\n\t\tif (this.watchers.size === 0) {\n\t\t\tdirectWatchers.delete(this.filePath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.watchers;\n\t}\n}\n\nclass RecursiveWatcher {\n\tconstructor(rootPath) {\n\t\tthis.rootPath = rootPath;\n\t\t/** @type {Map<Watcher, string>} */\n\t\tthis.mapWatcherToPath = new Map();\n\t\t/** @type {Map<string, Set<Watcher>>} */\n\t\tthis.mapPathToWatchers = new Map();\n\t\tthis.watcher = undefined;\n\t\ttry {\n\t\t\tconst watcher = fs.watch(rootPath, {\n\t\t\t\trecursive: true\n\t\t\t});\n\t\t\tthis.watcher = watcher;\n\t\t\twatcher.on(\"change\", (type, filename) => {\n\t\t\t\tif (!filename) {\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) to all watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\t\tw.emit(\"change\", type);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst dir = path.dirname(filename);\n\t\t\t\t\tconst watchers = this.mapPathToWatchers.get(dir);\n\t\t\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t\t\t`[watchpack] dispatch ${type} event in recursive watcher (${\n\t\t\t\t\t\t\t\tthis.rootPath\n\t\t\t\t\t\t\t}) for '${filename}' to ${\n\t\t\t\t\t\t\t\twatchers ? watchers.size : 0\n\t\t\t\t\t\t\t} watchers\\n`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (watchers === undefined) return;\n\t\t\t\t\tfor (const w of watchers) {\n\t\t\t\t\t\tw.emit(\"change\", type, path.basename(filename));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\twatcher.on(\"error\", error => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", error);\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tfor (const w of this.mapWatcherToPath.keys()) {\n\t\t\t\t\tw.emit(\"error\", err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\twatcherCount++;\n\t\tif (recursiveWatcherLogging) {\n\t\t\tprocess.stderr.write(\n\t\t\t\t`[watchpack] created recursive watcher at ${rootPath}\\n`\n\t\t\t);\n\t\t}\n\t}\n\n\tadd(filePath, watcher) {\n\t\tunderlyingWatcher.set(watcher, this);\n\t\tconst subpath = filePath.slice(this.rootPath.length + 1) || \".\";\n\t\tthis.mapWatcherToPath.set(watcher, subpath);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tif (set === undefined) {\n\t\t\tconst newSet = new Set();\n\t\t\tnewSet.add(watcher);\n\t\t\tthis.mapPathToWatchers.set(subpath, newSet);\n\t\t} else {\n\t\t\tset.add(watcher);\n\t\t}\n\t}\n\n\tremove(watcher) {\n\t\tconst subpath = this.mapWatcherToPath.get(watcher);\n\t\tif (!subpath) return;\n\t\tthis.mapWatcherToPath.delete(watcher);\n\t\tconst set = this.mapPathToWatchers.get(subpath);\n\t\tset.delete(watcher);\n\t\tif (set.size === 0) {\n\t\t\tthis.mapPathToWatchers.delete(subpath);\n\t\t}\n\t\tif (this.mapWatcherToPath.size === 0) {\n\t\t\trecursiveWatchers.delete(this.rootPath);\n\t\t\twatcherCount--;\n\t\t\tif (this.watcher) this.watcher.close();\n\t\t\tif (recursiveWatcherLogging) {\n\t\t\t\tprocess.stderr.write(\n\t\t\t\t\t`[watchpack] closed recursive watcher at ${this.rootPath}\\n`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetWatchers() {\n\t\treturn this.mapWatcherToPath;\n\t}\n}\n\nclass Watcher extends EventEmitter {\n\tclose() {\n\t\tif (pendingWatchers.has(this)) {\n\t\t\tpendingWatchers.delete(this);\n\t\t\treturn;\n\t\t}\n\t\tconst watcher = underlyingWatcher.get(this);\n\t\twatcher.remove(this);\n\t\tunderlyingWatcher.delete(this);\n\t}\n}\n\nconst createDirectWatcher = filePath => {\n\tconst existing = directWatchers.get(filePath);\n\tif (existing !== undefined) return existing;\n\tconst w = new DirectWatcher(filePath);\n\tdirectWatchers.set(filePath, w);\n\treturn w;\n};\n\nconst createRecursiveWatcher = rootPath => {\n\tconst existing = recursiveWatchers.get(rootPath);\n\tif (existing !== undefined) return existing;\n\tconst w = new RecursiveWatcher(rootPath);\n\trecursiveWatchers.set(rootPath, w);\n\treturn w;\n};\n\nconst execute = () => {\n\t/** @type {Map<string, Watcher[] | Watcher>} */\n\tconst map = new Map();\n\tconst addWatcher = (watcher, filePath) => {\n\t\tconst entry = map.get(filePath);\n\t\tif (entry === undefined) {\n\t\t\tmap.set(filePath, watcher);\n\t\t} else if (Array.isArray(entry)) {\n\t\t\tentry.push(watcher);\n\t\t} else {\n\t\t\tmap.set(filePath, [entry, watcher]);\n\t\t}\n\t};\n\tfor (const [watcher, filePath] of pendingWatchers) {\n\t\taddWatcher(watcher, filePath);\n\t}\n\tpendingWatchers.clear();\n\n\t// Fast case when we are not reaching the limit\n\tif (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {\n\t\t// Create watchers for all entries in the map\n\t\tfor (const [filePath, entry] of map) {\n\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\tif (Array.isArray(entry)) {\n\t\t\t\tfor (const item of entry) w.add(item);\n\t\t\t} else {\n\t\t\t\tw.add(entry);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t// Reconsider existing watchers to improving watch plan\n\tfor (const watcher of recursiveWatchers.values()) {\n\t\tfor (const [w, subpath] of watcher.getWatchers()) {\n\t\t\taddWatcher(w, path.join(watcher.rootPath, subpath));\n\t\t}\n\t}\n\tfor (const watcher of directWatchers.values()) {\n\t\tfor (const w of watcher.getWatchers()) {\n\t\t\taddWatcher(w, watcher.filePath);\n\t\t}\n\t}\n\n\t// Merge map entries to keep watcher limit\n\t// Create a 10% buffer to be able to enter fast case more often\n\tconst plan = reducePlan(map, watcherLimit * 0.9);\n\n\t// Update watchers for all entries in the map\n\tfor (const [filePath, entry] of plan) {\n\t\tif (entry.size === 1) {\n\t\t\tfor (const [watcher, filePath] of entry) {\n\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\tif (old === w) continue;\n\t\t\t\tw.add(watcher);\n\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t}\n\t\t} else {\n\t\t\tconst filePaths = new Set(entry.values());\n\t\t\tif (filePaths.size > 1) {\n\t\t\t\tconst w = createRecursiveWatcher(filePath);\n\t\t\t\tfor (const [watcher, watcherPath] of entry) {\n\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\tw.add(watcherPath, watcher);\n\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (const filePath of filePaths) {\n\t\t\t\t\tconst w = createDirectWatcher(filePath);\n\t\t\t\t\tfor (const watcher of entry.keys()) {\n\t\t\t\t\t\tconst old = underlyingWatcher.get(watcher);\n\t\t\t\t\t\tif (old === w) continue;\n\t\t\t\t\t\tw.add(watcher);\n\t\t\t\t\t\tif (old !== undefined) old.remove(watcher);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\nexports.watch = filePath => {\n\tconst watcher = new Watcher();\n\t// Find an existing watcher\n\tconst directWatcher = directWatchers.get(filePath);\n\tif (directWatcher !== undefined) {\n\t\tdirectWatcher.add(watcher);\n\t\treturn watcher;\n\t}\n\tlet current = filePath;\n\tfor (;;) {\n\t\tconst recursiveWatcher = recursiveWatchers.get(current);\n\t\tif (recursiveWatcher !== undefined) {\n\t\t\trecursiveWatcher.add(filePath, watcher);\n\t\t\treturn watcher;\n\t\t}\n\t\tconst parent = path.dirname(current);\n\t\tif (parent === current) break;\n\t\tcurrent = parent;\n\t}\n\t// Queue up watcher for creation\n\tpendingWatchers.set(watcher, filePath);\n\tif (!isBatch) execute();\n\treturn watcher;\n};\n\nexports.batch = fn => {\n\tisBatch = true;\n\ttry {\n\t\tfn();\n\t} finally {\n\t\tisBatch = false;\n\t\texecute();\n\t}\n};\n\nexports.getNumberOfWatchers = () => {\n\treturn watcherCount;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}