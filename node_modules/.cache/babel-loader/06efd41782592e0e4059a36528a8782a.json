{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  SyncHook,\n  AsyncSeriesHook\n} = require(\"tapable\");\n\nconst {\n  makeWebpackError\n} = require(\"../HookWebpackError\");\n\nconst WebpackError = require(\"../WebpackError\");\n\nconst ArrayQueue = require(\"./ArrayQueue\");\n\nconst QUEUED_STATE = 0;\nconst PROCESSING_STATE = 1;\nconst DONE_STATE = 2;\nlet inHandleResult = 0;\n/**\n * @template T\n * @callback Callback\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\n\nclass AsyncQueueEntry {\n  /**\n   * @param {T} item the item\n   * @param {Callback<R>} callback the callback\n   */\n  constructor(item, callback) {\n    this.item = item;\n    /** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE} */\n\n    this.state = QUEUED_STATE;\n    this.callback = callback;\n    /** @type {Callback<R>[] | undefined} */\n\n    this.callbacks = undefined;\n    this.result = undefined;\n    /** @type {WebpackError | undefined} */\n\n    this.error = undefined;\n  }\n\n}\n/**\n * @template T\n * @template K\n * @template R\n */\n\n\nclass AsyncQueue {\n  /**\n   * @param {Object} options options object\n   * @param {string=} options.name name of the queue\n   * @param {number=} options.parallelism how many items should be processed at once\n   * @param {AsyncQueue<any, any, any>=} options.parent parent queue, which will have priority over this queue and with shared parallelism\n   * @param {function(T): K=} options.getKey extract key from item\n   * @param {function(T, Callback<R>): void} options.processor async function to process items\n   */\n  constructor(_ref) {\n    let {\n      name,\n      parallelism,\n      parent,\n      processor,\n      getKey\n    } = _ref;\n    this._name = name;\n    this._parallelism = parallelism || 1;\n    this._processor = processor;\n\n    this._getKey = getKey || (\n    /** @type {(T) => K} */\n    item =>\n    /** @type {any} */\n    item);\n    /** @type {Map<K, AsyncQueueEntry<T, K, R>>} */\n\n\n    this._entries = new Map();\n    /** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>} */\n\n    this._queued = new ArrayQueue();\n    /** @type {AsyncQueue<any, any, any>[]} */\n\n    this._children = undefined;\n    this._activeTasks = 0;\n    this._willEnsureProcessing = false;\n    this._needProcessing = false;\n    this._stopped = false;\n    this._root = parent ? parent._root : this;\n\n    if (parent) {\n      if (this._root._children === undefined) {\n        this._root._children = [this];\n      } else {\n        this._root._children.push(this);\n      }\n    }\n\n    this.hooks = {\n      /** @type {AsyncSeriesHook<[T]>} */\n      beforeAdd: new AsyncSeriesHook([\"item\"]),\n\n      /** @type {SyncHook<[T]>} */\n      added: new SyncHook([\"item\"]),\n\n      /** @type {AsyncSeriesHook<[T]>} */\n      beforeStart: new AsyncSeriesHook([\"item\"]),\n\n      /** @type {SyncHook<[T]>} */\n      started: new SyncHook([\"item\"]),\n\n      /** @type {SyncHook<[T, Error, R]>} */\n      result: new SyncHook([\"item\", \"error\", \"result\"])\n    };\n    this._ensureProcessing = this._ensureProcessing.bind(this);\n  }\n  /**\n   * @param {T} item an item\n   * @param {Callback<R>} callback callback function\n   * @returns {void}\n   */\n\n\n  add(item, callback) {\n    if (this._stopped) return callback(new WebpackError(\"Queue was stopped\"));\n    this.hooks.beforeAdd.callAsync(item, err => {\n      if (err) {\n        callback(makeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeAdd`));\n        return;\n      }\n\n      const key = this._getKey(item);\n\n      const entry = this._entries.get(key);\n\n      if (entry !== undefined) {\n        if (entry.state === DONE_STATE) {\n          if (inHandleResult++ > 3) {\n            process.nextTick(() => callback(entry.error, entry.result));\n          } else {\n            callback(entry.error, entry.result);\n          }\n\n          inHandleResult--;\n        } else if (entry.callbacks === undefined) {\n          entry.callbacks = [callback];\n        } else {\n          entry.callbacks.push(callback);\n        }\n\n        return;\n      }\n\n      const newEntry = new AsyncQueueEntry(item, callback);\n\n      if (this._stopped) {\n        this.hooks.added.call(item);\n        this._root._activeTasks++;\n        process.nextTick(() => this._handleResult(newEntry, new WebpackError(\"Queue was stopped\")));\n      } else {\n        this._entries.set(key, newEntry);\n\n        this._queued.enqueue(newEntry);\n\n        const root = this._root;\n        root._needProcessing = true;\n\n        if (root._willEnsureProcessing === false) {\n          root._willEnsureProcessing = true;\n          setImmediate(root._ensureProcessing);\n        }\n\n        this.hooks.added.call(item);\n      }\n    });\n  }\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n\n\n  invalidate(item) {\n    const key = this._getKey(item);\n\n    const entry = this._entries.get(key);\n\n    this._entries.delete(key);\n\n    if (entry.state === QUEUED_STATE) {\n      this._queued.delete(entry);\n    }\n  }\n  /**\n   * Waits for an already started item\n   * @param {T} item an item\n   * @param {Callback<R>} callback callback function\n   * @returns {void}\n   */\n\n\n  waitFor(item, callback) {\n    const key = this._getKey(item);\n\n    const entry = this._entries.get(key);\n\n    if (entry === undefined) {\n      return callback(new WebpackError(\"waitFor can only be called for an already started item\"));\n    }\n\n    if (entry.state === DONE_STATE) {\n      process.nextTick(() => callback(entry.error, entry.result));\n    } else if (entry.callbacks === undefined) {\n      entry.callbacks = [callback];\n    } else {\n      entry.callbacks.push(callback);\n    }\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  stop() {\n    this._stopped = true;\n    const queue = this._queued;\n    this._queued = new ArrayQueue();\n    const root = this._root;\n\n    for (const entry of queue) {\n      this._entries.delete(this._getKey(entry.item));\n\n      root._activeTasks++;\n\n      this._handleResult(entry, new WebpackError(\"Queue was stopped\"));\n    }\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  increaseParallelism() {\n    const root = this._root;\n    root._parallelism++;\n    /* istanbul ignore next */\n\n    if (root._willEnsureProcessing === false && root._needProcessing) {\n      root._willEnsureProcessing = true;\n      setImmediate(root._ensureProcessing);\n    }\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  decreaseParallelism() {\n    const root = this._root;\n    root._parallelism--;\n  }\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently being processed\n   */\n\n\n  isProcessing(item) {\n    const key = this._getKey(item);\n\n    const entry = this._entries.get(key);\n\n    return entry !== undefined && entry.state === PROCESSING_STATE;\n  }\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently queued\n   */\n\n\n  isQueued(item) {\n    const key = this._getKey(item);\n\n    const entry = this._entries.get(key);\n\n    return entry !== undefined && entry.state === QUEUED_STATE;\n  }\n  /**\n   * @param {T} item an item\n   * @returns {boolean} true, if the item is currently queued\n   */\n\n\n  isDone(item) {\n    const key = this._getKey(item);\n\n    const entry = this._entries.get(key);\n\n    return entry !== undefined && entry.state === DONE_STATE;\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  _ensureProcessing() {\n    while (this._activeTasks < this._parallelism) {\n      const entry = this._queued.dequeue();\n\n      if (entry === undefined) break;\n      this._activeTasks++;\n      entry.state = PROCESSING_STATE;\n\n      this._startProcessing(entry);\n    }\n\n    this._willEnsureProcessing = false;\n    if (this._queued.length > 0) return;\n\n    if (this._children !== undefined) {\n      for (const child of this._children) {\n        while (this._activeTasks < this._parallelism) {\n          const entry = child._queued.dequeue();\n\n          if (entry === undefined) break;\n          this._activeTasks++;\n          entry.state = PROCESSING_STATE;\n\n          child._startProcessing(entry);\n        }\n\n        if (child._queued.length > 0) return;\n      }\n    }\n\n    if (!this._willEnsureProcessing) this._needProcessing = false;\n  }\n  /**\n   * @param {AsyncQueueEntry<T, K, R>} entry the entry\n   * @returns {void}\n   */\n\n\n  _startProcessing(entry) {\n    this.hooks.beforeStart.callAsync(entry.item, err => {\n      if (err) {\n        this._handleResult(entry, makeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeStart`));\n\n        return;\n      }\n\n      let inCallback = false;\n\n      try {\n        this._processor(entry.item, (e, r) => {\n          inCallback = true;\n\n          this._handleResult(entry, e, r);\n        });\n      } catch (err) {\n        if (inCallback) throw err;\n\n        this._handleResult(entry, err, null);\n      }\n\n      this.hooks.started.call(entry.item);\n    });\n  }\n  /**\n   * @param {AsyncQueueEntry<T, K, R>} entry the entry\n   * @param {WebpackError=} err error, if any\n   * @param {R=} result result, if any\n   * @returns {void}\n   */\n\n\n  _handleResult(entry, err, result) {\n    this.hooks.result.callAsync(entry.item, err, result, hookError => {\n      const error = hookError ? makeWebpackError(hookError, `AsyncQueue(${this._name}).hooks.result`) : err;\n      const callback = entry.callback;\n      const callbacks = entry.callbacks;\n      entry.state = DONE_STATE;\n      entry.callback = undefined;\n      entry.callbacks = undefined;\n      entry.result = result;\n      entry.error = error;\n      const root = this._root;\n      root._activeTasks--;\n\n      if (root._willEnsureProcessing === false && root._needProcessing) {\n        root._willEnsureProcessing = true;\n        setImmediate(root._ensureProcessing);\n      }\n\n      if (inHandleResult++ > 3) {\n        process.nextTick(() => {\n          callback(error, result);\n\n          if (callbacks !== undefined) {\n            for (const callback of callbacks) {\n              callback(error, result);\n            }\n          }\n        });\n      } else {\n        callback(error, result);\n\n        if (callbacks !== undefined) {\n          for (const callback of callbacks) {\n            callback(error, result);\n          }\n        }\n      }\n\n      inHandleResult--;\n    });\n  }\n\n  clear() {\n    this._entries.clear();\n\n    this._queued.clear();\n\n    this._activeTasks = 0;\n    this._willEnsureProcessing = false;\n    this._needProcessing = false;\n    this._stopped = false;\n  }\n\n}\n\nmodule.exports = AsyncQueue;","map":{"version":3,"names":["SyncHook","AsyncSeriesHook","require","makeWebpackError","WebpackError","ArrayQueue","QUEUED_STATE","PROCESSING_STATE","DONE_STATE","inHandleResult","AsyncQueueEntry","constructor","item","callback","state","callbacks","undefined","result","error","AsyncQueue","name","parallelism","parent","processor","getKey","_name","_parallelism","_processor","_getKey","_entries","Map","_queued","_children","_activeTasks","_willEnsureProcessing","_needProcessing","_stopped","_root","push","hooks","beforeAdd","added","beforeStart","started","_ensureProcessing","bind","add","callAsync","err","key","entry","get","process","nextTick","newEntry","call","_handleResult","set","enqueue","root","setImmediate","invalidate","delete","waitFor","stop","queue","increaseParallelism","decreaseParallelism","isProcessing","isQueued","isDone","dequeue","_startProcessing","length","child","inCallback","e","r","hookError","clear","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/util/AsyncQueue.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncHook, AsyncSeriesHook } = require(\"tapable\");\nconst { makeWebpackError } = require(\"../HookWebpackError\");\nconst WebpackError = require(\"../WebpackError\");\nconst ArrayQueue = require(\"./ArrayQueue\");\n\nconst QUEUED_STATE = 0;\nconst PROCESSING_STATE = 1;\nconst DONE_STATE = 2;\n\nlet inHandleResult = 0;\n\n/**\n * @template T\n * @callback Callback\n * @param {(WebpackError | null)=} err\n * @param {T=} result\n */\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueueEntry {\n\t/**\n\t * @param {T} item the item\n\t * @param {Callback<R>} callback the callback\n\t */\n\tconstructor(item, callback) {\n\t\tthis.item = item;\n\t\t/** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE} */\n\t\tthis.state = QUEUED_STATE;\n\t\tthis.callback = callback;\n\t\t/** @type {Callback<R>[] | undefined} */\n\t\tthis.callbacks = undefined;\n\t\tthis.result = undefined;\n\t\t/** @type {WebpackError | undefined} */\n\t\tthis.error = undefined;\n\t}\n}\n\n/**\n * @template T\n * @template K\n * @template R\n */\nclass AsyncQueue {\n\t/**\n\t * @param {Object} options options object\n\t * @param {string=} options.name name of the queue\n\t * @param {number=} options.parallelism how many items should be processed at once\n\t * @param {AsyncQueue<any, any, any>=} options.parent parent queue, which will have priority over this queue and with shared parallelism\n\t * @param {function(T): K=} options.getKey extract key from item\n\t * @param {function(T, Callback<R>): void} options.processor async function to process items\n\t */\n\tconstructor({ name, parallelism, parent, processor, getKey }) {\n\t\tthis._name = name;\n\t\tthis._parallelism = parallelism || 1;\n\t\tthis._processor = processor;\n\t\tthis._getKey =\n\t\t\tgetKey || /** @type {(T) => K} */ (item => /** @type {any} */ (item));\n\t\t/** @type {Map<K, AsyncQueueEntry<T, K, R>>} */\n\t\tthis._entries = new Map();\n\t\t/** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>} */\n\t\tthis._queued = new ArrayQueue();\n\t\t/** @type {AsyncQueue<any, any, any>[]} */\n\t\tthis._children = undefined;\n\t\tthis._activeTasks = 0;\n\t\tthis._willEnsureProcessing = false;\n\t\tthis._needProcessing = false;\n\t\tthis._stopped = false;\n\t\tthis._root = parent ? parent._root : this;\n\t\tif (parent) {\n\t\t\tif (this._root._children === undefined) {\n\t\t\t\tthis._root._children = [this];\n\t\t\t} else {\n\t\t\t\tthis._root._children.push(this);\n\t\t\t}\n\t\t}\n\n\t\tthis.hooks = {\n\t\t\t/** @type {AsyncSeriesHook<[T]>} */\n\t\t\tbeforeAdd: new AsyncSeriesHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T]>} */\n\t\t\tadded: new SyncHook([\"item\"]),\n\t\t\t/** @type {AsyncSeriesHook<[T]>} */\n\t\t\tbeforeStart: new AsyncSeriesHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T]>} */\n\t\t\tstarted: new SyncHook([\"item\"]),\n\t\t\t/** @type {SyncHook<[T, Error, R]>} */\n\t\t\tresult: new SyncHook([\"item\", \"error\", \"result\"])\n\t\t};\n\n\t\tthis._ensureProcessing = this._ensureProcessing.bind(this);\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @param {Callback<R>} callback callback function\n\t * @returns {void}\n\t */\n\tadd(item, callback) {\n\t\tif (this._stopped) return callback(new WebpackError(\"Queue was stopped\"));\n\t\tthis.hooks.beforeAdd.callAsync(item, err => {\n\t\t\tif (err) {\n\t\t\t\tcallback(\n\t\t\t\t\tmakeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeAdd`)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst key = this._getKey(item);\n\t\t\tconst entry = this._entries.get(key);\n\t\t\tif (entry !== undefined) {\n\t\t\t\tif (entry.state === DONE_STATE) {\n\t\t\t\t\tif (inHandleResult++ > 3) {\n\t\t\t\t\t\tprocess.nextTick(() => callback(entry.error, entry.result));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback(entry.error, entry.result);\n\t\t\t\t\t}\n\t\t\t\t\tinHandleResult--;\n\t\t\t\t} else if (entry.callbacks === undefined) {\n\t\t\t\t\tentry.callbacks = [callback];\n\t\t\t\t} else {\n\t\t\t\t\tentry.callbacks.push(callback);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newEntry = new AsyncQueueEntry(item, callback);\n\t\t\tif (this._stopped) {\n\t\t\t\tthis.hooks.added.call(item);\n\t\t\t\tthis._root._activeTasks++;\n\t\t\t\tprocess.nextTick(() =>\n\t\t\t\t\tthis._handleResult(newEntry, new WebpackError(\"Queue was stopped\"))\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._entries.set(key, newEntry);\n\t\t\t\tthis._queued.enqueue(newEntry);\n\t\t\t\tconst root = this._root;\n\t\t\t\troot._needProcessing = true;\n\t\t\t\tif (root._willEnsureProcessing === false) {\n\t\t\t\t\troot._willEnsureProcessing = true;\n\t\t\t\t\tsetImmediate(root._ensureProcessing);\n\t\t\t\t}\n\t\t\t\tthis.hooks.added.call(item);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {void}\n\t */\n\tinvalidate(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\tthis._entries.delete(key);\n\t\tif (entry.state === QUEUED_STATE) {\n\t\t\tthis._queued.delete(entry);\n\t\t}\n\t}\n\n\t/**\n\t * Waits for an already started item\n\t * @param {T} item an item\n\t * @param {Callback<R>} callback callback function\n\t * @returns {void}\n\t */\n\twaitFor(item, callback) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\tif (entry === undefined) {\n\t\t\treturn callback(\n\t\t\t\tnew WebpackError(\n\t\t\t\t\t\"waitFor can only be called for an already started item\"\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t\tif (entry.state === DONE_STATE) {\n\t\t\tprocess.nextTick(() => callback(entry.error, entry.result));\n\t\t} else if (entry.callbacks === undefined) {\n\t\t\tentry.callbacks = [callback];\n\t\t} else {\n\t\t\tentry.callbacks.push(callback);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tstop() {\n\t\tthis._stopped = true;\n\t\tconst queue = this._queued;\n\t\tthis._queued = new ArrayQueue();\n\t\tconst root = this._root;\n\t\tfor (const entry of queue) {\n\t\t\tthis._entries.delete(this._getKey(entry.item));\n\t\t\troot._activeTasks++;\n\t\t\tthis._handleResult(entry, new WebpackError(\"Queue was stopped\"));\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tincreaseParallelism() {\n\t\tconst root = this._root;\n\t\troot._parallelism++;\n\t\t/* istanbul ignore next */\n\t\tif (root._willEnsureProcessing === false && root._needProcessing) {\n\t\t\troot._willEnsureProcessing = true;\n\t\t\tsetImmediate(root._ensureProcessing);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tdecreaseParallelism() {\n\t\tconst root = this._root;\n\t\troot._parallelism--;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently being processed\n\t */\n\tisProcessing(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === PROCESSING_STATE;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently queued\n\t */\n\tisQueued(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === QUEUED_STATE;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {boolean} true, if the item is currently queued\n\t */\n\tisDone(item) {\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._entries.get(key);\n\t\treturn entry !== undefined && entry.state === DONE_STATE;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\t_ensureProcessing() {\n\t\twhile (this._activeTasks < this._parallelism) {\n\t\t\tconst entry = this._queued.dequeue();\n\t\t\tif (entry === undefined) break;\n\t\t\tthis._activeTasks++;\n\t\t\tentry.state = PROCESSING_STATE;\n\t\t\tthis._startProcessing(entry);\n\t\t}\n\t\tthis._willEnsureProcessing = false;\n\t\tif (this._queued.length > 0) return;\n\t\tif (this._children !== undefined) {\n\t\t\tfor (const child of this._children) {\n\t\t\t\twhile (this._activeTasks < this._parallelism) {\n\t\t\t\t\tconst entry = child._queued.dequeue();\n\t\t\t\t\tif (entry === undefined) break;\n\t\t\t\t\tthis._activeTasks++;\n\t\t\t\t\tentry.state = PROCESSING_STATE;\n\t\t\t\t\tchild._startProcessing(entry);\n\t\t\t\t}\n\t\t\t\tif (child._queued.length > 0) return;\n\t\t\t}\n\t\t}\n\t\tif (!this._willEnsureProcessing) this._needProcessing = false;\n\t}\n\n\t/**\n\t * @param {AsyncQueueEntry<T, K, R>} entry the entry\n\t * @returns {void}\n\t */\n\t_startProcessing(entry) {\n\t\tthis.hooks.beforeStart.callAsync(entry.item, err => {\n\t\t\tif (err) {\n\t\t\t\tthis._handleResult(\n\t\t\t\t\tentry,\n\t\t\t\t\tmakeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeStart`)\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet inCallback = false;\n\t\t\ttry {\n\t\t\t\tthis._processor(entry.item, (e, r) => {\n\t\t\t\t\tinCallback = true;\n\t\t\t\t\tthis._handleResult(entry, e, r);\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\tif (inCallback) throw err;\n\t\t\t\tthis._handleResult(entry, err, null);\n\t\t\t}\n\t\t\tthis.hooks.started.call(entry.item);\n\t\t});\n\t}\n\n\t/**\n\t * @param {AsyncQueueEntry<T, K, R>} entry the entry\n\t * @param {WebpackError=} err error, if any\n\t * @param {R=} result result, if any\n\t * @returns {void}\n\t */\n\t_handleResult(entry, err, result) {\n\t\tthis.hooks.result.callAsync(entry.item, err, result, hookError => {\n\t\t\tconst error = hookError\n\t\t\t\t? makeWebpackError(hookError, `AsyncQueue(${this._name}).hooks.result`)\n\t\t\t\t: err;\n\n\t\t\tconst callback = entry.callback;\n\t\t\tconst callbacks = entry.callbacks;\n\t\t\tentry.state = DONE_STATE;\n\t\t\tentry.callback = undefined;\n\t\t\tentry.callbacks = undefined;\n\t\t\tentry.result = result;\n\t\t\tentry.error = error;\n\n\t\t\tconst root = this._root;\n\t\t\troot._activeTasks--;\n\t\t\tif (root._willEnsureProcessing === false && root._needProcessing) {\n\t\t\t\troot._willEnsureProcessing = true;\n\t\t\t\tsetImmediate(root._ensureProcessing);\n\t\t\t}\n\n\t\t\tif (inHandleResult++ > 3) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tcallback(error, result);\n\t\t\t\t\tif (callbacks !== undefined) {\n\t\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\t\tcallback(error, result);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcallback(error, result);\n\t\t\t\tif (callbacks !== undefined) {\n\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\tcallback(error, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tinHandleResult--;\n\t\t});\n\t}\n\n\tclear() {\n\t\tthis._entries.clear();\n\t\tthis._queued.clear();\n\t\tthis._activeTasks = 0;\n\t\tthis._willEnsureProcessing = false;\n\t\tthis._needProcessing = false;\n\t\tthis._stopped = false;\n\t}\n}\n\nmodule.exports = AsyncQueue;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}