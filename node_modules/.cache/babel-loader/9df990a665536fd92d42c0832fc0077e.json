{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst webpackSchema = require(\"../schemas/WebpackOptions.json\"); // TODO add originPath to PathItem for better errors\n\n/**\n * @typedef {Object} PathItem\n * @property {any} schema the part of the schema\n * @property {string} path the path in the config\n */\n\n/** @typedef {\"unknown-argument\" | \"unexpected-non-array-in-path\" | \"unexpected-non-object-in-path\" | \"multiple-values-unexpected\" | \"invalid-value\"} ProblemType */\n\n/**\n * @typedef {Object} Problem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string} argument\n * @property {any=} value\n * @property {number=} index\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} LocalProblem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} ArgumentConfig\n * @property {string} description\n * @property {string} [negatedDescription]\n * @property {string} path\n * @property {boolean} multiple\n * @property {\"enum\"|\"string\"|\"path\"|\"number\"|\"boolean\"|\"RegExp\"|\"reset\"} type\n * @property {any[]=} values\n */\n\n/**\n * @typedef {Object} Argument\n * @property {string} description\n * @property {\"string\"|\"number\"|\"boolean\"} simpleType\n * @property {boolean} multiple\n * @property {ArgumentConfig[]} configs\n */\n\n/**\n * @param {any=} schema a json schema to create arguments for (by default webpack schema is used)\n * @returns {Record<string, Argument>} object of arguments\n */\n\n\nconst getArguments = function () {\n  let schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : webpackSchema;\n\n  /** @type {Record<string, Argument>} */\n  const flags = {};\n\n  const pathToArgumentName = input => {\n    return input.replace(/\\./g, \"-\").replace(/\\[\\]/g, \"\").replace(/(\\p{Uppercase_Letter}+|\\p{Lowercase_Letter}|\\d)(\\p{Uppercase_Letter}+)/gu, \"$1-$2\").replace(/-?[^\\p{Uppercase_Letter}\\p{Lowercase_Letter}\\d]+/gu, \"-\").toLowerCase();\n  };\n\n  const getSchemaPart = path => {\n    const newPath = path.split(\"/\");\n    let schemaPart = schema;\n\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[newPath[i]];\n\n      if (!inner) {\n        break;\n      }\n\n      schemaPart = inner;\n    }\n\n    return schemaPart;\n  };\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} description\n   */\n\n\n  const getDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.description) return schema.cli.description;\n      }\n\n      if (schema.description) return schema.description;\n    }\n  };\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} negative description\n   */\n\n\n  const getNegatedDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.negatedDescription) return schema.cli.negatedDescription;\n      }\n    }\n  };\n  /**\n   *\n   * @param {PathItem[]} path path in the schema\n   * @returns {string | undefined} reset description\n   */\n\n\n  const getResetDescription = path => {\n    for (const {\n      schema\n    } of path) {\n      if (schema.cli) {\n        if (schema.cli.helper) continue;\n        if (schema.cli.resetDescription) return schema.cli.resetDescription;\n      }\n    }\n  };\n  /**\n   *\n   * @param {any} schemaPart schema\n   * @returns {Pick<ArgumentConfig, \"type\"|\"values\">} partial argument config\n   */\n\n\n  const schemaToArgumentConfig = schemaPart => {\n    if (schemaPart.enum) {\n      return {\n        type: \"enum\",\n        values: schemaPart.enum\n      };\n    }\n\n    switch (schemaPart.type) {\n      case \"number\":\n        return {\n          type: \"number\"\n        };\n\n      case \"string\":\n        return {\n          type: schemaPart.absolutePath ? \"path\" : \"string\"\n        };\n\n      case \"boolean\":\n        return {\n          type: \"boolean\"\n        };\n    }\n\n    if (schemaPart.instanceof === \"RegExp\") {\n      return {\n        type: \"RegExp\"\n      };\n    }\n\n    return undefined;\n  };\n  /**\n   * @param {PathItem[]} path path in the schema\n   * @returns {void}\n   */\n\n\n  const addResetFlag = path => {\n    const schemaPath = path[0].path;\n    const name = pathToArgumentName(`${schemaPath}.reset`);\n    const description = getResetDescription(path) || `Clear all items provided in '${schemaPath}' configuration. ${getDescription(path)}`;\n    flags[name] = {\n      configs: [{\n        type: \"reset\",\n        multiple: false,\n        description,\n        path: schemaPath\n      }],\n      description: undefined,\n      simpleType: undefined,\n      multiple: undefined\n    };\n  };\n  /**\n   * @param {PathItem[]} path full path in schema\n   * @param {boolean} multiple inside of an array\n   * @returns {number} number of arguments added\n   */\n\n\n  const addFlag = (path, multiple) => {\n    const argConfigBase = schemaToArgumentConfig(path[0].schema);\n    if (!argConfigBase) return 0;\n    const negatedDescription = getNegatedDescription(path);\n    const name = pathToArgumentName(path[0].path);\n    /** @type {ArgumentConfig} */\n\n    const argConfig = { ...argConfigBase,\n      multiple,\n      description: getDescription(path),\n      path: path[0].path\n    };\n\n    if (negatedDescription) {\n      argConfig.negatedDescription = negatedDescription;\n    }\n\n    if (!flags[name]) {\n      flags[name] = {\n        configs: [],\n        description: undefined,\n        simpleType: undefined,\n        multiple: undefined\n      };\n    }\n\n    if (flags[name].configs.some(item => JSON.stringify(item) === JSON.stringify(argConfig))) {\n      return 0;\n    }\n\n    if (flags[name].configs.some(item => item.type === argConfig.type && item.multiple !== multiple)) {\n      if (multiple) {\n        throw new Error(`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`);\n      }\n\n      return 0;\n    }\n\n    flags[name].configs.push(argConfig);\n    return 1;\n  }; // TODO support `not` and `if/then/else`\n  // TODO support `const`, but we don't use it on our schema\n\n  /**\n   *\n   * @param {object} schemaPart the current schema\n   * @param {string} schemaPath the current path in the schema\n   * @param {{schema: object, path: string}[]} path all previous visited schemaParts\n   * @param {string | null} inArray if inside of an array, the path to the array\n   * @returns {number} added arguments\n   */\n\n\n  const traverse = function (schemaPart) {\n    let schemaPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    let inArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    while (schemaPart.$ref) {\n      schemaPart = getSchemaPart(schemaPart.$ref);\n    }\n\n    const repetitions = path.filter(_ref => {\n      let {\n        schema\n      } = _ref;\n      return schema === schemaPart;\n    });\n\n    if (repetitions.length >= 2 || repetitions.some(_ref2 => {\n      let {\n        path\n      } = _ref2;\n      return path === schemaPath;\n    })) {\n      return 0;\n    }\n\n    if (schemaPart.cli && schemaPart.cli.exclude) return 0;\n    const fullPath = [{\n      schema: schemaPart,\n      path: schemaPath\n    }, ...path];\n    let addedArguments = 0;\n    addedArguments += addFlag(fullPath, !!inArray);\n\n    if (schemaPart.type === \"object\") {\n      if (schemaPart.properties) {\n        for (const property of Object.keys(schemaPart.properties)) {\n          addedArguments += traverse(schemaPart.properties[property], schemaPath ? `${schemaPath}.${property}` : property, fullPath, inArray);\n        }\n      }\n\n      return addedArguments;\n    }\n\n    if (schemaPart.type === \"array\") {\n      if (inArray) {\n        return 0;\n      }\n\n      if (Array.isArray(schemaPart.items)) {\n        let i = 0;\n\n        for (const item of schemaPart.items) {\n          addedArguments += traverse(item, `${schemaPath}.${i}`, fullPath, schemaPath);\n        }\n\n        return addedArguments;\n      }\n\n      addedArguments += traverse(schemaPart.items, `${schemaPath}[]`, fullPath, schemaPath);\n\n      if (addedArguments > 0) {\n        addResetFlag(fullPath);\n        addedArguments++;\n      }\n\n      return addedArguments;\n    }\n\n    const maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;\n\n    if (maybeOf) {\n      const items = maybeOf;\n\n      for (let i = 0; i < items.length; i++) {\n        addedArguments += traverse(items[i], schemaPath, fullPath, inArray);\n      }\n\n      return addedArguments;\n    }\n\n    return addedArguments;\n  };\n\n  traverse(schema); // Summarize flags\n\n  for (const name of Object.keys(flags)) {\n    const argument = flags[name];\n    argument.description = argument.configs.reduce((desc, _ref3) => {\n      let {\n        description\n      } = _ref3;\n      if (!desc) return description;\n      if (!description) return desc;\n      if (desc.includes(description)) return desc;\n      return `${desc} ${description}`;\n    },\n    /** @type {string | undefined} */\n    undefined);\n    argument.simpleType = argument.configs.reduce((t, argConfig) => {\n      /** @type {\"string\" | \"number\" | \"boolean\"} */\n      let type = \"string\";\n\n      switch (argConfig.type) {\n        case \"number\":\n          type = \"number\";\n          break;\n\n        case \"reset\":\n        case \"boolean\":\n          type = \"boolean\";\n          break;\n\n        case \"enum\":\n          if (argConfig.values.every(v => typeof v === \"boolean\")) type = \"boolean\";\n          if (argConfig.values.every(v => typeof v === \"number\")) type = \"number\";\n          break;\n      }\n\n      if (t === undefined) return type;\n      return t === type ? t : \"string\";\n    },\n    /** @type {\"string\" | \"number\" | \"boolean\" | undefined} */\n    undefined);\n    argument.multiple = argument.configs.some(c => c.multiple);\n  }\n\n  return flags;\n};\n\nconst cliAddedItems = new WeakMap();\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {{ problem?: LocalProblem, object?: any, property?: string | number, value?: any }} problem or object with property and value\n */\n\nconst getObjectAndProperty = function (config, schemaPath) {\n  let index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (!schemaPath) return {\n    value: config\n  };\n  const parts = schemaPath.split(\".\");\n  let property = parts.pop();\n  let current = config;\n  let i = 0;\n\n  for (const part of parts) {\n    const isArray = part.endsWith(\"[]\");\n    const name = isArray ? part.slice(0, -2) : part;\n    let value = current[name];\n\n    if (isArray) {\n      if (value === undefined) {\n        value = {};\n        current[name] = [...Array.from({\n          length: index\n        }), value];\n        cliAddedItems.set(current[name], index + 1);\n      } else if (!Array.isArray(value)) {\n        return {\n          problem: {\n            type: \"unexpected-non-array-in-path\",\n            path: parts.slice(0, i).join(\".\")\n          }\n        };\n      } else {\n        let addedItems = cliAddedItems.get(value) || 0;\n\n        while (addedItems <= index) {\n          value.push(undefined);\n          addedItems++;\n        }\n\n        cliAddedItems.set(value, addedItems);\n        const x = value.length - addedItems + index;\n\n        if (value[x] === undefined) {\n          value[x] = {};\n        } else if (value[x] === null || typeof value[x] !== \"object\") {\n          return {\n            problem: {\n              type: \"unexpected-non-object-in-path\",\n              path: parts.slice(0, i).join(\".\")\n            }\n          };\n        }\n\n        value = value[x];\n      }\n    } else {\n      if (value === undefined) {\n        value = current[name] = {};\n      } else if (value === null || typeof value !== \"object\") {\n        return {\n          problem: {\n            type: \"unexpected-non-object-in-path\",\n            path: parts.slice(0, i).join(\".\")\n          }\n        };\n      }\n    }\n\n    current = value;\n    i++;\n  }\n\n  let value = current[property];\n\n  if (property.endsWith(\"[]\")) {\n    const name = property.slice(0, -2);\n    const value = current[name];\n\n    if (value === undefined) {\n      current[name] = [...Array.from({\n        length: index\n      }), undefined];\n      cliAddedItems.set(current[name], index + 1);\n      return {\n        object: current[name],\n        property: index,\n        value: undefined\n      };\n    } else if (!Array.isArray(value)) {\n      current[name] = [value, ...Array.from({\n        length: index\n      }), undefined];\n      cliAddedItems.set(current[name], index + 1);\n      return {\n        object: current[name],\n        property: index + 1,\n        value: undefined\n      };\n    } else {\n      let addedItems = cliAddedItems.get(value) || 0;\n\n      while (addedItems <= index) {\n        value.push(undefined);\n        addedItems++;\n      }\n\n      cliAddedItems.set(value, addedItems);\n      const x = value.length - addedItems + index;\n\n      if (value[x] === undefined) {\n        value[x] = {};\n      } else if (value[x] === null || typeof value[x] !== \"object\") {\n        return {\n          problem: {\n            type: \"unexpected-non-object-in-path\",\n            path: schemaPath\n          }\n        };\n      }\n\n      return {\n        object: value,\n        property: x,\n        value: value[x]\n      };\n    }\n  }\n\n  return {\n    object: current,\n    property,\n    value\n  };\n};\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {any} value parsed value\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {LocalProblem | null} problem or null for success\n */\n\n\nconst setValue = (config, schemaPath, value, index) => {\n  const {\n    problem,\n    object,\n    property\n  } = getObjectAndProperty(config, schemaPath, index);\n  if (problem) return problem;\n  object[property] = value;\n  return null;\n};\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} config configuration\n * @param {any} value the value\n * @param {number | undefined} index the index if multiple values provided\n * @returns {LocalProblem | null} a problem if any\n */\n\n\nconst processArgumentConfig = (argConfig, config, value, index) => {\n  if (index !== undefined && !argConfig.multiple) {\n    return {\n      type: \"multiple-values-unexpected\",\n      path: argConfig.path\n    };\n  }\n\n  const parsed = parseValueForArgumentConfig(argConfig, value);\n\n  if (parsed === undefined) {\n    return {\n      type: \"invalid-value\",\n      path: argConfig.path,\n      expected: getExpectedValue(argConfig)\n    };\n  }\n\n  const problem = setValue(config, argConfig.path, parsed, index);\n  if (problem) return problem;\n  return null;\n};\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @returns {string | undefined} expected message\n */\n\n\nconst getExpectedValue = argConfig => {\n  switch (argConfig.type) {\n    default:\n      return argConfig.type;\n\n    case \"boolean\":\n      return \"true | false\";\n\n    case \"RegExp\":\n      return \"regular expression (example: /ab?c*/)\";\n\n    case \"enum\":\n      return argConfig.values.map(v => `${v}`).join(\" | \");\n\n    case \"reset\":\n      return \"true (will reset the previous value to an empty array)\";\n  }\n};\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} value the value\n * @returns {any | undefined} parsed value\n */\n\n\nconst parseValueForArgumentConfig = (argConfig, value) => {\n  switch (argConfig.type) {\n    case \"string\":\n      if (typeof value === \"string\") {\n        return value;\n      }\n\n      break;\n\n    case \"path\":\n      if (typeof value === \"string\") {\n        return path.resolve(value);\n      }\n\n      break;\n\n    case \"number\":\n      if (typeof value === \"number\") return value;\n\n      if (typeof value === \"string\" && /^[+-]?\\d*(\\.\\d*)[eE]\\d+$/) {\n        const n = +value;\n        if (!isNaN(n)) return n;\n      }\n\n      break;\n\n    case \"boolean\":\n      if (typeof value === \"boolean\") return value;\n      if (value === \"true\") return true;\n      if (value === \"false\") return false;\n      break;\n\n    case \"RegExp\":\n      if (value instanceof RegExp) return value;\n\n      if (typeof value === \"string\") {\n        // cspell:word yugi\n        const match = /^\\/(.*)\\/([yugi]*)$/.exec(value);\n        if (match && !/[^\\\\]\\//.test(match[1])) return new RegExp(match[1], match[2]);\n      }\n\n      break;\n\n    case \"enum\":\n      if (argConfig.values.includes(value)) return value;\n\n      for (const item of argConfig.values) {\n        if (`${item}` === value) return item;\n      }\n\n      break;\n\n    case \"reset\":\n      if (value === true) return [];\n      break;\n  }\n};\n/**\n * @param {Record<string, Argument>} args object of arguments\n * @param {any} config configuration\n * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>} values object with values\n * @returns {Problem[] | null} problems or null for success\n */\n\n\nconst processArguments = (args, config, values) => {\n  /** @type {Problem[]} */\n  const problems = [];\n\n  for (const key of Object.keys(values)) {\n    const arg = args[key];\n\n    if (!arg) {\n      problems.push({\n        type: \"unknown-argument\",\n        path: \"\",\n        argument: key\n      });\n      continue;\n    }\n\n    const processValue = (value, i) => {\n      const currentProblems = [];\n\n      for (const argConfig of arg.configs) {\n        const problem = processArgumentConfig(argConfig, config, value, i);\n\n        if (!problem) {\n          return;\n        }\n\n        currentProblems.push({ ...problem,\n          argument: key,\n          value: value,\n          index: i\n        });\n      }\n\n      problems.push(...currentProblems);\n    };\n\n    let value = values[key];\n\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        processValue(value[i], i);\n      }\n    } else {\n      processValue(value, undefined);\n    }\n  }\n\n  if (problems.length === 0) return null;\n  return problems;\n};\n\nexports.getArguments = getArguments;\nexports.processArguments = processArguments;","map":{"version":3,"names":["path","require","webpackSchema","getArguments","schema","flags","pathToArgumentName","input","replace","toLowerCase","getSchemaPart","newPath","split","schemaPart","i","length","inner","getDescription","cli","helper","description","getNegatedDescription","negatedDescription","getResetDescription","resetDescription","schemaToArgumentConfig","enum","type","values","absolutePath","instanceof","undefined","addResetFlag","schemaPath","name","configs","multiple","simpleType","addFlag","argConfigBase","argConfig","some","item","JSON","stringify","Error","push","traverse","inArray","$ref","repetitions","filter","exclude","fullPath","addedArguments","properties","property","Object","keys","Array","isArray","items","maybeOf","oneOf","anyOf","allOf","argument","reduce","desc","includes","t","every","v","c","cliAddedItems","WeakMap","getObjectAndProperty","config","index","value","parts","pop","current","part","endsWith","slice","from","set","problem","join","addedItems","get","x","object","setValue","processArgumentConfig","parsed","parseValueForArgumentConfig","expected","getExpectedValue","map","resolve","n","isNaN","RegExp","match","exec","test","processArguments","args","problems","key","arg","processValue","currentProblems","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/cli.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst webpackSchema = require(\"../schemas/WebpackOptions.json\");\n\n// TODO add originPath to PathItem for better errors\n/**\n * @typedef {Object} PathItem\n * @property {any} schema the part of the schema\n * @property {string} path the path in the config\n */\n\n/** @typedef {\"unknown-argument\" | \"unexpected-non-array-in-path\" | \"unexpected-non-object-in-path\" | \"multiple-values-unexpected\" | \"invalid-value\"} ProblemType */\n\n/**\n * @typedef {Object} Problem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string} argument\n * @property {any=} value\n * @property {number=} index\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} LocalProblem\n * @property {ProblemType} type\n * @property {string} path\n * @property {string=} expected\n */\n\n/**\n * @typedef {Object} ArgumentConfig\n * @property {string} description\n * @property {string} [negatedDescription]\n * @property {string} path\n * @property {boolean} multiple\n * @property {\"enum\"|\"string\"|\"path\"|\"number\"|\"boolean\"|\"RegExp\"|\"reset\"} type\n * @property {any[]=} values\n */\n\n/**\n * @typedef {Object} Argument\n * @property {string} description\n * @property {\"string\"|\"number\"|\"boolean\"} simpleType\n * @property {boolean} multiple\n * @property {ArgumentConfig[]} configs\n */\n\n/**\n * @param {any=} schema a json schema to create arguments for (by default webpack schema is used)\n * @returns {Record<string, Argument>} object of arguments\n */\nconst getArguments = (schema = webpackSchema) => {\n\t/** @type {Record<string, Argument>} */\n\tconst flags = {};\n\n\tconst pathToArgumentName = input => {\n\t\treturn input\n\t\t\t.replace(/\\./g, \"-\")\n\t\t\t.replace(/\\[\\]/g, \"\")\n\t\t\t.replace(\n\t\t\t\t/(\\p{Uppercase_Letter}+|\\p{Lowercase_Letter}|\\d)(\\p{Uppercase_Letter}+)/gu,\n\t\t\t\t\"$1-$2\"\n\t\t\t)\n\t\t\t.replace(/-?[^\\p{Uppercase_Letter}\\p{Lowercase_Letter}\\d]+/gu, \"-\")\n\t\t\t.toLowerCase();\n\t};\n\n\tconst getSchemaPart = path => {\n\t\tconst newPath = path.split(\"/\");\n\n\t\tlet schemaPart = schema;\n\n\t\tfor (let i = 1; i < newPath.length; i++) {\n\t\t\tconst inner = schemaPart[newPath[i]];\n\n\t\t\tif (!inner) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tschemaPart = inner;\n\t\t}\n\n\t\treturn schemaPart;\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} description\n\t */\n\tconst getDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.description) return schema.cli.description;\n\t\t\t}\n\t\t\tif (schema.description) return schema.description;\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} negative description\n\t */\n\tconst getNegatedDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.negatedDescription) return schema.cli.negatedDescription;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {string | undefined} reset description\n\t */\n\tconst getResetDescription = path => {\n\t\tfor (const { schema } of path) {\n\t\t\tif (schema.cli) {\n\t\t\t\tif (schema.cli.helper) continue;\n\t\t\t\tif (schema.cli.resetDescription) return schema.cli.resetDescription;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t *\n\t * @param {any} schemaPart schema\n\t * @returns {Pick<ArgumentConfig, \"type\"|\"values\">} partial argument config\n\t */\n\tconst schemaToArgumentConfig = schemaPart => {\n\t\tif (schemaPart.enum) {\n\t\t\treturn {\n\t\t\t\ttype: \"enum\",\n\t\t\t\tvalues: schemaPart.enum\n\t\t\t};\n\t\t}\n\t\tswitch (schemaPart.type) {\n\t\t\tcase \"number\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"number\"\n\t\t\t\t};\n\t\t\tcase \"string\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: schemaPart.absolutePath ? \"path\" : \"string\"\n\t\t\t\t};\n\t\t\tcase \"boolean\":\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"boolean\"\n\t\t\t\t};\n\t\t}\n\t\tif (schemaPart.instanceof === \"RegExp\") {\n\t\t\treturn {\n\t\t\t\ttype: \"RegExp\"\n\t\t\t};\n\t\t}\n\t\treturn undefined;\n\t};\n\n\t/**\n\t * @param {PathItem[]} path path in the schema\n\t * @returns {void}\n\t */\n\tconst addResetFlag = path => {\n\t\tconst schemaPath = path[0].path;\n\t\tconst name = pathToArgumentName(`${schemaPath}.reset`);\n\t\tconst description =\n\t\t\tgetResetDescription(path) ||\n\t\t\t`Clear all items provided in '${schemaPath}' configuration. ${getDescription(\n\t\t\t\tpath\n\t\t\t)}`;\n\t\tflags[name] = {\n\t\t\tconfigs: [\n\t\t\t\t{\n\t\t\t\t\ttype: \"reset\",\n\t\t\t\t\tmultiple: false,\n\t\t\t\t\tdescription,\n\t\t\t\t\tpath: schemaPath\n\t\t\t\t}\n\t\t\t],\n\t\t\tdescription: undefined,\n\t\t\tsimpleType: undefined,\n\t\t\tmultiple: undefined\n\t\t};\n\t};\n\n\t/**\n\t * @param {PathItem[]} path full path in schema\n\t * @param {boolean} multiple inside of an array\n\t * @returns {number} number of arguments added\n\t */\n\tconst addFlag = (path, multiple) => {\n\t\tconst argConfigBase = schemaToArgumentConfig(path[0].schema);\n\t\tif (!argConfigBase) return 0;\n\n\t\tconst negatedDescription = getNegatedDescription(path);\n\t\tconst name = pathToArgumentName(path[0].path);\n\t\t/** @type {ArgumentConfig} */\n\t\tconst argConfig = {\n\t\t\t...argConfigBase,\n\t\t\tmultiple,\n\t\t\tdescription: getDescription(path),\n\t\t\tpath: path[0].path\n\t\t};\n\n\t\tif (negatedDescription) {\n\t\t\targConfig.negatedDescription = negatedDescription;\n\t\t}\n\n\t\tif (!flags[name]) {\n\t\t\tflags[name] = {\n\t\t\t\tconfigs: [],\n\t\t\t\tdescription: undefined,\n\t\t\t\tsimpleType: undefined,\n\t\t\t\tmultiple: undefined\n\t\t\t};\n\t\t}\n\n\t\tif (\n\t\t\tflags[name].configs.some(\n\t\t\t\titem => JSON.stringify(item) === JSON.stringify(argConfig)\n\t\t\t)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (\n\t\t\tflags[name].configs.some(\n\t\t\t\titem => item.type === argConfig.type && item.multiple !== multiple\n\t\t\t)\n\t\t) {\n\t\t\tif (multiple) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Conflicting schema for ${path[0].path} with ${argConfig.type} type (array type must be before single item type)`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tflags[name].configs.push(argConfig);\n\n\t\treturn 1;\n\t};\n\n\t// TODO support `not` and `if/then/else`\n\t// TODO support `const`, but we don't use it on our schema\n\t/**\n\t *\n\t * @param {object} schemaPart the current schema\n\t * @param {string} schemaPath the current path in the schema\n\t * @param {{schema: object, path: string}[]} path all previous visited schemaParts\n\t * @param {string | null} inArray if inside of an array, the path to the array\n\t * @returns {number} added arguments\n\t */\n\tconst traverse = (schemaPart, schemaPath = \"\", path = [], inArray = null) => {\n\t\twhile (schemaPart.$ref) {\n\t\t\tschemaPart = getSchemaPart(schemaPart.$ref);\n\t\t}\n\n\t\tconst repetitions = path.filter(({ schema }) => schema === schemaPart);\n\t\tif (\n\t\t\trepetitions.length >= 2 ||\n\t\t\trepetitions.some(({ path }) => path === schemaPath)\n\t\t) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (schemaPart.cli && schemaPart.cli.exclude) return 0;\n\n\t\tconst fullPath = [{ schema: schemaPart, path: schemaPath }, ...path];\n\n\t\tlet addedArguments = 0;\n\n\t\taddedArguments += addFlag(fullPath, !!inArray);\n\n\t\tif (schemaPart.type === \"object\") {\n\t\t\tif (schemaPart.properties) {\n\t\t\t\tfor (const property of Object.keys(schemaPart.properties)) {\n\t\t\t\t\taddedArguments += traverse(\n\t\t\t\t\t\tschemaPart.properties[property],\n\t\t\t\t\t\tschemaPath ? `${schemaPath}.${property}` : property,\n\t\t\t\t\t\tfullPath,\n\t\t\t\t\t\tinArray\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\tif (schemaPart.type === \"array\") {\n\t\t\tif (inArray) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (Array.isArray(schemaPart.items)) {\n\t\t\t\tlet i = 0;\n\t\t\t\tfor (const item of schemaPart.items) {\n\t\t\t\t\taddedArguments += traverse(\n\t\t\t\t\t\titem,\n\t\t\t\t\t\t`${schemaPath}.${i}`,\n\t\t\t\t\t\tfullPath,\n\t\t\t\t\t\tschemaPath\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn addedArguments;\n\t\t\t}\n\n\t\t\taddedArguments += traverse(\n\t\t\t\tschemaPart.items,\n\t\t\t\t`${schemaPath}[]`,\n\t\t\t\tfullPath,\n\t\t\t\tschemaPath\n\t\t\t);\n\n\t\t\tif (addedArguments > 0) {\n\t\t\t\taddResetFlag(fullPath);\n\t\t\t\taddedArguments++;\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\tconst maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;\n\n\t\tif (maybeOf) {\n\t\t\tconst items = maybeOf;\n\n\t\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\t\taddedArguments += traverse(items[i], schemaPath, fullPath, inArray);\n\t\t\t}\n\n\t\t\treturn addedArguments;\n\t\t}\n\n\t\treturn addedArguments;\n\t};\n\n\ttraverse(schema);\n\n\t// Summarize flags\n\tfor (const name of Object.keys(flags)) {\n\t\tconst argument = flags[name];\n\t\targument.description = argument.configs.reduce((desc, { description }) => {\n\t\t\tif (!desc) return description;\n\t\t\tif (!description) return desc;\n\t\t\tif (desc.includes(description)) return desc;\n\t\t\treturn `${desc} ${description}`;\n\t\t}, /** @type {string | undefined} */ (undefined));\n\t\targument.simpleType = argument.configs.reduce((t, argConfig) => {\n\t\t\t/** @type {\"string\" | \"number\" | \"boolean\"} */\n\t\t\tlet type = \"string\";\n\t\t\tswitch (argConfig.type) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\ttype = \"number\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"reset\":\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\ttype = \"boolean\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"enum\":\n\t\t\t\t\tif (argConfig.values.every(v => typeof v === \"boolean\"))\n\t\t\t\t\t\ttype = \"boolean\";\n\t\t\t\t\tif (argConfig.values.every(v => typeof v === \"number\"))\n\t\t\t\t\t\ttype = \"number\";\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t === undefined) return type;\n\t\t\treturn t === type ? t : \"string\";\n\t\t}, /** @type {\"string\" | \"number\" | \"boolean\" | undefined} */ (undefined));\n\t\targument.multiple = argument.configs.some(c => c.multiple);\n\t}\n\n\treturn flags;\n};\n\nconst cliAddedItems = new WeakMap();\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {{ problem?: LocalProblem, object?: any, property?: string | number, value?: any }} problem or object with property and value\n */\nconst getObjectAndProperty = (config, schemaPath, index = 0) => {\n\tif (!schemaPath) return { value: config };\n\tconst parts = schemaPath.split(\".\");\n\tlet property = parts.pop();\n\tlet current = config;\n\tlet i = 0;\n\tfor (const part of parts) {\n\t\tconst isArray = part.endsWith(\"[]\");\n\t\tconst name = isArray ? part.slice(0, -2) : part;\n\t\tlet value = current[name];\n\t\tif (isArray) {\n\t\t\tif (value === undefined) {\n\t\t\t\tvalue = {};\n\t\t\t\tcurrent[name] = [...Array.from({ length: index }), value];\n\t\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\t} else if (!Array.isArray(value)) {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-array-in-path\",\n\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tlet addedItems = cliAddedItems.get(value) || 0;\n\t\t\t\twhile (addedItems <= index) {\n\t\t\t\t\tvalue.push(undefined);\n\t\t\t\t\taddedItems++;\n\t\t\t\t}\n\t\t\t\tcliAddedItems.set(value, addedItems);\n\t\t\t\tconst x = value.length - addedItems + index;\n\t\t\t\tif (value[x] === undefined) {\n\t\t\t\t\tvalue[x] = {};\n\t\t\t\t} else if (value[x] === null || typeof value[x] !== \"object\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tproblem: {\n\t\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tvalue = value[x];\n\t\t\t}\n\t\t} else {\n\t\t\tif (value === undefined) {\n\t\t\t\tvalue = current[name] = {};\n\t\t\t} else if (value === null || typeof value !== \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\tpath: parts.slice(0, i).join(\".\")\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tcurrent = value;\n\t\ti++;\n\t}\n\tlet value = current[property];\n\tif (property.endsWith(\"[]\")) {\n\t\tconst name = property.slice(0, -2);\n\t\tconst value = current[name];\n\t\tif (value === undefined) {\n\t\t\tcurrent[name] = [...Array.from({ length: index }), undefined];\n\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\treturn { object: current[name], property: index, value: undefined };\n\t\t} else if (!Array.isArray(value)) {\n\t\t\tcurrent[name] = [value, ...Array.from({ length: index }), undefined];\n\t\t\tcliAddedItems.set(current[name], index + 1);\n\t\t\treturn { object: current[name], property: index + 1, value: undefined };\n\t\t} else {\n\t\t\tlet addedItems = cliAddedItems.get(value) || 0;\n\t\t\twhile (addedItems <= index) {\n\t\t\t\tvalue.push(undefined);\n\t\t\t\taddedItems++;\n\t\t\t}\n\t\t\tcliAddedItems.set(value, addedItems);\n\t\t\tconst x = value.length - addedItems + index;\n\t\t\tif (value[x] === undefined) {\n\t\t\t\tvalue[x] = {};\n\t\t\t} else if (value[x] === null || typeof value[x] !== \"object\") {\n\t\t\t\treturn {\n\t\t\t\t\tproblem: {\n\t\t\t\t\t\ttype: \"unexpected-non-object-in-path\",\n\t\t\t\t\t\tpath: schemaPath\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tobject: value,\n\t\t\t\tproperty: x,\n\t\t\t\tvalue: value[x]\n\t\t\t};\n\t\t}\n\t}\n\treturn { object: current, property, value };\n};\n\n/**\n * @param {any} config configuration\n * @param {string} schemaPath path in the config\n * @param {any} value parsed value\n * @param {number | undefined} index index of value when multiple values are provided, otherwise undefined\n * @returns {LocalProblem | null} problem or null for success\n */\nconst setValue = (config, schemaPath, value, index) => {\n\tconst { problem, object, property } = getObjectAndProperty(\n\t\tconfig,\n\t\tschemaPath,\n\t\tindex\n\t);\n\tif (problem) return problem;\n\tobject[property] = value;\n\treturn null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} config configuration\n * @param {any} value the value\n * @param {number | undefined} index the index if multiple values provided\n * @returns {LocalProblem | null} a problem if any\n */\nconst processArgumentConfig = (argConfig, config, value, index) => {\n\tif (index !== undefined && !argConfig.multiple) {\n\t\treturn {\n\t\t\ttype: \"multiple-values-unexpected\",\n\t\t\tpath: argConfig.path\n\t\t};\n\t}\n\tconst parsed = parseValueForArgumentConfig(argConfig, value);\n\tif (parsed === undefined) {\n\t\treturn {\n\t\t\ttype: \"invalid-value\",\n\t\t\tpath: argConfig.path,\n\t\t\texpected: getExpectedValue(argConfig)\n\t\t};\n\t}\n\tconst problem = setValue(config, argConfig.path, parsed, index);\n\tif (problem) return problem;\n\treturn null;\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @returns {string | undefined} expected message\n */\nconst getExpectedValue = argConfig => {\n\tswitch (argConfig.type) {\n\t\tdefault:\n\t\t\treturn argConfig.type;\n\t\tcase \"boolean\":\n\t\t\treturn \"true | false\";\n\t\tcase \"RegExp\":\n\t\t\treturn \"regular expression (example: /ab?c*/)\";\n\t\tcase \"enum\":\n\t\t\treturn argConfig.values.map(v => `${v}`).join(\" | \");\n\t\tcase \"reset\":\n\t\t\treturn \"true (will reset the previous value to an empty array)\";\n\t}\n};\n\n/**\n * @param {ArgumentConfig} argConfig processing instructions\n * @param {any} value the value\n * @returns {any | undefined} parsed value\n */\nconst parseValueForArgumentConfig = (argConfig, value) => {\n\tswitch (argConfig.type) {\n\t\tcase \"string\":\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"path\":\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\treturn path.resolve(value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"number\":\n\t\t\tif (typeof value === \"number\") return value;\n\t\t\tif (typeof value === \"string\" && /^[+-]?\\d*(\\.\\d*)[eE]\\d+$/) {\n\t\t\t\tconst n = +value;\n\t\t\t\tif (!isNaN(n)) return n;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"boolean\":\n\t\t\tif (typeof value === \"boolean\") return value;\n\t\t\tif (value === \"true\") return true;\n\t\t\tif (value === \"false\") return false;\n\t\t\tbreak;\n\t\tcase \"RegExp\":\n\t\t\tif (value instanceof RegExp) return value;\n\t\t\tif (typeof value === \"string\") {\n\t\t\t\t// cspell:word yugi\n\t\t\t\tconst match = /^\\/(.*)\\/([yugi]*)$/.exec(value);\n\t\t\t\tif (match && !/[^\\\\]\\//.test(match[1]))\n\t\t\t\t\treturn new RegExp(match[1], match[2]);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"enum\":\n\t\t\tif (argConfig.values.includes(value)) return value;\n\t\t\tfor (const item of argConfig.values) {\n\t\t\t\tif (`${item}` === value) return item;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase \"reset\":\n\t\t\tif (value === true) return [];\n\t\t\tbreak;\n\t}\n};\n\n/**\n * @param {Record<string, Argument>} args object of arguments\n * @param {any} config configuration\n * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>} values object with values\n * @returns {Problem[] | null} problems or null for success\n */\nconst processArguments = (args, config, values) => {\n\t/** @type {Problem[]} */\n\tconst problems = [];\n\tfor (const key of Object.keys(values)) {\n\t\tconst arg = args[key];\n\t\tif (!arg) {\n\t\t\tproblems.push({\n\t\t\t\ttype: \"unknown-argument\",\n\t\t\t\tpath: \"\",\n\t\t\t\targument: key\n\t\t\t});\n\t\t\tcontinue;\n\t\t}\n\t\tconst processValue = (value, i) => {\n\t\t\tconst currentProblems = [];\n\t\t\tfor (const argConfig of arg.configs) {\n\t\t\t\tconst problem = processArgumentConfig(argConfig, config, value, i);\n\t\t\t\tif (!problem) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcurrentProblems.push({\n\t\t\t\t\t...problem,\n\t\t\t\t\targument: key,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tindex: i\n\t\t\t\t});\n\t\t\t}\n\t\t\tproblems.push(...currentProblems);\n\t\t};\n\t\tlet value = values[key];\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\tprocessValue(value[i], i);\n\t\t\t}\n\t\t} else {\n\t\t\tprocessValue(value, undefined);\n\t\t}\n\t}\n\tif (problems.length === 0) return null;\n\treturn problems;\n};\n\nexports.getArguments = getArguments;\nexports.processArguments = processArguments;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}