{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  getMap,\n  getSourceAndMap\n} = require(\"./helpers/getFromStreamChunks\");\n\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\n\nconst getGeneratedSourceInfo = require(\"./helpers/getGeneratedSourceInfo\");\n\nconst Source = require(\"./Source\");\n\nconst splitIntoPotentialTokens = require(\"./helpers/splitIntoPotentialTokens\");\n\nclass OriginalSource extends Source {\n  constructor(value, name) {\n    super();\n    const isBuffer = Buffer.isBuffer(value);\n    this._value = isBuffer ? undefined : value;\n    this._valueAsBuffer = isBuffer ? value : undefined;\n    this._name = name;\n  }\n\n  getName() {\n    return this._name;\n  }\n\n  source() {\n    if (this._value === undefined) {\n      this._value = this._valueAsBuffer.toString(\"utf-8\");\n    }\n\n    return this._value;\n  }\n\n  buffer() {\n    if (this._valueAsBuffer === undefined) {\n      this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n    }\n\n    return this._valueAsBuffer;\n  }\n\n  map(options) {\n    return getMap(this, options);\n  }\n\n  sourceAndMap(options) {\n    return getSourceAndMap(this, options);\n  }\n  /**\n   * @param {object} options options\n   * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n   * @param {function(number, string, string)} onSource called for each source\n   * @param {function(number, string)} onName called for each name\n   * @returns {void}\n   */\n\n\n  streamChunks(options, onChunk, onSource, onName) {\n    if (this._value === undefined) {\n      this._value = this._valueAsBuffer.toString(\"utf-8\");\n    }\n\n    onSource(0, this._name, this._value);\n    const finalSource = !!(options && options.finalSource);\n\n    if (!options || options.columns !== false) {\n      // With column info we need to read all lines and split them\n      const matches = splitIntoPotentialTokens(this._value);\n      let line = 1;\n      let column = 0;\n\n      if (matches !== null) {\n        for (const match of matches) {\n          const isEndOfLine = match.endsWith(\"\\n\");\n\n          if (isEndOfLine && match.length === 1) {\n            if (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);\n          } else {\n            const chunk = finalSource ? undefined : match;\n            onChunk(chunk, line, column, 0, line, column, -1);\n          }\n\n          if (isEndOfLine) {\n            line++;\n            column = 0;\n          } else {\n            column += match.length;\n          }\n        }\n      }\n\n      return {\n        generatedLine: line,\n        generatedColumn: column,\n        source: finalSource ? this._value : undefined\n      };\n    } else if (finalSource) {\n      // Without column info and with final source we only\n      // need meta info to generate mapping\n      const result = getGeneratedSourceInfo(this._value);\n      const {\n        generatedLine,\n        generatedColumn\n      } = result;\n\n      if (generatedColumn === 0) {\n        for (let line = 1; line < generatedLine; line++) onChunk(undefined, line, 0, 0, line, 0, -1);\n      } else {\n        for (let line = 1; line <= generatedLine; line++) onChunk(undefined, line, 0, 0, line, 0, -1);\n      }\n\n      return result;\n    } else {\n      // Without column info, but also without final source\n      // we need to split source by lines\n      let line = 1;\n      const matches = splitIntoLines(this._value);\n      let match;\n\n      for (match of matches) {\n        onChunk(finalSource ? undefined : match, line, 0, 0, line, 0, -1);\n        line++;\n      }\n\n      return matches.length === 0 || match.endsWith(\"\\n\") ? {\n        generatedLine: matches.length + 1,\n        generatedColumn: 0,\n        source: finalSource ? this._value : undefined\n      } : {\n        generatedLine: matches.length,\n        generatedColumn: match.length,\n        source: finalSource ? this._value : undefined\n      };\n    }\n  }\n\n  updateHash(hash) {\n    if (this._valueAsBuffer === undefined) {\n      this._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n    }\n\n    hash.update(\"OriginalSource\");\n    hash.update(this._valueAsBuffer);\n    hash.update(this._name || \"\");\n  }\n\n}\n\nmodule.exports = OriginalSource;","map":{"version":3,"names":["getMap","getSourceAndMap","require","splitIntoLines","getGeneratedSourceInfo","Source","splitIntoPotentialTokens","OriginalSource","constructor","value","name","isBuffer","Buffer","_value","undefined","_valueAsBuffer","_name","getName","source","toString","buffer","from","map","options","sourceAndMap","streamChunks","onChunk","onSource","onName","finalSource","columns","matches","line","column","match","isEndOfLine","endsWith","length","chunk","generatedLine","generatedColumn","result","updateHash","hash","update","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack-sources/lib/OriginalSource.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { getMap, getSourceAndMap } = require(\"./helpers/getFromStreamChunks\");\nconst splitIntoLines = require(\"./helpers/splitIntoLines\");\nconst getGeneratedSourceInfo = require(\"./helpers/getGeneratedSourceInfo\");\nconst Source = require(\"./Source\");\nconst splitIntoPotentialTokens = require(\"./helpers/splitIntoPotentialTokens\");\n\nclass OriginalSource extends Source {\n\tconstructor(value, name) {\n\t\tsuper();\n\t\tconst isBuffer = Buffer.isBuffer(value);\n\t\tthis._value = isBuffer ? undefined : value;\n\t\tthis._valueAsBuffer = isBuffer ? value : undefined;\n\t\tthis._name = name;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tsource() {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\treturn this._value;\n\t}\n\n\tbuffer() {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\treturn this._valueAsBuffer;\n\t}\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\t/**\n\t * @param {object} options options\n\t * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code\n\t * @param {function(number, string, string)} onSource called for each source\n\t * @param {function(number, string)} onName called for each name\n\t * @returns {void}\n\t */\n\tstreamChunks(options, onChunk, onSource, onName) {\n\t\tif (this._value === undefined) {\n\t\t\tthis._value = this._valueAsBuffer.toString(\"utf-8\");\n\t\t}\n\t\tonSource(0, this._name, this._value);\n\t\tconst finalSource = !!(options && options.finalSource);\n\t\tif (!options || options.columns !== false) {\n\t\t\t// With column info we need to read all lines and split them\n\t\t\tconst matches = splitIntoPotentialTokens(this._value);\n\t\t\tlet line = 1;\n\t\t\tlet column = 0;\n\t\t\tif (matches !== null) {\n\t\t\t\tfor (const match of matches) {\n\t\t\t\t\tconst isEndOfLine = match.endsWith(\"\\n\");\n\t\t\t\t\tif (isEndOfLine && match.length === 1) {\n\t\t\t\t\t\tif (!finalSource) onChunk(match, line, column, -1, -1, -1, -1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst chunk = finalSource ? undefined : match;\n\t\t\t\t\t\tonChunk(chunk, line, column, 0, line, column, -1);\n\t\t\t\t\t}\n\t\t\t\t\tif (isEndOfLine) {\n\t\t\t\t\t\tline++;\n\t\t\t\t\t\tcolumn = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcolumn += match.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tgeneratedLine: line,\n\t\t\t\tgeneratedColumn: column,\n\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t};\n\t\t} else if (finalSource) {\n\t\t\t// Without column info and with final source we only\n\t\t\t// need meta info to generate mapping\n\t\t\tconst result = getGeneratedSourceInfo(this._value);\n\t\t\tconst { generatedLine, generatedColumn } = result;\n\t\t\tif (generatedColumn === 0) {\n\t\t\t\tfor (let line = 1; line < generatedLine; line++)\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\n\t\t\t} else {\n\t\t\t\tfor (let line = 1; line <= generatedLine; line++)\n\t\t\t\t\tonChunk(undefined, line, 0, 0, line, 0, -1);\n\t\t\t}\n\t\t\treturn result;\n\t\t} else {\n\t\t\t// Without column info, but also without final source\n\t\t\t// we need to split source by lines\n\t\t\tlet line = 1;\n\t\t\tconst matches = splitIntoLines(this._value);\n\t\t\tlet match;\n\t\t\tfor (match of matches) {\n\t\t\t\tonChunk(finalSource ? undefined : match, line, 0, 0, line, 0, -1);\n\t\t\t\tline++;\n\t\t\t}\n\t\t\treturn matches.length === 0 || match.endsWith(\"\\n\")\n\t\t\t\t? {\n\t\t\t\t\t\tgeneratedLine: matches.length + 1,\n\t\t\t\t\t\tgeneratedColumn: 0,\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t\t  }\n\t\t\t\t: {\n\t\t\t\t\t\tgeneratedLine: matches.length,\n\t\t\t\t\t\tgeneratedColumn: match.length,\n\t\t\t\t\t\tsource: finalSource ? this._value : undefined\n\t\t\t\t  };\n\t\t}\n\t}\n\n\tupdateHash(hash) {\n\t\tif (this._valueAsBuffer === undefined) {\n\t\t\tthis._valueAsBuffer = Buffer.from(this._value, \"utf-8\");\n\t\t}\n\t\thash.update(\"OriginalSource\");\n\t\thash.update(this._valueAsBuffer);\n\t\thash.update(this._name || \"\");\n\t}\n}\n\nmodule.exports = OriginalSource;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}