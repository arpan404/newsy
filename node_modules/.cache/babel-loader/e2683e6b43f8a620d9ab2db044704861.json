{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ChunkGraph = require(\"./ChunkGraph\");\n\nconst Entrypoint = require(\"./Entrypoint\");\n\nconst {\n  intersect\n} = require(\"./util/SetHelpers\");\n\nconst SortableSet = require(\"./util/SortableSet\");\n\nconst StringXor = require(\"./util/StringXor\");\n\nconst {\n  compareModulesByIdentifier,\n  compareChunkGroupsByIndex,\n  compareModulesById\n} = require(\"./util/comparators\");\n\nconst {\n  createArrayToSetDeprecationSet\n} = require(\"./util/deprecation\");\n\nconst {\n  mergeRuntime\n} = require(\"./util/runtime\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\n\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\n\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n\n/** @typedef {import(\"./util/Hash\")} Hash */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n\nconst ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\n/**\n * @typedef {Object} WithId an object who has an id property *\n * @property {string | number} id the id of the object\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkMaps\n * @property {Record<string|number, string>} hash\n * @property {Record<string|number, Record<string, string>>} contentHash\n * @property {Record<string|number, string>} name\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkModuleMaps\n * @property {Record<string|number, (string|number)[]>} id\n * @property {Record<string|number, string>} hash\n */\n\nlet debugId = 1000;\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\n\nclass Chunk {\n  /**\n   * @param {string=} name of chunk being created, is optional (for subclasses)\n   * @param {boolean} backCompat enable backward-compatibility\n   */\n  constructor(name) {\n    let backCompat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    /** @type {number | string | null} */\n    this.id = null;\n    /** @type {(number|string)[] | null} */\n\n    this.ids = null;\n    /** @type {number} */\n\n    this.debugId = debugId++;\n    /** @type {string} */\n\n    this.name = name;\n    /** @type {SortableSet<string>} */\n\n    this.idNameHints = new SortableSet();\n    /** @type {boolean} */\n\n    this.preventIntegration = false;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n\n    this.filenameTemplate = undefined;\n    /** @type {(string | function(PathData, AssetInfo=): string)?} */\n\n    this.cssFilenameTemplate = undefined;\n    /** @private @type {SortableSet<ChunkGroup>} */\n\n    this._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\n    /** @type {RuntimeSpec} */\n\n    this.runtime = undefined;\n    /** @type {Set<string>} */\n\n    this.files = backCompat ? new ChunkFilesSet() : new Set();\n    /** @type {Set<string>} */\n\n    this.auxiliaryFiles = new Set();\n    /** @type {boolean} */\n\n    this.rendered = false;\n    /** @type {string=} */\n\n    this.hash = undefined;\n    /** @type {Record<string, string>} */\n\n    this.contentHash = Object.create(null);\n    /** @type {string=} */\n\n    this.renderedHash = undefined;\n    /** @type {string=} */\n\n    this.chunkReason = undefined;\n    /** @type {boolean} */\n\n    this.extraAsync = false;\n  } // TODO remove in webpack 6\n  // BACKWARD-COMPAT START\n\n\n  get entryModule() {\n    const entryModules = Array.from(ChunkGraph.getChunkGraphForChunk(this, \"Chunk.entryModule\", \"DEP_WEBPACK_CHUNK_ENTRY_MODULE\").getChunkEntryModulesIterable(this));\n\n    if (entryModules.length === 0) {\n      return undefined;\n    } else if (entryModules.length === 1) {\n      return entryModules[0];\n    } else {\n      throw new Error(\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\");\n    }\n  }\n  /**\n   * @returns {boolean} true, if the chunk contains an entry module\n   */\n\n\n  hasEntryModule() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasEntryModule\", \"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\").getNumberOfEntryModules(this) > 0;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {boolean} true, if the chunk could be added\n   */\n\n\n  addModule(module) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.addModule\", \"DEP_WEBPACK_CHUNK_ADD_MODULE\");\n    if (chunkGraph.isModuleInChunk(module, this)) return false;\n    chunkGraph.connectChunkAndModule(this, module);\n    return true;\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {void}\n   */\n\n\n  removeModule(module) {\n    ChunkGraph.getChunkGraphForChunk(this, \"Chunk.removeModule\", \"DEP_WEBPACK_CHUNK_REMOVE_MODULE\").disconnectChunkAndModule(this, module);\n  }\n  /**\n   * @returns {number} the number of module which are contained in this chunk\n   */\n\n\n  getNumberOfModules() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getNumberOfModules\", \"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\").getNumberOfChunkModules(this);\n  }\n\n  get modulesIterable() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesIterable\", \"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\");\n    return chunkGraph.getOrderedChunkModulesIterable(this, compareModulesByIdentifier);\n  }\n  /**\n   * @param {Chunk} otherChunk the chunk to compare with\n   * @returns {-1|0|1} the comparison result\n   */\n\n\n  compareTo(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.compareTo\", \"DEP_WEBPACK_CHUNK_COMPARE_TO\");\n    return chunkGraph.compareChunks(this, otherChunk);\n  }\n  /**\n   * @param {Module} module the module\n   * @returns {boolean} true, if the chunk contains the module\n   */\n\n\n  containsModule(module) {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.containsModule\", \"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\").isModuleInChunk(module, this);\n  }\n  /**\n   * @returns {Module[]} the modules for this chunk\n   */\n\n\n  getModules() {\n    return ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getModules\", \"DEP_WEBPACK_CHUNK_GET_MODULES\").getChunkModules(this);\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  remove() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.remove\", \"DEP_WEBPACK_CHUNK_REMOVE\");\n    chunkGraph.disconnectChunk(this);\n    this.disconnectFromGroups();\n  }\n  /**\n   * @param {Module} module the module\n   * @param {Chunk} otherChunk the target chunk\n   * @returns {void}\n   */\n\n\n  moveModule(module, otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.moveModule\", \"DEP_WEBPACK_CHUNK_MOVE_MODULE\");\n    chunkGraph.disconnectChunkAndModule(this, module);\n    chunkGraph.connectChunkAndModule(otherChunk, module);\n  }\n  /**\n   * @param {Chunk} otherChunk the other chunk\n   * @returns {boolean} true, if the specified chunk has been integrated\n   */\n\n\n  integrate(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integrate\", \"DEP_WEBPACK_CHUNK_INTEGRATE\");\n\n    if (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\n      chunkGraph.integrateChunks(this, otherChunk);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * @param {Chunk} otherChunk the other chunk\n   * @returns {boolean} true, if chunks could be integrated\n   */\n\n\n  canBeIntegrated(otherChunk) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.canBeIntegrated\", \"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\");\n    return chunkGraph.canChunksBeIntegrated(this, otherChunk);\n  }\n  /**\n   * @returns {boolean} true, if this chunk contains no module\n   */\n\n\n  isEmpty() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.isEmpty\", \"DEP_WEBPACK_CHUNK_IS_EMPTY\");\n    return chunkGraph.getNumberOfChunkModules(this) === 0;\n  }\n  /**\n   * @returns {number} total size of all modules in this chunk\n   */\n\n\n  modulesSize() {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.modulesSize\", \"DEP_WEBPACK_CHUNK_MODULES_SIZE\");\n    return chunkGraph.getChunkModulesSize(this);\n  }\n  /**\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of this chunk\n   */\n\n\n  size() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.size\", \"DEP_WEBPACK_CHUNK_SIZE\");\n    return chunkGraph.getChunkSize(this, options);\n  }\n  /**\n   * @param {Chunk} otherChunk the other chunk\n   * @param {ChunkSizeOptions} options options object\n   * @returns {number} total size of the chunk or false if the chunk can't be integrated\n   */\n\n\n  integratedSize(otherChunk, options) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.integratedSize\", \"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\");\n    return chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\n  }\n  /**\n   * @param {ModuleFilterPredicate} filterFn function used to filter modules\n   * @returns {ChunkModuleMaps} module map information\n   */\n\n\n  getChunkModuleMaps(filterFn) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.getChunkModuleMaps\", \"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\");\n    /** @type {Record<string|number, (string|number)[]>} */\n\n    const chunkModuleIdMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n\n    const chunkModuleHashMap = Object.create(null);\n\n    for (const asyncChunk of this.getAllAsyncChunks()) {\n      /** @type {(string|number)[]} */\n      let array;\n\n      for (const module of chunkGraph.getOrderedChunkModulesIterable(asyncChunk, compareModulesById(chunkGraph))) {\n        if (filterFn(module)) {\n          if (array === undefined) {\n            array = [];\n            chunkModuleIdMap[asyncChunk.id] = array;\n          }\n\n          const moduleId = chunkGraph.getModuleId(module);\n          array.push(moduleId);\n          chunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(module, undefined);\n        }\n      }\n    }\n\n    return {\n      id: chunkModuleIdMap,\n      hash: chunkModuleHashMap\n    };\n  }\n  /**\n   * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n   * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n   * @returns {boolean} return true if module exists in graph\n   */\n\n\n  hasModuleInGraph(filterFn, filterChunkFn) {\n    const chunkGraph = ChunkGraph.getChunkGraphForChunk(this, \"Chunk.hasModuleInGraph\", \"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\");\n    return chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\n  }\n  /**\n   * @deprecated\n   * @param {boolean} realHash whether the full hash or the rendered hash is to be used\n   * @returns {ChunkMaps} the chunk map information\n   */\n\n\n  getChunkMaps(realHash) {\n    /** @type {Record<string|number, string>} */\n    const chunkHashMap = Object.create(null);\n    /** @type {Record<string|number, Record<string, string>>} */\n\n    const chunkContentHashMap = Object.create(null);\n    /** @type {Record<string|number, string>} */\n\n    const chunkNameMap = Object.create(null);\n\n    for (const chunk of this.getAllAsyncChunks()) {\n      chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\n      for (const key of Object.keys(chunk.contentHash)) {\n        if (!chunkContentHashMap[key]) {\n          chunkContentHashMap[key] = Object.create(null);\n        }\n\n        chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n      }\n\n      if (chunk.name) {\n        chunkNameMap[chunk.id] = chunk.name;\n      }\n    }\n\n    return {\n      hash: chunkHashMap,\n      contentHash: chunkContentHashMap,\n      name: chunkNameMap\n    };\n  } // BACKWARD-COMPAT END\n\n  /**\n   * @returns {boolean} whether or not the Chunk will have a runtime\n   */\n\n\n  hasRuntime() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @returns {boolean} whether or not this chunk can be an initial chunk\n   */\n\n\n  canBeInitial() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup.isInitial()) return true;\n    }\n\n    return false;\n  }\n  /**\n   * @returns {boolean} whether this chunk can only be an initial chunk\n   */\n\n\n  isOnlyInitial() {\n    if (this._groups.size <= 0) return false;\n\n    for (const chunkGroup of this._groups) {\n      if (!chunkGroup.isInitial()) return false;\n    }\n\n    return true;\n  }\n  /**\n   * @returns {EntryOptions | undefined} the entry options for this chunk\n   */\n\n\n  getEntryOptions() {\n    for (const chunkGroup of this._groups) {\n      if (chunkGroup instanceof Entrypoint) {\n        return chunkGroup.options;\n      }\n    }\n\n    return undefined;\n  }\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n   * @returns {void}\n   */\n\n\n  addGroup(chunkGroup) {\n    this._groups.add(chunkGroup);\n  }\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n   * @returns {void}\n   */\n\n\n  removeGroup(chunkGroup) {\n    this._groups.delete(chunkGroup);\n  }\n  /**\n   * @param {ChunkGroup} chunkGroup the chunkGroup to check\n   * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n   */\n\n\n  isInGroup(chunkGroup) {\n    return this._groups.has(chunkGroup);\n  }\n  /**\n   * @returns {number} the amount of groups that the said chunk is in\n   */\n\n\n  getNumberOfGroups() {\n    return this._groups.size;\n  }\n  /**\n   * @returns {Iterable<ChunkGroup>} the chunkGroups that the said chunk is referenced in\n   */\n\n\n  get groupsIterable() {\n    this._groups.sort();\n\n    return this._groups;\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  disconnectFromGroups() {\n    for (const chunkGroup of this._groups) {\n      chunkGroup.removeChunk(this);\n    }\n  }\n  /**\n   * @param {Chunk} newChunk the new chunk that will be split out of\n   * @returns {void}\n   */\n\n\n  split(newChunk) {\n    for (const chunkGroup of this._groups) {\n      chunkGroup.insertChunk(newChunk, this);\n      newChunk.addGroup(chunkGroup);\n    }\n\n    for (const idHint of this.idNameHints) {\n      newChunk.idNameHints.add(idHint);\n    }\n\n    newChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\n  }\n  /**\n   * @param {Hash} hash hash (will be modified)\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @returns {void}\n   */\n\n\n  updateHash(hash, chunkGraph) {\n    hash.update(`${this.id} ${this.ids ? this.ids.join() : \"\"} ${this.name || \"\"} `);\n    const xor = new StringXor();\n\n    for (const m of chunkGraph.getChunkModulesIterable(this)) {\n      xor.add(chunkGraph.getModuleHash(m, this.runtime));\n    }\n\n    xor.updateHash(hash);\n    const entryModules = chunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\n\n    for (const [m, chunkGroup] of entryModules) {\n      hash.update(`entry${chunkGraph.getModuleId(m)}${chunkGroup.id}`);\n    }\n  }\n  /**\n   * @returns {Set<Chunk>} a set of all the async chunks\n   */\n\n\n  getAllAsyncChunks() {\n    const queue = new Set();\n    const chunks = new Set();\n    const initialChunks = intersect(Array.from(this.groupsIterable, g => new Set(g.chunks)));\n    const initialQueue = new Set(this.groupsIterable);\n\n    for (const chunkGroup of initialQueue) {\n      for (const child of chunkGroup.childrenIterable) {\n        if (child instanceof Entrypoint) {\n          initialQueue.add(child);\n        } else {\n          queue.add(child);\n        }\n      }\n    }\n\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!initialChunks.has(chunk)) {\n          chunks.add(chunk);\n        }\n      }\n\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    return chunks;\n  }\n  /**\n   * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\n   */\n\n\n  getAllInitialChunks() {\n    const chunks = new Set();\n    const queue = new Set(this.groupsIterable);\n\n    for (const group of queue) {\n      if (group.isInitial()) {\n        for (const c of group.chunks) chunks.add(c);\n\n        for (const g of group.childrenIterable) queue.add(g);\n      }\n    }\n\n    return chunks;\n  }\n  /**\n   * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\n   */\n\n\n  getAllReferencedChunks() {\n    const queue = new Set(this.groupsIterable);\n    const chunks = new Set();\n\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        chunks.add(chunk);\n      }\n\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    return chunks;\n  }\n  /**\n   * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\n   */\n\n\n  getAllReferencedAsyncEntrypoints() {\n    const queue = new Set(this.groupsIterable);\n    const entrypoints = new Set();\n\n    for (const chunkGroup of queue) {\n      for (const entrypoint of chunkGroup.asyncEntrypointsIterable) {\n        entrypoints.add(entrypoint);\n      }\n\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    return entrypoints;\n  }\n  /**\n   * @returns {boolean} true, if the chunk references async chunks\n   */\n\n\n  hasAsyncChunks() {\n    const queue = new Set();\n    const initialChunks = intersect(Array.from(this.groupsIterable, g => new Set(g.chunks)));\n\n    for (const chunkGroup of this.groupsIterable) {\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    for (const chunkGroup of queue) {\n      for (const chunk of chunkGroup.chunks) {\n        if (!initialChunks.has(chunk)) {\n          return true;\n        }\n      }\n\n      for (const child of chunkGroup.childrenIterable) {\n        queue.add(child);\n      }\n    }\n\n    return false;\n  }\n  /**\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n   * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\n   */\n\n\n  getChildIdsByOrders(chunkGraph, filterFn) {\n    /** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n    const lists = new Map();\n\n    for (const group of this.groupsIterable) {\n      if (group.chunks[group.chunks.length - 1] === this) {\n        for (const childGroup of group.childrenIterable) {\n          for (const key of Object.keys(childGroup.options)) {\n            if (key.endsWith(\"Order\")) {\n              const name = key.slice(0, key.length - \"Order\".length);\n              let list = lists.get(name);\n\n              if (list === undefined) {\n                list = [];\n                lists.set(name, list);\n              }\n\n              list.push({\n                order: childGroup.options[key],\n                group: childGroup\n              });\n            }\n          }\n        }\n      }\n    }\n    /** @type {Record<string, (string | number)[]>} */\n\n\n    const result = Object.create(null);\n\n    for (const [name, list] of lists) {\n      list.sort((a, b) => {\n        const cmp = b.order - a.order;\n        if (cmp !== 0) return cmp;\n        return a.group.compareTo(chunkGraph, b.group);\n      });\n      /** @type {Set<string | number>} */\n\n      const chunkIdSet = new Set();\n\n      for (const item of list) {\n        for (const chunk of item.group.chunks) {\n          if (filterFn && !filterFn(chunk, chunkGraph)) continue;\n          chunkIdSet.add(chunk.id);\n        }\n      }\n\n      if (chunkIdSet.size > 0) {\n        result[name] = Array.from(chunkIdSet);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {string} type option name\n   * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\n   */\n\n\n  getChildrenOfTypeInOrder(chunkGraph, type) {\n    const list = [];\n\n    for (const group of this.groupsIterable) {\n      for (const childGroup of group.childrenIterable) {\n        const order = childGroup.options[type];\n        if (order === undefined) continue;\n        list.push({\n          order,\n          group,\n          childGroup\n        });\n      }\n    }\n\n    if (list.length === 0) return undefined;\n    list.sort((a, b) => {\n      const cmp = b.order - a.order;\n      if (cmp !== 0) return cmp;\n      return a.group.compareTo(chunkGraph, b.group);\n    });\n    const result = [];\n    let lastEntry;\n\n    for (const {\n      group,\n      childGroup\n    } of list) {\n      if (lastEntry && lastEntry.onChunks === group.chunks) {\n        for (const chunk of childGroup.chunks) {\n          lastEntry.chunks.add(chunk);\n        }\n      } else {\n        result.push(lastEntry = {\n          onChunks: group.chunks,\n          chunks: new Set(childGroup.chunks)\n        });\n      }\n    }\n\n    return result;\n  }\n  /**\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\n   * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n   * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\n   */\n\n\n  getChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\n    /** @type {Record<string|number, Record<string, (string | number)[]>>} */\n    const chunkMaps = Object.create(null);\n    /**\n     * @param {Chunk} chunk a chunk\n     * @returns {void}\n     */\n\n    const addChildIdsByOrdersToMap = chunk => {\n      const data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\n\n      for (const key of Object.keys(data)) {\n        let chunkMap = chunkMaps[key];\n\n        if (chunkMap === undefined) {\n          chunkMaps[key] = chunkMap = Object.create(null);\n        }\n\n        chunkMap[chunk.id] = data[key];\n      }\n    };\n\n    if (includeDirectChildren) {\n      /** @type {Set<Chunk>} */\n      const chunks = new Set();\n\n      for (const chunkGroup of this.groupsIterable) {\n        for (const chunk of chunkGroup.chunks) {\n          chunks.add(chunk);\n        }\n      }\n\n      for (const chunk of chunks) {\n        addChildIdsByOrdersToMap(chunk);\n      }\n    }\n\n    for (const chunk of this.getAllAsyncChunks()) {\n      addChildIdsByOrdersToMap(chunk);\n    }\n\n    return chunkMaps;\n  }\n\n}\n\nmodule.exports = Chunk;","map":{"version":3,"names":["ChunkGraph","require","Entrypoint","intersect","SortableSet","StringXor","compareModulesByIdentifier","compareChunkGroupsByIndex","compareModulesById","createArrayToSetDeprecationSet","mergeRuntime","ChunkFilesSet","debugId","Chunk","constructor","name","backCompat","id","ids","idNameHints","preventIntegration","filenameTemplate","undefined","cssFilenameTemplate","_groups","runtime","files","Set","auxiliaryFiles","rendered","hash","contentHash","Object","create","renderedHash","chunkReason","extraAsync","entryModule","entryModules","Array","from","getChunkGraphForChunk","getChunkEntryModulesIterable","length","Error","hasEntryModule","getNumberOfEntryModules","addModule","module","chunkGraph","isModuleInChunk","connectChunkAndModule","removeModule","disconnectChunkAndModule","getNumberOfModules","getNumberOfChunkModules","modulesIterable","getOrderedChunkModulesIterable","compareTo","otherChunk","compareChunks","containsModule","getModules","getChunkModules","remove","disconnectChunk","disconnectFromGroups","moveModule","integrate","canChunksBeIntegrated","integrateChunks","canBeIntegrated","isEmpty","modulesSize","getChunkModulesSize","size","options","getChunkSize","integratedSize","getIntegratedChunksSize","getChunkModuleMaps","filterFn","chunkModuleIdMap","chunkModuleHashMap","asyncChunk","getAllAsyncChunks","array","moduleId","getModuleId","push","getRenderedModuleHash","hasModuleInGraph","filterChunkFn","getChunkMaps","realHash","chunkHashMap","chunkContentHashMap","chunkNameMap","chunk","key","keys","hasRuntime","chunkGroup","getRuntimeChunk","canBeInitial","isInitial","isOnlyInitial","getEntryOptions","addGroup","add","removeGroup","delete","isInGroup","has","getNumberOfGroups","groupsIterable","sort","removeChunk","split","newChunk","insertChunk","idHint","updateHash","update","join","xor","m","getChunkModulesIterable","getModuleHash","getChunkEntryModulesWithChunkGroupIterable","queue","chunks","initialChunks","g","initialQueue","child","childrenIterable","getAllInitialChunks","group","c","getAllReferencedChunks","getAllReferencedAsyncEntrypoints","entrypoints","entrypoint","asyncEntrypointsIterable","hasAsyncChunks","getChildIdsByOrders","lists","Map","childGroup","endsWith","slice","list","get","set","order","result","a","b","cmp","chunkIdSet","item","getChildrenOfTypeInOrder","type","lastEntry","onChunks","getChildIdsByOrdersMap","includeDirectChildren","chunkMaps","addChildIdsByOrdersToMap","data","chunkMap","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/Chunk.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst { intersect } = require(\"./util/SetHelpers\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst StringXor = require(\"./util/StringXor\");\nconst {\n\tcompareModulesByIdentifier,\n\tcompareChunkGroupsByIndex,\n\tcompareModulesById\n} = require(\"./util/comparators\");\nconst { createArrayToSetDeprecationSet } = require(\"./util/deprecation\");\nconst { mergeRuntime } = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./ChunkGraph\").ChunkFilterPredicate} ChunkFilterPredicate */\n/** @typedef {import(\"./ChunkGraph\").ChunkSizeOptions} ChunkSizeOptions */\n/** @typedef {import(\"./ChunkGraph\").ModuleFilterPredicate} ModuleFilterPredicate */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compilation\").PathData} PathData */\n/** @typedef {import(\"./Entrypoint\").EntryOptions} EntryOptions */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleGraph\")} ModuleGraph */\n/** @typedef {import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst ChunkFilesSet = createArrayToSetDeprecationSet(\"chunk.files\");\n\n/**\n * @typedef {Object} WithId an object who has an id property *\n * @property {string | number} id the id of the object\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkMaps\n * @property {Record<string|number, string>} hash\n * @property {Record<string|number, Record<string, string>>} contentHash\n * @property {Record<string|number, string>} name\n */\n\n/**\n * @deprecated\n * @typedef {Object} ChunkModuleMaps\n * @property {Record<string|number, (string|number)[]>} id\n * @property {Record<string|number, string>} hash\n */\n\nlet debugId = 1000;\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nclass Chunk {\n\t/**\n\t * @param {string=} name of chunk being created, is optional (for subclasses)\n\t * @param {boolean} backCompat enable backward-compatibility\n\t */\n\tconstructor(name, backCompat = true) {\n\t\t/** @type {number | string | null} */\n\t\tthis.id = null;\n\t\t/** @type {(number|string)[] | null} */\n\t\tthis.ids = null;\n\t\t/** @type {number} */\n\t\tthis.debugId = debugId++;\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\t\t/** @type {SortableSet<string>} */\n\t\tthis.idNameHints = new SortableSet();\n\t\t/** @type {boolean} */\n\t\tthis.preventIntegration = false;\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\n\t\tthis.filenameTemplate = undefined;\n\t\t/** @type {(string | function(PathData, AssetInfo=): string)?} */\n\t\tthis.cssFilenameTemplate = undefined;\n\t\t/** @private @type {SortableSet<ChunkGroup>} */\n\t\tthis._groups = new SortableSet(undefined, compareChunkGroupsByIndex);\n\t\t/** @type {RuntimeSpec} */\n\t\tthis.runtime = undefined;\n\t\t/** @type {Set<string>} */\n\t\tthis.files = backCompat ? new ChunkFilesSet() : new Set();\n\t\t/** @type {Set<string>} */\n\t\tthis.auxiliaryFiles = new Set();\n\t\t/** @type {boolean} */\n\t\tthis.rendered = false;\n\t\t/** @type {string=} */\n\t\tthis.hash = undefined;\n\t\t/** @type {Record<string, string>} */\n\t\tthis.contentHash = Object.create(null);\n\t\t/** @type {string=} */\n\t\tthis.renderedHash = undefined;\n\t\t/** @type {string=} */\n\t\tthis.chunkReason = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.extraAsync = false;\n\t}\n\n\t// TODO remove in webpack 6\n\t// BACKWARD-COMPAT START\n\tget entryModule() {\n\t\tconst entryModules = Array.from(\n\t\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\t\tthis,\n\t\t\t\t\"Chunk.entryModule\",\n\t\t\t\t\"DEP_WEBPACK_CHUNK_ENTRY_MODULE\"\n\t\t\t).getChunkEntryModulesIterable(this)\n\t\t);\n\t\tif (entryModules.length === 0) {\n\t\t\treturn undefined;\n\t\t} else if (entryModules.length === 1) {\n\t\t\treturn entryModules[0];\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t\"Module.entryModule: Multiple entry modules are not supported by the deprecated API (Use the new ChunkGroup API)\"\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {boolean} true, if the chunk contains an entry module\n\t */\n\thasEntryModule() {\n\t\treturn (\n\t\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\t\tthis,\n\t\t\t\t\"Chunk.hasEntryModule\",\n\t\t\t\t\"DEP_WEBPACK_CHUNK_HAS_ENTRY_MODULE\"\n\t\t\t).getNumberOfEntryModules(this) > 0\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, if the chunk could be added\n\t */\n\taddModule(module) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.addModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_ADD_MODULE\"\n\t\t);\n\t\tif (chunkGraph.isModuleInChunk(module, this)) return false;\n\t\tchunkGraph.connectChunkAndModule(this, module);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {void}\n\t */\n\tremoveModule(module) {\n\t\tChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.removeModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE_MODULE\"\n\t\t).disconnectChunkAndModule(this, module);\n\t}\n\n\t/**\n\t * @returns {number} the number of module which are contained in this chunk\n\t */\n\tgetNumberOfModules() {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getNumberOfModules\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_NUMBER_OF_MODULES\"\n\t\t).getNumberOfChunkModules(this);\n\t}\n\n\tget modulesIterable() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.modulesIterable\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_ITERABLE\"\n\t\t);\n\t\treturn chunkGraph.getOrderedChunkModulesIterable(\n\t\t\tthis,\n\t\t\tcompareModulesByIdentifier\n\t\t);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the chunk to compare with\n\t * @returns {-1|0|1} the comparison result\n\t */\n\tcompareTo(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.compareTo\",\n\t\t\t\"DEP_WEBPACK_CHUNK_COMPARE_TO\"\n\t\t);\n\t\treturn chunkGraph.compareChunks(this, otherChunk);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, if the chunk contains the module\n\t */\n\tcontainsModule(module) {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.containsModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_CONTAINS_MODULE\"\n\t\t).isModuleInChunk(module, this);\n\t}\n\n\t/**\n\t * @returns {Module[]} the modules for this chunk\n\t */\n\tgetModules() {\n\t\treturn ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getModules\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_MODULES\"\n\t\t).getChunkModules(this);\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tremove() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.remove\",\n\t\t\t\"DEP_WEBPACK_CHUNK_REMOVE\"\n\t\t);\n\t\tchunkGraph.disconnectChunk(this);\n\t\tthis.disconnectFromGroups();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {Chunk} otherChunk the target chunk\n\t * @returns {void}\n\t */\n\tmoveModule(module, otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.moveModule\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MOVE_MODULE\"\n\t\t);\n\t\tchunkGraph.disconnectChunkAndModule(this, module);\n\t\tchunkGraph.connectChunkAndModule(otherChunk, module);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @returns {boolean} true, if the specified chunk has been integrated\n\t */\n\tintegrate(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.integrate\",\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATE\"\n\t\t);\n\t\tif (chunkGraph.canChunksBeIntegrated(this, otherChunk)) {\n\t\t\tchunkGraph.integrateChunks(this, otherChunk);\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @returns {boolean} true, if chunks could be integrated\n\t */\n\tcanBeIntegrated(otherChunk) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.canBeIntegrated\",\n\t\t\t\"DEP_WEBPACK_CHUNK_CAN_BE_INTEGRATED\"\n\t\t);\n\t\treturn chunkGraph.canChunksBeIntegrated(this, otherChunk);\n\t}\n\n\t/**\n\t * @returns {boolean} true, if this chunk contains no module\n\t */\n\tisEmpty() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.isEmpty\",\n\t\t\t\"DEP_WEBPACK_CHUNK_IS_EMPTY\"\n\t\t);\n\t\treturn chunkGraph.getNumberOfChunkModules(this) === 0;\n\t}\n\n\t/**\n\t * @returns {number} total size of all modules in this chunk\n\t */\n\tmodulesSize() {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.modulesSize\",\n\t\t\t\"DEP_WEBPACK_CHUNK_MODULES_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getChunkModulesSize(this);\n\t}\n\n\t/**\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of this chunk\n\t */\n\tsize(options = {}) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.size\",\n\t\t\t\"DEP_WEBPACK_CHUNK_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getChunkSize(this, options);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @param {ChunkSizeOptions} options options object\n\t * @returns {number} total size of the chunk or false if the chunk can't be integrated\n\t */\n\tintegratedSize(otherChunk, options) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.integratedSize\",\n\t\t\t\"DEP_WEBPACK_CHUNK_INTEGRATED_SIZE\"\n\t\t);\n\t\treturn chunkGraph.getIntegratedChunksSize(this, otherChunk, options);\n\t}\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @returns {ChunkModuleMaps} module map information\n\t */\n\tgetChunkModuleMaps(filterFn) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.getChunkModuleMaps\",\n\t\t\t\"DEP_WEBPACK_CHUNK_GET_CHUNK_MODULE_MAPS\"\n\t\t);\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const asyncChunk of this.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of chunkGraph.getOrderedChunkModulesIterable(\n\t\t\t\tasyncChunk,\n\t\t\t\tcompareModulesById(chunkGraph)\n\t\t\t)) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[asyncChunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\t\t\t\tarray.push(moduleId);\n\t\t\t\t\tchunkModuleHashMap[moduleId] = chunkGraph.getRenderedModuleHash(\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tundefined\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tid: chunkModuleIdMap,\n\t\t\thash: chunkModuleHashMap\n\t\t};\n\t}\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn predicate function used to filter modules\n\t * @param {ChunkFilterPredicate=} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(filterFn, filterChunkFn) {\n\t\tconst chunkGraph = ChunkGraph.getChunkGraphForChunk(\n\t\t\tthis,\n\t\t\t\"Chunk.hasModuleInGraph\",\n\t\t\t\"DEP_WEBPACK_CHUNK_HAS_MODULE_IN_GRAPH\"\n\t\t);\n\t\treturn chunkGraph.hasModuleInGraph(this, filterFn, filterChunkFn);\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {boolean} realHash whether the full hash or the rendered hash is to be used\n\t * @returns {ChunkMaps} the chunk map information\n\t */\n\tgetChunkMaps(realHash) {\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, Record<string, string>>} */\n\t\tconst chunkContentHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkNameMap = Object.create(null);\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\tchunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\t\t\tfor (const key of Object.keys(chunk.contentHash)) {\n\t\t\t\tif (!chunkContentHashMap[key]) {\n\t\t\t\t\tchunkContentHashMap[key] = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n\t\t\t}\n\t\t\tif (chunk.name) {\n\t\t\t\tchunkNameMap[chunk.id] = chunk.name;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\thash: chunkHashMap,\n\t\t\tcontentHash: chunkContentHashMap,\n\t\t\tname: chunkNameMap\n\t\t};\n\t}\n\t// BACKWARD-COMPAT END\n\n\t/**\n\t * @returns {boolean} whether or not the Chunk will have a runtime\n\t */\n\thasRuntime() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (\n\t\t\t\tchunkGroup instanceof Entrypoint &&\n\t\t\t\tchunkGroup.getRuntimeChunk() === this\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether or not this chunk can be an initial chunk\n\t */\n\tcanBeInitial() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup.isInitial()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether this chunk can only be an initial chunk\n\t */\n\tisOnlyInitial() {\n\t\tif (this._groups.size <= 0) return false;\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (!chunkGroup.isInitial()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {EntryOptions | undefined} the entry options for this chunk\n\t */\n\tgetEntryOptions() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup instanceof Entrypoint) {\n\t\t\t\treturn chunkGroup.options;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n\t * @returns {void}\n\t */\n\taddGroup(chunkGroup) {\n\t\tthis._groups.add(chunkGroup);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n\t * @returns {void}\n\t */\n\tremoveGroup(chunkGroup) {\n\t\tthis._groups.delete(chunkGroup);\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to check\n\t * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n\t */\n\tisInGroup(chunkGroup) {\n\t\treturn this._groups.has(chunkGroup);\n\t}\n\n\t/**\n\t * @returns {number} the amount of groups that the said chunk is in\n\t */\n\tgetNumberOfGroups() {\n\t\treturn this._groups.size;\n\t}\n\n\t/**\n\t * @returns {Iterable<ChunkGroup>} the chunkGroups that the said chunk is referenced in\n\t */\n\tget groupsIterable() {\n\t\tthis._groups.sort();\n\t\treturn this._groups;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tdisconnectFromGroups() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.removeChunk(this);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Chunk} newChunk the new chunk that will be split out of\n\t * @returns {void}\n\t */\n\tsplit(newChunk) {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.insertChunk(newChunk, this);\n\t\t\tnewChunk.addGroup(chunkGroup);\n\t\t}\n\t\tfor (const idHint of this.idNameHints) {\n\t\t\tnewChunk.idNameHints.add(idHint);\n\t\t}\n\t\tnewChunk.runtime = mergeRuntime(newChunk.runtime, this.runtime);\n\t}\n\n\t/**\n\t * @param {Hash} hash hash (will be modified)\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @returns {void}\n\t */\n\tupdateHash(hash, chunkGraph) {\n\t\thash.update(\n\t\t\t`${this.id} ${this.ids ? this.ids.join() : \"\"} ${this.name || \"\"} `\n\t\t);\n\t\tconst xor = new StringXor();\n\t\tfor (const m of chunkGraph.getChunkModulesIterable(this)) {\n\t\t\txor.add(chunkGraph.getModuleHash(m, this.runtime));\n\t\t}\n\t\txor.updateHash(hash);\n\t\tconst entryModules =\n\t\t\tchunkGraph.getChunkEntryModulesWithChunkGroupIterable(this);\n\t\tfor (const [m, chunkGroup] of entryModules) {\n\t\t\thash.update(`entry${chunkGraph.getModuleId(m)}${chunkGroup.id}`);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the async chunks\n\t */\n\tgetAllAsyncChunks() {\n\t\tconst queue = new Set();\n\t\tconst chunks = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tconst initialQueue = new Set(this.groupsIterable);\n\n\t\tfor (const chunkGroup of initialQueue) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tif (child instanceof Entrypoint) {\n\t\t\t\t\tinitialQueue.add(child);\n\t\t\t\t} else {\n\t\t\t\t\tqueue.add(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the initial chunks (including itself)\n\t */\n\tgetAllInitialChunks() {\n\t\tconst chunks = new Set();\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tfor (const group of queue) {\n\t\t\tif (group.isInitial()) {\n\t\t\t\tfor (const c of group.chunks) chunks.add(c);\n\t\t\t\tfor (const g of group.childrenIterable) queue.add(g);\n\t\t\t}\n\t\t}\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the referenced chunks (including itself)\n\t */\n\tgetAllReferencedChunks() {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst chunks = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tchunks.add(chunk);\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @returns {Set<Entrypoint>} a set of all the referenced entrypoints\n\t */\n\tgetAllReferencedAsyncEntrypoints() {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst entrypoints = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const entrypoint of chunkGroup.asyncEntrypointsIterable) {\n\t\t\t\tentrypoints.add(entrypoint);\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn entrypoints;\n\t}\n\n\t/**\n\t * @returns {boolean} true, if the chunk references async chunks\n\t */\n\thasAsyncChunks() {\n\t\tconst queue = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n\t * @returns {Record<string, (string | number)[]>} a record object of names to lists of child ids(?)\n\t */\n\tgetChildIdsByOrders(chunkGraph, filterFn) {\n\t\t/** @type {Map<string, {order: number, group: ChunkGroup}[]>} */\n\t\tconst lists = new Map();\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tif (group.chunks[group.chunks.length - 1] === this) {\n\t\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t\t\tconst name = key.slice(0, key.length - \"Order\".length);\n\t\t\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\t\tlist = [];\n\t\t\t\t\t\t\t\tlists.set(name, list);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlist.push({\n\t\t\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {Record<string, (string | number)[]>} */\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t\t});\n\t\t\t/** @type {Set<string | number>} */\n\t\t\tconst chunkIdSet = new Set();\n\t\t\tfor (const item of list) {\n\t\t\t\tfor (const chunk of item.group.chunks) {\n\t\t\t\t\tif (filterFn && !filterFn(chunk, chunkGraph)) continue;\n\t\t\t\t\tchunkIdSet.add(chunk.id);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (chunkIdSet.size > 0) {\n\t\t\t\tresult[name] = Array.from(chunkIdSet);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {string} type option name\n\t * @returns {{ onChunks: Chunk[], chunks: Set<Chunk> }[]} referenced chunks for a specific type\n\t */\n\tgetChildrenOfTypeInOrder(chunkGraph, type) {\n\t\tconst list = [];\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\tconst order = childGroup.options[type];\n\t\t\t\tif (order === undefined) continue;\n\t\t\t\tlist.push({\n\t\t\t\t\torder,\n\t\t\t\t\tgroup,\n\t\t\t\t\tchildGroup\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (list.length === 0) return undefined;\n\t\tlist.sort((a, b) => {\n\t\t\tconst cmp = b.order - a.order;\n\t\t\tif (cmp !== 0) return cmp;\n\t\t\treturn a.group.compareTo(chunkGraph, b.group);\n\t\t});\n\t\tconst result = [];\n\t\tlet lastEntry;\n\t\tfor (const { group, childGroup } of list) {\n\t\t\tif (lastEntry && lastEntry.onChunks === group.chunks) {\n\t\t\t\tfor (const chunk of childGroup.chunks) {\n\t\t\t\t\tlastEntry.chunks.add(chunk);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult.push(\n\t\t\t\t\t(lastEntry = {\n\t\t\t\t\t\tonChunks: group.chunks,\n\t\t\t\t\t\tchunks: new Set(childGroup.chunks)\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {boolean=} includeDirectChildren include direct children (by default only children of async children are included)\n\t * @param {ChunkFilterPredicate=} filterFn function used to filter chunks\n\t * @returns {Record<string|number, Record<string, (string | number)[]>>} a record object of names to lists of child ids(?) by chunk id\n\t */\n\tgetChildIdsByOrdersMap(chunkGraph, includeDirectChildren, filterFn) {\n\t\t/** @type {Record<string|number, Record<string, (string | number)[]>>} */\n\t\tconst chunkMaps = Object.create(null);\n\n\t\t/**\n\t\t * @param {Chunk} chunk a chunk\n\t\t * @returns {void}\n\t\t */\n\t\tconst addChildIdsByOrdersToMap = chunk => {\n\t\t\tconst data = chunk.getChildIdsByOrders(chunkGraph, filterFn);\n\t\t\tfor (const key of Object.keys(data)) {\n\t\t\t\tlet chunkMap = chunkMaps[key];\n\t\t\t\tif (chunkMap === undefined) {\n\t\t\t\t\tchunkMaps[key] = chunkMap = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkMap[chunk.id] = data[key];\n\t\t\t}\n\t\t};\n\n\t\tif (includeDirectChildren) {\n\t\t\t/** @type {Set<Chunk>} */\n\t\t\tconst chunks = new Set();\n\t\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t}\n\n\t\treturn chunkMaps;\n\t}\n}\n\nmodule.exports = Chunk;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}