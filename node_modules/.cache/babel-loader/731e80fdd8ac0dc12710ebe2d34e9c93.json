{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst ChunkGraph = require(\"../ChunkGraph\");\n\nconst ModuleGraph = require(\"../ModuleGraph\");\n\nconst {\n  STAGE_DEFAULT\n} = require(\"../OptimizationStages\");\n\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\n\nconst {\n  compareModulesByIdentifier\n} = require(\"../util/comparators\");\n\nconst {\n  intersectRuntime,\n  mergeRuntimeOwned,\n  filterRuntime,\n  runtimeToString,\n  mergeRuntime\n} = require(\"../util/runtime\");\n\nconst ConcatenatedModule = require(\"./ConcatenatedModule\");\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} Statistics\n * @property {number} cached\n * @property {number} alreadyInConfig\n * @property {number} invalidModule\n * @property {number} incorrectChunks\n * @property {number} incorrectDependency\n * @property {number} incorrectModuleDependency\n * @property {number} incorrectChunksOfImporter\n * @property {number} incorrectRuntimeCondition\n * @property {number} importerFailed\n * @property {number} added\n */\n\n\nconst formatBailoutReason = msg => {\n  return \"ModuleConcatenation bailout: \" + msg;\n};\n\nclass ModuleConcatenationPlugin {\n  constructor(options) {\n    if (typeof options !== \"object\") options = {};\n    this.options = options;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const {\n      _backCompat: backCompat\n    } = compiler;\n    compiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", compilation => {\n      if (compilation.moduleMemCaches) {\n        throw new Error(\"optimization.concatenateModules can't be used with cacheUnaffected as module concatenation is a global effect\");\n      }\n\n      const moduleGraph = compilation.moduleGraph;\n      const bailoutReasonMap = new Map();\n\n      const setBailoutReason = (module, reason) => {\n        setInnerBailoutReason(module, reason);\n        moduleGraph.getOptimizationBailout(module).push(typeof reason === \"function\" ? rs => formatBailoutReason(reason(rs)) : formatBailoutReason(reason));\n      };\n\n      const setInnerBailoutReason = (module, reason) => {\n        bailoutReasonMap.set(module, reason);\n      };\n\n      const getInnerBailoutReason = (module, requestShortener) => {\n        const reason = bailoutReasonMap.get(module);\n        if (typeof reason === \"function\") return reason(requestShortener);\n        return reason;\n      };\n\n      const formatBailoutWarning = (module, problem) => requestShortener => {\n        if (typeof problem === \"function\") {\n          return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)}: ${problem(requestShortener)}`);\n        }\n\n        const reason = getInnerBailoutReason(module, requestShortener);\n        const reasonWithPrefix = reason ? `: ${reason}` : \"\";\n\n        if (module === problem) {\n          return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)}${reasonWithPrefix}`);\n        } else {\n          return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)} because of ${problem.readableIdentifier(requestShortener)}${reasonWithPrefix}`);\n        }\n      };\n\n      compilation.hooks.optimizeChunkModules.tapAsync({\n        name: \"ModuleConcatenationPlugin\",\n        stage: STAGE_DEFAULT\n      }, (allChunks, modules, callback) => {\n        const logger = compilation.getLogger(\"webpack.ModuleConcatenationPlugin\");\n        const {\n          chunkGraph,\n          moduleGraph\n        } = compilation;\n        const relevantModules = [];\n        const possibleInners = new Set();\n        const context = {\n          chunkGraph,\n          moduleGraph\n        };\n        logger.time(\"select relevant modules\");\n\n        for (const module of modules) {\n          let canBeRoot = true;\n          let canBeInner = true;\n          const bailoutReason = module.getConcatenationBailoutReason(context);\n\n          if (bailoutReason) {\n            setBailoutReason(module, bailoutReason);\n            continue;\n          } // Must not be an async module\n\n\n          if (moduleGraph.isAsync(module)) {\n            setBailoutReason(module, `Module is async`);\n            continue;\n          } // Must be in strict mode\n\n\n          if (!module.buildInfo.strict) {\n            setBailoutReason(module, `Module is not in strict mode`);\n            continue;\n          } // Module must be in any chunk (we don't want to do useless work)\n\n\n          if (chunkGraph.getNumberOfModuleChunks(module) === 0) {\n            setBailoutReason(module, \"Module is not in any chunk\");\n            continue;\n          } // Exports must be known (and not dynamic)\n\n\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          const relevantExports = exportsInfo.getRelevantExports(undefined);\n          const unknownReexports = relevantExports.filter(exportInfo => {\n            return exportInfo.isReexport() && !exportInfo.getTarget(moduleGraph);\n          });\n\n          if (unknownReexports.length > 0) {\n            setBailoutReason(module, `Reexports in this module do not have a static target (${Array.from(unknownReexports, exportInfo => `${exportInfo.name || \"other exports\"}: ${exportInfo.getUsedInfo()}`).join(\", \")})`);\n            continue;\n          } // Root modules must have a static list of exports\n\n\n          const unknownProvidedExports = relevantExports.filter(exportInfo => {\n            return exportInfo.provided !== true;\n          });\n\n          if (unknownProvidedExports.length > 0) {\n            setBailoutReason(module, `List of module exports is dynamic (${Array.from(unknownProvidedExports, exportInfo => `${exportInfo.name || \"other exports\"}: ${exportInfo.getProvidedInfo()} and ${exportInfo.getUsedInfo()}`).join(\", \")})`);\n            canBeRoot = false;\n          } // Module must not be an entry point\n\n\n          if (chunkGraph.isEntryModule(module)) {\n            setInnerBailoutReason(module, \"Module is an entry point\");\n            canBeInner = false;\n          }\n\n          if (canBeRoot) relevantModules.push(module);\n          if (canBeInner) possibleInners.add(module);\n        }\n\n        logger.timeEnd(\"select relevant modules\");\n        logger.debug(`${relevantModules.length} potential root modules, ${possibleInners.size} potential inner modules`); // sort by depth\n        // modules with lower depth are more likely suited as roots\n        // this improves performance, because modules already selected as inner are skipped\n\n        logger.time(\"sort relevant modules\");\n        relevantModules.sort((a, b) => {\n          return moduleGraph.getDepth(a) - moduleGraph.getDepth(b);\n        });\n        logger.timeEnd(\"sort relevant modules\");\n        /** @type {Statistics} */\n\n        const stats = {\n          cached: 0,\n          alreadyInConfig: 0,\n          invalidModule: 0,\n          incorrectChunks: 0,\n          incorrectDependency: 0,\n          incorrectModuleDependency: 0,\n          incorrectChunksOfImporter: 0,\n          incorrectRuntimeCondition: 0,\n          importerFailed: 0,\n          added: 0\n        };\n        let statsCandidates = 0;\n        let statsSizeSum = 0;\n        let statsEmptyConfigurations = 0;\n        logger.time(\"find modules to concatenate\");\n        const concatConfigurations = [];\n        const usedAsInner = new Set();\n\n        for (const currentRoot of relevantModules) {\n          // when used by another configuration as inner:\n          // the other configuration is better and we can skip this one\n          // TODO reconsider that when it's only used in a different runtime\n          if (usedAsInner.has(currentRoot)) continue;\n          let chunkRuntime = undefined;\n\n          for (const r of chunkGraph.getModuleRuntimes(currentRoot)) {\n            chunkRuntime = mergeRuntimeOwned(chunkRuntime, r);\n          }\n\n          const exportsInfo = moduleGraph.getExportsInfo(currentRoot);\n          const filteredRuntime = filterRuntime(chunkRuntime, r => exportsInfo.isModuleUsed(r));\n          const activeRuntime = filteredRuntime === true ? chunkRuntime : filteredRuntime === false ? undefined : filteredRuntime; // create a configuration with the root\n\n          const currentConfiguration = new ConcatConfiguration(currentRoot, activeRuntime); // cache failures to add modules\n\n          const failureCache = new Map(); // potential optional import candidates\n\n          /** @type {Set<Module>} */\n\n          const candidates = new Set(); // try to add all imports\n\n          for (const imp of this._getImports(compilation, currentRoot, activeRuntime)) {\n            candidates.add(imp);\n          }\n\n          for (const imp of candidates) {\n            const impCandidates = new Set();\n\n            const problem = this._tryToAdd(compilation, currentConfiguration, imp, chunkRuntime, activeRuntime, possibleInners, impCandidates, failureCache, chunkGraph, true, stats);\n\n            if (problem) {\n              failureCache.set(imp, problem);\n              currentConfiguration.addWarning(imp, problem);\n            } else {\n              for (const c of impCandidates) {\n                candidates.add(c);\n              }\n            }\n          }\n\n          statsCandidates += candidates.size;\n\n          if (!currentConfiguration.isEmpty()) {\n            const modules = currentConfiguration.getModules();\n            statsSizeSum += modules.size;\n            concatConfigurations.push(currentConfiguration);\n\n            for (const module of modules) {\n              if (module !== currentConfiguration.rootModule) {\n                usedAsInner.add(module);\n              }\n            }\n          } else {\n            statsEmptyConfigurations++;\n            const optimizationBailouts = moduleGraph.getOptimizationBailout(currentRoot);\n\n            for (const warning of currentConfiguration.getWarningsSorted()) {\n              optimizationBailouts.push(formatBailoutWarning(warning[0], warning[1]));\n            }\n          }\n        }\n\n        logger.timeEnd(\"find modules to concatenate\");\n        logger.debug(`${concatConfigurations.length} successful concat configurations (avg size: ${statsSizeSum / concatConfigurations.length}), ${statsEmptyConfigurations} bailed out completely`);\n        logger.debug(`${statsCandidates} candidates were considered for adding (${stats.cached} cached failure, ${stats.alreadyInConfig} already in config, ${stats.invalidModule} invalid module, ${stats.incorrectChunks} incorrect chunks, ${stats.incorrectDependency} incorrect dependency, ${stats.incorrectChunksOfImporter} incorrect chunks of importer, ${stats.incorrectModuleDependency} incorrect module dependency, ${stats.incorrectRuntimeCondition} incorrect runtime condition, ${stats.importerFailed} importer failed, ${stats.added} added)`); // HACK: Sort configurations by length and start with the longest one\n        // to get the biggest groups possible. Used modules are marked with usedModules\n        // TODO: Allow to reuse existing configuration while trying to add dependencies.\n        // This would improve performance. O(n^2) -> O(n)\n\n        logger.time(`sort concat configurations`);\n        concatConfigurations.sort((a, b) => {\n          return b.modules.size - a.modules.size;\n        });\n        logger.timeEnd(`sort concat configurations`);\n        const usedModules = new Set();\n        logger.time(\"create concatenated modules\");\n        asyncLib.each(concatConfigurations, (concatConfiguration, callback) => {\n          const rootModule = concatConfiguration.rootModule; // Avoid overlapping configurations\n          // TODO: remove this when todo above is fixed\n\n          if (usedModules.has(rootModule)) return callback();\n          const modules = concatConfiguration.getModules();\n\n          for (const m of modules) {\n            usedModules.add(m);\n          } // Create a new ConcatenatedModule\n\n\n          let newModule = ConcatenatedModule.create(rootModule, modules, concatConfiguration.runtime, compiler.root, compilation.outputOptions.hashFunction);\n\n          const build = () => {\n            newModule.build(compiler.options, compilation, null, null, err => {\n              if (err) {\n                if (!err.module) {\n                  err.module = newModule;\n                }\n\n                return callback(err);\n              }\n\n              integrate();\n            });\n          };\n\n          const integrate = () => {\n            if (backCompat) {\n              ChunkGraph.setChunkGraphForModule(newModule, chunkGraph);\n              ModuleGraph.setModuleGraphForModule(newModule, moduleGraph);\n            }\n\n            for (const warning of concatConfiguration.getWarningsSorted()) {\n              moduleGraph.getOptimizationBailout(newModule).push(formatBailoutWarning(warning[0], warning[1]));\n            }\n\n            moduleGraph.cloneModuleAttributes(rootModule, newModule);\n\n            for (const m of modules) {\n              // add to builtModules when one of the included modules was built\n              if (compilation.builtModules.has(m)) {\n                compilation.builtModules.add(newModule);\n              }\n\n              if (m !== rootModule) {\n                // attach external references to the concatenated module too\n                moduleGraph.copyOutgoingModuleConnections(m, newModule, c => {\n                  return c.originModule === m && !(c.dependency instanceof HarmonyImportDependency && modules.has(c.module));\n                }); // remove module from chunk\n\n                for (const chunk of chunkGraph.getModuleChunksIterable(rootModule)) {\n                  const sourceTypes = chunkGraph.getChunkModuleSourceTypes(chunk, m);\n\n                  if (sourceTypes.size === 1) {\n                    chunkGraph.disconnectChunkAndModule(chunk, m);\n                  } else {\n                    const newSourceTypes = new Set(sourceTypes);\n                    newSourceTypes.delete(\"javascript\");\n                    chunkGraph.setChunkModuleSourceTypes(chunk, m, newSourceTypes);\n                  }\n                }\n              }\n            }\n\n            compilation.modules.delete(rootModule);\n            ChunkGraph.clearChunkGraphForModule(rootModule);\n            ModuleGraph.clearModuleGraphForModule(rootModule); // remove module from chunk\n\n            chunkGraph.replaceModule(rootModule, newModule); // replace module references with the concatenated module\n\n            moduleGraph.moveModuleConnections(rootModule, newModule, c => {\n              const otherModule = c.module === rootModule ? c.originModule : c.module;\n              const innerConnection = c.dependency instanceof HarmonyImportDependency && modules.has(otherModule);\n              return !innerConnection;\n            }); // add concatenated module to the compilation\n\n            compilation.modules.add(newModule);\n            callback();\n          };\n\n          build();\n        }, err => {\n          logger.timeEnd(\"create concatenated modules\");\n          process.nextTick(callback.bind(null, err));\n        });\n      });\n    });\n  }\n  /**\n   * @param {Compilation} compilation the compilation\n   * @param {Module} module the module to be added\n   * @param {RuntimeSpec} runtime the runtime scope\n   * @returns {Set<Module>} the imported modules\n   */\n\n\n  _getImports(compilation, module, runtime) {\n    const moduleGraph = compilation.moduleGraph;\n    const set = new Set();\n\n    for (const dep of module.dependencies) {\n      // Get reference info only for harmony Dependencies\n      if (!(dep instanceof HarmonyImportDependency)) continue;\n      const connection = moduleGraph.getConnection(dep); // Reference is valid and has a module\n\n      if (!connection || !connection.module || !connection.isTargetActive(runtime)) {\n        continue;\n      }\n\n      const importedNames = compilation.getDependencyReferencedExports(dep, undefined);\n\n      if (importedNames.every(i => Array.isArray(i) ? i.length > 0 : i.name.length > 0) || Array.isArray(moduleGraph.getProvidedExports(module))) {\n        set.add(connection.module);\n      }\n    }\n\n    return set;\n  }\n  /**\n   * @param {Compilation} compilation webpack compilation\n   * @param {ConcatConfiguration} config concat configuration (will be modified when added)\n   * @param {Module} module the module to be added\n   * @param {RuntimeSpec} runtime the runtime scope of the generated code\n   * @param {RuntimeSpec} activeRuntime the runtime scope of the root module\n   * @param {Set<Module>} possibleModules modules that are candidates\n   * @param {Set<Module>} candidates list of potential candidates (will be added to)\n   * @param {Map<Module, Module | function(RequestShortener): string>} failureCache cache for problematic modules to be more performant\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {boolean} avoidMutateOnFailure avoid mutating the config when adding fails\n   * @param {Statistics} statistics gathering metrics\n   * @returns {Module | function(RequestShortener): string} the problematic module\n   */\n\n\n  _tryToAdd(compilation, config, module, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, avoidMutateOnFailure, statistics) {\n    const cacheEntry = failureCache.get(module);\n\n    if (cacheEntry) {\n      statistics.cached++;\n      return cacheEntry;\n    } // Already added?\n\n\n    if (config.has(module)) {\n      statistics.alreadyInConfig++;\n      return null;\n    } // Not possible to add?\n\n\n    if (!possibleModules.has(module)) {\n      statistics.invalidModule++;\n      failureCache.set(module, module); // cache failures for performance\n\n      return module;\n    } // Module must be in the correct chunks\n\n\n    const missingChunks = Array.from(chunkGraph.getModuleChunksIterable(config.rootModule)).filter(chunk => !chunkGraph.isModuleInChunk(module, chunk));\n\n    if (missingChunks.length > 0) {\n      const problem = requestShortener => {\n        const missingChunksList = Array.from(new Set(missingChunks.map(chunk => chunk.name || \"unnamed chunk(s)\"))).sort();\n        const chunks = Array.from(new Set(Array.from(chunkGraph.getModuleChunksIterable(module)).map(chunk => chunk.name || \"unnamed chunk(s)\"))).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is not in the same chunk(s) (expected in chunk(s) ${missingChunksList.join(\", \")}, module is in chunk(s) ${chunks.join(\", \")})`;\n      };\n\n      statistics.incorrectChunks++;\n      failureCache.set(module, problem); // cache failures for performance\n\n      return problem;\n    }\n\n    const moduleGraph = compilation.moduleGraph;\n    const incomingConnections = moduleGraph.getIncomingConnectionsByOriginModule(module);\n    const incomingConnectionsFromNonModules = incomingConnections.get(null) || incomingConnections.get(undefined);\n\n    if (incomingConnectionsFromNonModules) {\n      const activeNonModulesConnections = incomingConnectionsFromNonModules.filter(connection => {\n        // We are not interested in inactive connections\n        // or connections without dependency\n        return connection.isActive(runtime);\n      });\n\n      if (activeNonModulesConnections.length > 0) {\n        const problem = requestShortener => {\n          const importingExplanations = new Set(activeNonModulesConnections.map(c => c.explanation).filter(Boolean));\n          const explanations = Array.from(importingExplanations).sort();\n          return `Module ${module.readableIdentifier(requestShortener)} is referenced ${explanations.length > 0 ? `by: ${explanations.join(\", \")}` : \"in an unsupported way\"}`;\n        };\n\n        statistics.incorrectDependency++;\n        failureCache.set(module, problem); // cache failures for performance\n\n        return problem;\n      }\n    }\n    /** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\n\n    const incomingConnectionsFromModules = new Map();\n\n    for (const [originModule, connections] of incomingConnections) {\n      if (originModule) {\n        // Ignore connection from orphan modules\n        if (chunkGraph.getNumberOfModuleChunks(originModule) === 0) continue; // We don't care for connections from other runtimes\n\n        let originRuntime = undefined;\n\n        for (const r of chunkGraph.getModuleRuntimes(originModule)) {\n          originRuntime = mergeRuntimeOwned(originRuntime, r);\n        }\n\n        if (!intersectRuntime(runtime, originRuntime)) continue; // We are not interested in inactive connections\n\n        const activeConnections = connections.filter(connection => connection.isActive(runtime));\n        if (activeConnections.length > 0) incomingConnectionsFromModules.set(originModule, activeConnections);\n      }\n    }\n\n    const incomingModules = Array.from(incomingConnectionsFromModules.keys()); // Module must be in the same chunks like the referencing module\n\n    const otherChunkModules = incomingModules.filter(originModule => {\n      for (const chunk of chunkGraph.getModuleChunksIterable(config.rootModule)) {\n        if (!chunkGraph.isModuleInChunk(originModule, chunk)) {\n          return true;\n        }\n      }\n\n      return false;\n    });\n\n    if (otherChunkModules.length > 0) {\n      const problem = requestShortener => {\n        const names = otherChunkModules.map(m => m.readableIdentifier(requestShortener)).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is referenced from different chunks by these modules: ${names.join(\", \")}`;\n      };\n\n      statistics.incorrectChunksOfImporter++;\n      failureCache.set(module, problem); // cache failures for performance\n\n      return problem;\n    }\n    /** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\n\n    const nonHarmonyConnections = new Map();\n\n    for (const [originModule, connections] of incomingConnectionsFromModules) {\n      const selected = connections.filter(connection => !connection.dependency || !(connection.dependency instanceof HarmonyImportDependency));\n      if (selected.length > 0) nonHarmonyConnections.set(originModule, connections);\n    }\n\n    if (nonHarmonyConnections.size > 0) {\n      const problem = requestShortener => {\n        const names = Array.from(nonHarmonyConnections).map(_ref => {\n          let [originModule, connections] = _ref;\n          return `${originModule.readableIdentifier(requestShortener)} (referenced with ${Array.from(new Set(connections.map(c => c.dependency && c.dependency.type).filter(Boolean))).sort().join(\", \")})`;\n        }).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is referenced from these modules with unsupported syntax: ${names.join(\", \")}`;\n      };\n\n      statistics.incorrectModuleDependency++;\n      failureCache.set(module, problem); // cache failures for performance\n\n      return problem;\n    }\n\n    if (runtime !== undefined && typeof runtime !== \"string\") {\n      // Module must be consistently referenced in the same runtimes\n\n      /** @type {{ originModule: Module, runtimeCondition: RuntimeSpec }[]} */\n      const otherRuntimeConnections = [];\n\n      outer: for (const [originModule, connections] of incomingConnectionsFromModules) {\n        /** @type {false | RuntimeSpec} */\n        let currentRuntimeCondition = false;\n\n        for (const connection of connections) {\n          const runtimeCondition = filterRuntime(runtime, runtime => {\n            return connection.isTargetActive(runtime);\n          });\n          if (runtimeCondition === false) continue;\n          if (runtimeCondition === true) continue outer;\n\n          if (currentRuntimeCondition !== false) {\n            currentRuntimeCondition = mergeRuntime(currentRuntimeCondition, runtimeCondition);\n          } else {\n            currentRuntimeCondition = runtimeCondition;\n          }\n        }\n\n        if (currentRuntimeCondition !== false) {\n          otherRuntimeConnections.push({\n            originModule,\n            runtimeCondition: currentRuntimeCondition\n          });\n        }\n      }\n\n      if (otherRuntimeConnections.length > 0) {\n        const problem = requestShortener => {\n          return `Module ${module.readableIdentifier(requestShortener)} is runtime-dependent referenced by these modules: ${Array.from(otherRuntimeConnections, _ref2 => {\n            let {\n              originModule,\n              runtimeCondition\n            } = _ref2;\n            return `${originModule.readableIdentifier(requestShortener)} (expected runtime ${runtimeToString(runtime)}, module is only referenced in ${runtimeToString(\n            /** @type {RuntimeSpec} */\n            runtimeCondition)})`;\n          }).join(\", \")}`;\n        };\n\n        statistics.incorrectRuntimeCondition++;\n        failureCache.set(module, problem); // cache failures for performance\n\n        return problem;\n      }\n    }\n\n    let backup;\n\n    if (avoidMutateOnFailure) {\n      backup = config.snapshot();\n    } // Add the module\n\n\n    config.add(module);\n    incomingModules.sort(compareModulesByIdentifier); // Every module which depends on the added module must be in the configuration too.\n\n    for (const originModule of incomingModules) {\n      const problem = this._tryToAdd(compilation, config, originModule, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, false, statistics);\n\n      if (problem) {\n        if (backup !== undefined) config.rollback(backup);\n        statistics.importerFailed++;\n        failureCache.set(module, problem); // cache failures for performance\n\n        return problem;\n      }\n    } // Add imports to possible candidates list\n\n\n    for (const imp of this._getImports(compilation, module, runtime)) {\n      candidates.add(imp);\n    }\n\n    statistics.added++;\n    return null;\n  }\n\n}\n\nclass ConcatConfiguration {\n  /**\n   * @param {Module} rootModule the root module\n   * @param {RuntimeSpec} runtime the runtime\n   */\n  constructor(rootModule, runtime) {\n    this.rootModule = rootModule;\n    this.runtime = runtime;\n    /** @type {Set<Module>} */\n\n    this.modules = new Set();\n    this.modules.add(rootModule);\n    /** @type {Map<Module, Module | function(RequestShortener): string>} */\n\n    this.warnings = new Map();\n  }\n\n  add(module) {\n    this.modules.add(module);\n  }\n\n  has(module) {\n    return this.modules.has(module);\n  }\n\n  isEmpty() {\n    return this.modules.size === 1;\n  }\n\n  addWarning(module, problem) {\n    this.warnings.set(module, problem);\n  }\n\n  getWarningsSorted() {\n    return new Map(Array.from(this.warnings).sort((a, b) => {\n      const ai = a[0].identifier();\n      const bi = b[0].identifier();\n      if (ai < bi) return -1;\n      if (ai > bi) return 1;\n      return 0;\n    }));\n  }\n  /**\n   * @returns {Set<Module>} modules as set\n   */\n\n\n  getModules() {\n    return this.modules;\n  }\n\n  snapshot() {\n    return this.modules.size;\n  }\n\n  rollback(snapshot) {\n    const modules = this.modules;\n\n    for (const m of modules) {\n      if (snapshot === 0) {\n        modules.delete(m);\n      } else {\n        snapshot--;\n      }\n    }\n  }\n\n}\n\nmodule.exports = ModuleConcatenationPlugin;","map":{"version":3,"names":["asyncLib","require","ChunkGraph","ModuleGraph","STAGE_DEFAULT","HarmonyImportDependency","compareModulesByIdentifier","intersectRuntime","mergeRuntimeOwned","filterRuntime","runtimeToString","mergeRuntime","ConcatenatedModule","formatBailoutReason","msg","ModuleConcatenationPlugin","constructor","options","apply","compiler","_backCompat","backCompat","hooks","compilation","tap","moduleMemCaches","Error","moduleGraph","bailoutReasonMap","Map","setBailoutReason","module","reason","setInnerBailoutReason","getOptimizationBailout","push","rs","set","getInnerBailoutReason","requestShortener","get","formatBailoutWarning","problem","readableIdentifier","reasonWithPrefix","optimizeChunkModules","tapAsync","name","stage","allChunks","modules","callback","logger","getLogger","chunkGraph","relevantModules","possibleInners","Set","context","time","canBeRoot","canBeInner","bailoutReason","getConcatenationBailoutReason","isAsync","buildInfo","strict","getNumberOfModuleChunks","exportsInfo","getExportsInfo","relevantExports","getRelevantExports","undefined","unknownReexports","filter","exportInfo","isReexport","getTarget","length","Array","from","getUsedInfo","join","unknownProvidedExports","provided","getProvidedInfo","isEntryModule","add","timeEnd","debug","size","sort","a","b","getDepth","stats","cached","alreadyInConfig","invalidModule","incorrectChunks","incorrectDependency","incorrectModuleDependency","incorrectChunksOfImporter","incorrectRuntimeCondition","importerFailed","added","statsCandidates","statsSizeSum","statsEmptyConfigurations","concatConfigurations","usedAsInner","currentRoot","has","chunkRuntime","r","getModuleRuntimes","filteredRuntime","isModuleUsed","activeRuntime","currentConfiguration","ConcatConfiguration","failureCache","candidates","imp","_getImports","impCandidates","_tryToAdd","addWarning","c","isEmpty","getModules","rootModule","optimizationBailouts","warning","getWarningsSorted","usedModules","each","concatConfiguration","m","newModule","create","runtime","root","outputOptions","hashFunction","build","err","integrate","setChunkGraphForModule","setModuleGraphForModule","cloneModuleAttributes","builtModules","copyOutgoingModuleConnections","originModule","dependency","chunk","getModuleChunksIterable","sourceTypes","getChunkModuleSourceTypes","disconnectChunkAndModule","newSourceTypes","delete","setChunkModuleSourceTypes","clearChunkGraphForModule","clearModuleGraphForModule","replaceModule","moveModuleConnections","otherModule","innerConnection","process","nextTick","bind","dep","dependencies","connection","getConnection","isTargetActive","importedNames","getDependencyReferencedExports","every","i","isArray","getProvidedExports","config","possibleModules","avoidMutateOnFailure","statistics","cacheEntry","missingChunks","isModuleInChunk","missingChunksList","map","chunks","incomingConnections","getIncomingConnectionsByOriginModule","incomingConnectionsFromNonModules","activeNonModulesConnections","isActive","importingExplanations","explanation","Boolean","explanations","incomingConnectionsFromModules","connections","originRuntime","activeConnections","incomingModules","keys","otherChunkModules","names","nonHarmonyConnections","selected","type","otherRuntimeConnections","outer","currentRuntimeCondition","runtimeCondition","backup","snapshot","rollback","warnings","ai","identifier","bi","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/optimize/ModuleConcatenationPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst ChunkGraph = require(\"../ChunkGraph\");\nconst ModuleGraph = require(\"../ModuleGraph\");\nconst { STAGE_DEFAULT } = require(\"../OptimizationStages\");\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\nconst { compareModulesByIdentifier } = require(\"../util/comparators\");\nconst {\n\tintersectRuntime,\n\tmergeRuntimeOwned,\n\tfilterRuntime,\n\truntimeToString,\n\tmergeRuntime\n} = require(\"../util/runtime\");\nconst ConcatenatedModule = require(\"./ConcatenatedModule\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {Object} Statistics\n * @property {number} cached\n * @property {number} alreadyInConfig\n * @property {number} invalidModule\n * @property {number} incorrectChunks\n * @property {number} incorrectDependency\n * @property {number} incorrectModuleDependency\n * @property {number} incorrectChunksOfImporter\n * @property {number} incorrectRuntimeCondition\n * @property {number} importerFailed\n * @property {number} added\n */\n\nconst formatBailoutReason = msg => {\n\treturn \"ModuleConcatenation bailout: \" + msg;\n};\n\nclass ModuleConcatenationPlugin {\n\tconstructor(options) {\n\t\tif (typeof options !== \"object\") options = {};\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { _backCompat: backCompat } = compiler;\n\t\tcompiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", compilation => {\n\t\t\tif (compilation.moduleMemCaches) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"optimization.concatenateModules can't be used with cacheUnaffected as module concatenation is a global effect\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tconst bailoutReasonMap = new Map();\n\n\t\t\tconst setBailoutReason = (module, reason) => {\n\t\t\t\tsetInnerBailoutReason(module, reason);\n\t\t\t\tmoduleGraph\n\t\t\t\t\t.getOptimizationBailout(module)\n\t\t\t\t\t.push(\n\t\t\t\t\t\ttypeof reason === \"function\"\n\t\t\t\t\t\t\t? rs => formatBailoutReason(reason(rs))\n\t\t\t\t\t\t\t: formatBailoutReason(reason)\n\t\t\t\t\t);\n\t\t\t};\n\n\t\t\tconst setInnerBailoutReason = (module, reason) => {\n\t\t\t\tbailoutReasonMap.set(module, reason);\n\t\t\t};\n\n\t\t\tconst getInnerBailoutReason = (module, requestShortener) => {\n\t\t\t\tconst reason = bailoutReasonMap.get(module);\n\t\t\t\tif (typeof reason === \"function\") return reason(requestShortener);\n\t\t\t\treturn reason;\n\t\t\t};\n\n\t\t\tconst formatBailoutWarning = (module, problem) => requestShortener => {\n\t\t\t\tif (typeof problem === \"function\") {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}: ${problem(requestShortener)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst reason = getInnerBailoutReason(module, requestShortener);\n\t\t\t\tconst reasonWithPrefix = reason ? `: ${reason}` : \"\";\n\t\t\t\tif (module === problem) {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}${reasonWithPrefix}`\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)} because of ${problem.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}${reasonWithPrefix}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tcompilation.hooks.optimizeChunkModules.tapAsync(\n\t\t\t\t{\n\t\t\t\t\tname: \"ModuleConcatenationPlugin\",\n\t\t\t\t\tstage: STAGE_DEFAULT\n\t\t\t\t},\n\t\t\t\t(allChunks, modules, callback) => {\n\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\"webpack.ModuleConcatenationPlugin\"\n\t\t\t\t\t);\n\t\t\t\t\tconst { chunkGraph, moduleGraph } = compilation;\n\t\t\t\t\tconst relevantModules = [];\n\t\t\t\t\tconst possibleInners = new Set();\n\t\t\t\t\tconst context = {\n\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t};\n\t\t\t\t\tlogger.time(\"select relevant modules\");\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tlet canBeRoot = true;\n\t\t\t\t\t\tlet canBeInner = true;\n\n\t\t\t\t\t\tconst bailoutReason = module.getConcatenationBailoutReason(context);\n\t\t\t\t\t\tif (bailoutReason) {\n\t\t\t\t\t\t\tsetBailoutReason(module, bailoutReason);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Must not be an async module\n\t\t\t\t\t\tif (moduleGraph.isAsync(module)) {\n\t\t\t\t\t\t\tsetBailoutReason(module, `Module is async`);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Must be in strict mode\n\t\t\t\t\t\tif (!module.buildInfo.strict) {\n\t\t\t\t\t\t\tsetBailoutReason(module, `Module is not in strict mode`);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Module must be in any chunk (we don't want to do useless work)\n\t\t\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(module) === 0) {\n\t\t\t\t\t\t\tsetBailoutReason(module, \"Module is not in any chunk\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Exports must be known (and not dynamic)\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tconst relevantExports = exportsInfo.getRelevantExports(undefined);\n\t\t\t\t\t\tconst unknownReexports = relevantExports.filter(exportInfo => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\texportInfo.isReexport() && !exportInfo.getTarget(moduleGraph)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (unknownReexports.length > 0) {\n\t\t\t\t\t\t\tsetBailoutReason(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t`Reexports in this module do not have a static target (${Array.from(\n\t\t\t\t\t\t\t\t\tunknownReexports,\n\t\t\t\t\t\t\t\t\texportInfo =>\n\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\texportInfo.name || \"other exports\"\n\t\t\t\t\t\t\t\t\t\t}: ${exportInfo.getUsedInfo()}`\n\t\t\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Root modules must have a static list of exports\n\t\t\t\t\t\tconst unknownProvidedExports = relevantExports.filter(\n\t\t\t\t\t\t\texportInfo => {\n\t\t\t\t\t\t\t\treturn exportInfo.provided !== true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (unknownProvidedExports.length > 0) {\n\t\t\t\t\t\t\tsetBailoutReason(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t`List of module exports is dynamic (${Array.from(\n\t\t\t\t\t\t\t\t\tunknownProvidedExports,\n\t\t\t\t\t\t\t\t\texportInfo =>\n\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\texportInfo.name || \"other exports\"\n\t\t\t\t\t\t\t\t\t\t}: ${exportInfo.getProvidedInfo()} and ${exportInfo.getUsedInfo()}`\n\t\t\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcanBeRoot = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Module must not be an entry point\n\t\t\t\t\t\tif (chunkGraph.isEntryModule(module)) {\n\t\t\t\t\t\t\tsetInnerBailoutReason(module, \"Module is an entry point\");\n\t\t\t\t\t\t\tcanBeInner = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canBeRoot) relevantModules.push(module);\n\t\t\t\t\t\tif (canBeInner) possibleInners.add(module);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"select relevant modules\");\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${relevantModules.length} potential root modules, ${possibleInners.size} potential inner modules`\n\t\t\t\t\t);\n\t\t\t\t\t// sort by depth\n\t\t\t\t\t// modules with lower depth are more likely suited as roots\n\t\t\t\t\t// this improves performance, because modules already selected as inner are skipped\n\t\t\t\t\tlogger.time(\"sort relevant modules\");\n\t\t\t\t\trelevantModules.sort((a, b) => {\n\t\t\t\t\t\treturn moduleGraph.getDepth(a) - moduleGraph.getDepth(b);\n\t\t\t\t\t});\n\t\t\t\t\tlogger.timeEnd(\"sort relevant modules\");\n\n\t\t\t\t\t/** @type {Statistics} */\n\t\t\t\t\tconst stats = {\n\t\t\t\t\t\tcached: 0,\n\t\t\t\t\t\talreadyInConfig: 0,\n\t\t\t\t\t\tinvalidModule: 0,\n\t\t\t\t\t\tincorrectChunks: 0,\n\t\t\t\t\t\tincorrectDependency: 0,\n\t\t\t\t\t\tincorrectModuleDependency: 0,\n\t\t\t\t\t\tincorrectChunksOfImporter: 0,\n\t\t\t\t\t\tincorrectRuntimeCondition: 0,\n\t\t\t\t\t\timporterFailed: 0,\n\t\t\t\t\t\tadded: 0\n\t\t\t\t\t};\n\t\t\t\t\tlet statsCandidates = 0;\n\t\t\t\t\tlet statsSizeSum = 0;\n\t\t\t\t\tlet statsEmptyConfigurations = 0;\n\n\t\t\t\t\tlogger.time(\"find modules to concatenate\");\n\t\t\t\t\tconst concatConfigurations = [];\n\t\t\t\t\tconst usedAsInner = new Set();\n\t\t\t\t\tfor (const currentRoot of relevantModules) {\n\t\t\t\t\t\t// when used by another configuration as inner:\n\t\t\t\t\t\t// the other configuration is better and we can skip this one\n\t\t\t\t\t\t// TODO reconsider that when it's only used in a different runtime\n\t\t\t\t\t\tif (usedAsInner.has(currentRoot)) continue;\n\n\t\t\t\t\t\tlet chunkRuntime = undefined;\n\t\t\t\t\t\tfor (const r of chunkGraph.getModuleRuntimes(currentRoot)) {\n\t\t\t\t\t\t\tchunkRuntime = mergeRuntimeOwned(chunkRuntime, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(currentRoot);\n\t\t\t\t\t\tconst filteredRuntime = filterRuntime(chunkRuntime, r =>\n\t\t\t\t\t\t\texportsInfo.isModuleUsed(r)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst activeRuntime =\n\t\t\t\t\t\t\tfilteredRuntime === true\n\t\t\t\t\t\t\t\t? chunkRuntime\n\t\t\t\t\t\t\t\t: filteredRuntime === false\n\t\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t\t: filteredRuntime;\n\n\t\t\t\t\t\t// create a configuration with the root\n\t\t\t\t\t\tconst currentConfiguration = new ConcatConfiguration(\n\t\t\t\t\t\t\tcurrentRoot,\n\t\t\t\t\t\t\tactiveRuntime\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// cache failures to add modules\n\t\t\t\t\t\tconst failureCache = new Map();\n\n\t\t\t\t\t\t// potential optional import candidates\n\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\tconst candidates = new Set();\n\n\t\t\t\t\t\t// try to add all imports\n\t\t\t\t\t\tfor (const imp of this._getImports(\n\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\tcurrentRoot,\n\t\t\t\t\t\t\tactiveRuntime\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tcandidates.add(imp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const imp of candidates) {\n\t\t\t\t\t\t\tconst impCandidates = new Set();\n\t\t\t\t\t\t\tconst problem = this._tryToAdd(\n\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\tcurrentConfiguration,\n\t\t\t\t\t\t\t\timp,\n\t\t\t\t\t\t\t\tchunkRuntime,\n\t\t\t\t\t\t\t\tactiveRuntime,\n\t\t\t\t\t\t\t\tpossibleInners,\n\t\t\t\t\t\t\t\timpCandidates,\n\t\t\t\t\t\t\t\tfailureCache,\n\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tstats\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (problem) {\n\t\t\t\t\t\t\t\tfailureCache.set(imp, problem);\n\t\t\t\t\t\t\t\tcurrentConfiguration.addWarning(imp, problem);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const c of impCandidates) {\n\t\t\t\t\t\t\t\t\tcandidates.add(c);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatsCandidates += candidates.size;\n\t\t\t\t\t\tif (!currentConfiguration.isEmpty()) {\n\t\t\t\t\t\t\tconst modules = currentConfiguration.getModules();\n\t\t\t\t\t\t\tstatsSizeSum += modules.size;\n\t\t\t\t\t\t\tconcatConfigurations.push(currentConfiguration);\n\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\tif (module !== currentConfiguration.rootModule) {\n\t\t\t\t\t\t\t\t\tusedAsInner.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstatsEmptyConfigurations++;\n\t\t\t\t\t\t\tconst optimizationBailouts =\n\t\t\t\t\t\t\t\tmoduleGraph.getOptimizationBailout(currentRoot);\n\t\t\t\t\t\t\tfor (const warning of currentConfiguration.getWarningsSorted()) {\n\t\t\t\t\t\t\t\toptimizationBailouts.push(\n\t\t\t\t\t\t\t\t\tformatBailoutWarning(warning[0], warning[1])\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"find modules to concatenate\");\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${\n\t\t\t\t\t\t\tconcatConfigurations.length\n\t\t\t\t\t\t} successful concat configurations (avg size: ${\n\t\t\t\t\t\t\tstatsSizeSum / concatConfigurations.length\n\t\t\t\t\t\t}), ${statsEmptyConfigurations} bailed out completely`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${statsCandidates} candidates were considered for adding (${stats.cached} cached failure, ${stats.alreadyInConfig} already in config, ${stats.invalidModule} invalid module, ${stats.incorrectChunks} incorrect chunks, ${stats.incorrectDependency} incorrect dependency, ${stats.incorrectChunksOfImporter} incorrect chunks of importer, ${stats.incorrectModuleDependency} incorrect module dependency, ${stats.incorrectRuntimeCondition} incorrect runtime condition, ${stats.importerFailed} importer failed, ${stats.added} added)`\n\t\t\t\t\t);\n\t\t\t\t\t// HACK: Sort configurations by length and start with the longest one\n\t\t\t\t\t// to get the biggest groups possible. Used modules are marked with usedModules\n\t\t\t\t\t// TODO: Allow to reuse existing configuration while trying to add dependencies.\n\t\t\t\t\t// This would improve performance. O(n^2) -> O(n)\n\t\t\t\t\tlogger.time(`sort concat configurations`);\n\t\t\t\t\tconcatConfigurations.sort((a, b) => {\n\t\t\t\t\t\treturn b.modules.size - a.modules.size;\n\t\t\t\t\t});\n\t\t\t\t\tlogger.timeEnd(`sort concat configurations`);\n\t\t\t\t\tconst usedModules = new Set();\n\n\t\t\t\t\tlogger.time(\"create concatenated modules\");\n\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\tconcatConfigurations,\n\t\t\t\t\t\t(concatConfiguration, callback) => {\n\t\t\t\t\t\t\tconst rootModule = concatConfiguration.rootModule;\n\n\t\t\t\t\t\t\t// Avoid overlapping configurations\n\t\t\t\t\t\t\t// TODO: remove this when todo above is fixed\n\t\t\t\t\t\t\tif (usedModules.has(rootModule)) return callback();\n\t\t\t\t\t\t\tconst modules = concatConfiguration.getModules();\n\t\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\t\tusedModules.add(m);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Create a new ConcatenatedModule\n\t\t\t\t\t\t\tlet newModule = ConcatenatedModule.create(\n\t\t\t\t\t\t\t\trootModule,\n\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\tconcatConfiguration.runtime,\n\t\t\t\t\t\t\t\tcompiler.root,\n\t\t\t\t\t\t\t\tcompilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst build = () => {\n\t\t\t\t\t\t\t\tnewModule.build(\n\t\t\t\t\t\t\t\t\tcompiler.options,\n\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tif (!err.module) {\n\t\t\t\t\t\t\t\t\t\t\t\terr.module = newModule;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tintegrate();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst integrate = () => {\n\t\t\t\t\t\t\t\tif (backCompat) {\n\t\t\t\t\t\t\t\t\tChunkGraph.setChunkGraphForModule(newModule, chunkGraph);\n\t\t\t\t\t\t\t\t\tModuleGraph.setModuleGraphForModule(newModule, moduleGraph);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor (const warning of concatConfiguration.getWarningsSorted()) {\n\t\t\t\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t\t\t\t\t\t.getOptimizationBailout(newModule)\n\t\t\t\t\t\t\t\t\t\t.push(formatBailoutWarning(warning[0], warning[1]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmoduleGraph.cloneModuleAttributes(rootModule, newModule);\n\t\t\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\t\t\t// add to builtModules when one of the included modules was built\n\t\t\t\t\t\t\t\t\tif (compilation.builtModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\tcompilation.builtModules.add(newModule);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (m !== rootModule) {\n\t\t\t\t\t\t\t\t\t\t// attach external references to the concatenated module too\n\t\t\t\t\t\t\t\t\t\tmoduleGraph.copyOutgoingModuleConnections(\n\t\t\t\t\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\t\t\t\t\tnewModule,\n\t\t\t\t\t\t\t\t\t\t\tc => {\n\t\t\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t\t\tc.originModule === m &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tc.dependency instanceof HarmonyImportDependency &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodules.has(c.module)\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t// remove module from chunk\n\t\t\t\t\t\t\t\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(\n\t\t\t\t\t\t\t\t\t\t\trootModule\n\t\t\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\t\t\tconst sourceTypes = chunkGraph.getChunkModuleSourceTypes(\n\t\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\t\tm\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tif (sourceTypes.size === 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, m);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tconst newSourceTypes = new Set(sourceTypes);\n\t\t\t\t\t\t\t\t\t\t\t\tnewSourceTypes.delete(\"javascript\");\n\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph.setChunkModuleSourceTypes(\n\t\t\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewSourceTypes\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.modules.delete(rootModule);\n\t\t\t\t\t\t\t\tChunkGraph.clearChunkGraphForModule(rootModule);\n\t\t\t\t\t\t\t\tModuleGraph.clearModuleGraphForModule(rootModule);\n\n\t\t\t\t\t\t\t\t// remove module from chunk\n\t\t\t\t\t\t\t\tchunkGraph.replaceModule(rootModule, newModule);\n\t\t\t\t\t\t\t\t// replace module references with the concatenated module\n\t\t\t\t\t\t\t\tmoduleGraph.moveModuleConnections(rootModule, newModule, c => {\n\t\t\t\t\t\t\t\t\tconst otherModule =\n\t\t\t\t\t\t\t\t\t\tc.module === rootModule ? c.originModule : c.module;\n\t\t\t\t\t\t\t\t\tconst innerConnection =\n\t\t\t\t\t\t\t\t\t\tc.dependency instanceof HarmonyImportDependency &&\n\t\t\t\t\t\t\t\t\t\tmodules.has(otherModule);\n\t\t\t\t\t\t\t\t\treturn !innerConnection;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t// add concatenated module to the compilation\n\t\t\t\t\t\t\t\tcompilation.modules.add(newModule);\n\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbuild();\n\t\t\t\t\t\t},\n\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"create concatenated modules\");\n\t\t\t\t\t\t\tprocess.nextTick(callback.bind(null, err));\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {Module} module the module to be added\n\t * @param {RuntimeSpec} runtime the runtime scope\n\t * @returns {Set<Module>} the imported modules\n\t */\n\t_getImports(compilation, module, runtime) {\n\t\tconst moduleGraph = compilation.moduleGraph;\n\t\tconst set = new Set();\n\t\tfor (const dep of module.dependencies) {\n\t\t\t// Get reference info only for harmony Dependencies\n\t\t\tif (!(dep instanceof HarmonyImportDependency)) continue;\n\n\t\t\tconst connection = moduleGraph.getConnection(dep);\n\t\t\t// Reference is valid and has a module\n\t\t\tif (\n\t\t\t\t!connection ||\n\t\t\t\t!connection.module ||\n\t\t\t\t!connection.isTargetActive(runtime)\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst importedNames = compilation.getDependencyReferencedExports(\n\t\t\t\tdep,\n\t\t\t\tundefined\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\timportedNames.every(i =>\n\t\t\t\t\tArray.isArray(i) ? i.length > 0 : i.name.length > 0\n\t\t\t\t) ||\n\t\t\t\tArray.isArray(moduleGraph.getProvidedExports(module))\n\t\t\t) {\n\t\t\t\tset.add(connection.module);\n\t\t\t}\n\t\t}\n\t\treturn set;\n\t}\n\n\t/**\n\t * @param {Compilation} compilation webpack compilation\n\t * @param {ConcatConfiguration} config concat configuration (will be modified when added)\n\t * @param {Module} module the module to be added\n\t * @param {RuntimeSpec} runtime the runtime scope of the generated code\n\t * @param {RuntimeSpec} activeRuntime the runtime scope of the root module\n\t * @param {Set<Module>} possibleModules modules that are candidates\n\t * @param {Set<Module>} candidates list of potential candidates (will be added to)\n\t * @param {Map<Module, Module | function(RequestShortener): string>} failureCache cache for problematic modules to be more performant\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {boolean} avoidMutateOnFailure avoid mutating the config when adding fails\n\t * @param {Statistics} statistics gathering metrics\n\t * @returns {Module | function(RequestShortener): string} the problematic module\n\t */\n\t_tryToAdd(\n\t\tcompilation,\n\t\tconfig,\n\t\tmodule,\n\t\truntime,\n\t\tactiveRuntime,\n\t\tpossibleModules,\n\t\tcandidates,\n\t\tfailureCache,\n\t\tchunkGraph,\n\t\tavoidMutateOnFailure,\n\t\tstatistics\n\t) {\n\t\tconst cacheEntry = failureCache.get(module);\n\t\tif (cacheEntry) {\n\t\t\tstatistics.cached++;\n\t\t\treturn cacheEntry;\n\t\t}\n\n\t\t// Already added?\n\t\tif (config.has(module)) {\n\t\t\tstatistics.alreadyInConfig++;\n\t\t\treturn null;\n\t\t}\n\n\t\t// Not possible to add?\n\t\tif (!possibleModules.has(module)) {\n\t\t\tstatistics.invalidModule++;\n\t\t\tfailureCache.set(module, module); // cache failures for performance\n\t\t\treturn module;\n\t\t}\n\n\t\t// Module must be in the correct chunks\n\t\tconst missingChunks = Array.from(\n\t\t\tchunkGraph.getModuleChunksIterable(config.rootModule)\n\t\t).filter(chunk => !chunkGraph.isModuleInChunk(module, chunk));\n\t\tif (missingChunks.length > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst missingChunksList = Array.from(\n\t\t\t\t\tnew Set(missingChunks.map(chunk => chunk.name || \"unnamed chunk(s)\"))\n\t\t\t\t).sort();\n\t\t\t\tconst chunks = Array.from(\n\t\t\t\t\tnew Set(\n\t\t\t\t\t\tArray.from(chunkGraph.getModuleChunksIterable(module)).map(\n\t\t\t\t\t\t\tchunk => chunk.name || \"unnamed chunk(s)\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t).sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is not in the same chunk(s) (expected in chunk(s) ${missingChunksList.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}, module is in chunk(s) ${chunks.join(\", \")})`;\n\t\t\t};\n\t\t\tstatistics.incorrectChunks++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\tconst moduleGraph = compilation.moduleGraph;\n\n\t\tconst incomingConnections =\n\t\t\tmoduleGraph.getIncomingConnectionsByOriginModule(module);\n\n\t\tconst incomingConnectionsFromNonModules =\n\t\t\tincomingConnections.get(null) || incomingConnections.get(undefined);\n\t\tif (incomingConnectionsFromNonModules) {\n\t\t\tconst activeNonModulesConnections =\n\t\t\t\tincomingConnectionsFromNonModules.filter(connection => {\n\t\t\t\t\t// We are not interested in inactive connections\n\t\t\t\t\t// or connections without dependency\n\t\t\t\t\treturn connection.isActive(runtime);\n\t\t\t\t});\n\t\t\tif (activeNonModulesConnections.length > 0) {\n\t\t\t\tconst problem = requestShortener => {\n\t\t\t\t\tconst importingExplanations = new Set(\n\t\t\t\t\t\tactiveNonModulesConnections.map(c => c.explanation).filter(Boolean)\n\t\t\t\t\t);\n\t\t\t\t\tconst explanations = Array.from(importingExplanations).sort();\n\t\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)} is referenced ${\n\t\t\t\t\t\texplanations.length > 0\n\t\t\t\t\t\t\t? `by: ${explanations.join(\", \")}`\n\t\t\t\t\t\t\t: \"in an unsupported way\"\n\t\t\t\t\t}`;\n\t\t\t\t};\n\t\t\t\tstatistics.incorrectDependency++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\t\tconst incomingConnectionsFromModules = new Map();\n\t\tfor (const [originModule, connections] of incomingConnections) {\n\t\t\tif (originModule) {\n\t\t\t\t// Ignore connection from orphan modules\n\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(originModule) === 0) continue;\n\n\t\t\t\t// We don't care for connections from other runtimes\n\t\t\t\tlet originRuntime = undefined;\n\t\t\t\tfor (const r of chunkGraph.getModuleRuntimes(originModule)) {\n\t\t\t\t\toriginRuntime = mergeRuntimeOwned(originRuntime, r);\n\t\t\t\t}\n\n\t\t\t\tif (!intersectRuntime(runtime, originRuntime)) continue;\n\n\t\t\t\t// We are not interested in inactive connections\n\t\t\t\tconst activeConnections = connections.filter(connection =>\n\t\t\t\t\tconnection.isActive(runtime)\n\t\t\t\t);\n\t\t\t\tif (activeConnections.length > 0)\n\t\t\t\t\tincomingConnectionsFromModules.set(originModule, activeConnections);\n\t\t\t}\n\t\t}\n\n\t\tconst incomingModules = Array.from(incomingConnectionsFromModules.keys());\n\n\t\t// Module must be in the same chunks like the referencing module\n\t\tconst otherChunkModules = incomingModules.filter(originModule => {\n\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(\n\t\t\t\tconfig.rootModule\n\t\t\t)) {\n\t\t\t\tif (!chunkGraph.isModuleInChunk(originModule, chunk)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\tif (otherChunkModules.length > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst names = otherChunkModules\n\t\t\t\t\t.map(m => m.readableIdentifier(requestShortener))\n\t\t\t\t\t.sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is referenced from different chunks by these modules: ${names.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}`;\n\t\t\t};\n\t\t\tstatistics.incorrectChunksOfImporter++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\t/** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\t\tconst nonHarmonyConnections = new Map();\n\t\tfor (const [originModule, connections] of incomingConnectionsFromModules) {\n\t\t\tconst selected = connections.filter(\n\t\t\t\tconnection =>\n\t\t\t\t\t!connection.dependency ||\n\t\t\t\t\t!(connection.dependency instanceof HarmonyImportDependency)\n\t\t\t);\n\t\t\tif (selected.length > 0)\n\t\t\t\tnonHarmonyConnections.set(originModule, connections);\n\t\t}\n\t\tif (nonHarmonyConnections.size > 0) {\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst names = Array.from(nonHarmonyConnections)\n\t\t\t\t\t.map(([originModule, connections]) => {\n\t\t\t\t\t\treturn `${originModule.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)} (referenced with ${Array.from(\n\t\t\t\t\t\t\tnew Set(\n\t\t\t\t\t\t\t\tconnections\n\t\t\t\t\t\t\t\t\t.map(c => c.dependency && c.dependency.type)\n\t\t\t\t\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.sort()\n\t\t\t\t\t\t\t.join(\", \")})`;\n\t\t\t\t\t})\n\t\t\t\t\t.sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is referenced from these modules with unsupported syntax: ${names.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}`;\n\t\t\t};\n\t\t\tstatistics.incorrectModuleDependency++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\tif (runtime !== undefined && typeof runtime !== \"string\") {\n\t\t\t// Module must be consistently referenced in the same runtimes\n\t\t\t/** @type {{ originModule: Module, runtimeCondition: RuntimeSpec }[]} */\n\t\t\tconst otherRuntimeConnections = [];\n\t\t\touter: for (const [\n\t\t\t\toriginModule,\n\t\t\t\tconnections\n\t\t\t] of incomingConnectionsFromModules) {\n\t\t\t\t/** @type {false | RuntimeSpec} */\n\t\t\t\tlet currentRuntimeCondition = false;\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst runtimeCondition = filterRuntime(runtime, runtime => {\n\t\t\t\t\t\treturn connection.isTargetActive(runtime);\n\t\t\t\t\t});\n\t\t\t\t\tif (runtimeCondition === false) continue;\n\t\t\t\t\tif (runtimeCondition === true) continue outer;\n\t\t\t\t\tif (currentRuntimeCondition !== false) {\n\t\t\t\t\t\tcurrentRuntimeCondition = mergeRuntime(\n\t\t\t\t\t\t\tcurrentRuntimeCondition,\n\t\t\t\t\t\t\truntimeCondition\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrentRuntimeCondition = runtimeCondition;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentRuntimeCondition !== false) {\n\t\t\t\t\totherRuntimeConnections.push({\n\t\t\t\t\t\toriginModule,\n\t\t\t\t\t\truntimeCondition: currentRuntimeCondition\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (otherRuntimeConnections.length > 0) {\n\t\t\t\tconst problem = requestShortener => {\n\t\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)} is runtime-dependent referenced by these modules: ${Array.from(\n\t\t\t\t\t\totherRuntimeConnections,\n\t\t\t\t\t\t({ originModule, runtimeCondition }) =>\n\t\t\t\t\t\t\t`${originModule.readableIdentifier(\n\t\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t\t)} (expected runtime ${runtimeToString(\n\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t)}, module is only referenced in ${runtimeToString(\n\t\t\t\t\t\t\t\t/** @type {RuntimeSpec} */ (runtimeCondition)\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t).join(\", \")}`;\n\t\t\t\t};\n\t\t\t\tstatistics.incorrectRuntimeCondition++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\tlet backup;\n\t\tif (avoidMutateOnFailure) {\n\t\t\tbackup = config.snapshot();\n\t\t}\n\n\t\t// Add the module\n\t\tconfig.add(module);\n\n\t\tincomingModules.sort(compareModulesByIdentifier);\n\n\t\t// Every module which depends on the added module must be in the configuration too.\n\t\tfor (const originModule of incomingModules) {\n\t\t\tconst problem = this._tryToAdd(\n\t\t\t\tcompilation,\n\t\t\t\tconfig,\n\t\t\t\toriginModule,\n\t\t\t\truntime,\n\t\t\t\tactiveRuntime,\n\t\t\t\tpossibleModules,\n\t\t\t\tcandidates,\n\t\t\t\tfailureCache,\n\t\t\t\tchunkGraph,\n\t\t\t\tfalse,\n\t\t\t\tstatistics\n\t\t\t);\n\t\t\tif (problem) {\n\t\t\t\tif (backup !== undefined) config.rollback(backup);\n\t\t\t\tstatistics.importerFailed++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\t// Add imports to possible candidates list\n\t\tfor (const imp of this._getImports(compilation, module, runtime)) {\n\t\t\tcandidates.add(imp);\n\t\t}\n\t\tstatistics.added++;\n\t\treturn null;\n\t}\n}\n\nclass ConcatConfiguration {\n\t/**\n\t * @param {Module} rootModule the root module\n\t * @param {RuntimeSpec} runtime the runtime\n\t */\n\tconstructor(rootModule, runtime) {\n\t\tthis.rootModule = rootModule;\n\t\tthis.runtime = runtime;\n\t\t/** @type {Set<Module>} */\n\t\tthis.modules = new Set();\n\t\tthis.modules.add(rootModule);\n\t\t/** @type {Map<Module, Module | function(RequestShortener): string>} */\n\t\tthis.warnings = new Map();\n\t}\n\n\tadd(module) {\n\t\tthis.modules.add(module);\n\t}\n\n\thas(module) {\n\t\treturn this.modules.has(module);\n\t}\n\n\tisEmpty() {\n\t\treturn this.modules.size === 1;\n\t}\n\n\taddWarning(module, problem) {\n\t\tthis.warnings.set(module, problem);\n\t}\n\n\tgetWarningsSorted() {\n\t\treturn new Map(\n\t\t\tArray.from(this.warnings).sort((a, b) => {\n\t\t\t\tconst ai = a[0].identifier();\n\t\t\t\tconst bi = b[0].identifier();\n\t\t\t\tif (ai < bi) return -1;\n\t\t\t\tif (ai > bi) return 1;\n\t\t\t\treturn 0;\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * @returns {Set<Module>} modules as set\n\t */\n\tgetModules() {\n\t\treturn this.modules;\n\t}\n\n\tsnapshot() {\n\t\treturn this.modules.size;\n\t}\n\n\trollback(snapshot) {\n\t\tconst modules = this.modules;\n\t\tfor (const m of modules) {\n\t\t\tif (snapshot === 0) {\n\t\t\t\tmodules.delete(m);\n\t\t\t} else {\n\t\t\t\tsnapshot--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = ModuleConcatenationPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}