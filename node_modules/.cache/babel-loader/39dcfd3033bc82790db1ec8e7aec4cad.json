{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  SyncHook\n} = require(\"tapable\");\n/**\n * @typedef {Object} RuleCondition\n * @property {string | string[]} property\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} Condition\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {RuleCondition[]} conditions\n * @property {(Effect|function(object): Effect[])[]} effects\n * @property {CompiledRule[]=} rules\n * @property {CompiledRule[]=} oneOf\n */\n\n/**\n * @typedef {Object} Effect\n * @property {string} type\n * @property {any} value\n */\n\n/**\n * @typedef {Object} RuleSet\n * @property {Map<string, any>} references map of references in the rule set (may grow over time)\n * @property {function(object): Effect[]} exec execute the rule set\n */\n\n\nclass RuleSetCompiler {\n  constructor(plugins) {\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[string, object, Set<string>, CompiledRule, Map<string, any>]>} */\n      rule: new SyncHook([\"path\", \"rule\", \"unhandledProperties\", \"compiledRule\", \"references\"])\n    });\n\n    if (plugins) {\n      for (const plugin of plugins) {\n        plugin.apply(this);\n      }\n    }\n  }\n  /**\n   * @param {object[]} ruleSet raw user provided rules\n   * @returns {RuleSet} compiled RuleSet\n   */\n\n\n  compile(ruleSet) {\n    const refs = new Map();\n    const rules = this.compileRules(\"ruleSet\", ruleSet, refs);\n    /**\n     * @param {object} data data passed in\n     * @param {CompiledRule} rule the compiled rule\n     * @param {Effect[]} effects an array where effects are pushed to\n     * @returns {boolean} true, if the rule has matched\n     */\n\n    const execRule = (data, rule, effects) => {\n      for (const condition of rule.conditions) {\n        const p = condition.property;\n\n        if (Array.isArray(p)) {\n          let current = data;\n\n          for (const subProperty of p) {\n            if (current && typeof current === \"object\" && Object.prototype.hasOwnProperty.call(current, subProperty)) {\n              current = current[subProperty];\n            } else {\n              current = undefined;\n              break;\n            }\n          }\n\n          if (current !== undefined) {\n            if (!condition.fn(current)) return false;\n            continue;\n          }\n        } else if (p in data) {\n          const value = data[p];\n\n          if (value !== undefined) {\n            if (!condition.fn(value)) return false;\n            continue;\n          }\n        }\n\n        if (!condition.matchWhenEmpty) {\n          return false;\n        }\n      }\n\n      for (const effect of rule.effects) {\n        if (typeof effect === \"function\") {\n          const returnedEffects = effect(data);\n\n          for (const effect of returnedEffects) {\n            effects.push(effect);\n          }\n        } else {\n          effects.push(effect);\n        }\n      }\n\n      if (rule.rules) {\n        for (const childRule of rule.rules) {\n          execRule(data, childRule, effects);\n        }\n      }\n\n      if (rule.oneOf) {\n        for (const childRule of rule.oneOf) {\n          if (execRule(data, childRule, effects)) {\n            break;\n          }\n        }\n      }\n\n      return true;\n    };\n\n    return {\n      references: refs,\n      exec: data => {\n        /** @type {Effect[]} */\n        const effects = [];\n\n        for (const rule of rules) {\n          execRule(data, rule, effects);\n        }\n\n        return effects;\n      }\n    };\n  }\n  /**\n   * @param {string} path current path\n   * @param {object[]} rules the raw rules provided by user\n   * @param {Map<string, any>} refs references\n   * @returns {CompiledRule[]} rules\n   */\n\n\n  compileRules(path, rules, refs) {\n    return rules.map((rule, i) => this.compileRule(`${path}[${i}]`, rule, refs));\n  }\n  /**\n   * @param {string} path current path\n   * @param {object} rule the raw rule provided by user\n   * @param {Map<string, any>} refs references\n   * @returns {CompiledRule} normalized and compiled rule for processing\n   */\n\n\n  compileRule(path, rule, refs) {\n    const unhandledProperties = new Set(Object.keys(rule).filter(key => rule[key] !== undefined));\n    /** @type {CompiledRule} */\n\n    const compiledRule = {\n      conditions: [],\n      effects: [],\n      rules: undefined,\n      oneOf: undefined\n    };\n    this.hooks.rule.call(path, rule, unhandledProperties, compiledRule, refs);\n\n    if (unhandledProperties.has(\"rules\")) {\n      unhandledProperties.delete(\"rules\");\n      const rules = rule.rules;\n      if (!Array.isArray(rules)) throw this.error(path, rules, \"Rule.rules must be an array of rules\");\n      compiledRule.rules = this.compileRules(`${path}.rules`, rules, refs);\n    }\n\n    if (unhandledProperties.has(\"oneOf\")) {\n      unhandledProperties.delete(\"oneOf\");\n      const oneOf = rule.oneOf;\n      if (!Array.isArray(oneOf)) throw this.error(path, oneOf, \"Rule.oneOf must be an array of rules\");\n      compiledRule.oneOf = this.compileRules(`${path}.oneOf`, oneOf, refs);\n    }\n\n    if (unhandledProperties.size > 0) {\n      throw this.error(path, rule, `Properties ${Array.from(unhandledProperties).join(\", \")} are unknown`);\n    }\n\n    return compiledRule;\n  }\n  /**\n   * @param {string} path current path\n   * @param {any} condition user provided condition value\n   * @returns {Condition} compiled condition\n   */\n\n\n  compileCondition(path, condition) {\n    if (condition === \"\") {\n      return {\n        matchWhenEmpty: true,\n        fn: str => str === \"\"\n      };\n    }\n\n    if (!condition) {\n      throw this.error(path, condition, \"Expected condition but got falsy value\");\n    }\n\n    if (typeof condition === \"string\") {\n      return {\n        matchWhenEmpty: condition.length === 0,\n        fn: str => typeof str === \"string\" && str.startsWith(condition)\n      };\n    }\n\n    if (typeof condition === \"function\") {\n      try {\n        return {\n          matchWhenEmpty: condition(\"\"),\n          fn: condition\n        };\n      } catch (err) {\n        throw this.error(path, condition, \"Evaluation of condition function threw error\");\n      }\n    }\n\n    if (condition instanceof RegExp) {\n      return {\n        matchWhenEmpty: condition.test(\"\"),\n        fn: v => typeof v === \"string\" && condition.test(v)\n      };\n    }\n\n    if (Array.isArray(condition)) {\n      const items = condition.map((c, i) => this.compileCondition(`${path}[${i}]`, c));\n      return this.combineConditionsOr(items);\n    }\n\n    if (typeof condition !== \"object\") {\n      throw this.error(path, condition, `Unexpected ${typeof condition} when condition was expected`);\n    }\n\n    const conditions = [];\n\n    for (const key of Object.keys(condition)) {\n      const value = condition[key];\n\n      switch (key) {\n        case \"or\":\n          if (value) {\n            if (!Array.isArray(value)) {\n              throw this.error(`${path}.or`, condition.and, \"Expected array of conditions\");\n            }\n\n            conditions.push(this.compileCondition(`${path}.or`, value));\n          }\n\n          break;\n\n        case \"and\":\n          if (value) {\n            if (!Array.isArray(value)) {\n              throw this.error(`${path}.and`, condition.and, \"Expected array of conditions\");\n            }\n\n            let i = 0;\n\n            for (const item of value) {\n              conditions.push(this.compileCondition(`${path}.and[${i}]`, item));\n              i++;\n            }\n          }\n\n          break;\n\n        case \"not\":\n          if (value) {\n            const matcher = this.compileCondition(`${path}.not`, value);\n            const fn = matcher.fn;\n            conditions.push({\n              matchWhenEmpty: !matcher.matchWhenEmpty,\n              fn: v => !fn(v)\n            });\n          }\n\n          break;\n\n        default:\n          throw this.error(`${path}.${key}`, condition[key], `Unexpected property ${key} in condition`);\n      }\n    }\n\n    if (conditions.length === 0) {\n      throw this.error(path, condition, \"Expected condition, but got empty thing\");\n    }\n\n    return this.combineConditionsAnd(conditions);\n  }\n  /**\n   * @param {Condition[]} conditions some conditions\n   * @returns {Condition} merged condition\n   */\n\n\n  combineConditionsOr(conditions) {\n    if (conditions.length === 0) {\n      return {\n        matchWhenEmpty: false,\n        fn: () => false\n      };\n    } else if (conditions.length === 1) {\n      return conditions[0];\n    } else {\n      return {\n        matchWhenEmpty: conditions.some(c => c.matchWhenEmpty),\n        fn: v => conditions.some(c => c.fn(v))\n      };\n    }\n  }\n  /**\n   * @param {Condition[]} conditions some conditions\n   * @returns {Condition} merged condition\n   */\n\n\n  combineConditionsAnd(conditions) {\n    if (conditions.length === 0) {\n      return {\n        matchWhenEmpty: false,\n        fn: () => false\n      };\n    } else if (conditions.length === 1) {\n      return conditions[0];\n    } else {\n      return {\n        matchWhenEmpty: conditions.every(c => c.matchWhenEmpty),\n        fn: v => conditions.every(c => c.fn(v))\n      };\n    }\n  }\n  /**\n   * @param {string} path current path\n   * @param {any} value value at the error location\n   * @param {string} message message explaining the problem\n   * @returns {Error} an error object\n   */\n\n\n  error(path, value, message) {\n    return new Error(`Compiling RuleSet failed: ${message} (at ${path}: ${value})`);\n  }\n\n}\n\nmodule.exports = RuleSetCompiler;","map":{"version":3,"names":["SyncHook","require","RuleSetCompiler","constructor","plugins","hooks","Object","freeze","rule","plugin","apply","compile","ruleSet","refs","Map","rules","compileRules","execRule","data","effects","condition","conditions","p","property","Array","isArray","current","subProperty","prototype","hasOwnProperty","call","undefined","fn","value","matchWhenEmpty","effect","returnedEffects","push","childRule","oneOf","references","exec","path","map","i","compileRule","unhandledProperties","Set","keys","filter","key","compiledRule","has","delete","error","size","from","join","compileCondition","str","length","startsWith","err","RegExp","test","v","items","c","combineConditionsOr","and","item","matcher","combineConditionsAnd","some","every","message","Error","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/rules/RuleSetCompiler.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncHook } = require(\"tapable\");\n\n/**\n * @typedef {Object} RuleCondition\n * @property {string | string[]} property\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} Condition\n * @property {boolean} matchWhenEmpty\n * @property {function(string): boolean} fn\n */\n\n/**\n * @typedef {Object} CompiledRule\n * @property {RuleCondition[]} conditions\n * @property {(Effect|function(object): Effect[])[]} effects\n * @property {CompiledRule[]=} rules\n * @property {CompiledRule[]=} oneOf\n */\n\n/**\n * @typedef {Object} Effect\n * @property {string} type\n * @property {any} value\n */\n\n/**\n * @typedef {Object} RuleSet\n * @property {Map<string, any>} references map of references in the rule set (may grow over time)\n * @property {function(object): Effect[]} exec execute the rule set\n */\n\nclass RuleSetCompiler {\n\tconstructor(plugins) {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[string, object, Set<string>, CompiledRule, Map<string, any>]>} */\n\t\t\trule: new SyncHook([\n\t\t\t\t\"path\",\n\t\t\t\t\"rule\",\n\t\t\t\t\"unhandledProperties\",\n\t\t\t\t\"compiledRule\",\n\t\t\t\t\"references\"\n\t\t\t])\n\t\t});\n\t\tif (plugins) {\n\t\t\tfor (const plugin of plugins) {\n\t\t\t\tplugin.apply(this);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {object[]} ruleSet raw user provided rules\n\t * @returns {RuleSet} compiled RuleSet\n\t */\n\tcompile(ruleSet) {\n\t\tconst refs = new Map();\n\t\tconst rules = this.compileRules(\"ruleSet\", ruleSet, refs);\n\n\t\t/**\n\t\t * @param {object} data data passed in\n\t\t * @param {CompiledRule} rule the compiled rule\n\t\t * @param {Effect[]} effects an array where effects are pushed to\n\t\t * @returns {boolean} true, if the rule has matched\n\t\t */\n\t\tconst execRule = (data, rule, effects) => {\n\t\t\tfor (const condition of rule.conditions) {\n\t\t\t\tconst p = condition.property;\n\t\t\t\tif (Array.isArray(p)) {\n\t\t\t\t\tlet current = data;\n\t\t\t\t\tfor (const subProperty of p) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcurrent &&\n\t\t\t\t\t\t\ttypeof current === \"object\" &&\n\t\t\t\t\t\t\tObject.prototype.hasOwnProperty.call(current, subProperty)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcurrent = current[subProperty];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrent = undefined;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (current !== undefined) {\n\t\t\t\t\t\tif (!condition.fn(current)) return false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (p in data) {\n\t\t\t\t\tconst value = data[p];\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\tif (!condition.fn(value)) return false;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!condition.matchWhenEmpty) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const effect of rule.effects) {\n\t\t\t\tif (typeof effect === \"function\") {\n\t\t\t\t\tconst returnedEffects = effect(data);\n\t\t\t\t\tfor (const effect of returnedEffects) {\n\t\t\t\t\t\teffects.push(effect);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teffects.push(effect);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rule.rules) {\n\t\t\t\tfor (const childRule of rule.rules) {\n\t\t\t\t\texecRule(data, childRule, effects);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rule.oneOf) {\n\t\t\t\tfor (const childRule of rule.oneOf) {\n\t\t\t\t\tif (execRule(data, childRule, effects)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\treturn {\n\t\t\treferences: refs,\n\t\t\texec: data => {\n\t\t\t\t/** @type {Effect[]} */\n\t\t\t\tconst effects = [];\n\t\t\t\tfor (const rule of rules) {\n\t\t\t\t\texecRule(data, rule, effects);\n\t\t\t\t}\n\t\t\t\treturn effects;\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {object[]} rules the raw rules provided by user\n\t * @param {Map<string, any>} refs references\n\t * @returns {CompiledRule[]} rules\n\t */\n\tcompileRules(path, rules, refs) {\n\t\treturn rules.map((rule, i) =>\n\t\t\tthis.compileRule(`${path}[${i}]`, rule, refs)\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {object} rule the raw rule provided by user\n\t * @param {Map<string, any>} refs references\n\t * @returns {CompiledRule} normalized and compiled rule for processing\n\t */\n\tcompileRule(path, rule, refs) {\n\t\tconst unhandledProperties = new Set(\n\t\t\tObject.keys(rule).filter(key => rule[key] !== undefined)\n\t\t);\n\n\t\t/** @type {CompiledRule} */\n\t\tconst compiledRule = {\n\t\t\tconditions: [],\n\t\t\teffects: [],\n\t\t\trules: undefined,\n\t\t\toneOf: undefined\n\t\t};\n\n\t\tthis.hooks.rule.call(path, rule, unhandledProperties, compiledRule, refs);\n\n\t\tif (unhandledProperties.has(\"rules\")) {\n\t\t\tunhandledProperties.delete(\"rules\");\n\t\t\tconst rules = rule.rules;\n\t\t\tif (!Array.isArray(rules))\n\t\t\t\tthrow this.error(path, rules, \"Rule.rules must be an array of rules\");\n\t\t\tcompiledRule.rules = this.compileRules(`${path}.rules`, rules, refs);\n\t\t}\n\n\t\tif (unhandledProperties.has(\"oneOf\")) {\n\t\t\tunhandledProperties.delete(\"oneOf\");\n\t\t\tconst oneOf = rule.oneOf;\n\t\t\tif (!Array.isArray(oneOf))\n\t\t\t\tthrow this.error(path, oneOf, \"Rule.oneOf must be an array of rules\");\n\t\t\tcompiledRule.oneOf = this.compileRules(`${path}.oneOf`, oneOf, refs);\n\t\t}\n\n\t\tif (unhandledProperties.size > 0) {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\trule,\n\t\t\t\t`Properties ${Array.from(unhandledProperties).join(\", \")} are unknown`\n\t\t\t);\n\t\t}\n\n\t\treturn compiledRule;\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {any} condition user provided condition value\n\t * @returns {Condition} compiled condition\n\t */\n\tcompileCondition(path, condition) {\n\t\tif (condition === \"\") {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: true,\n\t\t\t\tfn: str => str === \"\"\n\t\t\t};\n\t\t}\n\t\tif (!condition) {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\tcondition,\n\t\t\t\t\"Expected condition but got falsy value\"\n\t\t\t);\n\t\t}\n\t\tif (typeof condition === \"string\") {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: condition.length === 0,\n\t\t\t\tfn: str => typeof str === \"string\" && str.startsWith(condition)\n\t\t\t};\n\t\t}\n\t\tif (typeof condition === \"function\") {\n\t\t\ttry {\n\t\t\t\treturn {\n\t\t\t\t\tmatchWhenEmpty: condition(\"\"),\n\t\t\t\t\tfn: condition\n\t\t\t\t};\n\t\t\t} catch (err) {\n\t\t\t\tthrow this.error(\n\t\t\t\t\tpath,\n\t\t\t\t\tcondition,\n\t\t\t\t\t\"Evaluation of condition function threw error\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (condition instanceof RegExp) {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: condition.test(\"\"),\n\t\t\t\tfn: v => typeof v === \"string\" && condition.test(v)\n\t\t\t};\n\t\t}\n\t\tif (Array.isArray(condition)) {\n\t\t\tconst items = condition.map((c, i) =>\n\t\t\t\tthis.compileCondition(`${path}[${i}]`, c)\n\t\t\t);\n\t\t\treturn this.combineConditionsOr(items);\n\t\t}\n\n\t\tif (typeof condition !== \"object\") {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\tcondition,\n\t\t\t\t`Unexpected ${typeof condition} when condition was expected`\n\t\t\t);\n\t\t}\n\n\t\tconst conditions = [];\n\t\tfor (const key of Object.keys(condition)) {\n\t\t\tconst value = condition[key];\n\t\t\tswitch (key) {\n\t\t\t\tcase \"or\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\tthrow this.error(\n\t\t\t\t\t\t\t\t`${path}.or`,\n\t\t\t\t\t\t\t\tcondition.and,\n\t\t\t\t\t\t\t\t\"Expected array of conditions\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconditions.push(this.compileCondition(`${path}.or`, value));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"and\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\tthrow this.error(\n\t\t\t\t\t\t\t\t`${path}.and`,\n\t\t\t\t\t\t\t\tcondition.and,\n\t\t\t\t\t\t\t\t\"Expected array of conditions\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\tfor (const item of value) {\n\t\t\t\t\t\t\tconditions.push(this.compileCondition(`${path}.and[${i}]`, item));\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"not\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tconst matcher = this.compileCondition(`${path}.not`, value);\n\t\t\t\t\t\tconst fn = matcher.fn;\n\t\t\t\t\t\tconditions.push({\n\t\t\t\t\t\t\tmatchWhenEmpty: !matcher.matchWhenEmpty,\n\t\t\t\t\t\t\tfn: v => !fn(v)\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow this.error(\n\t\t\t\t\t\t`${path}.${key}`,\n\t\t\t\t\t\tcondition[key],\n\t\t\t\t\t\t`Unexpected property ${key} in condition`\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tif (conditions.length === 0) {\n\t\t\tthrow this.error(\n\t\t\t\tpath,\n\t\t\t\tcondition,\n\t\t\t\t\"Expected condition, but got empty thing\"\n\t\t\t);\n\t\t}\n\t\treturn this.combineConditionsAnd(conditions);\n\t}\n\n\t/**\n\t * @param {Condition[]} conditions some conditions\n\t * @returns {Condition} merged condition\n\t */\n\tcombineConditionsOr(conditions) {\n\t\tif (conditions.length === 0) {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: false,\n\t\t\t\tfn: () => false\n\t\t\t};\n\t\t} else if (conditions.length === 1) {\n\t\t\treturn conditions[0];\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: conditions.some(c => c.matchWhenEmpty),\n\t\t\t\tfn: v => conditions.some(c => c.fn(v))\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {Condition[]} conditions some conditions\n\t * @returns {Condition} merged condition\n\t */\n\tcombineConditionsAnd(conditions) {\n\t\tif (conditions.length === 0) {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: false,\n\t\t\t\tfn: () => false\n\t\t\t};\n\t\t} else if (conditions.length === 1) {\n\t\t\treturn conditions[0];\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tmatchWhenEmpty: conditions.every(c => c.matchWhenEmpty),\n\t\t\t\tfn: v => conditions.every(c => c.fn(v))\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} path current path\n\t * @param {any} value value at the error location\n\t * @param {string} message message explaining the problem\n\t * @returns {Error} an error object\n\t */\n\terror(path, value, message) {\n\t\treturn new Error(\n\t\t\t`Compiling RuleSet failed: ${message} (at ${path}: ${value})`\n\t\t);\n\t}\n}\n\nmodule.exports = RuleSetCompiler;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}