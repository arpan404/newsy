{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst LazySet = require(\"../util/LazySet\");\n\nconst makeSerializable = require(\"../util/makeSerializable\");\n/** @typedef {import(\"enhanced-resolve/lib/Resolver\")} Resolver */\n\n/** @typedef {import(\"../CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../FileSystemInfo\")} FileSystemInfo */\n\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n\n\nclass CacheEntry {\n  constructor(result, snapshot) {\n    this.result = result;\n    this.snapshot = snapshot;\n  }\n\n  serialize(_ref) {\n    let {\n      write\n    } = _ref;\n    write(this.result);\n    write(this.snapshot);\n  }\n\n  deserialize(_ref2) {\n    let {\n      read\n    } = _ref2;\n    this.result = read();\n    this.snapshot = read();\n  }\n\n}\n\nmakeSerializable(CacheEntry, \"webpack/lib/cache/ResolverCachePlugin\");\n/**\n * @template T\n * @param {Set<T> | LazySet<T>} set set to add items to\n * @param {Set<T> | LazySet<T>} otherSet set to add items from\n * @returns {void}\n */\n\nconst addAllToSet = (set, otherSet) => {\n  if (set instanceof LazySet) {\n    set.addAll(otherSet);\n  } else {\n    for (const item of otherSet) {\n      set.add(item);\n    }\n  }\n};\n/**\n * @param {Object} object an object\n * @param {boolean} excludeContext if true, context is not included in string\n * @returns {string} stringified version\n */\n\n\nconst objectToString = (object, excludeContext) => {\n  let str = \"\";\n\n  for (const key in object) {\n    if (excludeContext && key === \"context\") continue;\n    const value = object[key];\n\n    if (typeof value === \"object\" && value !== null) {\n      str += `|${key}=[${objectToString(value, false)}|]`;\n    } else {\n      str += `|${key}=|${value}`;\n    }\n  }\n\n  return str;\n};\n\nclass ResolverCachePlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const cache = compiler.getCache(\"ResolverCachePlugin\");\n    /** @type {FileSystemInfo} */\n\n    let fileSystemInfo;\n    let snapshotOptions;\n    let realResolves = 0;\n    let cachedResolves = 0;\n    let cacheInvalidResolves = 0;\n    let concurrentResolves = 0;\n    compiler.hooks.thisCompilation.tap(\"ResolverCachePlugin\", compilation => {\n      snapshotOptions = compilation.options.snapshot.resolve;\n      fileSystemInfo = compilation.fileSystemInfo;\n      compilation.hooks.finishModules.tap(\"ResolverCachePlugin\", () => {\n        if (realResolves + cachedResolves > 0) {\n          const logger = compilation.getLogger(\"webpack.ResolverCachePlugin\");\n          logger.log(`${Math.round(100 * realResolves / (realResolves + cachedResolves))}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`);\n          realResolves = 0;\n          cachedResolves = 0;\n          cacheInvalidResolves = 0;\n          concurrentResolves = 0;\n        }\n      });\n    });\n    /**\n     * @param {ItemCacheFacade} itemCache cache\n     * @param {Resolver} resolver the resolver\n     * @param {Object} resolveContext context for resolving meta info\n     * @param {Object} request the request info object\n     * @param {function((Error | null)=, Object=): void} callback callback function\n     * @returns {void}\n     */\n\n    const doRealResolve = (itemCache, resolver, resolveContext, request, callback) => {\n      realResolves++;\n      const newRequest = {\n        _ResolverCachePluginCacheMiss: true,\n        ...request\n      };\n      const newResolveContext = { ...resolveContext,\n        stack: new Set(),\n        missingDependencies: new LazySet(),\n        fileDependencies: new LazySet(),\n        contextDependencies: new LazySet()\n      };\n      let yieldResult;\n      let withYield = false;\n\n      if (typeof newResolveContext.yield === \"function\") {\n        yieldResult = [];\n        withYield = true;\n\n        newResolveContext.yield = obj => yieldResult.push(obj);\n      }\n\n      const propagate = key => {\n        if (resolveContext[key]) {\n          addAllToSet(resolveContext[key], newResolveContext[key]);\n        }\n      };\n\n      const resolveTime = Date.now();\n      resolver.doResolve(resolver.hooks.resolve, newRequest, \"Cache miss\", newResolveContext, (err, result) => {\n        propagate(\"fileDependencies\");\n        propagate(\"contextDependencies\");\n        propagate(\"missingDependencies\");\n        if (err) return callback(err);\n        const fileDependencies = newResolveContext.fileDependencies;\n        const contextDependencies = newResolveContext.contextDependencies;\n        const missingDependencies = newResolveContext.missingDependencies;\n        fileSystemInfo.createSnapshot(resolveTime, fileDependencies, contextDependencies, missingDependencies, snapshotOptions, (err, snapshot) => {\n          if (err) return callback(err);\n          const resolveResult = withYield ? yieldResult : result; // since we intercept resolve hook\n          // we still can get result in callback\n\n          if (withYield && result) yieldResult.push(result);\n\n          if (!snapshot) {\n            if (resolveResult) return callback(null, resolveResult);\n            return callback();\n          }\n\n          itemCache.store(new CacheEntry(resolveResult, snapshot), storeErr => {\n            if (storeErr) return callback(storeErr);\n            if (resolveResult) return callback(null, resolveResult);\n            callback();\n          });\n        });\n      });\n    };\n\n    compiler.resolverFactory.hooks.resolver.intercept({\n      factory(type, hook) {\n        /** @type {Map<string, (function(Error=, Object=): void)[]>} */\n        const activeRequests = new Map();\n        /** @type {Map<string, [function(Error=, Object=): void, function(Error=, Object=): void][]>} */\n\n        const activeRequestsWithYield = new Map();\n        hook.tap(\"ResolverCachePlugin\",\n        /**\n         * @param {Resolver} resolver the resolver\n         * @param {Object} options resolve options\n         * @param {Object} userOptions resolve options passed by the user\n         * @returns {void}\n         */\n        (resolver, options, userOptions) => {\n          if (options.cache !== true) return;\n          const optionsIdent = objectToString(userOptions, false);\n          const cacheWithContext = options.cacheWithContext !== undefined ? options.cacheWithContext : false;\n          resolver.hooks.resolve.tapAsync({\n            name: \"ResolverCachePlugin\",\n            stage: -100\n          }, (request, resolveContext, callback) => {\n            if (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {\n              return callback();\n            }\n\n            const withYield = typeof resolveContext.yield === \"function\";\n            const identifier = `${type}${withYield ? \"|yield\" : \"|default\"}${optionsIdent}${objectToString(request, !cacheWithContext)}`;\n\n            if (withYield) {\n              const activeRequest = activeRequestsWithYield.get(identifier);\n\n              if (activeRequest) {\n                activeRequest[0].push(callback);\n                activeRequest[1].push(resolveContext.yield);\n                return;\n              }\n            } else {\n              const activeRequest = activeRequests.get(identifier);\n\n              if (activeRequest) {\n                activeRequest.push(callback);\n                return;\n              }\n            }\n\n            const itemCache = cache.getItemCache(identifier, null);\n            let callbacks, yields;\n            const done = withYield ? (err, result) => {\n              if (callbacks === undefined) {\n                if (err) {\n                  callback(err);\n                } else {\n                  if (result) for (const r of result) resolveContext.yield(r);\n                  callback(null, null);\n                }\n\n                yields = undefined;\n                callbacks = false;\n              } else {\n                if (err) {\n                  for (const cb of callbacks) cb(err);\n                } else {\n                  for (let i = 0; i < callbacks.length; i++) {\n                    const cb = callbacks[i];\n                    const yield_ = yields[i];\n                    if (result) for (const r of result) yield_(r);\n                    cb(null, null);\n                  }\n                }\n\n                activeRequestsWithYield.delete(identifier);\n                yields = undefined;\n                callbacks = false;\n              }\n            } : (err, result) => {\n              if (callbacks === undefined) {\n                callback(err, result);\n                callbacks = false;\n              } else {\n                for (const callback of callbacks) {\n                  callback(err, result);\n                }\n\n                activeRequests.delete(identifier);\n                callbacks = false;\n              }\n            };\n            /**\n             * @param {Error=} err error if any\n             * @param {CacheEntry=} cacheEntry cache entry\n             * @returns {void}\n             */\n\n            const processCacheResult = (err, cacheEntry) => {\n              if (err) return done(err);\n\n              if (cacheEntry) {\n                const {\n                  snapshot,\n                  result\n                } = cacheEntry;\n                fileSystemInfo.checkSnapshotValid(snapshot, (err, valid) => {\n                  if (err || !valid) {\n                    cacheInvalidResolves++;\n                    return doRealResolve(itemCache, resolver, resolveContext, request, done);\n                  }\n\n                  cachedResolves++;\n\n                  if (resolveContext.missingDependencies) {\n                    addAllToSet(resolveContext.missingDependencies, snapshot.getMissingIterable());\n                  }\n\n                  if (resolveContext.fileDependencies) {\n                    addAllToSet(resolveContext.fileDependencies, snapshot.getFileIterable());\n                  }\n\n                  if (resolveContext.contextDependencies) {\n                    addAllToSet(resolveContext.contextDependencies, snapshot.getContextIterable());\n                  }\n\n                  done(null, result);\n                });\n              } else {\n                doRealResolve(itemCache, resolver, resolveContext, request, done);\n              }\n            };\n\n            itemCache.get(processCacheResult);\n\n            if (withYield && callbacks === undefined) {\n              callbacks = [callback];\n              yields = [resolveContext.yield];\n              activeRequestsWithYield.set(identifier,\n              /** @type {[any, any]} */\n              [callbacks, yields]);\n            } else if (callbacks === undefined) {\n              callbacks = [callback];\n              activeRequests.set(identifier, callbacks);\n            }\n          });\n        });\n        return hook;\n      }\n\n    });\n  }\n\n}\n\nmodule.exports = ResolverCachePlugin;","map":{"version":3,"names":["LazySet","require","makeSerializable","CacheEntry","constructor","result","snapshot","serialize","write","deserialize","read","addAllToSet","set","otherSet","addAll","item","add","objectToString","object","excludeContext","str","key","value","ResolverCachePlugin","apply","compiler","cache","getCache","fileSystemInfo","snapshotOptions","realResolves","cachedResolves","cacheInvalidResolves","concurrentResolves","hooks","thisCompilation","tap","compilation","options","resolve","finishModules","logger","getLogger","log","Math","round","doRealResolve","itemCache","resolver","resolveContext","request","callback","newRequest","_ResolverCachePluginCacheMiss","newResolveContext","stack","Set","missingDependencies","fileDependencies","contextDependencies","yieldResult","withYield","yield","obj","push","propagate","resolveTime","Date","now","doResolve","err","createSnapshot","resolveResult","store","storeErr","resolverFactory","intercept","factory","type","hook","activeRequests","Map","activeRequestsWithYield","userOptions","optionsIdent","cacheWithContext","undefined","tapAsync","name","stage","identifier","activeRequest","get","getItemCache","callbacks","yields","done","r","cb","i","length","yield_","delete","processCacheResult","cacheEntry","checkSnapshotValid","valid","getMissingIterable","getFileIterable","getContextIterable","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/cache/ResolverCachePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst LazySet = require(\"../util/LazySet\");\nconst makeSerializable = require(\"../util/makeSerializable\");\n\n/** @typedef {import(\"enhanced-resolve/lib/Resolver\")} Resolver */\n/** @typedef {import(\"../CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\")} FileSystemInfo */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n\nclass CacheEntry {\n\tconstructor(result, snapshot) {\n\t\tthis.result = result;\n\t\tthis.snapshot = snapshot;\n\t}\n\n\tserialize({ write }) {\n\t\twrite(this.result);\n\t\twrite(this.snapshot);\n\t}\n\n\tdeserialize({ read }) {\n\t\tthis.result = read();\n\t\tthis.snapshot = read();\n\t}\n}\n\nmakeSerializable(CacheEntry, \"webpack/lib/cache/ResolverCachePlugin\");\n\n/**\n * @template T\n * @param {Set<T> | LazySet<T>} set set to add items to\n * @param {Set<T> | LazySet<T>} otherSet set to add items from\n * @returns {void}\n */\nconst addAllToSet = (set, otherSet) => {\n\tif (set instanceof LazySet) {\n\t\tset.addAll(otherSet);\n\t} else {\n\t\tfor (const item of otherSet) {\n\t\t\tset.add(item);\n\t\t}\n\t}\n};\n\n/**\n * @param {Object} object an object\n * @param {boolean} excludeContext if true, context is not included in string\n * @returns {string} stringified version\n */\nconst objectToString = (object, excludeContext) => {\n\tlet str = \"\";\n\tfor (const key in object) {\n\t\tif (excludeContext && key === \"context\") continue;\n\t\tconst value = object[key];\n\t\tif (typeof value === \"object\" && value !== null) {\n\t\t\tstr += `|${key}=[${objectToString(value, false)}|]`;\n\t\t} else {\n\t\t\tstr += `|${key}=|${value}`;\n\t\t}\n\t}\n\treturn str;\n};\n\nclass ResolverCachePlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst cache = compiler.getCache(\"ResolverCachePlugin\");\n\t\t/** @type {FileSystemInfo} */\n\t\tlet fileSystemInfo;\n\t\tlet snapshotOptions;\n\t\tlet realResolves = 0;\n\t\tlet cachedResolves = 0;\n\t\tlet cacheInvalidResolves = 0;\n\t\tlet concurrentResolves = 0;\n\t\tcompiler.hooks.thisCompilation.tap(\"ResolverCachePlugin\", compilation => {\n\t\t\tsnapshotOptions = compilation.options.snapshot.resolve;\n\t\t\tfileSystemInfo = compilation.fileSystemInfo;\n\t\t\tcompilation.hooks.finishModules.tap(\"ResolverCachePlugin\", () => {\n\t\t\t\tif (realResolves + cachedResolves > 0) {\n\t\t\t\t\tconst logger = compilation.getLogger(\"webpack.ResolverCachePlugin\");\n\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t`${Math.round(\n\t\t\t\t\t\t\t(100 * realResolves) / (realResolves + cachedResolves)\n\t\t\t\t\t\t)}% really resolved (${realResolves} real resolves with ${cacheInvalidResolves} cached but invalid, ${cachedResolves} cached valid, ${concurrentResolves} concurrent)`\n\t\t\t\t\t);\n\t\t\t\t\trealResolves = 0;\n\t\t\t\t\tcachedResolves = 0;\n\t\t\t\t\tcacheInvalidResolves = 0;\n\t\t\t\t\tconcurrentResolves = 0;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t/**\n\t\t * @param {ItemCacheFacade} itemCache cache\n\t\t * @param {Resolver} resolver the resolver\n\t\t * @param {Object} resolveContext context for resolving meta info\n\t\t * @param {Object} request the request info object\n\t\t * @param {function((Error | null)=, Object=): void} callback callback function\n\t\t * @returns {void}\n\t\t */\n\t\tconst doRealResolve = (\n\t\t\titemCache,\n\t\t\tresolver,\n\t\t\tresolveContext,\n\t\t\trequest,\n\t\t\tcallback\n\t\t) => {\n\t\t\trealResolves++;\n\t\t\tconst newRequest = {\n\t\t\t\t_ResolverCachePluginCacheMiss: true,\n\t\t\t\t...request\n\t\t\t};\n\t\t\tconst newResolveContext = {\n\t\t\t\t...resolveContext,\n\t\t\t\tstack: new Set(),\n\t\t\t\tmissingDependencies: new LazySet(),\n\t\t\t\tfileDependencies: new LazySet(),\n\t\t\t\tcontextDependencies: new LazySet()\n\t\t\t};\n\t\t\tlet yieldResult;\n\t\t\tlet withYield = false;\n\t\t\tif (typeof newResolveContext.yield === \"function\") {\n\t\t\t\tyieldResult = [];\n\t\t\t\twithYield = true;\n\t\t\t\tnewResolveContext.yield = obj => yieldResult.push(obj);\n\t\t\t}\n\t\t\tconst propagate = key => {\n\t\t\t\tif (resolveContext[key]) {\n\t\t\t\t\taddAllToSet(resolveContext[key], newResolveContext[key]);\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst resolveTime = Date.now();\n\t\t\tresolver.doResolve(\n\t\t\t\tresolver.hooks.resolve,\n\t\t\t\tnewRequest,\n\t\t\t\t\"Cache miss\",\n\t\t\t\tnewResolveContext,\n\t\t\t\t(err, result) => {\n\t\t\t\t\tpropagate(\"fileDependencies\");\n\t\t\t\t\tpropagate(\"contextDependencies\");\n\t\t\t\t\tpropagate(\"missingDependencies\");\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tconst fileDependencies = newResolveContext.fileDependencies;\n\t\t\t\t\tconst contextDependencies = newResolveContext.contextDependencies;\n\t\t\t\t\tconst missingDependencies = newResolveContext.missingDependencies;\n\t\t\t\t\tfileSystemInfo.createSnapshot(\n\t\t\t\t\t\tresolveTime,\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tsnapshotOptions,\n\t\t\t\t\t\t(err, snapshot) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resolveResult = withYield ? yieldResult : result;\n\t\t\t\t\t\t\t// since we intercept resolve hook\n\t\t\t\t\t\t\t// we still can get result in callback\n\t\t\t\t\t\t\tif (withYield && result) yieldResult.push(result);\n\t\t\t\t\t\t\tif (!snapshot) {\n\t\t\t\t\t\t\t\tif (resolveResult) return callback(null, resolveResult);\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titemCache.store(\n\t\t\t\t\t\t\t\tnew CacheEntry(resolveResult, snapshot),\n\t\t\t\t\t\t\t\tstoreErr => {\n\t\t\t\t\t\t\t\t\tif (storeErr) return callback(storeErr);\n\t\t\t\t\t\t\t\t\tif (resolveResult) return callback(null, resolveResult);\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\t\tcompiler.resolverFactory.hooks.resolver.intercept({\n\t\t\tfactory(type, hook) {\n\t\t\t\t/** @type {Map<string, (function(Error=, Object=): void)[]>} */\n\t\t\t\tconst activeRequests = new Map();\n\t\t\t\t/** @type {Map<string, [function(Error=, Object=): void, function(Error=, Object=): void][]>} */\n\t\t\t\tconst activeRequestsWithYield = new Map();\n\t\t\t\thook.tap(\n\t\t\t\t\t\"ResolverCachePlugin\",\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Resolver} resolver the resolver\n\t\t\t\t\t * @param {Object} options resolve options\n\t\t\t\t\t * @param {Object} userOptions resolve options passed by the user\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\t(resolver, options, userOptions) => {\n\t\t\t\t\t\tif (options.cache !== true) return;\n\t\t\t\t\t\tconst optionsIdent = objectToString(userOptions, false);\n\t\t\t\t\t\tconst cacheWithContext =\n\t\t\t\t\t\t\toptions.cacheWithContext !== undefined\n\t\t\t\t\t\t\t\t? options.cacheWithContext\n\t\t\t\t\t\t\t\t: false;\n\t\t\t\t\t\tresolver.hooks.resolve.tapAsync(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tname: \"ResolverCachePlugin\",\n\t\t\t\t\t\t\t\tstage: -100\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(request, resolveContext, callback) => {\n\t\t\t\t\t\t\t\tif (request._ResolverCachePluginCacheMiss || !fileSystemInfo) {\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst withYield = typeof resolveContext.yield === \"function\";\n\t\t\t\t\t\t\t\tconst identifier = `${type}${\n\t\t\t\t\t\t\t\t\twithYield ? \"|yield\" : \"|default\"\n\t\t\t\t\t\t\t\t}${optionsIdent}${objectToString(request, !cacheWithContext)}`;\n\n\t\t\t\t\t\t\t\tif (withYield) {\n\t\t\t\t\t\t\t\t\tconst activeRequest = activeRequestsWithYield.get(identifier);\n\t\t\t\t\t\t\t\t\tif (activeRequest) {\n\t\t\t\t\t\t\t\t\t\tactiveRequest[0].push(callback);\n\t\t\t\t\t\t\t\t\t\tactiveRequest[1].push(resolveContext.yield);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst activeRequest = activeRequests.get(identifier);\n\t\t\t\t\t\t\t\t\tif (activeRequest) {\n\t\t\t\t\t\t\t\t\t\tactiveRequest.push(callback);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst itemCache = cache.getItemCache(identifier, null);\n\t\t\t\t\t\t\t\tlet callbacks, yields;\n\t\t\t\t\t\t\t\tconst done = withYield\n\t\t\t\t\t\t\t\t\t? (err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (result)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (const r of result) resolveContext.yield(r);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(null, null);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tyields = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (const cb of callbacks) cb(err);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < callbacks.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst cb = callbacks[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst yield_ = yields[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (result) for (const r of result) yield_(r);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcb(null, null);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tactiveRequestsWithYield.delete(identifier);\n\t\t\t\t\t\t\t\t\t\t\t\tyields = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t: (err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tfor (const callback of callbacks) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tactiveRequests.delete(identifier);\n\t\t\t\t\t\t\t\t\t\t\t\tcallbacks = false;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t  };\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Error=} err error if any\n\t\t\t\t\t\t\t\t * @param {CacheEntry=} cacheEntry cache entry\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst processCacheResult = (err, cacheEntry) => {\n\t\t\t\t\t\t\t\t\tif (err) return done(err);\n\n\t\t\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\t\t\tconst { snapshot, result } = cacheEntry;\n\t\t\t\t\t\t\t\t\t\tfileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\t\t\t\t\tsnapshot,\n\t\t\t\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\t\t\t\tif (err || !valid) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tcacheInvalidResolves++;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn doRealResolve(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\titemCache,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolver,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdone\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcachedResolves++;\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.missingDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.missingDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getMissingIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.fileDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.fileDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getFileIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (resolveContext.contextDependencies) {\n\t\t\t\t\t\t\t\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tresolveContext.contextDependencies,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsnapshot.getContextIterable()\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tdone(null, result);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tdoRealResolve(\n\t\t\t\t\t\t\t\t\t\t\titemCache,\n\t\t\t\t\t\t\t\t\t\t\tresolver,\n\t\t\t\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t\t\t\tdone\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\titemCache.get(processCacheResult);\n\t\t\t\t\t\t\t\tif (withYield && callbacks === undefined) {\n\t\t\t\t\t\t\t\t\tcallbacks = [callback];\n\t\t\t\t\t\t\t\t\tyields = [resolveContext.yield];\n\t\t\t\t\t\t\t\t\tactiveRequestsWithYield.set(\n\t\t\t\t\t\t\t\t\t\tidentifier,\n\t\t\t\t\t\t\t\t\t\t/** @type {[any, any]} */ ([callbacks, yields])\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else if (callbacks === undefined) {\n\t\t\t\t\t\t\t\t\tcallbacks = [callback];\n\t\t\t\t\t\t\t\t\tactiveRequests.set(identifier, callbacks);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\treturn hook;\n\t\t\t}\n\t\t});\n\t}\n}\n\nmodule.exports = ResolverCachePlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}