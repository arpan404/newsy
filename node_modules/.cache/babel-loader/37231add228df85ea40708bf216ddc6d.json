{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  provide\n} = require(\"./util/MapHelpers\");\n\nconst {\n  first\n} = require(\"./util/SetHelpers\");\n\nconst createHash = require(\"./util/createHash\");\n\nconst {\n  runtimeToString,\n  RuntimeSpecMap\n} = require(\"./util/runtime\");\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./Module\").CodeGenerationResult} CodeGenerationResult */\n\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n\nclass CodeGenerationResults {\n  /**\n   * @param {string | Hash} hashFunction the hash function to use\n   */\n  constructor() {\n    let hashFunction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"md4\";\n\n    /** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>} */\n    this.map = new Map();\n    this._hashFunction = hashFunction;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {CodeGenerationResult} the CodeGenerationResult\n   */\n\n\n  get(module, runtime) {\n    const entry = this.map.get(module);\n\n    if (entry === undefined) {\n      throw new Error(`No code generation entry for ${module.identifier()} (existing entries: ${Array.from(this.map.keys(), m => m.identifier()).join(\", \")})`);\n    }\n\n    if (runtime === undefined) {\n      if (entry.size > 1) {\n        const results = new Set(entry.values());\n\n        if (results.size !== 1) {\n          throw new Error(`No unique code generation entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(entry.keys(), r => runtimeToString(r)).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`);\n        }\n\n        return first(results);\n      }\n\n      return entry.values().next().value;\n    }\n\n    const result = entry.get(runtime);\n\n    if (result === undefined) {\n      throw new Error(`No code generation entry for runtime ${runtimeToString(runtime)} for ${module.identifier()} (existing runtimes: ${Array.from(entry.keys(), r => runtimeToString(r)).join(\", \")})`);\n    }\n\n    return result;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {boolean} true, when we have data for this\n   */\n\n\n  has(module, runtime) {\n    const entry = this.map.get(module);\n\n    if (entry === undefined) {\n      return false;\n    }\n\n    if (runtime !== undefined) {\n      return entry.has(runtime);\n    } else if (entry.size > 1) {\n      const results = new Set(entry.values());\n      return results.size === 1;\n    } else {\n      return entry.size === 1;\n    }\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {string} sourceType the source type\n   * @returns {Source} a source\n   */\n\n\n  getSource(module, runtime, sourceType) {\n    return this.get(module, runtime).sources.get(sourceType);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {ReadonlySet<string>} runtime requirements\n   */\n\n\n  getRuntimeRequirements(module, runtime) {\n    return this.get(module, runtime).runtimeRequirements;\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {string} key data key\n   * @returns {any} data generated by code generation\n   */\n\n\n  getData(module, runtime, key) {\n    const data = this.get(module, runtime).data;\n    return data === undefined ? undefined : data.get(key);\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @returns {any} hash of the code generation\n   */\n\n\n  getHash(module, runtime) {\n    const info = this.get(module, runtime);\n    if (info.hash !== undefined) return info.hash;\n    const hash = createHash(this._hashFunction);\n\n    for (const [type, source] of info.sources) {\n      hash.update(type);\n      source.updateHash(hash);\n    }\n\n    if (info.runtimeRequirements) {\n      for (const rr of info.runtimeRequirements) hash.update(rr);\n    }\n\n    return info.hash =\n    /** @type {string} */\n    hash.digest(\"hex\");\n  }\n  /**\n   * @param {Module} module the module\n   * @param {RuntimeSpec} runtime runtime(s)\n   * @param {CodeGenerationResult} result result from module\n   * @returns {void}\n   */\n\n\n  add(module, runtime, result) {\n    const map = provide(this.map, module, () => new RuntimeSpecMap());\n    map.set(runtime, result);\n  }\n\n}\n\nmodule.exports = CodeGenerationResults;","map":{"version":3,"names":["provide","require","first","createHash","runtimeToString","RuntimeSpecMap","CodeGenerationResults","constructor","hashFunction","map","Map","_hashFunction","get","module","runtime","entry","undefined","Error","identifier","Array","from","keys","m","join","size","results","Set","values","r","next","value","result","has","getSource","sourceType","sources","getRuntimeRequirements","runtimeRequirements","getData","key","data","getHash","info","hash","type","source","update","updateHash","rr","digest","add","set","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/CodeGenerationResults.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { provide } = require(\"./util/MapHelpers\");\nconst { first } = require(\"./util/SetHelpers\");\nconst createHash = require(\"./util/createHash\");\nconst { runtimeToString, RuntimeSpecMap } = require(\"./util/runtime\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").CodeGenerationResult} CodeGenerationResult */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nclass CodeGenerationResults {\n\t/**\n\t * @param {string | Hash} hashFunction the hash function to use\n\t */\n\tconstructor(hashFunction = \"md4\") {\n\t\t/** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>} */\n\t\tthis.map = new Map();\n\t\tthis._hashFunction = hashFunction;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {CodeGenerationResult} the CodeGenerationResult\n\t */\n\tget(module, runtime) {\n\t\tconst entry = this.map.get(module);\n\t\tif (entry === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`No code generation entry for ${module.identifier()} (existing entries: ${Array.from(\n\t\t\t\t\tthis.map.keys(),\n\t\t\t\t\tm => m.identifier()\n\t\t\t\t).join(\", \")})`\n\t\t\t);\n\t\t}\n\t\tif (runtime === undefined) {\n\t\t\tif (entry.size > 1) {\n\t\t\t\tconst results = new Set(entry.values());\n\t\t\t\tif (results.size !== 1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`No unique code generation entry for unspecified runtime for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\t\t\tentry.keys(),\n\t\t\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t\t\t).join(\", \")}).\nCaller might not support runtime-dependent code generation (opt-out via optimization.usedExports: \"global\").`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn first(results);\n\t\t\t}\n\t\t\treturn entry.values().next().value;\n\t\t}\n\t\tconst result = entry.get(runtime);\n\t\tif (result === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`No code generation entry for runtime ${runtimeToString(\n\t\t\t\t\truntime\n\t\t\t\t)} for ${module.identifier()} (existing runtimes: ${Array.from(\n\t\t\t\t\tentry.keys(),\n\t\t\t\t\tr => runtimeToString(r)\n\t\t\t\t).join(\", \")})`\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {boolean} true, when we have data for this\n\t */\n\thas(module, runtime) {\n\t\tconst entry = this.map.get(module);\n\t\tif (entry === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\tif (runtime !== undefined) {\n\t\t\treturn entry.has(runtime);\n\t\t} else if (entry.size > 1) {\n\t\t\tconst results = new Set(entry.values());\n\t\t\treturn results.size === 1;\n\t\t} else {\n\t\t\treturn entry.size === 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {string} sourceType the source type\n\t * @returns {Source} a source\n\t */\n\tgetSource(module, runtime, sourceType) {\n\t\treturn this.get(module, runtime).sources.get(sourceType);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {ReadonlySet<string>} runtime requirements\n\t */\n\tgetRuntimeRequirements(module, runtime) {\n\t\treturn this.get(module, runtime).runtimeRequirements;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {string} key data key\n\t * @returns {any} data generated by code generation\n\t */\n\tgetData(module, runtime, key) {\n\t\tconst data = this.get(module, runtime).data;\n\t\treturn data === undefined ? undefined : data.get(key);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @returns {any} hash of the code generation\n\t */\n\tgetHash(module, runtime) {\n\t\tconst info = this.get(module, runtime);\n\t\tif (info.hash !== undefined) return info.hash;\n\t\tconst hash = createHash(this._hashFunction);\n\t\tfor (const [type, source] of info.sources) {\n\t\t\thash.update(type);\n\t\t\tsource.updateHash(hash);\n\t\t}\n\t\tif (info.runtimeRequirements) {\n\t\t\tfor (const rr of info.runtimeRequirements) hash.update(rr);\n\t\t}\n\t\treturn (info.hash = /** @type {string} */ (hash.digest(\"hex\")));\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {RuntimeSpec} runtime runtime(s)\n\t * @param {CodeGenerationResult} result result from module\n\t * @returns {void}\n\t */\n\tadd(module, runtime, result) {\n\t\tconst map = provide(this.map, module, () => new RuntimeSpecMap());\n\t\tmap.set(runtime, result);\n\t}\n}\n\nmodule.exports = CodeGenerationResults;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}