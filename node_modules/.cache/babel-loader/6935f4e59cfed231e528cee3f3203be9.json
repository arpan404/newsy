{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\n\nconst {\n  HookMap,\n  SyncHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\n\nconst {\n  cachedCleverMerge,\n  removeOperations,\n  resolveByProperty\n} = require(\"./util/cleverMerge\");\n/** @typedef {import(\"enhanced-resolve\").ResolveOptions} ResolveOptions */\n\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolveOptions} WebpackResolveOptions */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolvePluginInstance} ResolvePluginInstance */\n\n/** @typedef {WebpackResolveOptions & {dependencyType?: string, resolveToContext?: boolean }} ResolveOptionsWithDependencyType */\n\n/**\n * @typedef {Object} WithOptions\n * @property {function(Partial<ResolveOptionsWithDependencyType>): ResolverWithOptions} withOptions create a resolver with additional/different options\n */\n\n/** @typedef {Resolver & WithOptions} ResolverWithOptions */\n// need to be hoisted on module level for caching identity\n\n\nconst EMPTY_RESOLVE_OPTIONS = {};\n/**\n * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType enhanced options\n * @returns {ResolveOptions} merged options\n */\n\nconst convertToResolveOptions = resolveOptionsWithDepType => {\n  const {\n    dependencyType,\n    plugins,\n    ...remaining\n  } = resolveOptionsWithDepType; // check type compat\n\n  /** @type {Partial<ResolveOptions>} */\n\n  const partialOptions = { ...remaining,\n    plugins: plugins &&\n    /** @type {ResolvePluginInstance[]} */\n    plugins.filter(item => item !== \"...\")\n  };\n\n  if (!partialOptions.fileSystem) {\n    throw new Error(\"fileSystem is missing in resolveOptions, but it's required for enhanced-resolve\");\n  } // These weird types validate that we checked all non-optional properties\n\n\n  const options =\n  /** @type {Partial<ResolveOptions> & Pick<ResolveOptions, \"fileSystem\">} */\n  partialOptions;\n  return removeOperations(resolveByProperty(options, \"byDependency\", dependencyType));\n};\n/**\n * @typedef {Object} ResolverCache\n * @property {WeakMap<Object, ResolverWithOptions>} direct\n * @property {Map<string, ResolverWithOptions>} stringified\n */\n\n\nmodule.exports = class ResolverFactory {\n  constructor() {\n    this.hooks = Object.freeze({\n      /** @type {HookMap<SyncWaterfallHook<[ResolveOptionsWithDependencyType]>>} */\n      resolveOptions: new HookMap(() => new SyncWaterfallHook([\"resolveOptions\"])),\n\n      /** @type {HookMap<SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>>} */\n      resolver: new HookMap(() => new SyncHook([\"resolver\", \"resolveOptions\", \"userResolveOptions\"]))\n    });\n    /** @type {Map<string, ResolverCache>} */\n\n    this.cache = new Map();\n  }\n  /**\n   * @param {string} type type of resolver\n   * @param {ResolveOptionsWithDependencyType=} resolveOptions options\n   * @returns {ResolverWithOptions} the resolver\n   */\n\n\n  get(type) {\n    let resolveOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMPTY_RESOLVE_OPTIONS;\n    let typedCaches = this.cache.get(type);\n\n    if (!typedCaches) {\n      typedCaches = {\n        direct: new WeakMap(),\n        stringified: new Map()\n      };\n      this.cache.set(type, typedCaches);\n    }\n\n    const cachedResolver = typedCaches.direct.get(resolveOptions);\n\n    if (cachedResolver) {\n      return cachedResolver;\n    }\n\n    const ident = JSON.stringify(resolveOptions);\n    const resolver = typedCaches.stringified.get(ident);\n\n    if (resolver) {\n      typedCaches.direct.set(resolveOptions, resolver);\n      return resolver;\n    }\n\n    const newResolver = this._create(type, resolveOptions);\n\n    typedCaches.direct.set(resolveOptions, newResolver);\n    typedCaches.stringified.set(ident, newResolver);\n    return newResolver;\n  }\n  /**\n   * @param {string} type type of resolver\n   * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType options\n   * @returns {ResolverWithOptions} the resolver\n   */\n\n\n  _create(type, resolveOptionsWithDepType) {\n    /** @type {ResolveOptionsWithDependencyType} */\n    const originalResolveOptions = { ...resolveOptionsWithDepType\n    };\n    const resolveOptions = convertToResolveOptions(this.hooks.resolveOptions.for(type).call(resolveOptionsWithDepType));\n    const resolver =\n    /** @type {ResolverWithOptions} */\n    Factory.createResolver(resolveOptions);\n\n    if (!resolver) {\n      throw new Error(\"No resolver created\");\n    }\n    /** @type {WeakMap<Partial<ResolveOptionsWithDependencyType>, ResolverWithOptions>} */\n\n\n    const childCache = new WeakMap();\n\n    resolver.withOptions = options => {\n      const cacheEntry = childCache.get(options);\n      if (cacheEntry !== undefined) return cacheEntry;\n      const mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n      const resolver = this.get(type, mergedOptions);\n      childCache.set(options, resolver);\n      return resolver;\n    };\n\n    this.hooks.resolver.for(type).call(resolver, resolveOptions, originalResolveOptions);\n    return resolver;\n  }\n\n};","map":{"version":3,"names":["Factory","require","ResolverFactory","HookMap","SyncHook","SyncWaterfallHook","cachedCleverMerge","removeOperations","resolveByProperty","EMPTY_RESOLVE_OPTIONS","convertToResolveOptions","resolveOptionsWithDepType","dependencyType","plugins","remaining","partialOptions","filter","item","fileSystem","Error","options","module","exports","constructor","hooks","Object","freeze","resolveOptions","resolver","cache","Map","get","type","typedCaches","direct","WeakMap","stringified","set","cachedResolver","ident","JSON","stringify","newResolver","_create","originalResolveOptions","for","call","createResolver","childCache","withOptions","cacheEntry","undefined","mergedOptions"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/ResolverFactory.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\nconst { HookMap, SyncHook, SyncWaterfallHook } = require(\"tapable\");\nconst {\n\tcachedCleverMerge,\n\tremoveOperations,\n\tresolveByProperty\n} = require(\"./util/cleverMerge\");\n\n/** @typedef {import(\"enhanced-resolve\").ResolveOptions} ResolveOptions */\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolveOptions} WebpackResolveOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").ResolvePluginInstance} ResolvePluginInstance */\n\n/** @typedef {WebpackResolveOptions & {dependencyType?: string, resolveToContext?: boolean }} ResolveOptionsWithDependencyType */\n/**\n * @typedef {Object} WithOptions\n * @property {function(Partial<ResolveOptionsWithDependencyType>): ResolverWithOptions} withOptions create a resolver with additional/different options\n */\n\n/** @typedef {Resolver & WithOptions} ResolverWithOptions */\n\n// need to be hoisted on module level for caching identity\nconst EMPTY_RESOLVE_OPTIONS = {};\n\n/**\n * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType enhanced options\n * @returns {ResolveOptions} merged options\n */\nconst convertToResolveOptions = resolveOptionsWithDepType => {\n\tconst { dependencyType, plugins, ...remaining } = resolveOptionsWithDepType;\n\n\t// check type compat\n\t/** @type {Partial<ResolveOptions>} */\n\tconst partialOptions = {\n\t\t...remaining,\n\t\tplugins:\n\t\t\tplugins &&\n\t\t\t/** @type {ResolvePluginInstance[]} */ (\n\t\t\t\tplugins.filter(item => item !== \"...\")\n\t\t\t)\n\t};\n\n\tif (!partialOptions.fileSystem) {\n\t\tthrow new Error(\n\t\t\t\"fileSystem is missing in resolveOptions, but it's required for enhanced-resolve\"\n\t\t);\n\t}\n\t// These weird types validate that we checked all non-optional properties\n\tconst options =\n\t\t/** @type {Partial<ResolveOptions> & Pick<ResolveOptions, \"fileSystem\">} */ (\n\t\t\tpartialOptions\n\t\t);\n\n\treturn removeOperations(\n\t\tresolveByProperty(options, \"byDependency\", dependencyType)\n\t);\n};\n\n/**\n * @typedef {Object} ResolverCache\n * @property {WeakMap<Object, ResolverWithOptions>} direct\n * @property {Map<string, ResolverWithOptions>} stringified\n */\n\nmodule.exports = class ResolverFactory {\n\tconstructor() {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {HookMap<SyncWaterfallHook<[ResolveOptionsWithDependencyType]>>} */\n\t\t\tresolveOptions: new HookMap(\n\t\t\t\t() => new SyncWaterfallHook([\"resolveOptions\"])\n\t\t\t),\n\t\t\t/** @type {HookMap<SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>>} */\n\t\t\tresolver: new HookMap(\n\t\t\t\t() => new SyncHook([\"resolver\", \"resolveOptions\", \"userResolveOptions\"])\n\t\t\t)\n\t\t});\n\t\t/** @type {Map<string, ResolverCache>} */\n\t\tthis.cache = new Map();\n\t}\n\n\t/**\n\t * @param {string} type type of resolver\n\t * @param {ResolveOptionsWithDependencyType=} resolveOptions options\n\t * @returns {ResolverWithOptions} the resolver\n\t */\n\tget(type, resolveOptions = EMPTY_RESOLVE_OPTIONS) {\n\t\tlet typedCaches = this.cache.get(type);\n\t\tif (!typedCaches) {\n\t\t\ttypedCaches = {\n\t\t\t\tdirect: new WeakMap(),\n\t\t\t\tstringified: new Map()\n\t\t\t};\n\t\t\tthis.cache.set(type, typedCaches);\n\t\t}\n\t\tconst cachedResolver = typedCaches.direct.get(resolveOptions);\n\t\tif (cachedResolver) {\n\t\t\treturn cachedResolver;\n\t\t}\n\t\tconst ident = JSON.stringify(resolveOptions);\n\t\tconst resolver = typedCaches.stringified.get(ident);\n\t\tif (resolver) {\n\t\t\ttypedCaches.direct.set(resolveOptions, resolver);\n\t\t\treturn resolver;\n\t\t}\n\t\tconst newResolver = this._create(type, resolveOptions);\n\t\ttypedCaches.direct.set(resolveOptions, newResolver);\n\t\ttypedCaches.stringified.set(ident, newResolver);\n\t\treturn newResolver;\n\t}\n\n\t/**\n\t * @param {string} type type of resolver\n\t * @param {ResolveOptionsWithDependencyType} resolveOptionsWithDepType options\n\t * @returns {ResolverWithOptions} the resolver\n\t */\n\t_create(type, resolveOptionsWithDepType) {\n\t\t/** @type {ResolveOptionsWithDependencyType} */\n\t\tconst originalResolveOptions = { ...resolveOptionsWithDepType };\n\n\t\tconst resolveOptions = convertToResolveOptions(\n\t\t\tthis.hooks.resolveOptions.for(type).call(resolveOptionsWithDepType)\n\t\t);\n\t\tconst resolver = /** @type {ResolverWithOptions} */ (\n\t\t\tFactory.createResolver(resolveOptions)\n\t\t);\n\t\tif (!resolver) {\n\t\t\tthrow new Error(\"No resolver created\");\n\t\t}\n\t\t/** @type {WeakMap<Partial<ResolveOptionsWithDependencyType>, ResolverWithOptions>} */\n\t\tconst childCache = new WeakMap();\n\t\tresolver.withOptions = options => {\n\t\t\tconst cacheEntry = childCache.get(options);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tconst mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n\t\t\tconst resolver = this.get(type, mergedOptions);\n\t\t\tchildCache.set(options, resolver);\n\t\t\treturn resolver;\n\t\t};\n\t\tthis.hooks.resolver\n\t\t\t.for(type)\n\t\t\t.call(resolver, resolveOptions, originalResolveOptions);\n\t\treturn resolver;\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}