{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst SortableSet = require(\"./SortableSet\");\n/** @typedef {import(\"../Compilation\")} Compilation */\n\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {string | SortableSet<string> | undefined} RuntimeSpec */\n\n/** @typedef {RuntimeSpec | boolean} RuntimeCondition */\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {string} name name of the entry\n * @param {EntryOptions=} options optionally already received entry options\n * @returns {RuntimeSpec} runtime\n */\n\n\nexports.getEntryRuntime = (compilation, name, options) => {\n  let dependOn;\n  let runtime;\n\n  if (options) {\n    ({\n      dependOn,\n      runtime\n    } = options);\n  } else {\n    const entry = compilation.entries.get(name);\n    if (!entry) return name;\n    ({\n      dependOn,\n      runtime\n    } = entry.options);\n  }\n\n  if (dependOn) {\n    /** @type {RuntimeSpec} */\n    let result = undefined;\n    const queue = new Set(dependOn);\n\n    for (const name of queue) {\n      const dep = compilation.entries.get(name);\n      if (!dep) continue;\n      const {\n        dependOn,\n        runtime\n      } = dep.options;\n\n      if (dependOn) {\n        for (const name of dependOn) {\n          queue.add(name);\n        }\n      } else {\n        result = mergeRuntimeOwned(result, runtime || name);\n      }\n    }\n\n    return result || name;\n  } else {\n    return runtime || name;\n  }\n};\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(string): void} fn functor\n * @param {boolean} deterministicOrder enforce a deterministic order\n * @returns {void}\n */\n\n\nexports.forEachRuntime = function (runtime, fn) {\n  let deterministicOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (runtime === undefined) {\n    fn(undefined);\n  } else if (typeof runtime === \"string\") {\n    fn(runtime);\n  } else {\n    if (deterministicOrder) runtime.sort();\n\n    for (const r of runtime) {\n      fn(r);\n    }\n  }\n};\n\nconst getRuntimesKey = set => {\n  set.sort();\n  return Array.from(set).join(\"\\n\");\n};\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} key of runtimes\n */\n\n\nconst getRuntimeKey = runtime => {\n  if (runtime === undefined) return \"*\";\n  if (typeof runtime === \"string\") return runtime;\n  return runtime.getFromUnorderedCache(getRuntimesKey);\n};\n\nexports.getRuntimeKey = getRuntimeKey;\n/**\n * @param {string} key key of runtimes\n * @returns {RuntimeSpec} runtime(s)\n */\n\nconst keyToRuntime = key => {\n  if (key === \"*\") return undefined;\n  const items = key.split(\"\\n\");\n  if (items.length === 1) return items[0];\n  return new SortableSet(items);\n};\n\nexports.keyToRuntime = keyToRuntime;\n\nconst getRuntimesString = set => {\n  set.sort();\n  return Array.from(set).join(\"+\");\n};\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} readable version\n */\n\n\nconst runtimeToString = runtime => {\n  if (runtime === undefined) return \"*\";\n  if (typeof runtime === \"string\") return runtime;\n  return runtime.getFromUnorderedCache(getRuntimesString);\n};\n\nexports.runtimeToString = runtimeToString;\n/**\n * @param {RuntimeCondition} runtimeCondition runtime condition\n * @returns {string} readable version\n */\n\nexports.runtimeConditionToString = runtimeCondition => {\n  if (runtimeCondition === true) return \"true\";\n  if (runtimeCondition === false) return \"false\";\n  return runtimeToString(runtimeCondition);\n};\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {boolean} true, when they are equal\n */\n\n\nconst runtimeEqual = (a, b) => {\n  if (a === b) {\n    return true;\n  } else if (a === undefined || b === undefined || typeof a === \"string\" || typeof b === \"string\") {\n    return false;\n  } else if (a.size !== b.size) {\n    return false;\n  } else {\n    a.sort();\n    b.sort();\n    const aIt = a[Symbol.iterator]();\n    const bIt = b[Symbol.iterator]();\n\n    for (;;) {\n      const aV = aIt.next();\n      if (aV.done) return true;\n      const bV = bIt.next();\n      if (aV.value !== bV.value) return false;\n    }\n  }\n};\n\nexports.runtimeEqual = runtimeEqual;\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {-1|0|1} compare\n */\n\nexports.compareRuntime = (a, b) => {\n  if (a === b) {\n    return 0;\n  } else if (a === undefined) {\n    return -1;\n  } else if (b === undefined) {\n    return 1;\n  } else {\n    const aKey = getRuntimeKey(a);\n    const bKey = getRuntimeKey(b);\n    if (aKey < bKey) return -1;\n    if (aKey > bKey) return 1;\n    return 0;\n  }\n};\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\n\n\nconst mergeRuntime = (a, b) => {\n  if (a === undefined) {\n    return b;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      const set = new SortableSet();\n      set.add(a);\n      set.add(b);\n      return set;\n    } else if (b.has(a)) {\n      return b;\n    } else {\n      const set = new SortableSet(b);\n      set.add(a);\n      return set;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (a.has(b)) return a;\n      const set = new SortableSet(a);\n      set.add(b);\n      return set;\n    } else {\n      const set = new SortableSet(a);\n\n      for (const item of b) set.add(item);\n\n      if (set.size === a.size) return a;\n      return set;\n    }\n  }\n};\n\nexports.mergeRuntime = mergeRuntime;\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeCondition} result\n */\n\nexports.mergeRuntimeCondition = (a, b, runtime) => {\n  if (a === false) return b;\n  if (b === false) return a;\n  if (a === true || b === true) return true;\n  const merged = mergeRuntime(a, b);\n  if (merged === undefined) return undefined;\n\n  if (typeof merged === \"string\") {\n    if (typeof runtime === \"string\" && merged === runtime) return true;\n    return merged;\n  }\n\n  if (typeof runtime === \"string\" || runtime === undefined) return merged;\n  if (merged.size === runtime.size) return true;\n  return merged;\n};\n/**\n * @param {RuntimeSpec | true} a first\n * @param {RuntimeSpec | true} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeSpec | true} result\n */\n\n\nexports.mergeRuntimeConditionNonFalse = (a, b, runtime) => {\n  if (a === true || b === true) return true;\n  const merged = mergeRuntime(a, b);\n  if (merged === undefined) return undefined;\n\n  if (typeof merged === \"string\") {\n    if (typeof runtime === \"string\" && merged === runtime) return true;\n    return merged;\n  }\n\n  if (typeof runtime === \"string\" || runtime === undefined) return merged;\n  if (merged.size === runtime.size) return true;\n  return merged;\n};\n/**\n * @param {RuntimeSpec} a first (may be modified)\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\n\n\nconst mergeRuntimeOwned = (a, b) => {\n  if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (a === undefined) {\n    if (typeof b === \"string\") {\n      return b;\n    } else {\n      return new SortableSet(b);\n    }\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      const set = new SortableSet();\n      set.add(a);\n      set.add(b);\n      return set;\n    } else {\n      const set = new SortableSet(b);\n      set.add(a);\n      return set;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      a.add(b);\n      return a;\n    } else {\n      for (const item of b) a.add(item);\n\n      return a;\n    }\n  }\n};\n\nexports.mergeRuntimeOwned = mergeRuntimeOwned;\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\n\nexports.intersectRuntime = (a, b) => {\n  if (a === undefined) {\n    return b;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return a;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      return undefined;\n    } else if (b.has(a)) {\n      return a;\n    } else {\n      return undefined;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (a.has(b)) return b;\n      return undefined;\n    } else {\n      const set = new SortableSet();\n\n      for (const item of b) {\n        if (a.has(item)) set.add(item);\n      }\n\n      if (set.size === 0) return undefined;\n      if (set.size === 1) for (const item of set) return item;\n      return set;\n    }\n  }\n};\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} result\n */\n\n\nconst subtractRuntime = (a, b) => {\n  if (a === undefined) {\n    return undefined;\n  } else if (b === undefined) {\n    return a;\n  } else if (a === b) {\n    return undefined;\n  } else if (typeof a === \"string\") {\n    if (typeof b === \"string\") {\n      return a;\n    } else if (b.has(a)) {\n      return undefined;\n    } else {\n      return a;\n    }\n  } else {\n    if (typeof b === \"string\") {\n      if (!a.has(b)) return a;\n\n      if (a.size === 2) {\n        for (const item of a) {\n          if (item !== b) return item;\n        }\n      }\n\n      const set = new SortableSet(a);\n      set.delete(b);\n    } else {\n      const set = new SortableSet();\n\n      for (const item of a) {\n        if (!b.has(item)) set.add(item);\n      }\n\n      if (set.size === 0) return undefined;\n      if (set.size === 1) for (const item of set) return item;\n      return set;\n    }\n  }\n};\n\nexports.subtractRuntime = subtractRuntime;\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime runtime\n * @returns {RuntimeCondition} result\n */\n\nexports.subtractRuntimeCondition = (a, b, runtime) => {\n  if (b === true) return false;\n  if (b === false) return a;\n  if (a === false) return false;\n  const result = subtractRuntime(a === true ? runtime : a, b);\n  return result === undefined ? false : result;\n};\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(RuntimeSpec): boolean} filter filter function\n * @returns {boolean | RuntimeSpec} true/false if filter is constant for all runtimes, otherwise runtimes that are active\n */\n\n\nexports.filterRuntime = (runtime, filter) => {\n  if (runtime === undefined) return filter(undefined);\n  if (typeof runtime === \"string\") return filter(runtime);\n  let some = false;\n  let every = true;\n  let result = undefined;\n\n  for (const r of runtime) {\n    const v = filter(r);\n\n    if (v) {\n      some = true;\n      result = mergeRuntimeOwned(result, r);\n    } else {\n      every = false;\n    }\n  }\n\n  if (!some) return false;\n  if (every) return true;\n  return result;\n};\n/**\n * @template T\n */\n\n\nclass RuntimeSpecMap {\n  /**\n   * @param {RuntimeSpecMap<T>=} clone copy form this\n   */\n  constructor(clone) {\n    this._mode = clone ? clone._mode : 0; // 0 = empty, 1 = single entry, 2 = map\n\n    /** @type {RuntimeSpec} */\n\n    this._singleRuntime = clone ? clone._singleRuntime : undefined;\n    /** @type {T} */\n\n    this._singleValue = clone ? clone._singleValue : undefined;\n    /** @type {Map<string, T> | undefined} */\n\n    this._map = clone && clone._map ? new Map(clone._map) : undefined;\n  }\n  /**\n   * @param {RuntimeSpec} runtime the runtimes\n   * @returns {T} value\n   */\n\n\n  get(runtime) {\n    switch (this._mode) {\n      case 0:\n        return undefined;\n\n      case 1:\n        return runtimeEqual(this._singleRuntime, runtime) ? this._singleValue : undefined;\n\n      default:\n        return this._map.get(getRuntimeKey(runtime));\n    }\n  }\n  /**\n   * @param {RuntimeSpec} runtime the runtimes\n   * @returns {boolean} true, when the runtime is stored\n   */\n\n\n  has(runtime) {\n    switch (this._mode) {\n      case 0:\n        return false;\n\n      case 1:\n        return runtimeEqual(this._singleRuntime, runtime);\n\n      default:\n        return this._map.has(getRuntimeKey(runtime));\n    }\n  }\n\n  set(runtime, value) {\n    switch (this._mode) {\n      case 0:\n        this._mode = 1;\n        this._singleRuntime = runtime;\n        this._singleValue = value;\n        break;\n\n      case 1:\n        if (runtimeEqual(this._singleRuntime, runtime)) {\n          this._singleValue = value;\n          break;\n        }\n\n        this._mode = 2;\n        this._map = new Map();\n\n        this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\n        this._singleRuntime = undefined;\n        this._singleValue = undefined;\n\n      /* falls through */\n\n      default:\n        this._map.set(getRuntimeKey(runtime), value);\n\n    }\n  }\n\n  provide(runtime, computer) {\n    switch (this._mode) {\n      case 0:\n        this._mode = 1;\n        this._singleRuntime = runtime;\n        return this._singleValue = computer();\n\n      case 1:\n        {\n          if (runtimeEqual(this._singleRuntime, runtime)) {\n            return this._singleValue;\n          }\n\n          this._mode = 2;\n          this._map = new Map();\n\n          this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\n          this._singleRuntime = undefined;\n          this._singleValue = undefined;\n          const newValue = computer();\n\n          this._map.set(getRuntimeKey(runtime), newValue);\n\n          return newValue;\n        }\n\n      default:\n        {\n          const key = getRuntimeKey(runtime);\n\n          const value = this._map.get(key);\n\n          if (value !== undefined) return value;\n          const newValue = computer();\n\n          this._map.set(key, newValue);\n\n          return newValue;\n        }\n    }\n  }\n\n  delete(runtime) {\n    switch (this._mode) {\n      case 0:\n        return;\n\n      case 1:\n        if (runtimeEqual(this._singleRuntime, runtime)) {\n          this._mode = 0;\n          this._singleRuntime = undefined;\n          this._singleValue = undefined;\n        }\n\n        return;\n\n      default:\n        this._map.delete(getRuntimeKey(runtime));\n\n    }\n  }\n\n  update(runtime, fn) {\n    switch (this._mode) {\n      case 0:\n        throw new Error(\"runtime passed to update must exist\");\n\n      case 1:\n        {\n          if (runtimeEqual(this._singleRuntime, runtime)) {\n            this._singleValue = fn(this._singleValue);\n            break;\n          }\n\n          const newValue = fn(undefined);\n\n          if (newValue !== undefined) {\n            this._mode = 2;\n            this._map = new Map();\n\n            this._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\n            this._singleRuntime = undefined;\n            this._singleValue = undefined;\n\n            this._map.set(getRuntimeKey(runtime), newValue);\n          }\n\n          break;\n        }\n\n      default:\n        {\n          const key = getRuntimeKey(runtime);\n\n          const oldValue = this._map.get(key);\n\n          const newValue = fn(oldValue);\n          if (newValue !== oldValue) this._map.set(key, newValue);\n        }\n    }\n  }\n\n  keys() {\n    switch (this._mode) {\n      case 0:\n        return [];\n\n      case 1:\n        return [this._singleRuntime];\n\n      default:\n        return Array.from(this._map.keys(), keyToRuntime);\n    }\n  }\n\n  values() {\n    switch (this._mode) {\n      case 0:\n        return [][Symbol.iterator]();\n\n      case 1:\n        return [this._singleValue][Symbol.iterator]();\n\n      default:\n        return this._map.values();\n    }\n  }\n\n  get size() {\n    if (this._mode <= 1) return this._mode;\n    return this._map.size;\n  }\n\n}\n\nexports.RuntimeSpecMap = RuntimeSpecMap;\n\nclass RuntimeSpecSet {\n  constructor(iterable) {\n    /** @type {Map<string, RuntimeSpec>} */\n    this._map = new Map();\n\n    if (iterable) {\n      for (const item of iterable) {\n        this.add(item);\n      }\n    }\n  }\n\n  add(runtime) {\n    this._map.set(getRuntimeKey(runtime), runtime);\n  }\n\n  has(runtime) {\n    return this._map.has(getRuntimeKey(runtime));\n  }\n\n  [Symbol.iterator]() {\n    return this._map.values();\n  }\n\n  get size() {\n    return this._map.size;\n  }\n\n}\n\nexports.RuntimeSpecSet = RuntimeSpecSet;","map":{"version":3,"names":["SortableSet","require","exports","getEntryRuntime","compilation","name","options","dependOn","runtime","entry","entries","get","result","undefined","queue","Set","dep","add","mergeRuntimeOwned","forEachRuntime","fn","deterministicOrder","sort","r","getRuntimesKey","set","Array","from","join","getRuntimeKey","getFromUnorderedCache","keyToRuntime","key","items","split","length","getRuntimesString","runtimeToString","runtimeConditionToString","runtimeCondition","runtimeEqual","a","b","size","aIt","Symbol","iterator","bIt","aV","next","done","bV","value","compareRuntime","aKey","bKey","mergeRuntime","has","item","mergeRuntimeCondition","merged","mergeRuntimeConditionNonFalse","intersectRuntime","subtractRuntime","delete","subtractRuntimeCondition","filterRuntime","filter","some","every","v","RuntimeSpecMap","constructor","clone","_mode","_singleRuntime","_singleValue","_map","Map","provide","computer","newValue","update","Error","oldValue","keys","values","RuntimeSpecSet","iterable"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/util/runtime.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst SortableSet = require(\"./SortableSet\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Entrypoint\").EntryOptions} EntryOptions */\n\n/** @typedef {string | SortableSet<string> | undefined} RuntimeSpec */\n/** @typedef {RuntimeSpec | boolean} RuntimeCondition */\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {string} name name of the entry\n * @param {EntryOptions=} options optionally already received entry options\n * @returns {RuntimeSpec} runtime\n */\nexports.getEntryRuntime = (compilation, name, options) => {\n\tlet dependOn;\n\tlet runtime;\n\tif (options) {\n\t\t({ dependOn, runtime } = options);\n\t} else {\n\t\tconst entry = compilation.entries.get(name);\n\t\tif (!entry) return name;\n\t\t({ dependOn, runtime } = entry.options);\n\t}\n\tif (dependOn) {\n\t\t/** @type {RuntimeSpec} */\n\t\tlet result = undefined;\n\t\tconst queue = new Set(dependOn);\n\t\tfor (const name of queue) {\n\t\t\tconst dep = compilation.entries.get(name);\n\t\t\tif (!dep) continue;\n\t\t\tconst { dependOn, runtime } = dep.options;\n\t\t\tif (dependOn) {\n\t\t\t\tfor (const name of dependOn) {\n\t\t\t\t\tqueue.add(name);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresult = mergeRuntimeOwned(result, runtime || name);\n\t\t\t}\n\t\t}\n\t\treturn result || name;\n\t} else {\n\t\treturn runtime || name;\n\t}\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(string): void} fn functor\n * @param {boolean} deterministicOrder enforce a deterministic order\n * @returns {void}\n */\nexports.forEachRuntime = (runtime, fn, deterministicOrder = false) => {\n\tif (runtime === undefined) {\n\t\tfn(undefined);\n\t} else if (typeof runtime === \"string\") {\n\t\tfn(runtime);\n\t} else {\n\t\tif (deterministicOrder) runtime.sort();\n\t\tfor (const r of runtime) {\n\t\t\tfn(r);\n\t\t}\n\t}\n};\n\nconst getRuntimesKey = set => {\n\tset.sort();\n\treturn Array.from(set).join(\"\\n\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} key of runtimes\n */\nconst getRuntimeKey = runtime => {\n\tif (runtime === undefined) return \"*\";\n\tif (typeof runtime === \"string\") return runtime;\n\treturn runtime.getFromUnorderedCache(getRuntimesKey);\n};\nexports.getRuntimeKey = getRuntimeKey;\n\n/**\n * @param {string} key key of runtimes\n * @returns {RuntimeSpec} runtime(s)\n */\nconst keyToRuntime = key => {\n\tif (key === \"*\") return undefined;\n\tconst items = key.split(\"\\n\");\n\tif (items.length === 1) return items[0];\n\treturn new SortableSet(items);\n};\nexports.keyToRuntime = keyToRuntime;\n\nconst getRuntimesString = set => {\n\tset.sort();\n\treturn Array.from(set).join(\"+\");\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime(s)\n * @returns {string} readable version\n */\nconst runtimeToString = runtime => {\n\tif (runtime === undefined) return \"*\";\n\tif (typeof runtime === \"string\") return runtime;\n\treturn runtime.getFromUnorderedCache(getRuntimesString);\n};\nexports.runtimeToString = runtimeToString;\n\n/**\n * @param {RuntimeCondition} runtimeCondition runtime condition\n * @returns {string} readable version\n */\nexports.runtimeConditionToString = runtimeCondition => {\n\tif (runtimeCondition === true) return \"true\";\n\tif (runtimeCondition === false) return \"false\";\n\treturn runtimeToString(runtimeCondition);\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {boolean} true, when they are equal\n */\nconst runtimeEqual = (a, b) => {\n\tif (a === b) {\n\t\treturn true;\n\t} else if (\n\t\ta === undefined ||\n\t\tb === undefined ||\n\t\ttypeof a === \"string\" ||\n\t\ttypeof b === \"string\"\n\t) {\n\t\treturn false;\n\t} else if (a.size !== b.size) {\n\t\treturn false;\n\t} else {\n\t\ta.sort();\n\t\tb.sort();\n\t\tconst aIt = a[Symbol.iterator]();\n\t\tconst bIt = b[Symbol.iterator]();\n\t\tfor (;;) {\n\t\t\tconst aV = aIt.next();\n\t\t\tif (aV.done) return true;\n\t\t\tconst bV = bIt.next();\n\t\t\tif (aV.value !== bV.value) return false;\n\t\t}\n\t}\n};\nexports.runtimeEqual = runtimeEqual;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {-1|0|1} compare\n */\nexports.compareRuntime = (a, b) => {\n\tif (a === b) {\n\t\treturn 0;\n\t} else if (a === undefined) {\n\t\treturn -1;\n\t} else if (b === undefined) {\n\t\treturn 1;\n\t} else {\n\t\tconst aKey = getRuntimeKey(a);\n\t\tconst bKey = getRuntimeKey(b);\n\t\tif (aKey < bKey) return -1;\n\t\tif (aKey > bKey) return 1;\n\t\treturn 0;\n\t}\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nconst mergeRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn b;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\tconst set = new SortableSet();\n\t\t\tset.add(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else if (b.has(a)) {\n\t\t\treturn b;\n\t\t} else {\n\t\t\tconst set = new SortableSet(b);\n\t\t\tset.add(a);\n\t\t\treturn set;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (a.has(b)) return a;\n\t\t\tconst set = new SortableSet(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else {\n\t\t\tconst set = new SortableSet(a);\n\t\t\tfor (const item of b) set.add(item);\n\t\t\tif (set.size === a.size) return a;\n\t\t\treturn set;\n\t\t}\n\t}\n};\nexports.mergeRuntime = mergeRuntime;\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeCondition} result\n */\nexports.mergeRuntimeCondition = (a, b, runtime) => {\n\tif (a === false) return b;\n\tif (b === false) return a;\n\tif (a === true || b === true) return true;\n\tconst merged = mergeRuntime(a, b);\n\tif (merged === undefined) return undefined;\n\tif (typeof merged === \"string\") {\n\t\tif (typeof runtime === \"string\" && merged === runtime) return true;\n\t\treturn merged;\n\t}\n\tif (typeof runtime === \"string\" || runtime === undefined) return merged;\n\tif (merged.size === runtime.size) return true;\n\treturn merged;\n};\n\n/**\n * @param {RuntimeSpec | true} a first\n * @param {RuntimeSpec | true} b second\n * @param {RuntimeSpec} runtime full runtime\n * @returns {RuntimeSpec | true} result\n */\nexports.mergeRuntimeConditionNonFalse = (a, b, runtime) => {\n\tif (a === true || b === true) return true;\n\tconst merged = mergeRuntime(a, b);\n\tif (merged === undefined) return undefined;\n\tif (typeof merged === \"string\") {\n\t\tif (typeof runtime === \"string\" && merged === runtime) return true;\n\t\treturn merged;\n\t}\n\tif (typeof runtime === \"string\" || runtime === undefined) return merged;\n\tif (merged.size === runtime.size) return true;\n\treturn merged;\n};\n\n/**\n * @param {RuntimeSpec} a first (may be modified)\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nconst mergeRuntimeOwned = (a, b) => {\n\tif (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (a === undefined) {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn b;\n\t\t} else {\n\t\t\treturn new SortableSet(b);\n\t\t}\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\tconst set = new SortableSet();\n\t\t\tset.add(a);\n\t\t\tset.add(b);\n\t\t\treturn set;\n\t\t} else {\n\t\t\tconst set = new SortableSet(b);\n\t\t\tset.add(a);\n\t\t\treturn set;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\ta.add(b);\n\t\t\treturn a;\n\t\t} else {\n\t\t\tfor (const item of b) a.add(item);\n\t\t\treturn a;\n\t\t}\n\t}\n};\nexports.mergeRuntimeOwned = mergeRuntimeOwned;\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} merged\n */\nexports.intersectRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn b;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn a;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn undefined;\n\t\t} else if (b.has(a)) {\n\t\t\treturn a;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (a.has(b)) return b;\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\tconst set = new SortableSet();\n\t\t\tfor (const item of b) {\n\t\t\t\tif (a.has(item)) set.add(item);\n\t\t\t}\n\t\t\tif (set.size === 0) return undefined;\n\t\t\tif (set.size === 1) for (const item of set) return item;\n\t\t\treturn set;\n\t\t}\n\t}\n};\n\n/**\n * @param {RuntimeSpec} a first\n * @param {RuntimeSpec} b second\n * @returns {RuntimeSpec} result\n */\nconst subtractRuntime = (a, b) => {\n\tif (a === undefined) {\n\t\treturn undefined;\n\t} else if (b === undefined) {\n\t\treturn a;\n\t} else if (a === b) {\n\t\treturn undefined;\n\t} else if (typeof a === \"string\") {\n\t\tif (typeof b === \"string\") {\n\t\t\treturn a;\n\t\t} else if (b.has(a)) {\n\t\t\treturn undefined;\n\t\t} else {\n\t\t\treturn a;\n\t\t}\n\t} else {\n\t\tif (typeof b === \"string\") {\n\t\t\tif (!a.has(b)) return a;\n\t\t\tif (a.size === 2) {\n\t\t\t\tfor (const item of a) {\n\t\t\t\t\tif (item !== b) return item;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst set = new SortableSet(a);\n\t\t\tset.delete(b);\n\t\t} else {\n\t\t\tconst set = new SortableSet();\n\t\t\tfor (const item of a) {\n\t\t\t\tif (!b.has(item)) set.add(item);\n\t\t\t}\n\t\t\tif (set.size === 0) return undefined;\n\t\t\tif (set.size === 1) for (const item of set) return item;\n\t\t\treturn set;\n\t\t}\n\t}\n};\nexports.subtractRuntime = subtractRuntime;\n\n/**\n * @param {RuntimeCondition} a first\n * @param {RuntimeCondition} b second\n * @param {RuntimeSpec} runtime runtime\n * @returns {RuntimeCondition} result\n */\nexports.subtractRuntimeCondition = (a, b, runtime) => {\n\tif (b === true) return false;\n\tif (b === false) return a;\n\tif (a === false) return false;\n\tconst result = subtractRuntime(a === true ? runtime : a, b);\n\treturn result === undefined ? false : result;\n};\n\n/**\n * @param {RuntimeSpec} runtime runtime\n * @param {function(RuntimeSpec): boolean} filter filter function\n * @returns {boolean | RuntimeSpec} true/false if filter is constant for all runtimes, otherwise runtimes that are active\n */\nexports.filterRuntime = (runtime, filter) => {\n\tif (runtime === undefined) return filter(undefined);\n\tif (typeof runtime === \"string\") return filter(runtime);\n\tlet some = false;\n\tlet every = true;\n\tlet result = undefined;\n\tfor (const r of runtime) {\n\t\tconst v = filter(r);\n\t\tif (v) {\n\t\t\tsome = true;\n\t\t\tresult = mergeRuntimeOwned(result, r);\n\t\t} else {\n\t\t\tevery = false;\n\t\t}\n\t}\n\tif (!some) return false;\n\tif (every) return true;\n\treturn result;\n};\n\n/**\n * @template T\n */\nclass RuntimeSpecMap {\n\t/**\n\t * @param {RuntimeSpecMap<T>=} clone copy form this\n\t */\n\tconstructor(clone) {\n\t\tthis._mode = clone ? clone._mode : 0; // 0 = empty, 1 = single entry, 2 = map\n\t\t/** @type {RuntimeSpec} */\n\t\tthis._singleRuntime = clone ? clone._singleRuntime : undefined;\n\t\t/** @type {T} */\n\t\tthis._singleValue = clone ? clone._singleValue : undefined;\n\t\t/** @type {Map<string, T> | undefined} */\n\t\tthis._map = clone && clone._map ? new Map(clone._map) : undefined;\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t * @returns {T} value\n\t */\n\tget(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn undefined;\n\t\t\tcase 1:\n\t\t\t\treturn runtimeEqual(this._singleRuntime, runtime)\n\t\t\t\t\t? this._singleValue\n\t\t\t\t\t: undefined;\n\t\t\tdefault:\n\t\t\t\treturn this._map.get(getRuntimeKey(runtime));\n\t\t}\n\t}\n\n\t/**\n\t * @param {RuntimeSpec} runtime the runtimes\n\t * @returns {boolean} true, when the runtime is stored\n\t */\n\thas(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn false;\n\t\t\tcase 1:\n\t\t\t\treturn runtimeEqual(this._singleRuntime, runtime);\n\t\t\tdefault:\n\t\t\t\treturn this._map.has(getRuntimeKey(runtime));\n\t\t}\n\t}\n\n\tset(runtime, value) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthis._mode = 1;\n\t\t\t\tthis._singleRuntime = runtime;\n\t\t\t\tthis._singleValue = value;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._singleValue = value;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tthis._mode = 2;\n\t\t\t\tthis._map = new Map();\n\t\t\t\tthis._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\tthis._singleValue = undefined;\n\t\t\t/* falls through */\n\t\t\tdefault:\n\t\t\t\tthis._map.set(getRuntimeKey(runtime), value);\n\t\t}\n\t}\n\n\tprovide(runtime, computer) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthis._mode = 1;\n\t\t\t\tthis._singleRuntime = runtime;\n\t\t\t\treturn (this._singleValue = computer());\n\t\t\tcase 1: {\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\treturn this._singleValue;\n\t\t\t\t}\n\t\t\t\tthis._mode = 2;\n\t\t\t\tthis._map = new Map();\n\t\t\t\tthis._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\tthis._singleValue = undefined;\n\t\t\t\tconst newValue = computer();\n\t\t\t\tthis._map.set(getRuntimeKey(runtime), newValue);\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tconst key = getRuntimeKey(runtime);\n\t\t\t\tconst value = this._map.get(key);\n\t\t\t\tif (value !== undefined) return value;\n\t\t\t\tconst newValue = computer();\n\t\t\t\tthis._map.set(key, newValue);\n\t\t\t\treturn newValue;\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete(runtime) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn;\n\t\t\tcase 1:\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._mode = 0;\n\t\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\t\tthis._singleValue = undefined;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tthis._map.delete(getRuntimeKey(runtime));\n\t\t}\n\t}\n\n\tupdate(runtime, fn) {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\tthrow new Error(\"runtime passed to update must exist\");\n\t\t\tcase 1: {\n\t\t\t\tif (runtimeEqual(this._singleRuntime, runtime)) {\n\t\t\t\t\tthis._singleValue = fn(this._singleValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst newValue = fn(undefined);\n\t\t\t\tif (newValue !== undefined) {\n\t\t\t\t\tthis._mode = 2;\n\t\t\t\t\tthis._map = new Map();\n\t\t\t\t\tthis._map.set(getRuntimeKey(this._singleRuntime), this._singleValue);\n\t\t\t\t\tthis._singleRuntime = undefined;\n\t\t\t\t\tthis._singleValue = undefined;\n\t\t\t\t\tthis._map.set(getRuntimeKey(runtime), newValue);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tconst key = getRuntimeKey(runtime);\n\t\t\t\tconst oldValue = this._map.get(key);\n\t\t\t\tconst newValue = fn(oldValue);\n\t\t\t\tif (newValue !== oldValue) this._map.set(key, newValue);\n\t\t\t}\n\t\t}\n\t}\n\n\tkeys() {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn [];\n\t\t\tcase 1:\n\t\t\t\treturn [this._singleRuntime];\n\t\t\tdefault:\n\t\t\t\treturn Array.from(this._map.keys(), keyToRuntime);\n\t\t}\n\t}\n\n\tvalues() {\n\t\tswitch (this._mode) {\n\t\t\tcase 0:\n\t\t\t\treturn [][Symbol.iterator]();\n\t\t\tcase 1:\n\t\t\t\treturn [this._singleValue][Symbol.iterator]();\n\t\t\tdefault:\n\t\t\t\treturn this._map.values();\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (this._mode <= 1) return this._mode;\n\t\treturn this._map.size;\n\t}\n}\n\nexports.RuntimeSpecMap = RuntimeSpecMap;\n\nclass RuntimeSpecSet {\n\tconstructor(iterable) {\n\t\t/** @type {Map<string, RuntimeSpec>} */\n\t\tthis._map = new Map();\n\t\tif (iterable) {\n\t\t\tfor (const item of iterable) {\n\t\t\t\tthis.add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tadd(runtime) {\n\t\tthis._map.set(getRuntimeKey(runtime), runtime);\n\t}\n\n\thas(runtime) {\n\t\treturn this._map.has(getRuntimeKey(runtime));\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this._map.values();\n\t}\n\n\tget size() {\n\t\treturn this._map.size;\n\t}\n}\n\nexports.RuntimeSpecSet = RuntimeSpecSet;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}