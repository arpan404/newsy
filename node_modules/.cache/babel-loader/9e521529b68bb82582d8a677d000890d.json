{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst NormalModule = require(\"../NormalModule\");\n\nconst LazySet = require(\"../util/LazySet\");\n\nconst LoaderDependency = require(\"./LoaderDependency\");\n\nconst LoaderImportDependency = require(\"./LoaderImportDependency\");\n/** @typedef {import(\"../Compilation\").DepConstructor} DepConstructor */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/**\n * @callback LoadModuleCallback\n * @param {(Error | null)=} err error object\n * @param {string | Buffer=} source source code\n * @param {object=} map source map\n * @param {Module=} module loaded module if successful\n */\n\n/**\n * @callback ImportModuleCallback\n * @param {(Error | null)=} err error object\n * @param {any=} exports exports of the evaluated module\n */\n\n/**\n * @typedef {Object} ImportModuleOptions\n * @property {string=} layer the target layer\n * @property {string=} publicPath the target public path\n * @property {string=} baseUri target base uri\n */\n\n\nclass LoaderPlugin {\n  /**\n   * @param {Object} options options\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"LoaderPlugin\", (compilation, _ref) => {\n      let {\n        normalModuleFactory\n      } = _ref;\n      compilation.dependencyFactories.set(LoaderDependency, normalModuleFactory);\n      compilation.dependencyFactories.set(LoaderImportDependency, normalModuleFactory);\n    });\n    compiler.hooks.compilation.tap(\"LoaderPlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      NormalModule.getCompilationHooks(compilation).loader.tap(\"LoaderPlugin\", loaderContext => {\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {LoadModuleCallback} callback callback returning the loaded module or error\n         * @returns {void}\n         */\n        loaderContext.loadModule = (request, callback) => {\n          const dep = new LoaderDependency(request);\n          dep.loc = {\n            name: request\n          };\n          const factory = compilation.dependencyFactories.get(\n          /** @type {DepConstructor} */\n          dep.constructor);\n\n          if (factory === undefined) {\n            return callback(new Error(`No module factory available for dependency type: ${dep.constructor.name}`));\n          }\n\n          compilation.buildQueue.increaseParallelism();\n          compilation.handleModuleCreation({\n            factory,\n            dependencies: [dep],\n            originModule: loaderContext._module,\n            context: loaderContext.context,\n            recursive: false\n          }, err => {\n            compilation.buildQueue.decreaseParallelism();\n\n            if (err) {\n              return callback(err);\n            }\n\n            const referencedModule = moduleGraph.getModule(dep);\n\n            if (!referencedModule) {\n              return callback(new Error(\"Cannot load the module\"));\n            }\n\n            if (referencedModule.getNumberOfErrors() > 0) {\n              return callback(new Error(\"The loaded module contains errors\"));\n            }\n\n            const moduleSource = referencedModule.originalSource();\n\n            if (!moduleSource) {\n              return callback(new Error(\"The module created for a LoaderDependency must have an original source\"));\n            }\n\n            let source, map;\n\n            if (moduleSource.sourceAndMap) {\n              const sourceAndMap = moduleSource.sourceAndMap();\n              map = sourceAndMap.map;\n              source = sourceAndMap.source;\n            } else {\n              map = moduleSource.map();\n              source = moduleSource.source();\n            }\n\n            const fileDependencies = new LazySet();\n            const contextDependencies = new LazySet();\n            const missingDependencies = new LazySet();\n            const buildDependencies = new LazySet();\n            referencedModule.addCacheDependencies(fileDependencies, contextDependencies, missingDependencies, buildDependencies);\n\n            for (const d of fileDependencies) {\n              loaderContext.addDependency(d);\n            }\n\n            for (const d of contextDependencies) {\n              loaderContext.addContextDependency(d);\n            }\n\n            for (const d of missingDependencies) {\n              loaderContext.addMissingDependency(d);\n            }\n\n            for (const d of buildDependencies) {\n              loaderContext.addBuildDependency(d);\n            }\n\n            return callback(null, source, map, referencedModule);\n          });\n        };\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {ImportModuleOptions=} options options\n         * @param {ImportModuleCallback=} callback callback returning the exports\n         * @returns {void}\n         */\n\n\n        const importModule = (request, options, callback) => {\n          const dep = new LoaderImportDependency(request);\n          dep.loc = {\n            name: request\n          };\n          const factory = compilation.dependencyFactories.get(\n          /** @type {DepConstructor} */\n          dep.constructor);\n\n          if (factory === undefined) {\n            return callback(new Error(`No module factory available for dependency type: ${dep.constructor.name}`));\n          }\n\n          compilation.buildQueue.increaseParallelism();\n          compilation.handleModuleCreation({\n            factory,\n            dependencies: [dep],\n            originModule: loaderContext._module,\n            contextInfo: {\n              issuerLayer: options.layer\n            },\n            context: loaderContext.context,\n            connectOrigin: false\n          }, err => {\n            compilation.buildQueue.decreaseParallelism();\n\n            if (err) {\n              return callback(err);\n            }\n\n            const referencedModule = moduleGraph.getModule(dep);\n\n            if (!referencedModule) {\n              return callback(new Error(\"Cannot load the module\"));\n            }\n\n            compilation.executeModule(referencedModule, {\n              entryOptions: {\n                baseUri: options.baseUri,\n                publicPath: options.publicPath\n              }\n            }, (err, result) => {\n              if (err) return callback(err);\n\n              for (const d of result.fileDependencies) {\n                loaderContext.addDependency(d);\n              }\n\n              for (const d of result.contextDependencies) {\n                loaderContext.addContextDependency(d);\n              }\n\n              for (const d of result.missingDependencies) {\n                loaderContext.addMissingDependency(d);\n              }\n\n              for (const d of result.buildDependencies) {\n                loaderContext.addBuildDependency(d);\n              }\n\n              if (result.cacheable === false) loaderContext.cacheable(false);\n\n              for (const [name, {\n                source,\n                info\n              }] of result.assets) {\n                const {\n                  buildInfo\n                } = loaderContext._module;\n\n                if (!buildInfo.assets) {\n                  buildInfo.assets = Object.create(null);\n                  buildInfo.assetsInfo = new Map();\n                }\n\n                buildInfo.assets[name] = source;\n                buildInfo.assetsInfo.set(name, info);\n              }\n\n              callback(null, result.exports);\n            });\n          });\n        };\n        /**\n         * @param {string} request the request string to load the module from\n         * @param {ImportModuleOptions} options options\n         * @param {ImportModuleCallback=} callback callback returning the exports\n         * @returns {Promise<any> | void} exports\n         */\n\n\n        loaderContext.importModule = (request, options, callback) => {\n          if (!callback) {\n            return new Promise((resolve, reject) => {\n              importModule(request, options || {}, (err, result) => {\n                if (err) reject(err);else resolve(result);\n              });\n            });\n          }\n\n          return importModule(request, options || {}, callback);\n        };\n      });\n    });\n  }\n\n}\n\nmodule.exports = LoaderPlugin;","map":{"version":3,"names":["NormalModule","require","LazySet","LoaderDependency","LoaderImportDependency","LoaderPlugin","constructor","options","apply","compiler","hooks","compilation","tap","normalModuleFactory","dependencyFactories","set","moduleGraph","getCompilationHooks","loader","loaderContext","loadModule","request","callback","dep","loc","name","factory","get","undefined","Error","buildQueue","increaseParallelism","handleModuleCreation","dependencies","originModule","_module","context","recursive","err","decreaseParallelism","referencedModule","getModule","getNumberOfErrors","moduleSource","originalSource","source","map","sourceAndMap","fileDependencies","contextDependencies","missingDependencies","buildDependencies","addCacheDependencies","d","addDependency","addContextDependency","addMissingDependency","addBuildDependency","importModule","contextInfo","issuerLayer","layer","connectOrigin","executeModule","entryOptions","baseUri","publicPath","result","cacheable","info","assets","buildInfo","Object","create","assetsInfo","Map","exports","Promise","resolve","reject","module"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/dependencies/LoaderPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NormalModule = require(\"../NormalModule\");\nconst LazySet = require(\"../util/LazySet\");\nconst LoaderDependency = require(\"./LoaderDependency\");\nconst LoaderImportDependency = require(\"./LoaderImportDependency\");\n\n/** @typedef {import(\"../Compilation\").DepConstructor} DepConstructor */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n\n/**\n * @callback LoadModuleCallback\n * @param {(Error | null)=} err error object\n * @param {string | Buffer=} source source code\n * @param {object=} map source map\n * @param {Module=} module loaded module if successful\n */\n\n/**\n * @callback ImportModuleCallback\n * @param {(Error | null)=} err error object\n * @param {any=} exports exports of the evaluated module\n */\n\n/**\n * @typedef {Object} ImportModuleOptions\n * @property {string=} layer the target layer\n * @property {string=} publicPath the target public path\n * @property {string=} baseUri target base uri\n */\n\nclass LoaderPlugin {\n\t/**\n\t * @param {Object} options options\n\t */\n\tconstructor(options = {}) {}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"LoaderPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tLoaderDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tLoaderImportDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.hooks.compilation.tap(\"LoaderPlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tNormalModule.getCompilationHooks(compilation).loader.tap(\n\t\t\t\t\"LoaderPlugin\",\n\t\t\t\tloaderContext => {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {LoadModuleCallback} callback callback returning the loaded module or error\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tloaderContext.loadModule = (request, callback) => {\n\t\t\t\t\t\tconst dep = new LoaderDependency(request);\n\t\t\t\t\t\tdep.loc = {\n\t\t\t\t\t\t\tname: request\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst factory = compilation.dependencyFactories.get(\n\t\t\t\t\t\t\t/** @type {DepConstructor} */ (dep.constructor)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (factory === undefined) {\n\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`No module factory available for dependency type: ${dep.constructor.name}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcompilation.buildQueue.increaseParallelism();\n\t\t\t\t\t\tcompilation.handleModuleCreation(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfactory,\n\t\t\t\t\t\t\t\tdependencies: [dep],\n\t\t\t\t\t\t\t\toriginModule: loaderContext._module,\n\t\t\t\t\t\t\t\tcontext: loaderContext.context,\n\t\t\t\t\t\t\t\trecursive: false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tcompilation.buildQueue.decreaseParallelism();\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedModule = moduleGraph.getModule(dep);\n\t\t\t\t\t\t\t\tif (!referencedModule) {\n\t\t\t\t\t\t\t\t\treturn callback(new Error(\"Cannot load the module\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (referencedModule.getNumberOfErrors() > 0) {\n\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\tnew Error(\"The loaded module contains errors\")\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst moduleSource = referencedModule.originalSource();\n\t\t\t\t\t\t\t\tif (!moduleSource) {\n\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\"The module created for a LoaderDependency must have an original source\"\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet source, map;\n\t\t\t\t\t\t\t\tif (moduleSource.sourceAndMap) {\n\t\t\t\t\t\t\t\t\tconst sourceAndMap = moduleSource.sourceAndMap();\n\t\t\t\t\t\t\t\t\tmap = sourceAndMap.map;\n\t\t\t\t\t\t\t\t\tsource = sourceAndMap.source;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tmap = moduleSource.map();\n\t\t\t\t\t\t\t\t\tsource = moduleSource.source();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst fileDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst contextDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst missingDependencies = new LazySet();\n\t\t\t\t\t\t\t\tconst buildDependencies = new LazySet();\n\t\t\t\t\t\t\t\treferencedModule.addCacheDependencies(\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tbuildDependencies\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tfor (const d of fileDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of contextDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addContextDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of missingDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addMissingDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const d of buildDependencies) {\n\t\t\t\t\t\t\t\t\tloaderContext.addBuildDependency(d);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback(null, source, map, referencedModule);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {ImportModuleOptions=} options options\n\t\t\t\t\t * @param {ImportModuleCallback=} callback callback returning the exports\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst importModule = (request, options, callback) => {\n\t\t\t\t\t\tconst dep = new LoaderImportDependency(request);\n\t\t\t\t\t\tdep.loc = {\n\t\t\t\t\t\t\tname: request\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst factory = compilation.dependencyFactories.get(\n\t\t\t\t\t\t\t/** @type {DepConstructor} */ (dep.constructor)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (factory === undefined) {\n\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t`No module factory available for dependency type: ${dep.constructor.name}`\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcompilation.buildQueue.increaseParallelism();\n\t\t\t\t\t\tcompilation.handleModuleCreation(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfactory,\n\t\t\t\t\t\t\t\tdependencies: [dep],\n\t\t\t\t\t\t\t\toriginModule: loaderContext._module,\n\t\t\t\t\t\t\t\tcontextInfo: {\n\t\t\t\t\t\t\t\t\tissuerLayer: options.layer\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcontext: loaderContext.context,\n\t\t\t\t\t\t\t\tconnectOrigin: false\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\tcompilation.buildQueue.decreaseParallelism();\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedModule = moduleGraph.getModule(dep);\n\t\t\t\t\t\t\t\tif (!referencedModule) {\n\t\t\t\t\t\t\t\t\treturn callback(new Error(\"Cannot load the module\"));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.executeModule(\n\t\t\t\t\t\t\t\t\treferencedModule,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tentryOptions: {\n\t\t\t\t\t\t\t\t\t\t\tbaseUri: options.baseUri,\n\t\t\t\t\t\t\t\t\t\t\tpublicPath: options.publicPath\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.fileDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.contextDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addContextDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.missingDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addMissingDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const d of result.buildDependencies) {\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.addBuildDependency(d);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (result.cacheable === false)\n\t\t\t\t\t\t\t\t\t\t\tloaderContext.cacheable(false);\n\t\t\t\t\t\t\t\t\t\tfor (const [name, { source, info }] of result.assets) {\n\t\t\t\t\t\t\t\t\t\t\tconst { buildInfo } = loaderContext._module;\n\t\t\t\t\t\t\t\t\t\t\tif (!buildInfo.assets) {\n\t\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assets = Object.create(null);\n\t\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assetsInfo = new Map();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assets[name] = source;\n\t\t\t\t\t\t\t\t\t\t\tbuildInfo.assetsInfo.set(name, info);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback(null, result.exports);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} request the request string to load the module from\n\t\t\t\t\t * @param {ImportModuleOptions} options options\n\t\t\t\t\t * @param {ImportModuleCallback=} callback callback returning the exports\n\t\t\t\t\t * @returns {Promise<any> | void} exports\n\t\t\t\t\t */\n\t\t\t\t\tloaderContext.importModule = (request, options, callback) => {\n\t\t\t\t\t\tif (!callback) {\n\t\t\t\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\timportModule(request, options || {}, (err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) reject(err);\n\t\t\t\t\t\t\t\t\telse resolve(result);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn importModule(request, options || {}, callback);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LoaderPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}