{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Dependency = require(\"./Dependency\");\n\nconst {\n  UsageState\n} = require(\"./ExportsInfo\");\n\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\n\nconst {\n  STAGE_DEFAULT\n} = require(\"./OptimizationStages\");\n\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n\nconst TupleQueue = require(\"./util/TupleQueue\");\n\nconst {\n  getEntryRuntime,\n  mergeRuntimeOwned\n} = require(\"./util/runtime\");\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./Dependency\").ReferencedExport} ReferencedExport */\n\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n\nconst {\n  NO_EXPORTS_REFERENCED,\n  EXPORTS_OBJECT_REFERENCED\n} = Dependency;\n\nclass FlagDependencyUsagePlugin {\n  /**\n   * @param {boolean} global do a global analysis instead of per runtime\n   */\n  constructor(global) {\n    this.global = global;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"FlagDependencyUsagePlugin\", compilation => {\n      const moduleGraph = compilation.moduleGraph;\n      compilation.hooks.optimizeDependencies.tap({\n        name: \"FlagDependencyUsagePlugin\",\n        stage: STAGE_DEFAULT\n      }, modules => {\n        if (compilation.moduleMemCaches) {\n          throw new Error(\"optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect\");\n        }\n\n        const logger = compilation.getLogger(\"webpack.FlagDependencyUsagePlugin\");\n        /** @type {Map<ExportsInfo, Module>} */\n\n        const exportInfoToModuleMap = new Map();\n        /** @type {TupleQueue<[Module, RuntimeSpec]>} */\n\n        const queue = new TupleQueue();\n        /**\n         * @param {Module} module module to process\n         * @param {(string[] | ReferencedExport)[]} usedExports list of used exports\n         * @param {RuntimeSpec} runtime part of which runtime\n         * @param {boolean} forceSideEffects always apply side effects\n         * @returns {void}\n         */\n\n        const processReferencedModule = (module, usedExports, runtime, forceSideEffects) => {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n\n          if (usedExports.length > 0) {\n            if (!module.buildMeta || !module.buildMeta.exportsType) {\n              if (exportsInfo.setUsedWithoutInfo(runtime)) {\n                queue.enqueue(module, runtime);\n              }\n\n              return;\n            }\n\n            for (const usedExportInfo of usedExports) {\n              let usedExport;\n              let canMangle = true;\n\n              if (Array.isArray(usedExportInfo)) {\n                usedExport = usedExportInfo;\n              } else {\n                usedExport = usedExportInfo.name;\n                canMangle = usedExportInfo.canMangle !== false;\n              }\n\n              if (usedExport.length === 0) {\n                if (exportsInfo.setUsedInUnknownWay(runtime)) {\n                  queue.enqueue(module, runtime);\n                }\n              } else {\n                let currentExportsInfo = exportsInfo;\n\n                for (let i = 0; i < usedExport.length; i++) {\n                  const exportInfo = currentExportsInfo.getExportInfo(usedExport[i]);\n\n                  if (canMangle === false) {\n                    exportInfo.canMangleUse = false;\n                  }\n\n                  const lastOne = i === usedExport.length - 1;\n\n                  if (!lastOne) {\n                    const nestedInfo = exportInfo.getNestedExportsInfo();\n\n                    if (nestedInfo) {\n                      if (exportInfo.setUsedConditionally(used => used === UsageState.Unused, UsageState.OnlyPropertiesUsed, runtime)) {\n                        const currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);\n\n                        if (currentModule) {\n                          queue.enqueue(currentModule, runtime);\n                        }\n                      }\n\n                      currentExportsInfo = nestedInfo;\n                      continue;\n                    }\n                  }\n\n                  if (exportInfo.setUsedConditionally(v => v !== UsageState.Used, UsageState.Used, runtime)) {\n                    const currentModule = currentExportsInfo === exportsInfo ? module : exportInfoToModuleMap.get(currentExportsInfo);\n\n                    if (currentModule) {\n                      queue.enqueue(currentModule, runtime);\n                    }\n                  }\n\n                  break;\n                }\n              }\n            }\n          } else {\n            // for a module without side effects we stop tracking usage here when no export is used\n            // This module won't be evaluated in this case\n            // TODO webpack 6 remove this check\n            if (!forceSideEffects && module.factoryMeta !== undefined && module.factoryMeta.sideEffectFree) {\n              return;\n            }\n\n            if (exportsInfo.setUsedForSideEffectsOnly(runtime)) {\n              queue.enqueue(module, runtime);\n            }\n          }\n        };\n        /**\n         * @param {DependenciesBlock} module the module\n         * @param {RuntimeSpec} runtime part of which runtime\n         * @param {boolean} forceSideEffects always apply side effects\n         * @returns {void}\n         */\n\n\n        const processModule = (module, runtime, forceSideEffects) => {\n          /** @type {Map<Module, (string[] | ReferencedExport)[] | Map<string, string[] | ReferencedExport>>} */\n          const map = new Map();\n          /** @type {ArrayQueue<DependenciesBlock>} */\n\n          const queue = new ArrayQueue();\n          queue.enqueue(module);\n\n          for (;;) {\n            const block = queue.dequeue();\n            if (block === undefined) break;\n\n            for (const b of block.blocks) {\n              if (!this.global && b.groupOptions && b.groupOptions.entryOptions) {\n                processModule(b, b.groupOptions.entryOptions.runtime || undefined, true);\n              } else {\n                queue.enqueue(b);\n              }\n            }\n\n            for (const dep of block.dependencies) {\n              const connection = moduleGraph.getConnection(dep);\n\n              if (!connection || !connection.module) {\n                continue;\n              }\n\n              const activeState = connection.getActiveState(runtime);\n              if (activeState === false) continue;\n              const {\n                module\n              } = connection;\n\n              if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n                processModule(module, runtime, false);\n                continue;\n              }\n\n              const oldReferencedExports = map.get(module);\n\n              if (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) {\n                continue;\n              }\n\n              const referencedExports = compilation.getDependencyReferencedExports(dep, runtime);\n\n              if (oldReferencedExports === undefined || oldReferencedExports === NO_EXPORTS_REFERENCED || referencedExports === EXPORTS_OBJECT_REFERENCED) {\n                map.set(module, referencedExports);\n              } else if (oldReferencedExports !== undefined && referencedExports === NO_EXPORTS_REFERENCED) {\n                continue;\n              } else {\n                let exportsMap;\n\n                if (Array.isArray(oldReferencedExports)) {\n                  exportsMap = new Map();\n\n                  for (const item of oldReferencedExports) {\n                    if (Array.isArray(item)) {\n                      exportsMap.set(item.join(\"\\n\"), item);\n                    } else {\n                      exportsMap.set(item.name.join(\"\\n\"), item);\n                    }\n                  }\n\n                  map.set(module, exportsMap);\n                } else {\n                  exportsMap = oldReferencedExports;\n                }\n\n                for (const item of referencedExports) {\n                  if (Array.isArray(item)) {\n                    const key = item.join(\"\\n\");\n                    const oldItem = exportsMap.get(key);\n\n                    if (oldItem === undefined) {\n                      exportsMap.set(key, item);\n                    } // if oldItem is already an array we have to do nothing\n                    // if oldItem is an ReferencedExport object, we don't have to do anything\n                    // as canMangle defaults to true for arrays\n\n                  } else {\n                    const key = item.name.join(\"\\n\");\n                    const oldItem = exportsMap.get(key);\n\n                    if (oldItem === undefined || Array.isArray(oldItem)) {\n                      exportsMap.set(key, item);\n                    } else {\n                      exportsMap.set(key, {\n                        name: item.name,\n                        canMangle: item.canMangle && oldItem.canMangle\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          for (const [module, referencedExports] of map) {\n            if (Array.isArray(referencedExports)) {\n              processReferencedModule(module, referencedExports, runtime, forceSideEffects);\n            } else {\n              processReferencedModule(module, Array.from(referencedExports.values()), runtime, forceSideEffects);\n            }\n          }\n        };\n\n        logger.time(\"initialize exports usage\");\n\n        for (const module of modules) {\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          exportInfoToModuleMap.set(exportsInfo, module);\n          exportsInfo.setHasUseInfo();\n        }\n\n        logger.timeEnd(\"initialize exports usage\");\n        logger.time(\"trace exports usage in graph\");\n        /**\n         * @param {Dependency} dep dependency\n         * @param {RuntimeSpec} runtime runtime\n         */\n\n        const processEntryDependency = (dep, runtime) => {\n          const module = moduleGraph.getModule(dep);\n\n          if (module) {\n            processReferencedModule(module, NO_EXPORTS_REFERENCED, runtime, true);\n          }\n        };\n        /** @type {RuntimeSpec} */\n\n\n        let globalRuntime = undefined;\n\n        for (const [entryName, {\n          dependencies: deps,\n          includeDependencies: includeDeps,\n          options\n        }] of compilation.entries) {\n          const runtime = this.global ? undefined : getEntryRuntime(compilation, entryName, options);\n\n          for (const dep of deps) {\n            processEntryDependency(dep, runtime);\n          }\n\n          for (const dep of includeDeps) {\n            processEntryDependency(dep, runtime);\n          }\n\n          globalRuntime = mergeRuntimeOwned(globalRuntime, runtime);\n        }\n\n        for (const dep of compilation.globalEntry.dependencies) {\n          processEntryDependency(dep, globalRuntime);\n        }\n\n        for (const dep of compilation.globalEntry.includeDependencies) {\n          processEntryDependency(dep, globalRuntime);\n        }\n\n        while (queue.length) {\n          const [module, runtime] = queue.dequeue();\n          processModule(module, runtime, false);\n        }\n\n        logger.timeEnd(\"trace exports usage in graph\");\n      });\n    });\n  }\n\n}\n\nmodule.exports = FlagDependencyUsagePlugin;","map":{"version":3,"names":["Dependency","require","UsageState","ModuleGraphConnection","STAGE_DEFAULT","ArrayQueue","TupleQueue","getEntryRuntime","mergeRuntimeOwned","NO_EXPORTS_REFERENCED","EXPORTS_OBJECT_REFERENCED","FlagDependencyUsagePlugin","constructor","global","apply","compiler","hooks","compilation","tap","moduleGraph","optimizeDependencies","name","stage","modules","moduleMemCaches","Error","logger","getLogger","exportInfoToModuleMap","Map","queue","processReferencedModule","module","usedExports","runtime","forceSideEffects","exportsInfo","getExportsInfo","length","buildMeta","exportsType","setUsedWithoutInfo","enqueue","usedExportInfo","usedExport","canMangle","Array","isArray","setUsedInUnknownWay","currentExportsInfo","i","exportInfo","getExportInfo","canMangleUse","lastOne","nestedInfo","getNestedExportsInfo","setUsedConditionally","used","Unused","OnlyPropertiesUsed","currentModule","get","v","Used","factoryMeta","undefined","sideEffectFree","setUsedForSideEffectsOnly","processModule","map","block","dequeue","b","blocks","groupOptions","entryOptions","dep","dependencies","connection","getConnection","activeState","getActiveState","TRANSITIVE_ONLY","oldReferencedExports","referencedExports","getDependencyReferencedExports","set","exportsMap","item","join","key","oldItem","from","values","time","setHasUseInfo","timeEnd","processEntryDependency","getModule","globalRuntime","entryName","deps","includeDependencies","includeDeps","options","entries","globalEntry","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/FlagDependencyUsagePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst Dependency = require(\"./Dependency\");\nconst { UsageState } = require(\"./ExportsInfo\");\nconst ModuleGraphConnection = require(\"./ModuleGraphConnection\");\nconst { STAGE_DEFAULT } = require(\"./OptimizationStages\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\nconst TupleQueue = require(\"./util/TupleQueue\");\nconst { getEntryRuntime, mergeRuntimeOwned } = require(\"./util/runtime\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\").ReferencedExport} ReferencedExport */\n/** @typedef {import(\"./ExportsInfo\")} ExportsInfo */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\nconst { NO_EXPORTS_REFERENCED, EXPORTS_OBJECT_REFERENCED } = Dependency;\n\nclass FlagDependencyUsagePlugin {\n\t/**\n\t * @param {boolean} global do a global analysis instead of per runtime\n\t */\n\tconstructor(global) {\n\t\tthis.global = global;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"FlagDependencyUsagePlugin\", compilation => {\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t{\n\t\t\t\t\tname: \"FlagDependencyUsagePlugin\",\n\t\t\t\t\tstage: STAGE_DEFAULT\n\t\t\t\t},\n\t\t\t\tmodules => {\n\t\t\t\t\tif (compilation.moduleMemCaches) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\"webpack.FlagDependencyUsagePlugin\"\n\t\t\t\t\t);\n\t\t\t\t\t/** @type {Map<ExportsInfo, Module>} */\n\t\t\t\t\tconst exportInfoToModuleMap = new Map();\n\n\t\t\t\t\t/** @type {TupleQueue<[Module, RuntimeSpec]>} */\n\t\t\t\t\tconst queue = new TupleQueue();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Module} module module to process\n\t\t\t\t\t * @param {(string[] | ReferencedExport)[]} usedExports list of used exports\n\t\t\t\t\t * @param {RuntimeSpec} runtime part of which runtime\n\t\t\t\t\t * @param {boolean} forceSideEffects always apply side effects\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst processReferencedModule = (\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tusedExports,\n\t\t\t\t\t\truntime,\n\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t) => {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tif (usedExports.length > 0) {\n\t\t\t\t\t\t\tif (!module.buildMeta || !module.buildMeta.exportsType) {\n\t\t\t\t\t\t\t\tif (exportsInfo.setUsedWithoutInfo(runtime)) {\n\t\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const usedExportInfo of usedExports) {\n\t\t\t\t\t\t\t\tlet usedExport;\n\t\t\t\t\t\t\t\tlet canMangle = true;\n\t\t\t\t\t\t\t\tif (Array.isArray(usedExportInfo)) {\n\t\t\t\t\t\t\t\t\tusedExport = usedExportInfo;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tusedExport = usedExportInfo.name;\n\t\t\t\t\t\t\t\t\tcanMangle = usedExportInfo.canMangle !== false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (usedExport.length === 0) {\n\t\t\t\t\t\t\t\t\tif (exportsInfo.setUsedInUnknownWay(runtime)) {\n\t\t\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlet currentExportsInfo = exportsInfo;\n\t\t\t\t\t\t\t\t\tfor (let i = 0; i < usedExport.length; i++) {\n\t\t\t\t\t\t\t\t\t\tconst exportInfo = currentExportsInfo.getExportInfo(\n\t\t\t\t\t\t\t\t\t\t\tusedExport[i]\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (canMangle === false) {\n\t\t\t\t\t\t\t\t\t\t\texportInfo.canMangleUse = false;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst lastOne = i === usedExport.length - 1;\n\t\t\t\t\t\t\t\t\t\tif (!lastOne) {\n\t\t\t\t\t\t\t\t\t\t\tconst nestedInfo = exportInfo.getNestedExportsInfo();\n\t\t\t\t\t\t\t\t\t\t\tif (nestedInfo) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t\t\texportInfo.setUsedConditionally(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tused => used === UsageState.Unused,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tUsageState.OnlyPropertiesUsed,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst currentModule =\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo === exportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? module\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfoToModuleMap.get(currentExportsInfo);\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (currentModule) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(currentModule, runtime);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo = nestedInfo;\n\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\texportInfo.setUsedConditionally(\n\t\t\t\t\t\t\t\t\t\t\t\tv => v !== UsageState.Used,\n\t\t\t\t\t\t\t\t\t\t\t\tUsageState.Used,\n\t\t\t\t\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tconst currentModule =\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentExportsInfo === exportsInfo\n\t\t\t\t\t\t\t\t\t\t\t\t\t? module\n\t\t\t\t\t\t\t\t\t\t\t\t\t: exportInfoToModuleMap.get(currentExportsInfo);\n\t\t\t\t\t\t\t\t\t\t\tif (currentModule) {\n\t\t\t\t\t\t\t\t\t\t\t\tqueue.enqueue(currentModule, runtime);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// for a module without side effects we stop tracking usage here when no export is used\n\t\t\t\t\t\t\t// This module won't be evaluated in this case\n\t\t\t\t\t\t\t// TODO webpack 6 remove this check\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!forceSideEffects &&\n\t\t\t\t\t\t\t\tmodule.factoryMeta !== undefined &&\n\t\t\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (exportsInfo.setUsedForSideEffectsOnly(runtime)) {\n\t\t\t\t\t\t\t\tqueue.enqueue(module, runtime);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {DependenciesBlock} module the module\n\t\t\t\t\t * @param {RuntimeSpec} runtime part of which runtime\n\t\t\t\t\t * @param {boolean} forceSideEffects always apply side effects\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst processModule = (module, runtime, forceSideEffects) => {\n\t\t\t\t\t\t/** @type {Map<Module, (string[] | ReferencedExport)[] | Map<string, string[] | ReferencedExport>>} */\n\t\t\t\t\t\tconst map = new Map();\n\n\t\t\t\t\t\t/** @type {ArrayQueue<DependenciesBlock>} */\n\t\t\t\t\t\tconst queue = new ArrayQueue();\n\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\t\tconst block = queue.dequeue();\n\t\t\t\t\t\t\tif (block === undefined) break;\n\t\t\t\t\t\t\tfor (const b of block.blocks) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t!this.global &&\n\t\t\t\t\t\t\t\t\tb.groupOptions &&\n\t\t\t\t\t\t\t\t\tb.groupOptions.entryOptions\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tprocessModule(\n\t\t\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\t\t\tb.groupOptions.entryOptions.runtime || undefined,\n\t\t\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tqueue.enqueue(b);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const dep of block.dependencies) {\n\t\t\t\t\t\t\t\tconst connection = moduleGraph.getConnection(dep);\n\t\t\t\t\t\t\t\tif (!connection || !connection.module) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst activeState = connection.getActiveState(runtime);\n\t\t\t\t\t\t\t\tif (activeState === false) continue;\n\t\t\t\t\t\t\t\tconst { module } = connection;\n\t\t\t\t\t\t\t\tif (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {\n\t\t\t\t\t\t\t\t\tprocessModule(module, runtime, false);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst oldReferencedExports = map.get(module);\n\t\t\t\t\t\t\t\tif (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst referencedExports =\n\t\t\t\t\t\t\t\t\tcompilation.getDependencyReferencedExports(dep, runtime);\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\toldReferencedExports === undefined ||\n\t\t\t\t\t\t\t\t\toldReferencedExports === NO_EXPORTS_REFERENCED ||\n\t\t\t\t\t\t\t\t\treferencedExports === EXPORTS_OBJECT_REFERENCED\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tmap.set(module, referencedExports);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\toldReferencedExports !== undefined &&\n\t\t\t\t\t\t\t\t\treferencedExports === NO_EXPORTS_REFERENCED\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tlet exportsMap;\n\t\t\t\t\t\t\t\t\tif (Array.isArray(oldReferencedExports)) {\n\t\t\t\t\t\t\t\t\t\texportsMap = new Map();\n\t\t\t\t\t\t\t\t\t\tfor (const item of oldReferencedExports) {\n\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(item.join(\"\\n\"), item);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(item.name.join(\"\\n\"), item);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tmap.set(module, exportsMap);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\texportsMap = oldReferencedExports;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfor (const item of referencedExports) {\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(item)) {\n\t\t\t\t\t\t\t\t\t\t\tconst key = item.join(\"\\n\");\n\t\t\t\t\t\t\t\t\t\t\tconst oldItem = exportsMap.get(key);\n\t\t\t\t\t\t\t\t\t\t\tif (oldItem === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, item);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// if oldItem is already an array we have to do nothing\n\t\t\t\t\t\t\t\t\t\t\t// if oldItem is an ReferencedExport object, we don't have to do anything\n\t\t\t\t\t\t\t\t\t\t\t// as canMangle defaults to true for arrays\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tconst key = item.name.join(\"\\n\");\n\t\t\t\t\t\t\t\t\t\t\tconst oldItem = exportsMap.get(key);\n\t\t\t\t\t\t\t\t\t\t\tif (oldItem === undefined || Array.isArray(oldItem)) {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, item);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\texportsMap.set(key, {\n\t\t\t\t\t\t\t\t\t\t\t\t\tname: item.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcanMangle: item.canMangle && oldItem.canMangle\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const [module, referencedExports] of map) {\n\t\t\t\t\t\t\tif (Array.isArray(referencedExports)) {\n\t\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\treferencedExports,\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\tArray.from(referencedExports.values()),\n\t\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\t\tforceSideEffects\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tlogger.time(\"initialize exports usage\");\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\texportInfoToModuleMap.set(exportsInfo, module);\n\t\t\t\t\t\texportsInfo.setHasUseInfo();\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"initialize exports usage\");\n\n\t\t\t\t\tlogger.time(\"trace exports usage in graph\");\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Dependency} dep dependency\n\t\t\t\t\t * @param {RuntimeSpec} runtime runtime\n\t\t\t\t\t */\n\t\t\t\t\tconst processEntryDependency = (dep, runtime) => {\n\t\t\t\t\t\tconst module = moduleGraph.getModule(dep);\n\t\t\t\t\t\tif (module) {\n\t\t\t\t\t\t\tprocessReferencedModule(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tNO_EXPORTS_REFERENCED,\n\t\t\t\t\t\t\t\truntime,\n\t\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t/** @type {RuntimeSpec} */\n\t\t\t\t\tlet globalRuntime = undefined;\n\t\t\t\t\tfor (const [\n\t\t\t\t\t\tentryName,\n\t\t\t\t\t\t{ dependencies: deps, includeDependencies: includeDeps, options }\n\t\t\t\t\t] of compilation.entries) {\n\t\t\t\t\t\tconst runtime = this.global\n\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t: getEntryRuntime(compilation, entryName, options);\n\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\tprocessEntryDependency(dep, runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const dep of includeDeps) {\n\t\t\t\t\t\t\tprocessEntryDependency(dep, runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tglobalRuntime = mergeRuntimeOwned(globalRuntime, runtime);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const dep of compilation.globalEntry.dependencies) {\n\t\t\t\t\t\tprocessEntryDependency(dep, globalRuntime);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const dep of compilation.globalEntry.includeDependencies) {\n\t\t\t\t\t\tprocessEntryDependency(dep, globalRuntime);\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (queue.length) {\n\t\t\t\t\t\tconst [module, runtime] = queue.dequeue();\n\t\t\t\t\t\tprocessModule(module, runtime, false);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"trace exports usage in graph\");\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = FlagDependencyUsagePlugin;\n"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,UAAU,GAAGC,OAAO,CAAC,cAAD,CAA1B;;AACA,MAAM;EAAEC;AAAF,IAAiBD,OAAO,CAAC,eAAD,CAA9B;;AACA,MAAME,qBAAqB,GAAGF,OAAO,CAAC,yBAAD,CAArC;;AACA,MAAM;EAAEG;AAAF,IAAoBH,OAAO,CAAC,sBAAD,CAAjC;;AACA,MAAMI,UAAU,GAAGJ,OAAO,CAAC,mBAAD,CAA1B;;AACA,MAAMK,UAAU,GAAGL,OAAO,CAAC,mBAAD,CAA1B;;AACA,MAAM;EAAEM,eAAF;EAAmBC;AAAnB,IAAyCP,OAAO,CAAC,gBAAD,CAAtD;AAEA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;AAEA,MAAM;EAAEQ,qBAAF;EAAyBC;AAAzB,IAAuDV,UAA7D;;AAEA,MAAMW,yBAAN,CAAgC;EAC/B;AACD;AACA;EACCC,WAAW,CAACC,MAAD,EAAS;IACnB,KAAKA,MAAL,GAAcA,MAAd;EACA;EAED;AACD;AACA;AACA;AACA;;;EACCC,KAAK,CAACC,QAAD,EAAW;IACfA,QAAQ,CAACC,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CAA+B,2BAA/B,EAA4DD,WAAW,IAAI;MAC1E,MAAME,WAAW,GAAGF,WAAW,CAACE,WAAhC;MACAF,WAAW,CAACD,KAAZ,CAAkBI,oBAAlB,CAAuCF,GAAvC,CACC;QACCG,IAAI,EAAE,2BADP;QAECC,KAAK,EAAElB;MAFR,CADD,EAKCmB,OAAO,IAAI;QACV,IAAIN,WAAW,CAACO,eAAhB,EAAiC;UAChC,MAAM,IAAIC,KAAJ,CACL,gGADK,CAAN;QAGA;;QAED,MAAMC,MAAM,GAAGT,WAAW,CAACU,SAAZ,CACd,mCADc,CAAf;QAGA;;QACA,MAAMC,qBAAqB,GAAG,IAAIC,GAAJ,EAA9B;QAEA;;QACA,MAAMC,KAAK,GAAG,IAAIxB,UAAJ,EAAd;QAEA;AACL;AACA;AACA;AACA;AACA;AACA;;QACK,MAAMyB,uBAAuB,GAAG,CAC/BC,MAD+B,EAE/BC,WAF+B,EAG/BC,OAH+B,EAI/BC,gBAJ+B,KAK3B;UACJ,MAAMC,WAAW,GAAGjB,WAAW,CAACkB,cAAZ,CAA2BL,MAA3B,CAApB;;UACA,IAAIC,WAAW,CAACK,MAAZ,GAAqB,CAAzB,EAA4B;YAC3B,IAAI,CAACN,MAAM,CAACO,SAAR,IAAqB,CAACP,MAAM,CAACO,SAAP,CAAiBC,WAA3C,EAAwD;cACvD,IAAIJ,WAAW,CAACK,kBAAZ,CAA+BP,OAA/B,CAAJ,EAA6C;gBAC5CJ,KAAK,CAACY,OAAN,CAAcV,MAAd,EAAsBE,OAAtB;cACA;;cACD;YACA;;YACD,KAAK,MAAMS,cAAX,IAA6BV,WAA7B,EAA0C;cACzC,IAAIW,UAAJ;cACA,IAAIC,SAAS,GAAG,IAAhB;;cACA,IAAIC,KAAK,CAACC,OAAN,CAAcJ,cAAd,CAAJ,EAAmC;gBAClCC,UAAU,GAAGD,cAAb;cACA,CAFD,MAEO;gBACNC,UAAU,GAAGD,cAAc,CAACtB,IAA5B;gBACAwB,SAAS,GAAGF,cAAc,CAACE,SAAf,KAA6B,KAAzC;cACA;;cACD,IAAID,UAAU,CAACN,MAAX,KAAsB,CAA1B,EAA6B;gBAC5B,IAAIF,WAAW,CAACY,mBAAZ,CAAgCd,OAAhC,CAAJ,EAA8C;kBAC7CJ,KAAK,CAACY,OAAN,CAAcV,MAAd,EAAsBE,OAAtB;gBACA;cACD,CAJD,MAIO;gBACN,IAAIe,kBAAkB,GAAGb,WAAzB;;gBACA,KAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,UAAU,CAACN,MAA/B,EAAuCY,CAAC,EAAxC,EAA4C;kBAC3C,MAAMC,UAAU,GAAGF,kBAAkB,CAACG,aAAnB,CAClBR,UAAU,CAACM,CAAD,CADQ,CAAnB;;kBAGA,IAAIL,SAAS,KAAK,KAAlB,EAAyB;oBACxBM,UAAU,CAACE,YAAX,GAA0B,KAA1B;kBACA;;kBACD,MAAMC,OAAO,GAAGJ,CAAC,KAAKN,UAAU,CAACN,MAAX,GAAoB,CAA1C;;kBACA,IAAI,CAACgB,OAAL,EAAc;oBACb,MAAMC,UAAU,GAAGJ,UAAU,CAACK,oBAAX,EAAnB;;oBACA,IAAID,UAAJ,EAAgB;sBACf,IACCJ,UAAU,CAACM,oBAAX,CACCC,IAAI,IAAIA,IAAI,KAAKxD,UAAU,CAACyD,MAD7B,EAECzD,UAAU,CAAC0D,kBAFZ,EAGC1B,OAHD,CADD,EAME;wBACD,MAAM2B,aAAa,GAClBZ,kBAAkB,KAAKb,WAAvB,GACGJ,MADH,GAEGJ,qBAAqB,CAACkC,GAAtB,CAA0Bb,kBAA1B,CAHJ;;wBAIA,IAAIY,aAAJ,EAAmB;0BAClB/B,KAAK,CAACY,OAAN,CAAcmB,aAAd,EAA6B3B,OAA7B;wBACA;sBACD;;sBACDe,kBAAkB,GAAGM,UAArB;sBACA;oBACA;kBACD;;kBACD,IACCJ,UAAU,CAACM,oBAAX,CACCM,CAAC,IAAIA,CAAC,KAAK7D,UAAU,CAAC8D,IADvB,EAEC9D,UAAU,CAAC8D,IAFZ,EAGC9B,OAHD,CADD,EAME;oBACD,MAAM2B,aAAa,GAClBZ,kBAAkB,KAAKb,WAAvB,GACGJ,MADH,GAEGJ,qBAAqB,CAACkC,GAAtB,CAA0Bb,kBAA1B,CAHJ;;oBAIA,IAAIY,aAAJ,EAAmB;sBAClB/B,KAAK,CAACY,OAAN,CAAcmB,aAAd,EAA6B3B,OAA7B;oBACA;kBACD;;kBACD;gBACA;cACD;YACD;UACD,CAvED,MAuEO;YACN;YACA;YACA;YACA,IACC,CAACC,gBAAD,IACAH,MAAM,CAACiC,WAAP,KAAuBC,SADvB,IAEAlC,MAAM,CAACiC,WAAP,CAAmBE,cAHpB,EAIE;cACD;YACA;;YACD,IAAI/B,WAAW,CAACgC,yBAAZ,CAAsClC,OAAtC,CAAJ,EAAoD;cACnDJ,KAAK,CAACY,OAAN,CAAcV,MAAd,EAAsBE,OAAtB;YACA;UACD;QACD,CA7FD;QA+FA;AACL;AACA;AACA;AACA;AACA;;;QACK,MAAMmC,aAAa,GAAG,CAACrC,MAAD,EAASE,OAAT,EAAkBC,gBAAlB,KAAuC;UAC5D;UACA,MAAMmC,GAAG,GAAG,IAAIzC,GAAJ,EAAZ;UAEA;;UACA,MAAMC,KAAK,GAAG,IAAIzB,UAAJ,EAAd;UACAyB,KAAK,CAACY,OAAN,CAAcV,MAAd;;UACA,SAAS;YACR,MAAMuC,KAAK,GAAGzC,KAAK,CAAC0C,OAAN,EAAd;YACA,IAAID,KAAK,KAAKL,SAAd,EAAyB;;YACzB,KAAK,MAAMO,CAAX,IAAgBF,KAAK,CAACG,MAAtB,EAA8B;cAC7B,IACC,CAAC,KAAK7D,MAAN,IACA4D,CAAC,CAACE,YADF,IAEAF,CAAC,CAACE,YAAF,CAAeC,YAHhB,EAIE;gBACDP,aAAa,CACZI,CADY,EAEZA,CAAC,CAACE,YAAF,CAAeC,YAAf,CAA4B1C,OAA5B,IAAuCgC,SAF3B,EAGZ,IAHY,CAAb;cAKA,CAVD,MAUO;gBACNpC,KAAK,CAACY,OAAN,CAAc+B,CAAd;cACA;YACD;;YACD,KAAK,MAAMI,GAAX,IAAkBN,KAAK,CAACO,YAAxB,EAAsC;cACrC,MAAMC,UAAU,GAAG5D,WAAW,CAAC6D,aAAZ,CAA0BH,GAA1B,CAAnB;;cACA,IAAI,CAACE,UAAD,IAAe,CAACA,UAAU,CAAC/C,MAA/B,EAAuC;gBACtC;cACA;;cACD,MAAMiD,WAAW,GAAGF,UAAU,CAACG,cAAX,CAA0BhD,OAA1B,CAApB;cACA,IAAI+C,WAAW,KAAK,KAApB,EAA2B;cAC3B,MAAM;gBAAEjD;cAAF,IAAa+C,UAAnB;;cACA,IAAIE,WAAW,KAAK9E,qBAAqB,CAACgF,eAA1C,EAA2D;gBAC1Dd,aAAa,CAACrC,MAAD,EAASE,OAAT,EAAkB,KAAlB,CAAb;gBACA;cACA;;cACD,MAAMkD,oBAAoB,GAAGd,GAAG,CAACR,GAAJ,CAAQ9B,MAAR,CAA7B;;cACA,IAAIoD,oBAAoB,KAAK1E,yBAA7B,EAAwD;gBACvD;cACA;;cACD,MAAM2E,iBAAiB,GACtBpE,WAAW,CAACqE,8BAAZ,CAA2CT,GAA3C,EAAgD3C,OAAhD,CADD;;cAEA,IACCkD,oBAAoB,KAAKlB,SAAzB,IACAkB,oBAAoB,KAAK3E,qBADzB,IAEA4E,iBAAiB,KAAK3E,yBAHvB,EAIE;gBACD4D,GAAG,CAACiB,GAAJ,CAAQvD,MAAR,EAAgBqD,iBAAhB;cACA,CAND,MAMO,IACND,oBAAoB,KAAKlB,SAAzB,IACAmB,iBAAiB,KAAK5E,qBAFhB,EAGL;gBACD;cACA,CALM,MAKA;gBACN,IAAI+E,UAAJ;;gBACA,IAAI1C,KAAK,CAACC,OAAN,CAAcqC,oBAAd,CAAJ,EAAyC;kBACxCI,UAAU,GAAG,IAAI3D,GAAJ,EAAb;;kBACA,KAAK,MAAM4D,IAAX,IAAmBL,oBAAnB,EAAyC;oBACxC,IAAItC,KAAK,CAACC,OAAN,CAAc0C,IAAd,CAAJ,EAAyB;sBACxBD,UAAU,CAACD,GAAX,CAAeE,IAAI,CAACC,IAAL,CAAU,IAAV,CAAf,EAAgCD,IAAhC;oBACA,CAFD,MAEO;sBACND,UAAU,CAACD,GAAX,CAAeE,IAAI,CAACpE,IAAL,CAAUqE,IAAV,CAAe,IAAf,CAAf,EAAqCD,IAArC;oBACA;kBACD;;kBACDnB,GAAG,CAACiB,GAAJ,CAAQvD,MAAR,EAAgBwD,UAAhB;gBACA,CAVD,MAUO;kBACNA,UAAU,GAAGJ,oBAAb;gBACA;;gBACD,KAAK,MAAMK,IAAX,IAAmBJ,iBAAnB,EAAsC;kBACrC,IAAIvC,KAAK,CAACC,OAAN,CAAc0C,IAAd,CAAJ,EAAyB;oBACxB,MAAME,GAAG,GAAGF,IAAI,CAACC,IAAL,CAAU,IAAV,CAAZ;oBACA,MAAME,OAAO,GAAGJ,UAAU,CAAC1B,GAAX,CAAe6B,GAAf,CAAhB;;oBACA,IAAIC,OAAO,KAAK1B,SAAhB,EAA2B;sBAC1BsB,UAAU,CAACD,GAAX,CAAeI,GAAf,EAAoBF,IAApB;oBACA,CALuB,CAMxB;oBACA;oBACA;;kBACA,CATD,MASO;oBACN,MAAME,GAAG,GAAGF,IAAI,CAACpE,IAAL,CAAUqE,IAAV,CAAe,IAAf,CAAZ;oBACA,MAAME,OAAO,GAAGJ,UAAU,CAAC1B,GAAX,CAAe6B,GAAf,CAAhB;;oBACA,IAAIC,OAAO,KAAK1B,SAAZ,IAAyBpB,KAAK,CAACC,OAAN,CAAc6C,OAAd,CAA7B,EAAqD;sBACpDJ,UAAU,CAACD,GAAX,CAAeI,GAAf,EAAoBF,IAApB;oBACA,CAFD,MAEO;sBACND,UAAU,CAACD,GAAX,CAAeI,GAAf,EAAoB;wBACnBtE,IAAI,EAAEoE,IAAI,CAACpE,IADQ;wBAEnBwB,SAAS,EAAE4C,IAAI,CAAC5C,SAAL,IAAkB+C,OAAO,CAAC/C;sBAFlB,CAApB;oBAIA;kBACD;gBACD;cACD;YACD;UACD;;UAED,KAAK,MAAM,CAACb,MAAD,EAASqD,iBAAT,CAAX,IAA0Cf,GAA1C,EAA+C;YAC9C,IAAIxB,KAAK,CAACC,OAAN,CAAcsC,iBAAd,CAAJ,EAAsC;cACrCtD,uBAAuB,CACtBC,MADsB,EAEtBqD,iBAFsB,EAGtBnD,OAHsB,EAItBC,gBAJsB,CAAvB;YAMA,CAPD,MAOO;cACNJ,uBAAuB,CACtBC,MADsB,EAEtBc,KAAK,CAAC+C,IAAN,CAAWR,iBAAiB,CAACS,MAAlB,EAAX,CAFsB,EAGtB5D,OAHsB,EAItBC,gBAJsB,CAAvB;YAMA;UACD;QACD,CAjHD;;QAmHAT,MAAM,CAACqE,IAAP,CAAY,0BAAZ;;QACA,KAAK,MAAM/D,MAAX,IAAqBT,OAArB,EAA8B;UAC7B,MAAMa,WAAW,GAAGjB,WAAW,CAACkB,cAAZ,CAA2BL,MAA3B,CAApB;UACAJ,qBAAqB,CAAC2D,GAAtB,CAA0BnD,WAA1B,EAAuCJ,MAAvC;UACAI,WAAW,CAAC4D,aAAZ;QACA;;QACDtE,MAAM,CAACuE,OAAP,CAAe,0BAAf;QAEAvE,MAAM,CAACqE,IAAP,CAAY,8BAAZ;QAEA;AACL;AACA;AACA;;QACK,MAAMG,sBAAsB,GAAG,CAACrB,GAAD,EAAM3C,OAAN,KAAkB;UAChD,MAAMF,MAAM,GAAGb,WAAW,CAACgF,SAAZ,CAAsBtB,GAAtB,CAAf;;UACA,IAAI7C,MAAJ,EAAY;YACXD,uBAAuB,CACtBC,MADsB,EAEtBvB,qBAFsB,EAGtByB,OAHsB,EAItB,IAJsB,CAAvB;UAMA;QACD,CAVD;QAWA;;;QACA,IAAIkE,aAAa,GAAGlC,SAApB;;QACA,KAAK,MAAM,CACVmC,SADU,EAEV;UAAEvB,YAAY,EAAEwB,IAAhB;UAAsBC,mBAAmB,EAAEC,WAA3C;UAAwDC;QAAxD,CAFU,CAAX,IAGKxF,WAAW,CAACyF,OAHjB,EAG0B;UACzB,MAAMxE,OAAO,GAAG,KAAKrB,MAAL,GACbqD,SADa,GAEb3D,eAAe,CAACU,WAAD,EAAcoF,SAAd,EAAyBI,OAAzB,CAFlB;;UAGA,KAAK,MAAM5B,GAAX,IAAkByB,IAAlB,EAAwB;YACvBJ,sBAAsB,CAACrB,GAAD,EAAM3C,OAAN,CAAtB;UACA;;UACD,KAAK,MAAM2C,GAAX,IAAkB2B,WAAlB,EAA+B;YAC9BN,sBAAsB,CAACrB,GAAD,EAAM3C,OAAN,CAAtB;UACA;;UACDkE,aAAa,GAAG5F,iBAAiB,CAAC4F,aAAD,EAAgBlE,OAAhB,CAAjC;QACA;;QACD,KAAK,MAAM2C,GAAX,IAAkB5D,WAAW,CAAC0F,WAAZ,CAAwB7B,YAA1C,EAAwD;UACvDoB,sBAAsB,CAACrB,GAAD,EAAMuB,aAAN,CAAtB;QACA;;QACD,KAAK,MAAMvB,GAAX,IAAkB5D,WAAW,CAAC0F,WAAZ,CAAwBJ,mBAA1C,EAA+D;UAC9DL,sBAAsB,CAACrB,GAAD,EAAMuB,aAAN,CAAtB;QACA;;QAED,OAAOtE,KAAK,CAACQ,MAAb,EAAqB;UACpB,MAAM,CAACN,MAAD,EAASE,OAAT,IAAoBJ,KAAK,CAAC0C,OAAN,EAA1B;UACAH,aAAa,CAACrC,MAAD,EAASE,OAAT,EAAkB,KAAlB,CAAb;QACA;;QACDR,MAAM,CAACuE,OAAP,CAAe,8BAAf;MACA,CA1SF;IA4SA,CA9SD;EA+SA;;AA7T8B;;AAgUhCjE,MAAM,CAAC4E,OAAP,GAAiBjG,yBAAjB"},"metadata":{},"sourceType":"script"}