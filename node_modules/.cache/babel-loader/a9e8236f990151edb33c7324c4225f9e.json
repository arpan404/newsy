{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\n\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\n\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\n\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache(nodeInterop);\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n      FUNC_HANGING_STATEMENT = 2,\n      FUNC_NULLABLE_ID = 4;\n\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor() {\n      super(...arguments);\n      this.assertToken = new TokenType(keyword);\n    }\n\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n\n      this.next();\n    }\n\n    readToken(code) {\n      let i = 0;\n\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      } // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n\n\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      } // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n\n\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n      // Parse node.source.\n\n      node.source = this.parseMaybeAssign();\n\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n\n      this._eat(tt.parenR);\n\n      return this.finishNode(node, \"ImportExpression\");\n    } // ported from acorn/src/statement.js pp.parseExport\n\n\n    parseExport(node, exports) {\n      this.next(); // export * from '...'\n\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n\n        this.expectContextual(\"from\");\n\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n\n        node.source = this.parseExprAtom();\n\n        if (this.type === this.assertToken) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n\n          if (isAsync) {\n            this.next();\n          }\n\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      } // export var|const|let|function|class ...\n\n\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local); // check if export is defined\n\n            this.checkLocalExport(spec.local);\n          }\n\n          node.source = null;\n        }\n\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    parseImport(node) {\n      this.next(); // import '...'\n\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n\n      if (this.type === this.assertToken) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n\n      const attrs = this.parseAssertEntries();\n\n      this._eat(tt.braceR);\n\n      return attrs;\n    }\n\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n\n        const node = this.startNode(); // parse AssertionKey : IdentifierName, StringLiteral\n\n        let assertionKeyNode;\n\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n\n        this.next();\n        node.key = assertionKeyNode; // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n\n        attrNames.add(node.key.name);\n\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n\n      return attrs;\n    }\n\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","importAssertions","_acorn","_interopRequireWildcard","require","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","leftCurlyBrace","charCodeAt","space","keyword","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","Parser","acorn","tokTypes","tt","TokenType","constructor","assertToken","_codeAt","i","input","_eat","t","type","unexpected","next","readToken","code","length","pos","label","finishToken","parseDynamicImport","node","source","parseMaybeAssign","eat","comma","parseObj","arguments","parenR","finishNode","parseExport","star","options","ecmaVersion","eatContextual","exported","parseIdent","checkExport","name","lastTokStart","expectContextual","string","parseExprAtom","assertions","parseImportAssertions","semicolon","_default","isAsync","_function","isAsyncFunction","fNode","startNode","declaration","parseFunction","_class","cNode","parseClass","shouldParseExportStatement","parseStatement","checkVariableExport","declarations","id","start","specifiers","parseExportSpecifiers","list","spec","checkUnreserved","local","checkLocalExport","parseImport","parseImportSpecifiers","braceL","attrs","parseAssertEntries","braceR","attrNames","Set","assertionKeyNode","parseLiteral","raise","add","push"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/acorn-import-assertions/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAssertions = importAssertions;\n\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst keyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n      FUNC_HANGING_STATEMENT = 2,\n      FUNC_NULLABLE_ID = 4;\n\nfunction importAssertions(Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.assertToken = new TokenType(keyword);\n    }\n\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n\n      this.next();\n    }\n\n    readToken(code) {\n      let i = 0;\n\n      for (; i < keyword.length; i++) {\n        if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n          return super.readToken(code);\n        }\n      } // ensure that the keyword is at the correct location\n      // ie `assert{...` or `assert {...`\n\n\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `assert` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      } // If we're inside a dynamic import expression we'll parse\n      // the `assert` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { assert: { type: \"json\" } })`\n\n\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n\n      this.pos += keyword.length;\n      return this.finishToken(this.assertToken);\n    }\n\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n      // Parse node.source.\n\n      node.source = this.parseMaybeAssign();\n\n      if (this.eat(tt.comma)) {\n        const obj = this.parseObj(false);\n        node.arguments = [obj];\n      }\n\n      this._eat(tt.parenR);\n\n      return this.finishNode(node, \"ImportExpression\");\n    } // ported from acorn/src/statement.js pp.parseExport\n\n\n    parseExport(node, exports) {\n      this.next(); // export * from '...'\n\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n\n        this.expectContextual(\"from\");\n\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n\n        node.source = this.parseExprAtom();\n\n        if (this.type === this.assertToken) {\n          this.next();\n          const assertions = this.parseImportAssertions();\n\n          if (assertions) {\n            node.assertions = assertions;\n          }\n        }\n\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n\n          if (isAsync) {\n            this.next();\n          }\n\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      } // export var|const|let|function|class ...\n\n\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n\n          node.source = this.parseExprAtom();\n\n          if (this.type === this.assertToken) {\n            this.next();\n            const assertions = this.parseImportAssertions();\n\n            if (assertions) {\n              node.assertions = assertions;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local); // check if export is defined\n\n            this.checkLocalExport(spec.local);\n          }\n\n          node.source = null;\n        }\n\n        this.semicolon();\n      }\n\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    parseImport(node) {\n      this.next(); // import '...'\n\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n\n      if (this.type === this.assertToken) {\n        this.next();\n        const assertions = this.parseImportAssertions();\n\n        if (assertions) {\n          node.assertions = assertions;\n        }\n      }\n\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    parseImportAssertions() {\n      this._eat(tt.braceL);\n\n      const attrs = this.parseAssertEntries();\n\n      this._eat(tt.braceR);\n\n      return attrs;\n    }\n\n    parseAssertEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n\n        const node = this.startNode(); // parse AssertionKey : IdentifierName, StringLiteral\n\n        let assertionKeyNode;\n\n        if (this.type === tt.string) {\n          assertionKeyNode = this.parseLiteral(this.value);\n        } else {\n          assertionKeyNode = this.parseIdent(true);\n        }\n\n        this.next();\n        node.key = assertionKeyNode; // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in assertions\");\n        }\n\n        attrNames.add(node.key.name);\n\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an assertion value\");\n        }\n\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n\n      return attrs;\n    }\n\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}