{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\"; // Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\n\nconst similarity = (a, b) => {\n  const l = Math.min(a.length, b.length);\n  let dist = 0;\n\n  for (let i = 0; i < l; i++) {\n    const ca = a.charCodeAt(i);\n    const cb = b.charCodeAt(i);\n    dist += Math.max(0, 10 - Math.abs(ca - cb));\n  }\n\n  return dist;\n};\n/**\n * @param {string} a key\n * @param {string} b key\n * @param {Set<string>} usedNames set of already used names\n * @returns {string} the common part and a single char for the difference\n */\n\n\nconst getName = (a, b, usedNames) => {\n  const l = Math.min(a.length, b.length);\n  let i = 0;\n\n  while (i < l) {\n    if (a.charCodeAt(i) !== b.charCodeAt(i)) {\n      i++;\n      break;\n    }\n\n    i++;\n  }\n\n  while (i < l) {\n    const name = a.slice(0, i);\n    const lowerName = name.toLowerCase();\n\n    if (!usedNames.has(lowerName)) {\n      usedNames.add(lowerName);\n      return name;\n    }\n\n    i++;\n  } // names always contain a hash, so this is always unique\n  // we don't need to check usedNames nor add it\n\n\n  return a;\n};\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\n\n\nconst addSizeTo = (total, size) => {\n  for (const key of Object.keys(size)) {\n    total[key] = (total[key] || 0) + size[key];\n  }\n};\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\n\n\nconst subtractSizeFrom = (total, size) => {\n  for (const key of Object.keys(size)) {\n    total[key] -= size[key];\n  }\n};\n/**\n * @param {Iterable<Node>} nodes some nodes\n * @returns {Record<string, number>} total size\n */\n\n\nconst sumSize = nodes => {\n  const sum = Object.create(null);\n\n  for (const node of nodes) {\n    addSizeTo(sum, node.size);\n  }\n\n  return sum;\n};\n\nconst isTooBig = (size, maxSize) => {\n  for (const key of Object.keys(size)) {\n    const s = size[key];\n    if (s === 0) continue;\n    const maxSizeValue = maxSize[key];\n\n    if (typeof maxSizeValue === \"number\") {\n      if (s > maxSizeValue) return true;\n    }\n  }\n\n  return false;\n};\n\nconst isTooSmall = (size, minSize) => {\n  for (const key of Object.keys(size)) {\n    const s = size[key];\n    if (s === 0) continue;\n    const minSizeValue = minSize[key];\n\n    if (typeof minSizeValue === \"number\") {\n      if (s < minSizeValue) return true;\n    }\n  }\n\n  return false;\n};\n\nconst getTooSmallTypes = (size, minSize) => {\n  const types = new Set();\n\n  for (const key of Object.keys(size)) {\n    const s = size[key];\n    if (s === 0) continue;\n    const minSizeValue = minSize[key];\n\n    if (typeof minSizeValue === \"number\") {\n      if (s < minSizeValue) types.add(key);\n    }\n  }\n\n  return types;\n};\n\nconst getNumberOfMatchingSizeTypes = (size, types) => {\n  let i = 0;\n\n  for (const key of Object.keys(size)) {\n    if (size[key] !== 0 && types.has(key)) i++;\n  }\n\n  return i;\n};\n\nconst selectiveSizeSum = (size, types) => {\n  let sum = 0;\n\n  for (const key of Object.keys(size)) {\n    if (size[key] !== 0 && types.has(key)) sum += size[key];\n  }\n\n  return sum;\n};\n/**\n * @template T\n */\n\n\nclass Node {\n  /**\n   * @param {T} item item\n   * @param {string} key key\n   * @param {Record<string, number>} size size\n   */\n  constructor(item, key, size) {\n    this.item = item;\n    this.key = key;\n    this.size = size;\n  }\n\n}\n/**\n * @template T\n */\n\n\nclass Group {\n  /**\n   * @param {Node<T>[]} nodes nodes\n   * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n   * @param {Record<string, number>=} size size of the group\n   */\n  constructor(nodes, similarities, size) {\n    this.nodes = nodes;\n    this.similarities = similarities;\n    this.size = size || sumSize(nodes);\n    /** @type {string} */\n\n    this.key = undefined;\n  }\n  /**\n   * @param {function(Node): boolean} filter filter function\n   * @returns {Node[]} removed nodes\n   */\n\n\n  popNodes(filter) {\n    const newNodes = [];\n    const newSimilarities = [];\n    const resultNodes = [];\n    let lastNode;\n\n    for (let i = 0; i < this.nodes.length; i++) {\n      const node = this.nodes[i];\n\n      if (filter(node)) {\n        resultNodes.push(node);\n      } else {\n        if (newNodes.length > 0) {\n          newSimilarities.push(lastNode === this.nodes[i - 1] ? this.similarities[i - 1] : similarity(lastNode.key, node.key));\n        }\n\n        newNodes.push(node);\n        lastNode = node;\n      }\n    }\n\n    if (resultNodes.length === this.nodes.length) return undefined;\n    this.nodes = newNodes;\n    this.similarities = newSimilarities;\n    this.size = sumSize(newNodes);\n    return resultNodes;\n  }\n\n}\n/**\n * @param {Iterable<Node>} nodes nodes\n * @returns {number[]} similarities\n */\n\n\nconst getSimilarities = nodes => {\n  // calculate similarities between lexically adjacent nodes\n\n  /** @type {number[]} */\n  const similarities = [];\n  let last = undefined;\n\n  for (const node of nodes) {\n    if (last !== undefined) {\n      similarities.push(similarity(last.key, node.key));\n    }\n\n    last = node;\n  }\n\n  return similarities;\n};\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {Record<string, number>} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {Record<string, number>} maxSize maximum size of a group\n * @property {Record<string, number>} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): Record<string, number>} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\n\n\nmodule.exports = _ref => {\n  let {\n    maxSize,\n    minSize,\n    items,\n    getSize,\n    getKey\n  } = _ref;\n\n  /** @type {Group<T>[]} */\n  const result = [];\n  const nodes = Array.from(items, item => new Node(item, getKey(item), getSize(item)));\n  /** @type {Node<T>[]} */\n\n  const initialNodes = []; // lexically ordering of keys\n\n  nodes.sort((a, b) => {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  }); // return nodes bigger than maxSize directly as group\n  // But make sure that minSize is not violated\n\n  for (const node of nodes) {\n    if (isTooBig(node.size, maxSize) && !isTooSmall(node.size, minSize)) {\n      result.push(new Group([node], []));\n    } else {\n      initialNodes.push(node);\n    }\n  }\n\n  if (initialNodes.length > 0) {\n    const initialGroup = new Group(initialNodes, getSimilarities(initialNodes));\n\n    const removeProblematicNodes = function (group) {\n      let consideredSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : group.size;\n      const problemTypes = getTooSmallTypes(consideredSize, minSize);\n\n      if (problemTypes.size > 0) {\n        // We hit an edge case where the working set is already smaller than minSize\n        // We merge problematic nodes with the smallest result node to keep minSize intact\n        const problemNodes = group.popNodes(n => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0);\n        if (problemNodes === undefined) return false; // Only merge it with result nodes that have the problematic size type\n\n        const possibleResultGroups = result.filter(n => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0);\n\n        if (possibleResultGroups.length > 0) {\n          const bestGroup = possibleResultGroups.reduce((min, group) => {\n            const minMatches = getNumberOfMatchingSizeTypes(min, problemTypes);\n            const groupMatches = getNumberOfMatchingSizeTypes(group, problemTypes);\n            if (minMatches !== groupMatches) return minMatches < groupMatches ? group : min;\n            if (selectiveSizeSum(min.size, problemTypes) > selectiveSizeSum(group.size, problemTypes)) return group;\n            return min;\n          });\n\n          for (const node of problemNodes) bestGroup.nodes.push(node);\n\n          bestGroup.nodes.sort((a, b) => {\n            if (a.key < b.key) return -1;\n            if (a.key > b.key) return 1;\n            return 0;\n          });\n        } else {\n          // There are no other nodes with the same size types\n          // We create a new group and have to accept that it's smaller than minSize\n          result.push(new Group(problemNodes, null));\n        }\n\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    if (initialGroup.nodes.length > 0) {\n      const queue = [initialGroup];\n\n      while (queue.length) {\n        const group = queue.pop(); // only groups bigger than maxSize need to be splitted\n\n        if (!isTooBig(group.size, maxSize)) {\n          result.push(group);\n          continue;\n        } // If the group is already too small\n        // we try to work only with the unproblematic nodes\n\n\n        if (removeProblematicNodes(group)) {\n          // This changed something, so we try this group again\n          queue.push(group);\n          continue;\n        } // find unsplittable area from left and right\n        // going minSize from left and right\n        // at least one node need to be included otherwise we get stuck\n\n\n        let left = 1;\n        let leftSize = Object.create(null);\n        addSizeTo(leftSize, group.nodes[0].size);\n\n        while (left < group.nodes.length && isTooSmall(leftSize, minSize)) {\n          addSizeTo(leftSize, group.nodes[left].size);\n          left++;\n        }\n\n        let right = group.nodes.length - 2;\n        let rightSize = Object.create(null);\n        addSizeTo(rightSize, group.nodes[group.nodes.length - 1].size);\n\n        while (right >= 0 && isTooSmall(rightSize, minSize)) {\n          addSizeTo(rightSize, group.nodes[right].size);\n          right--;\n        } //      left v   v right\n        // [ O O O ] O O O [ O O O ]\n        // ^^^^^^^^^ leftSize\n        //       rightSize ^^^^^^^^^\n        // leftSize > minSize\n        // rightSize > minSize\n        // Perfect split: [ O O O ] [ O O O ]\n        //                right === left - 1\n\n\n        if (left - 1 > right) {\n          // We try to remove some problematic nodes to \"fix\" that\n          let prevSize;\n\n          if (right < group.nodes.length - left) {\n            subtractSizeFrom(rightSize, group.nodes[right + 1].size);\n            prevSize = rightSize;\n          } else {\n            subtractSizeFrom(leftSize, group.nodes[left - 1].size);\n            prevSize = leftSize;\n          }\n\n          if (removeProblematicNodes(group, prevSize)) {\n            // This changed something, so we try this group again\n            queue.push(group);\n            continue;\n          } // can't split group while holding minSize\n          // because minSize is preferred of maxSize we return\n          // the problematic nodes as result here even while it's too big\n          // To avoid this make sure maxSize > minSize * 3\n\n\n          result.push(group);\n          continue;\n        }\n\n        if (left <= right) {\n          // when there is a area between left and right\n          // we look for best split point\n          // we split at the minimum similarity\n          // here key space is separated the most\n          // But we also need to make sure to not create too small groups\n          let best = -1;\n          let bestSimilarity = Infinity;\n          let pos = left;\n          let rightSize = sumSize(group.nodes.slice(pos)); //       pos v   v right\n          // [ O O O ] O O O [ O O O ]\n          // ^^^^^^^^^ leftSize\n          // rightSize ^^^^^^^^^^^^^^^\n\n          while (pos <= right + 1) {\n            const similarity = group.similarities[pos - 1];\n\n            if (similarity < bestSimilarity && !isTooSmall(leftSize, minSize) && !isTooSmall(rightSize, minSize)) {\n              best = pos;\n              bestSimilarity = similarity;\n            }\n\n            addSizeTo(leftSize, group.nodes[pos].size);\n            subtractSizeFrom(rightSize, group.nodes[pos].size);\n            pos++;\n          }\n\n          if (best < 0) {\n            // This can't happen\n            // but if that assumption is wrong\n            // fallback to a big group\n            result.push(group);\n            continue;\n          }\n\n          left = best;\n          right = best - 1;\n        } // create two new groups for left and right area\n        // and queue them up\n\n\n        const rightNodes = [group.nodes[right + 1]];\n        /** @type {number[]} */\n\n        const rightSimilarities = [];\n\n        for (let i = right + 2; i < group.nodes.length; i++) {\n          rightSimilarities.push(group.similarities[i - 1]);\n          rightNodes.push(group.nodes[i]);\n        }\n\n        queue.push(new Group(rightNodes, rightSimilarities));\n        const leftNodes = [group.nodes[0]];\n        /** @type {number[]} */\n\n        const leftSimilarities = [];\n\n        for (let i = 1; i < left; i++) {\n          leftSimilarities.push(group.similarities[i - 1]);\n          leftNodes.push(group.nodes[i]);\n        }\n\n        queue.push(new Group(leftNodes, leftSimilarities));\n      }\n    }\n  } // lexically ordering\n\n\n  result.sort((a, b) => {\n    if (a.nodes[0].key < b.nodes[0].key) return -1;\n    if (a.nodes[0].key > b.nodes[0].key) return 1;\n    return 0;\n  }); // give every group a name\n\n  const usedNames = new Set();\n\n  for (let i = 0; i < result.length; i++) {\n    const group = result[i];\n\n    if (group.nodes.length === 1) {\n      group.key = group.nodes[0].key;\n    } else {\n      const first = group.nodes[0];\n      const last = group.nodes[group.nodes.length - 1];\n      const name = getName(first.key, last.key, usedNames);\n      group.key = name;\n    }\n  } // return the results\n\n\n  return result.map(group => {\n    /** @type {GroupedItems<T>} */\n    return {\n      key: group.key,\n      items: group.nodes.map(node => node.item),\n      size: group.size\n    };\n  });\n};","map":{"version":3,"names":["similarity","a","b","l","Math","min","length","dist","i","ca","charCodeAt","cb","max","abs","getName","usedNames","name","slice","lowerName","toLowerCase","has","add","addSizeTo","total","size","key","Object","keys","subtractSizeFrom","sumSize","nodes","sum","create","node","isTooBig","maxSize","s","maxSizeValue","isTooSmall","minSize","minSizeValue","getTooSmallTypes","types","Set","getNumberOfMatchingSizeTypes","selectiveSizeSum","Node","constructor","item","Group","similarities","undefined","popNodes","filter","newNodes","newSimilarities","resultNodes","lastNode","push","getSimilarities","last","module","exports","items","getSize","getKey","result","Array","from","initialNodes","sort","initialGroup","removeProblematicNodes","group","consideredSize","problemTypes","problemNodes","n","possibleResultGroups","bestGroup","reduce","minMatches","groupMatches","queue","pop","left","leftSize","right","rightSize","prevSize","best","bestSimilarity","Infinity","pos","rightNodes","rightSimilarities","leftNodes","leftSimilarities","first","map"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/util/deterministicGrouping.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nconst similarity = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet dist = 0;\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charCodeAt(i);\n\t\tconst cb = b.charCodeAt(i);\n\t\tdist += Math.max(0, 10 - Math.abs(ca - cb));\n\t}\n\treturn dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @param {Set<string>} usedNames set of already used names\n * @returns {string} the common part and a single char for the difference\n */\nconst getName = (a, b, usedNames) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet i = 0;\n\twhile (i < l) {\n\t\tif (a.charCodeAt(i) !== b.charCodeAt(i)) {\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\twhile (i < l) {\n\t\tconst name = a.slice(0, i);\n\t\tconst lowerName = name.toLowerCase();\n\t\tif (!usedNames.has(lowerName)) {\n\t\t\tusedNames.add(lowerName);\n\t\t\treturn name;\n\t\t}\n\t\ti++;\n\t}\n\t// names always contain a hash, so this is always unique\n\t// we don't need to check usedNames nor add it\n\treturn a;\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nconst addSizeTo = (total, size) => {\n\tfor (const key of Object.keys(size)) {\n\t\ttotal[key] = (total[key] || 0) + size[key];\n\t}\n};\n\n/**\n * @param {Record<string, number>} total total size\n * @param {Record<string, number>} size single size\n * @returns {void}\n */\nconst subtractSizeFrom = (total, size) => {\n\tfor (const key of Object.keys(size)) {\n\t\ttotal[key] -= size[key];\n\t}\n};\n\n/**\n * @param {Iterable<Node>} nodes some nodes\n * @returns {Record<string, number>} total size\n */\nconst sumSize = nodes => {\n\tconst sum = Object.create(null);\n\tfor (const node of nodes) {\n\t\taddSizeTo(sum, node.size);\n\t}\n\treturn sum;\n};\n\nconst isTooBig = (size, maxSize) => {\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst maxSizeValue = maxSize[key];\n\t\tif (typeof maxSizeValue === \"number\") {\n\t\t\tif (s > maxSizeValue) return true;\n\t\t}\n\t}\n\treturn false;\n};\n\nconst isTooSmall = (size, minSize) => {\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst minSizeValue = minSize[key];\n\t\tif (typeof minSizeValue === \"number\") {\n\t\t\tif (s < minSizeValue) return true;\n\t\t}\n\t}\n\treturn false;\n};\n\nconst getTooSmallTypes = (size, minSize) => {\n\tconst types = new Set();\n\tfor (const key of Object.keys(size)) {\n\t\tconst s = size[key];\n\t\tif (s === 0) continue;\n\t\tconst minSizeValue = minSize[key];\n\t\tif (typeof minSizeValue === \"number\") {\n\t\t\tif (s < minSizeValue) types.add(key);\n\t\t}\n\t}\n\treturn types;\n};\n\nconst getNumberOfMatchingSizeTypes = (size, types) => {\n\tlet i = 0;\n\tfor (const key of Object.keys(size)) {\n\t\tif (size[key] !== 0 && types.has(key)) i++;\n\t}\n\treturn i;\n};\n\nconst selectiveSizeSum = (size, types) => {\n\tlet sum = 0;\n\tfor (const key of Object.keys(size)) {\n\t\tif (size[key] !== 0 && types.has(key)) sum += size[key];\n\t}\n\treturn sum;\n};\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item item\n\t * @param {string} key key\n\t * @param {Record<string, number>} size size\n\t */\n\tconstructor(item, key, size) {\n\t\tthis.item = item;\n\t\tthis.key = key;\n\t\tthis.size = size;\n\t}\n}\n\n/**\n * @template T\n */\nclass Group {\n\t/**\n\t * @param {Node<T>[]} nodes nodes\n\t * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n\t * @param {Record<string, number>=} size size of the group\n\t */\n\tconstructor(nodes, similarities, size) {\n\t\tthis.nodes = nodes;\n\t\tthis.similarities = similarities;\n\t\tthis.size = size || sumSize(nodes);\n\t\t/** @type {string} */\n\t\tthis.key = undefined;\n\t}\n\n\t/**\n\t * @param {function(Node): boolean} filter filter function\n\t * @returns {Node[]} removed nodes\n\t */\n\tpopNodes(filter) {\n\t\tconst newNodes = [];\n\t\tconst newSimilarities = [];\n\t\tconst resultNodes = [];\n\t\tlet lastNode;\n\t\tfor (let i = 0; i < this.nodes.length; i++) {\n\t\t\tconst node = this.nodes[i];\n\t\t\tif (filter(node)) {\n\t\t\t\tresultNodes.push(node);\n\t\t\t} else {\n\t\t\t\tif (newNodes.length > 0) {\n\t\t\t\t\tnewSimilarities.push(\n\t\t\t\t\t\tlastNode === this.nodes[i - 1]\n\t\t\t\t\t\t\t? this.similarities[i - 1]\n\t\t\t\t\t\t\t: similarity(lastNode.key, node.key)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tnewNodes.push(node);\n\t\t\t\tlastNode = node;\n\t\t\t}\n\t\t}\n\t\tif (resultNodes.length === this.nodes.length) return undefined;\n\t\tthis.nodes = newNodes;\n\t\tthis.similarities = newSimilarities;\n\t\tthis.size = sumSize(newNodes);\n\t\treturn resultNodes;\n\t}\n}\n\n/**\n * @param {Iterable<Node>} nodes nodes\n * @returns {number[]} similarities\n */\nconst getSimilarities = nodes => {\n\t// calculate similarities between lexically adjacent nodes\n\t/** @type {number[]} */\n\tconst similarities = [];\n\tlet last = undefined;\n\tfor (const node of nodes) {\n\t\tif (last !== undefined) {\n\t\t\tsimilarities.push(similarity(last.key, node.key));\n\t\t}\n\t\tlast = node;\n\t}\n\treturn similarities;\n};\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {Record<string, number>} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {Record<string, number>} maxSize maximum size of a group\n * @property {Record<string, number>} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): Record<string, number>} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = ({ maxSize, minSize, items, getSize, getKey }) => {\n\t/** @type {Group<T>[]} */\n\tconst result = [];\n\n\tconst nodes = Array.from(\n\t\titems,\n\t\titem => new Node(item, getKey(item), getSize(item))\n\t);\n\n\t/** @type {Node<T>[]} */\n\tconst initialNodes = [];\n\n\t// lexically ordering of keys\n\tnodes.sort((a, b) => {\n\t\tif (a.key < b.key) return -1;\n\t\tif (a.key > b.key) return 1;\n\t\treturn 0;\n\t});\n\n\t// return nodes bigger than maxSize directly as group\n\t// But make sure that minSize is not violated\n\tfor (const node of nodes) {\n\t\tif (isTooBig(node.size, maxSize) && !isTooSmall(node.size, minSize)) {\n\t\t\tresult.push(new Group([node], []));\n\t\t} else {\n\t\t\tinitialNodes.push(node);\n\t\t}\n\t}\n\n\tif (initialNodes.length > 0) {\n\t\tconst initialGroup = new Group(initialNodes, getSimilarities(initialNodes));\n\n\t\tconst removeProblematicNodes = (group, consideredSize = group.size) => {\n\t\t\tconst problemTypes = getTooSmallTypes(consideredSize, minSize);\n\t\t\tif (problemTypes.size > 0) {\n\t\t\t\t// We hit an edge case where the working set is already smaller than minSize\n\t\t\t\t// We merge problematic nodes with the smallest result node to keep minSize intact\n\t\t\t\tconst problemNodes = group.popNodes(\n\t\t\t\t\tn => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0\n\t\t\t\t);\n\t\t\t\tif (problemNodes === undefined) return false;\n\t\t\t\t// Only merge it with result nodes that have the problematic size type\n\t\t\t\tconst possibleResultGroups = result.filter(\n\t\t\t\t\tn => getNumberOfMatchingSizeTypes(n.size, problemTypes) > 0\n\t\t\t\t);\n\t\t\t\tif (possibleResultGroups.length > 0) {\n\t\t\t\t\tconst bestGroup = possibleResultGroups.reduce((min, group) => {\n\t\t\t\t\t\tconst minMatches = getNumberOfMatchingSizeTypes(min, problemTypes);\n\t\t\t\t\t\tconst groupMatches = getNumberOfMatchingSizeTypes(\n\t\t\t\t\t\t\tgroup,\n\t\t\t\t\t\t\tproblemTypes\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (minMatches !== groupMatches)\n\t\t\t\t\t\t\treturn minMatches < groupMatches ? group : min;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tselectiveSizeSum(min.size, problemTypes) >\n\t\t\t\t\t\t\tselectiveSizeSum(group.size, problemTypes)\n\t\t\t\t\t\t)\n\t\t\t\t\t\t\treturn group;\n\t\t\t\t\t\treturn min;\n\t\t\t\t\t});\n\t\t\t\t\tfor (const node of problemNodes) bestGroup.nodes.push(node);\n\t\t\t\t\tbestGroup.nodes.sort((a, b) => {\n\t\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// There are no other nodes with the same size types\n\t\t\t\t\t// We create a new group and have to accept that it's smaller than minSize\n\t\t\t\t\tresult.push(new Group(problemNodes, null));\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\n\t\tif (initialGroup.nodes.length > 0) {\n\t\t\tconst queue = [initialGroup];\n\n\t\t\twhile (queue.length) {\n\t\t\t\tconst group = queue.pop();\n\t\t\t\t// only groups bigger than maxSize need to be splitted\n\t\t\t\tif (!isTooBig(group.size, maxSize)) {\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// If the group is already too small\n\t\t\t\t// we try to work only with the unproblematic nodes\n\t\t\t\tif (removeProblematicNodes(group)) {\n\t\t\t\t\t// This changed something, so we try this group again\n\t\t\t\t\tqueue.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find unsplittable area from left and right\n\t\t\t\t// going minSize from left and right\n\t\t\t\t// at least one node need to be included otherwise we get stuck\n\t\t\t\tlet left = 1;\n\t\t\t\tlet leftSize = Object.create(null);\n\t\t\t\taddSizeTo(leftSize, group.nodes[0].size);\n\t\t\t\twhile (left < group.nodes.length && isTooSmall(leftSize, minSize)) {\n\t\t\t\t\taddSizeTo(leftSize, group.nodes[left].size);\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\tlet right = group.nodes.length - 2;\n\t\t\t\tlet rightSize = Object.create(null);\n\t\t\t\taddSizeTo(rightSize, group.nodes[group.nodes.length - 1].size);\n\t\t\t\twhile (right >= 0 && isTooSmall(rightSize, minSize)) {\n\t\t\t\t\taddSizeTo(rightSize, group.nodes[right].size);\n\t\t\t\t\tright--;\n\t\t\t\t}\n\n\t\t\t\t//      left v   v right\n\t\t\t\t// [ O O O ] O O O [ O O O ]\n\t\t\t\t// ^^^^^^^^^ leftSize\n\t\t\t\t//       rightSize ^^^^^^^^^\n\t\t\t\t// leftSize > minSize\n\t\t\t\t// rightSize > minSize\n\n\t\t\t\t// Perfect split: [ O O O ] [ O O O ]\n\t\t\t\t//                right === left - 1\n\n\t\t\t\tif (left - 1 > right) {\n\t\t\t\t\t// We try to remove some problematic nodes to \"fix\" that\n\t\t\t\t\tlet prevSize;\n\t\t\t\t\tif (right < group.nodes.length - left) {\n\t\t\t\t\t\tsubtractSizeFrom(rightSize, group.nodes[right + 1].size);\n\t\t\t\t\t\tprevSize = rightSize;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsubtractSizeFrom(leftSize, group.nodes[left - 1].size);\n\t\t\t\t\t\tprevSize = leftSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (removeProblematicNodes(group, prevSize)) {\n\t\t\t\t\t\t// This changed something, so we try this group again\n\t\t\t\t\t\tqueue.push(group);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// can't split group while holding minSize\n\t\t\t\t\t// because minSize is preferred of maxSize we return\n\t\t\t\t\t// the problematic nodes as result here even while it's too big\n\t\t\t\t\t// To avoid this make sure maxSize > minSize * 3\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (left <= right) {\n\t\t\t\t\t// when there is a area between left and right\n\t\t\t\t\t// we look for best split point\n\t\t\t\t\t// we split at the minimum similarity\n\t\t\t\t\t// here key space is separated the most\n\t\t\t\t\t// But we also need to make sure to not create too small groups\n\t\t\t\t\tlet best = -1;\n\t\t\t\t\tlet bestSimilarity = Infinity;\n\t\t\t\t\tlet pos = left;\n\t\t\t\t\tlet rightSize = sumSize(group.nodes.slice(pos));\n\n\t\t\t\t\t//       pos v   v right\n\t\t\t\t\t// [ O O O ] O O O [ O O O ]\n\t\t\t\t\t// ^^^^^^^^^ leftSize\n\t\t\t\t\t// rightSize ^^^^^^^^^^^^^^^\n\n\t\t\t\t\twhile (pos <= right + 1) {\n\t\t\t\t\t\tconst similarity = group.similarities[pos - 1];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tsimilarity < bestSimilarity &&\n\t\t\t\t\t\t\t!isTooSmall(leftSize, minSize) &&\n\t\t\t\t\t\t\t!isTooSmall(rightSize, minSize)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tbest = pos;\n\t\t\t\t\t\t\tbestSimilarity = similarity;\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddSizeTo(leftSize, group.nodes[pos].size);\n\t\t\t\t\t\tsubtractSizeFrom(rightSize, group.nodes[pos].size);\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t}\n\t\t\t\t\tif (best < 0) {\n\t\t\t\t\t\t// This can't happen\n\t\t\t\t\t\t// but if that assumption is wrong\n\t\t\t\t\t\t// fallback to a big group\n\t\t\t\t\t\tresult.push(group);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tleft = best;\n\t\t\t\t\tright = best - 1;\n\t\t\t\t}\n\n\t\t\t\t// create two new groups for left and right area\n\t\t\t\t// and queue them up\n\t\t\t\tconst rightNodes = [group.nodes[right + 1]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst rightSimilarities = [];\n\t\t\t\tfor (let i = right + 2; i < group.nodes.length; i++) {\n\t\t\t\t\trightSimilarities.push(group.similarities[i - 1]);\n\t\t\t\t\trightNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(rightNodes, rightSimilarities));\n\n\t\t\t\tconst leftNodes = [group.nodes[0]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst leftSimilarities = [];\n\t\t\t\tfor (let i = 1; i < left; i++) {\n\t\t\t\t\tleftSimilarities.push(group.similarities[i - 1]);\n\t\t\t\t\tleftNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(leftNodes, leftSimilarities));\n\t\t\t}\n\t\t}\n\t}\n\n\t// lexically ordering\n\tresult.sort((a, b) => {\n\t\tif (a.nodes[0].key < b.nodes[0].key) return -1;\n\t\tif (a.nodes[0].key > b.nodes[0].key) return 1;\n\t\treturn 0;\n\t});\n\n\t// give every group a name\n\tconst usedNames = new Set();\n\tfor (let i = 0; i < result.length; i++) {\n\t\tconst group = result[i];\n\t\tif (group.nodes.length === 1) {\n\t\t\tgroup.key = group.nodes[0].key;\n\t\t} else {\n\t\t\tconst first = group.nodes[0];\n\t\t\tconst last = group.nodes[group.nodes.length - 1];\n\t\t\tconst name = getName(first.key, last.key, usedNames);\n\t\t\tgroup.key = name;\n\t\t}\n\t}\n\n\t// return the results\n\treturn result.map(group => {\n\t\t/** @type {GroupedItems<T>} */\n\t\treturn {\n\t\t\tkey: group.key,\n\t\t\titems: group.nodes.map(node => node.item),\n\t\t\tsize: group.size\n\t\t};\n\t});\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}