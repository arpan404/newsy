{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst {\n  ConcatSource,\n  RawSource\n} = require(\"webpack-sources\");\n\nconst Compilation = require(\"./Compilation\");\n\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\n\nconst ProgressPlugin = require(\"./ProgressPlugin\");\n\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\n\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\n\nconst createHash = require(\"./util/createHash\");\n\nconst {\n  relative,\n  dirname\n} = require(\"./util/fs\");\n\nconst {\n  makePathsAbsolute\n} = require(\"./util/identifier\");\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n\n/** @typedef {import(\"./Cache\").Etag} Etag */\n\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\n\n/** @typedef {import(\"./util/Hash\")} Hash */\n\n\nconst validate = createSchemaValidation(require(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"), () => require(\"../schemas/plugins/SourceMapDevToolPlugin.json\"), {\n  name: \"SourceMap DevTool Plugin\",\n  baseDataPath: \"options\"\n});\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {AssetInfo} assetInfo\n * @property {(string | Module)[]} modules\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {ItemCacheFacade} cacheItem cache item\n */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\n\nconst quoteMeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {AssetInfo} assetInfo the asset info\n * @param {MapOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @param {ItemCacheFacade} cacheItem cache item\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\n\n\nconst getTaskForFile = (file, asset, assetInfo, options, compilation, cacheItem) => {\n  let source;\n  /** @type {SourceMap} */\n\n  let sourceMap;\n  /**\n   * Check if asset can build source map\n   */\n\n  if (asset.sourceAndMap) {\n    const sourceAndMap = asset.sourceAndMap(options);\n    sourceMap =\n    /** @type {SourceMap} */\n    sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap =\n    /** @type {SourceMap} */\n    asset.map(options);\n    source = asset.source();\n  }\n\n  if (!sourceMap || typeof source !== \"string\") return;\n  const context = compilation.options.context;\n  const root = compilation.compiler.root;\n  const cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\n  const modules = sourceMap.sources.map(source => {\n    if (!source.startsWith(\"webpack://\")) return source;\n    source = cachedAbsolutify(source.slice(10));\n    const module = compilation.findModule(source);\n    return module || source;\n  });\n  return {\n    file,\n    asset,\n    source,\n    assetInfo,\n    sourceMap,\n    modules,\n    cacheItem\n  };\n};\n\nclass SourceMapDevToolPlugin {\n  /**\n   * @param {SourceMapDevToolPluginOptions} [options] options object\n   * @throws {Error} throws error, if got more than 1 arguments\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    validate(options);\n    /** @type {string | false} */\n\n    this.sourceMapFilename = options.filename;\n    /** @type {string | false} */\n\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# source\" + \"MappingURL=[url]\";\n    /** @type {string | Function} */\n\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    /** @type {string | Function} */\n\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    /** @type {string} */\n\n    this.namespace = options.namespace || \"\";\n    /** @type {SourceMapDevToolPluginOptions} */\n\n    this.options = options;\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const outputFs = compiler.outputFileSystem;\n    const sourceMapFilename = this.sourceMapFilename;\n    const sourceMappingURLComment = this.sourceMappingURLComment;\n    const moduleFilenameTemplate = this.moduleFilenameTemplate;\n    const namespace = this.namespace;\n    const fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n    const requestShortener = compiler.requestShortener;\n    const options = this.options;\n    options.test = options.test || /\\.((c|m)?js|css)($|\\?)/i;\n    const matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n    compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n      new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n      compilation.hooks.processAssets.tapAsync({\n        name: \"SourceMapDevToolPlugin\",\n        stage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\n        additionalAssets: true\n      }, (assets, callback) => {\n        const chunkGraph = compilation.chunkGraph;\n        const cache = compilation.getCache(\"SourceMapDevToolPlugin\");\n        /** @type {Map<string | Module, string>} */\n\n        const moduleToSourceNameMapping = new Map();\n        /**\n         * @type {Function}\n         * @returns {void}\n         */\n\n        const reportProgress = ProgressPlugin.getReporter(compilation.compiler) || (() => {});\n        /** @type {Map<string, Chunk>} */\n\n\n        const fileToChunk = new Map();\n\n        for (const chunk of compilation.chunks) {\n          for (const file of chunk.files) {\n            fileToChunk.set(file, chunk);\n          }\n\n          for (const file of chunk.auxiliaryFiles) {\n            fileToChunk.set(file, chunk);\n          }\n        }\n        /** @type {string[]} */\n\n\n        const files = [];\n\n        for (const file of Object.keys(assets)) {\n          if (matchObject(file)) {\n            files.push(file);\n          }\n        }\n\n        reportProgress(0.0);\n        /** @type {SourceMapTask[]} */\n\n        const tasks = [];\n        let fileIndex = 0;\n        asyncLib.each(files, (file, callback) => {\n          const asset = compilation.getAsset(file);\n\n          if (asset.info.related && asset.info.related.sourceMap) {\n            fileIndex++;\n            return callback();\n          }\n\n          const cacheItem = cache.getItemCache(file, cache.mergeEtags(cache.getLazyHashedEtag(asset.source), namespace));\n          cacheItem.get((err, cacheEntry) => {\n            if (err) {\n              return callback(err);\n            }\n            /**\n             * If presented in cache, reassigns assets. Cache assets already have source maps.\n             */\n\n\n            if (cacheEntry) {\n              const {\n                assets,\n                assetsInfo\n              } = cacheEntry;\n\n              for (const cachedFile of Object.keys(assets)) {\n                if (cachedFile === file) {\n                  compilation.updateAsset(cachedFile, assets[cachedFile], assetsInfo[cachedFile]);\n                } else {\n                  compilation.emitAsset(cachedFile, assets[cachedFile], assetsInfo[cachedFile]);\n                }\n                /**\n                 * Add file to chunk, if not presented there\n                 */\n\n\n                if (cachedFile !== file) {\n                  const chunk = fileToChunk.get(file);\n                  if (chunk !== undefined) chunk.auxiliaryFiles.add(cachedFile);\n                }\n              }\n\n              reportProgress(0.5 * ++fileIndex / files.length, file, \"restored cached SourceMap\");\n              return callback();\n            }\n\n            reportProgress(0.5 * fileIndex / files.length, file, \"generate SourceMap\");\n            /** @type {SourceMapTask | undefined} */\n\n            const task = getTaskForFile(file, asset.source, asset.info, {\n              module: options.module,\n              columns: options.columns\n            }, compilation, cacheItem);\n\n            if (task) {\n              const modules = task.modules;\n\n              for (let idx = 0; idx < modules.length; idx++) {\n                const module = modules[idx];\n\n                if (!moduleToSourceNameMapping.get(module)) {\n                  moduleToSourceNameMapping.set(module, ModuleFilenameHelpers.createFilename(module, {\n                    moduleFilenameTemplate: moduleFilenameTemplate,\n                    namespace: namespace\n                  }, {\n                    requestShortener,\n                    chunkGraph,\n                    hashFunction: compilation.outputOptions.hashFunction\n                  }));\n                }\n              }\n\n              tasks.push(task);\n            }\n\n            reportProgress(0.5 * ++fileIndex / files.length, file, \"generated SourceMap\");\n            callback();\n          });\n        }, err => {\n          if (err) {\n            return callback(err);\n          }\n\n          reportProgress(0.5, \"resolve sources\");\n          /** @type {Set<string>} */\n\n          const usedNamesSet = new Set(moduleToSourceNameMapping.values());\n          /** @type {Set<string>} */\n\n          const conflictDetectionSet = new Set();\n          /**\n           * all modules in defined order (longest identifier first)\n           * @type {Array<string | Module>}\n           */\n\n          const allModules = Array.from(moduleToSourceNameMapping.keys()).sort((a, b) => {\n            const ai = typeof a === \"string\" ? a : a.identifier();\n            const bi = typeof b === \"string\" ? b : b.identifier();\n            return ai.length - bi.length;\n          }); // find modules with conflicting source names\n\n          for (let idx = 0; idx < allModules.length; idx++) {\n            const module = allModules[idx];\n            let sourceName = moduleToSourceNameMapping.get(module);\n            let hasName = conflictDetectionSet.has(sourceName);\n\n            if (!hasName) {\n              conflictDetectionSet.add(sourceName);\n              continue;\n            } // try the fallback name first\n\n\n            sourceName = ModuleFilenameHelpers.createFilename(module, {\n              moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n              namespace: namespace\n            }, {\n              requestShortener,\n              chunkGraph,\n              hashFunction: compilation.outputOptions.hashFunction\n            });\n            hasName = usedNamesSet.has(sourceName);\n\n            if (!hasName) {\n              moduleToSourceNameMapping.set(module, sourceName);\n              usedNamesSet.add(sourceName);\n              continue;\n            } // otherwise just append stars until we have a valid name\n\n\n            while (hasName) {\n              sourceName += \"*\";\n              hasName = usedNamesSet.has(sourceName);\n            }\n\n            moduleToSourceNameMapping.set(module, sourceName);\n            usedNamesSet.add(sourceName);\n          }\n\n          let taskIndex = 0;\n          asyncLib.each(tasks, (task, callback) => {\n            const assets = Object.create(null);\n            const assetsInfo = Object.create(null);\n            const file = task.file;\n            const chunk = fileToChunk.get(file);\n            const sourceMap = task.sourceMap;\n            const source = task.source;\n            const modules = task.modules;\n            reportProgress(0.5 + 0.5 * taskIndex / tasks.length, file, \"attach SourceMap\");\n            const moduleFilenames = modules.map(m => moduleToSourceNameMapping.get(m));\n            sourceMap.sources = moduleFilenames;\n\n            if (options.noSources) {\n              sourceMap.sourcesContent = undefined;\n            }\n\n            sourceMap.sourceRoot = options.sourceRoot || \"\";\n            sourceMap.file = file;\n            const usesContentHash = sourceMapFilename && /\\[contenthash(:\\w+)?\\]/.test(sourceMapFilename); // If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\n\n            if (usesContentHash && task.assetInfo.contenthash) {\n              const contenthash = task.assetInfo.contenthash;\n              let pattern;\n\n              if (Array.isArray(contenthash)) {\n                pattern = contenthash.map(quoteMeta).join(\"|\");\n              } else {\n                pattern = quoteMeta(contenthash);\n              }\n\n              sourceMap.file = sourceMap.file.replace(new RegExp(pattern, \"g\"), m => \"x\".repeat(m.length));\n            }\n            /** @type {string | false} */\n\n\n            let currentSourceMappingURLComment = sourceMappingURLComment;\n\n            if (currentSourceMappingURLComment !== false && /\\.css($|\\?)/i.test(file)) {\n              currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\\n\\/\\/(.*)$/, \"\\n/*$1*/\");\n            }\n\n            const sourceMapString = JSON.stringify(sourceMap);\n\n            if (sourceMapFilename) {\n              let filename = file;\n              const sourceMapContentHash = usesContentHash &&\n              /** @type {string} */\n              createHash(compilation.outputOptions.hashFunction).update(sourceMapString).digest(\"hex\");\n              const pathParams = {\n                chunk,\n                filename: options.fileContext ? relative(outputFs, `/${options.fileContext}`, `/${filename}`) : filename,\n                contentHash: sourceMapContentHash\n              };\n              const {\n                path: sourceMapFile,\n                info: sourceMapInfo\n              } = compilation.getPathWithInfo(sourceMapFilename, pathParams);\n              const sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile : relative(outputFs, dirname(outputFs, `/${file}`), `/${sourceMapFile}`);\n              /** @type {Source} */\n\n              let asset = new RawSource(source);\n\n              if (currentSourceMappingURLComment !== false) {\n                // Add source map url to compilation asset, if currentSourceMappingURLComment is set\n                asset = new ConcatSource(asset, compilation.getPath(currentSourceMappingURLComment, Object.assign({\n                  url: sourceMapUrl\n                }, pathParams)));\n              }\n\n              const assetInfo = {\n                related: {\n                  sourceMap: sourceMapFile\n                }\n              };\n              assets[file] = asset;\n              assetsInfo[file] = assetInfo;\n              compilation.updateAsset(file, asset, assetInfo); // Add source map file to compilation assets and chunk files\n\n              const sourceMapAsset = new RawSource(sourceMapString);\n              const sourceMapAssetInfo = { ...sourceMapInfo,\n                development: true\n              };\n              assets[sourceMapFile] = sourceMapAsset;\n              assetsInfo[sourceMapFile] = sourceMapAssetInfo;\n              compilation.emitAsset(sourceMapFile, sourceMapAsset, sourceMapAssetInfo);\n              if (chunk !== undefined) chunk.auxiliaryFiles.add(sourceMapFile);\n            } else {\n              if (currentSourceMappingURLComment === false) {\n                throw new Error(\"SourceMapDevToolPlugin: append can't be false when no filename is provided\");\n              }\n              /**\n               * Add source map as data url to asset\n               */\n\n\n              const asset = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[map\\]/g, () => sourceMapString).replace(/\\[url\\]/g, () => `data:application/json;charset=utf-8;base64,${Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\")}`));\n              assets[file] = asset;\n              assetsInfo[file] = undefined;\n              compilation.updateAsset(file, asset);\n            }\n\n            task.cacheItem.store({\n              assets,\n              assetsInfo\n            }, err => {\n              reportProgress(0.5 + 0.5 * ++taskIndex / tasks.length, task.file, \"attached SourceMap\");\n\n              if (err) {\n                return callback(err);\n              }\n\n              callback();\n            });\n          }, err => {\n            reportProgress(1.0);\n            callback(err);\n          });\n        });\n      });\n    });\n  }\n\n}\n\nmodule.exports = SourceMapDevToolPlugin;","map":{"version":3,"names":["asyncLib","require","ConcatSource","RawSource","Compilation","ModuleFilenameHelpers","ProgressPlugin","SourceMapDevToolModuleOptionsPlugin","createSchemaValidation","createHash","relative","dirname","makePathsAbsolute","validate","name","baseDataPath","quoteMeta","str","replace","getTaskForFile","file","asset","assetInfo","options","compilation","cacheItem","source","sourceMap","sourceAndMap","map","context","root","compiler","cachedAbsolutify","bindContextCache","modules","sources","startsWith","slice","module","findModule","SourceMapDevToolPlugin","constructor","sourceMapFilename","filename","sourceMappingURLComment","append","moduleFilenameTemplate","fallbackModuleFilenameTemplate","namespace","apply","outputFs","outputFileSystem","requestShortener","test","matchObject","bind","undefined","hooks","tap","processAssets","tapAsync","stage","PROCESS_ASSETS_STAGE_DEV_TOOLING","additionalAssets","assets","callback","chunkGraph","cache","getCache","moduleToSourceNameMapping","Map","reportProgress","getReporter","fileToChunk","chunk","chunks","files","set","auxiliaryFiles","Object","keys","push","tasks","fileIndex","each","getAsset","info","related","getItemCache","mergeEtags","getLazyHashedEtag","get","err","cacheEntry","assetsInfo","cachedFile","updateAsset","emitAsset","add","length","task","columns","idx","createFilename","hashFunction","outputOptions","usedNamesSet","Set","values","conflictDetectionSet","allModules","Array","from","sort","a","b","ai","identifier","bi","sourceName","hasName","has","taskIndex","create","moduleFilenames","m","noSources","sourcesContent","sourceRoot","usesContentHash","contenthash","pattern","isArray","join","RegExp","repeat","currentSourceMappingURLComment","sourceMapString","JSON","stringify","sourceMapContentHash","update","digest","pathParams","fileContext","contentHash","path","sourceMapFile","sourceMapInfo","getPathWithInfo","sourceMapUrl","publicPath","getPath","assign","url","sourceMapAsset","sourceMapAssetInfo","development","Error","Buffer","toString","store","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/SourceMapDevToolPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { ConcatSource, RawSource } = require(\"webpack-sources\");\nconst Compilation = require(\"./Compilation\");\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst ProgressPlugin = require(\"./ProgressPlugin\");\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nconst createSchemaValidation = require(\"./util/create-schema-validation\");\nconst createHash = require(\"./util/createHash\");\nconst { relative, dirname } = require(\"./util/fs\");\nconst { makePathsAbsolute } = require(\"./util/identifier\");\n\n/** @typedef {import(\"webpack-sources\").MapOptions} MapOptions */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Cache\").Etag} Etag */\n/** @typedef {import(\"./CacheFacade\").ItemCacheFacade} ItemCacheFacade */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./NormalModule\").SourceMap} SourceMap */\n/** @typedef {import(\"./util/Hash\")} Hash */\n\nconst validate = createSchemaValidation(\n\trequire(\"../schemas/plugins/SourceMapDevToolPlugin.check.js\"),\n\t() => require(\"../schemas/plugins/SourceMapDevToolPlugin.json\"),\n\t{\n\t\tname: \"SourceMap DevTool Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {AssetInfo} assetInfo\n * @property {(string | Module)[]} modules\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {ItemCacheFacade} cacheItem cache item\n */\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quoteMeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {AssetInfo} assetInfo the asset info\n * @param {MapOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @param {ItemCacheFacade} cacheItem cache item\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\nconst getTaskForFile = (\n\tfile,\n\tasset,\n\tassetInfo,\n\toptions,\n\tcompilation,\n\tcacheItem\n) => {\n\tlet source;\n\t/** @type {SourceMap} */\n\tlet sourceMap;\n\t/**\n\t * Check if asset can build source map\n\t */\n\tif (asset.sourceAndMap) {\n\t\tconst sourceAndMap = asset.sourceAndMap(options);\n\t\tsourceMap = /** @type {SourceMap} */ (sourceAndMap.map);\n\t\tsource = sourceAndMap.source;\n\t} else {\n\t\tsourceMap = /** @type {SourceMap} */ (asset.map(options));\n\t\tsource = asset.source();\n\t}\n\tif (!sourceMap || typeof source !== \"string\") return;\n\tconst context = compilation.options.context;\n\tconst root = compilation.compiler.root;\n\tconst cachedAbsolutify = makePathsAbsolute.bindContextCache(context, root);\n\tconst modules = sourceMap.sources.map(source => {\n\t\tif (!source.startsWith(\"webpack://\")) return source;\n\t\tsource = cachedAbsolutify(source.slice(10));\n\t\tconst module = compilation.findModule(source);\n\t\treturn module || source;\n\t});\n\n\treturn {\n\t\tfile,\n\t\tasset,\n\t\tsource,\n\t\tassetInfo,\n\t\tsourceMap,\n\t\tmodules,\n\t\tcacheItem\n\t};\n};\n\nclass SourceMapDevToolPlugin {\n\t/**\n\t * @param {SourceMapDevToolPluginOptions} [options] options object\n\t * @throws {Error} throws error, if got more than 1 arguments\n\t */\n\tconstructor(options = {}) {\n\t\tvalidate(options);\n\n\t\t/** @type {string | false} */\n\t\tthis.sourceMapFilename = options.filename;\n\t\t/** @type {string | false} */\n\t\tthis.sourceMappingURLComment =\n\t\t\toptions.append === false\n\t\t\t\t? false\n\t\t\t\t: options.append || \"\\n//# source\" + \"MappingURL=[url]\";\n\t\t/** @type {string | Function} */\n\t\tthis.moduleFilenameTemplate =\n\t\t\toptions.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n\t\t/** @type {string | Function} */\n\t\tthis.fallbackModuleFilenameTemplate =\n\t\t\toptions.fallbackModuleFilenameTemplate ||\n\t\t\t\"webpack://[namespace]/[resourcePath]?[hash]\";\n\t\t/** @type {string} */\n\t\tthis.namespace = options.namespace || \"\";\n\t\t/** @type {SourceMapDevToolPluginOptions} */\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst outputFs = compiler.outputFileSystem;\n\t\tconst sourceMapFilename = this.sourceMapFilename;\n\t\tconst sourceMappingURLComment = this.sourceMappingURLComment;\n\t\tconst moduleFilenameTemplate = this.moduleFilenameTemplate;\n\t\tconst namespace = this.namespace;\n\t\tconst fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n\t\tconst requestShortener = compiler.requestShortener;\n\t\tconst options = this.options;\n\t\toptions.test = options.test || /\\.((c|m)?js|css)($|\\?)/i;\n\n\t\tconst matchObject = ModuleFilenameHelpers.matchObject.bind(\n\t\t\tundefined,\n\t\t\toptions\n\t\t);\n\n\t\tcompiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n\t\t\tnew SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n\n\t\t\tcompilation.hooks.processAssets.tapAsync(\n\t\t\t\t{\n\t\t\t\t\tname: \"SourceMapDevToolPlugin\",\n\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING,\n\t\t\t\t\tadditionalAssets: true\n\t\t\t\t},\n\t\t\t\t(assets, callback) => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst cache = compilation.getCache(\"SourceMapDevToolPlugin\");\n\t\t\t\t\t/** @type {Map<string | Module, string>} */\n\t\t\t\t\tconst moduleToSourceNameMapping = new Map();\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {Function}\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst reportProgress =\n\t\t\t\t\t\tProgressPlugin.getReporter(compilation.compiler) || (() => {});\n\n\t\t\t\t\t/** @type {Map<string, Chunk>} */\n\t\t\t\t\tconst fileToChunk = new Map();\n\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\tfor (const file of chunk.files) {\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const file of chunk.auxiliaryFiles) {\n\t\t\t\t\t\t\tfileToChunk.set(file, chunk);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {string[]} */\n\t\t\t\t\tconst files = [];\n\t\t\t\t\tfor (const file of Object.keys(assets)) {\n\t\t\t\t\t\tif (matchObject(file)) {\n\t\t\t\t\t\t\tfiles.push(file);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treportProgress(0.0);\n\t\t\t\t\t/** @type {SourceMapTask[]} */\n\t\t\t\t\tconst tasks = [];\n\t\t\t\t\tlet fileIndex = 0;\n\n\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\tfiles,\n\t\t\t\t\t\t(file, callback) => {\n\t\t\t\t\t\t\tconst asset = compilation.getAsset(file);\n\t\t\t\t\t\t\tif (asset.info.related && asset.info.related.sourceMap) {\n\t\t\t\t\t\t\t\tfileIndex++;\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst cacheItem = cache.getItemCache(\n\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\tcache.mergeEtags(\n\t\t\t\t\t\t\t\t\tcache.getLazyHashedEtag(asset.source),\n\t\t\t\t\t\t\t\t\tnamespace\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tcacheItem.get((err, cacheEntry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * If presented in cache, reassigns assets. Cache assets already have source maps.\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\t\tconst { assets, assetsInfo } = cacheEntry;\n\t\t\t\t\t\t\t\t\tfor (const cachedFile of Object.keys(assets)) {\n\t\t\t\t\t\t\t\t\t\tif (cachedFile === file) {\n\t\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\n\t\t\t\t\t\t\t\t\t\t\t\tcachedFile,\n\t\t\t\t\t\t\t\t\t\t\t\tassets[cachedFile],\n\t\t\t\t\t\t\t\t\t\t\t\tassetsInfo[cachedFile]\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * Add file to chunk, if not presented there\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tif (cachedFile !== file) {\n\t\t\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\n\t\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\n\t\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(cachedFile);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\t\"restored cached SourceMap\"\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t(0.5 * fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\"generate SourceMap\"\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t/** @type {SourceMapTask | undefined} */\n\t\t\t\t\t\t\t\tconst task = getTaskForFile(\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\tasset.source,\n\t\t\t\t\t\t\t\t\tasset.info,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmodule: options.module,\n\t\t\t\t\t\t\t\t\t\tcolumns: options.columns\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\tcacheItem\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (task) {\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\t\t\tfor (let idx = 0; idx < modules.length; idx++) {\n\t\t\t\t\t\t\t\t\t\tconst module = modules[idx];\n\t\t\t\t\t\t\t\t\t\tif (!moduleToSourceNameMapping.get(module)) {\n\t\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(\n\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\tModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: moduleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttasks.push(task);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t(0.5 * ++fileIndex) / files.length,\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\"generated SourceMap\"\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treportProgress(0.5, \"resolve sources\");\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst usedNamesSet = new Set(moduleToSourceNameMapping.values());\n\t\t\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\t\t\tconst conflictDetectionSet = new Set();\n\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * all modules in defined order (longest identifier first)\n\t\t\t\t\t\t\t * @type {Array<string | Module>}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst allModules = Array.from(\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.keys()\n\t\t\t\t\t\t\t).sort((a, b) => {\n\t\t\t\t\t\t\t\tconst ai = typeof a === \"string\" ? a : a.identifier();\n\t\t\t\t\t\t\t\tconst bi = typeof b === \"string\" ? b : b.identifier();\n\t\t\t\t\t\t\t\treturn ai.length - bi.length;\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// find modules with conflicting source names\n\t\t\t\t\t\t\tfor (let idx = 0; idx < allModules.length; idx++) {\n\t\t\t\t\t\t\t\tconst module = allModules[idx];\n\t\t\t\t\t\t\t\tlet sourceName = moduleToSourceNameMapping.get(module);\n\t\t\t\t\t\t\t\tlet hasName = conflictDetectionSet.has(sourceName);\n\t\t\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\t\t\tconflictDetectionSet.add(sourceName);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// try the fallback name first\n\t\t\t\t\t\t\t\tsourceName = ModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: fallbackModuleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\trequestShortener,\n\t\t\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\t\t\thashFunction: compilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// otherwise just append stars until we have a valid name\n\t\t\t\t\t\t\t\twhile (hasName) {\n\t\t\t\t\t\t\t\t\tsourceName += \"*\";\n\t\t\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlet taskIndex = 0;\n\n\t\t\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\t\t\ttasks,\n\t\t\t\t\t\t\t\t(task, callback) => {\n\t\t\t\t\t\t\t\t\tconst assets = Object.create(null);\n\t\t\t\t\t\t\t\t\tconst assetsInfo = Object.create(null);\n\t\t\t\t\t\t\t\t\tconst file = task.file;\n\t\t\t\t\t\t\t\t\tconst chunk = fileToChunk.get(file);\n\t\t\t\t\t\t\t\t\tconst sourceMap = task.sourceMap;\n\t\t\t\t\t\t\t\t\tconst source = task.source;\n\t\t\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * taskIndex) / tasks.length,\n\t\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t\t\"attach SourceMap\"\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\tconst moduleFilenames = modules.map(m =>\n\t\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.get(m)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tsourceMap.sources = moduleFilenames;\n\t\t\t\t\t\t\t\t\tif (options.noSources) {\n\t\t\t\t\t\t\t\t\t\tsourceMap.sourcesContent = undefined;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tsourceMap.sourceRoot = options.sourceRoot || \"\";\n\t\t\t\t\t\t\t\t\tsourceMap.file = file;\n\t\t\t\t\t\t\t\t\tconst usesContentHash =\n\t\t\t\t\t\t\t\t\t\tsourceMapFilename &&\n\t\t\t\t\t\t\t\t\t\t/\\[contenthash(:\\w+)?\\]/.test(sourceMapFilename);\n\n\t\t\t\t\t\t\t\t\t// If SourceMap and asset uses contenthash, avoid a circular dependency by hiding hash in `file`\n\t\t\t\t\t\t\t\t\tif (usesContentHash && task.assetInfo.contenthash) {\n\t\t\t\t\t\t\t\t\t\tconst contenthash = task.assetInfo.contenthash;\n\t\t\t\t\t\t\t\t\t\tlet pattern;\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(contenthash)) {\n\t\t\t\t\t\t\t\t\t\t\tpattern = contenthash.map(quoteMeta).join(\"|\");\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tpattern = quoteMeta(contenthash);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tsourceMap.file = sourceMap.file.replace(\n\t\t\t\t\t\t\t\t\t\t\tnew RegExp(pattern, \"g\"),\n\t\t\t\t\t\t\t\t\t\t\tm => \"x\".repeat(m.length)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t/** @type {string | false} */\n\t\t\t\t\t\t\t\t\tlet currentSourceMappingURLComment = sourceMappingURLComment;\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment !== false &&\n\t\t\t\t\t\t\t\t\t\t/\\.css($|\\?)/i.test(file)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment =\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment.replace(\n\t\t\t\t\t\t\t\t\t\t\t\t/^\\n\\/\\/(.*)$/,\n\t\t\t\t\t\t\t\t\t\t\t\t\"\\n/*$1*/\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst sourceMapString = JSON.stringify(sourceMap);\n\t\t\t\t\t\t\t\t\tif (sourceMapFilename) {\n\t\t\t\t\t\t\t\t\t\tlet filename = file;\n\t\t\t\t\t\t\t\t\t\tconst sourceMapContentHash =\n\t\t\t\t\t\t\t\t\t\t\tusesContentHash &&\n\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (\n\t\t\t\t\t\t\t\t\t\t\t\tcreateHash(compilation.outputOptions.hashFunction)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.update(sourceMapString)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.digest(\"hex\")\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst pathParams = {\n\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\tfilename: options.fileContext\n\t\t\t\t\t\t\t\t\t\t\t\t? relative(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${options.fileContext}`,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`/${filename}`\n\t\t\t\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t\t\t\t: filename,\n\t\t\t\t\t\t\t\t\t\t\tcontentHash: sourceMapContentHash\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tconst { path: sourceMapFile, info: sourceMapInfo } =\n\t\t\t\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\n\t\t\t\t\t\t\t\t\t\t\t\tsourceMapFilename,\n\t\t\t\t\t\t\t\t\t\t\t\tpathParams\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tconst sourceMapUrl = options.publicPath\n\t\t\t\t\t\t\t\t\t\t\t? options.publicPath + sourceMapFile\n\t\t\t\t\t\t\t\t\t\t\t: relative(\n\t\t\t\t\t\t\t\t\t\t\t\t\toutputFs,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdirname(outputFs, `/${file}`),\n\t\t\t\t\t\t\t\t\t\t\t\t\t`/${sourceMapFile}`\n\t\t\t\t\t\t\t\t\t\t\t  );\n\t\t\t\t\t\t\t\t\t\t/** @type {Source} */\n\t\t\t\t\t\t\t\t\t\tlet asset = new RawSource(source);\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment !== false) {\n\t\t\t\t\t\t\t\t\t\t\t// Add source map url to compilation asset, if currentSourceMappingURLComment is set\n\t\t\t\t\t\t\t\t\t\t\tasset = new ConcatSource(\n\t\t\t\t\t\t\t\t\t\t\t\tasset,\n\t\t\t\t\t\t\t\t\t\t\t\tcompilation.getPath(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment,\n\t\t\t\t\t\t\t\t\t\t\t\t\tObject.assign({ url: sourceMapUrl }, pathParams)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst assetInfo = {\n\t\t\t\t\t\t\t\t\t\t\trelated: { sourceMap: sourceMapFile }\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = assetInfo;\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset, assetInfo);\n\t\t\t\t\t\t\t\t\t\t// Add source map file to compilation assets and chunk files\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAsset = new RawSource(sourceMapString);\n\t\t\t\t\t\t\t\t\t\tconst sourceMapAssetInfo = {\n\t\t\t\t\t\t\t\t\t\t\t...sourceMapInfo,\n\t\t\t\t\t\t\t\t\t\t\tdevelopment: true\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tassets[sourceMapFile] = sourceMapAsset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[sourceMapFile] = sourceMapAssetInfo;\n\t\t\t\t\t\t\t\t\t\tcompilation.emitAsset(\n\t\t\t\t\t\t\t\t\t\t\tsourceMapFile,\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAsset,\n\t\t\t\t\t\t\t\t\t\t\tsourceMapAssetInfo\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (chunk !== undefined)\n\t\t\t\t\t\t\t\t\t\t\tchunk.auxiliaryFiles.add(sourceMapFile);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (currentSourceMappingURLComment === false) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\"SourceMapDevToolPlugin: append can't be false when no filename is provided\"\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * Add source map as data url to asset\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tconst asset = new ConcatSource(\n\t\t\t\t\t\t\t\t\t\t\tnew RawSource(source),\n\t\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(/\\[map\\]/g, () => sourceMapString)\n\t\t\t\t\t\t\t\t\t\t\t\t.replace(\n\t\t\t\t\t\t\t\t\t\t\t\t\t/\\[url\\]/g,\n\t\t\t\t\t\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`data:application/json;charset=utf-8;base64,${Buffer.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsourceMapString,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"utf-8\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t).toString(\"base64\")}`\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\t\t\tassetsInfo[file] = undefined;\n\t\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\ttask.cacheItem.store({ assets, assetsInfo }, err => {\n\t\t\t\t\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t\t\t\t\t0.5 + (0.5 * ++taskIndex) / tasks.length,\n\t\t\t\t\t\t\t\t\t\t\ttask.file,\n\t\t\t\t\t\t\t\t\t\t\t\"attached SourceMap\"\n\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\treportProgress(1.0);\n\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = SourceMapDevToolPlugin;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}