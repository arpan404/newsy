{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\"use strict\";\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * @typedef {Object} PathTreeNode\n * @property {Map<string, PathTreeNode>|null} children\n * @property {MappingValue} folder\n * @property {Map<string, MappingValue>|null} wildcards\n * @property {Map<string, MappingValue>} files\n */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {string[]} resolved paths\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\n\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\n\nmodule.exports.processExportsField = function processExportsField(exportsField) {\n  return createFieldProcessor(buildExportsFieldPathTree(exportsField), assertExportsFieldRequest, assertExportTarget);\n};\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\n\n\nmodule.exports.processImportsField = function processImportsField(importsField) {\n  return createFieldProcessor(buildImportsFieldPathTree(importsField), assertImportsFieldRequest, assertImportTarget);\n};\n/**\n * @param {PathTreeNode} treeRoot root\n * @param {(s: string) => string} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\n\n\nfunction createFieldProcessor(treeRoot, assertRequest, assertTarget) {\n  return function fieldProcessor(request, conditionNames) {\n    request = assertRequest(request);\n    const match = findMatch(request, treeRoot);\n    if (match === null) return [];\n    const [mapping, remainRequestIndex] = match;\n    /** @type {DirectMapping|null} */\n\n    let direct = null;\n\n    if (isConditionalMapping(mapping)) {\n      direct = conditionalMapping(\n      /** @type {ConditionalMapping} */\n      mapping, conditionNames); // matching not found\n\n      if (direct === null) return [];\n    } else {\n      direct =\n      /** @type {DirectMapping} */\n      mapping;\n    }\n\n    const remainingRequest = remainRequestIndex === request.length + 1 ? undefined : remainRequestIndex < 0 ? request.slice(-remainRequestIndex - 1) : request.slice(remainRequestIndex);\n    return directMapping(remainingRequest, remainRequestIndex < 0, direct, conditionNames, assertTarget);\n  };\n}\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\n\n\nfunction assertExportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== dotCode) {\n    throw new Error('Request should be relative path and start with \".\"');\n  }\n\n  if (request.length === 1) return \"\";\n\n  if (request.charCodeAt(1) !== slashCode) {\n    throw new Error('Request should be relative path and start with \"./\"');\n  }\n\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n\n  return request.slice(2);\n}\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\n\n\nfunction assertImportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== hashCode) {\n    throw new Error('Request should start with \"#\"');\n  }\n\n  if (request.length === 1) {\n    throw new Error(\"Request should have at least 2 characters\");\n  }\n\n  if (request.charCodeAt(1) === slashCode) {\n    throw new Error('Request should not start with \"#/\"');\n  }\n\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n\n  return request.slice(1);\n}\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\n\n\nfunction assertExportTarget(exp, expectFolder) {\n  if (exp.charCodeAt(0) === slashCode || exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode) {\n    throw new Error(`Export should be relative path and start with \"./\", got ${JSON.stringify(exp)}.`);\n  }\n\n  const isFolder = exp.charCodeAt(exp.length - 1) === slashCode;\n\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(exp)} should end with \"/\"` : `Expecting file to file mapping. ${JSON.stringify(exp)} should not end with \"/\"`);\n  }\n}\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\n\n\nfunction assertImportTarget(imp, expectFolder) {\n  const isFolder = imp.charCodeAt(imp.length - 1) === slashCode;\n\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(imp)} should end with \"/\"` : `Expecting file to file mapping. ${JSON.stringify(imp)} should not end with \"/\"`);\n  }\n}\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {PathTreeNode} treeRoot path tree root\n * @returns {[MappingValue, number]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings\n */\n\n\nfunction findMatch(request, treeRoot) {\n  if (request.length === 0) {\n    const value = treeRoot.files.get(\"\");\n    return value ? [value, 1] : null;\n  }\n\n  if (treeRoot.children === null && treeRoot.folder === null && treeRoot.wildcards === null) {\n    const value = treeRoot.files.get(request);\n    return value ? [value, request.length + 1] : null;\n  }\n\n  let node = treeRoot;\n  let lastNonSlashIndex = 0;\n  let slashIndex = request.indexOf(\"/\", 0);\n  /** @type {[MappingValue, number]|null} */\n\n  let lastFolderMatch = null;\n\n  const applyFolderMapping = () => {\n    const folderMapping = node.folder;\n\n    if (folderMapping) {\n      if (lastFolderMatch) {\n        lastFolderMatch[0] = folderMapping;\n        lastFolderMatch[1] = -lastNonSlashIndex - 1;\n      } else {\n        lastFolderMatch = [folderMapping, -lastNonSlashIndex - 1];\n      }\n    }\n  };\n\n  const applyWildcardMappings = (wildcardMappings, remainingRequest) => {\n    if (wildcardMappings) {\n      for (const [key, target] of wildcardMappings) {\n        if (remainingRequest.startsWith(key)) {\n          if (!lastFolderMatch) {\n            lastFolderMatch = [target, lastNonSlashIndex + key.length];\n          } else if (lastFolderMatch[1] < lastNonSlashIndex + key.length) {\n            lastFolderMatch[0] = target;\n            lastFolderMatch[1] = lastNonSlashIndex + key.length;\n          }\n        }\n      }\n    }\n  };\n\n  while (slashIndex !== -1) {\n    applyFolderMapping();\n    const wildcardMappings = node.wildcards;\n    if (!wildcardMappings && node.children === null) return lastFolderMatch;\n    const folder = request.slice(lastNonSlashIndex, slashIndex);\n    applyWildcardMappings(wildcardMappings, folder);\n    if (node.children === null) return lastFolderMatch;\n    const newNode = node.children.get(folder);\n\n    if (!newNode) {\n      return lastFolderMatch;\n    }\n\n    node = newNode;\n    lastNonSlashIndex = slashIndex + 1;\n    slashIndex = request.indexOf(\"/\", lastNonSlashIndex);\n  }\n\n  const remainingRequest = lastNonSlashIndex > 0 ? request.slice(lastNonSlashIndex) : request;\n  const value = node.files.get(remainingRequest);\n\n  if (value) {\n    return [value, request.length + 1];\n  }\n\n  applyFolderMapping();\n  applyWildcardMappings(node.wildcards, remainingRequest);\n  return lastFolderMatch;\n}\n/**\n * @param {ConditionalMapping|DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\n\n\nfunction isConditionalMapping(mapping) {\n  return mapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping);\n}\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} subpathMapping true, for subpath mappings\n * @param {DirectMapping|null} mappingTarget direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\n\n\nfunction directMapping(remainingRequest, subpathMapping, mappingTarget, conditionNames, assert) {\n  if (mappingTarget === null) return [];\n\n  if (typeof mappingTarget === \"string\") {\n    return [targetMapping(remainingRequest, subpathMapping, mappingTarget, assert)];\n  }\n\n  const targets = [];\n\n  for (const exp of mappingTarget) {\n    if (typeof exp === \"string\") {\n      targets.push(targetMapping(remainingRequest, subpathMapping, exp, assert));\n      continue;\n    }\n\n    const mapping = conditionalMapping(exp, conditionNames);\n    if (!mapping) continue;\n    const innerExports = directMapping(remainingRequest, subpathMapping, mapping, conditionNames, assert);\n\n    for (const innerExport of innerExports) {\n      targets.push(innerExport);\n    }\n  }\n\n  return targets;\n}\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} subpathMapping true, for subpath mappings\n * @param {string} mappingTarget direct export\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string} mapping result\n */\n\n\nfunction targetMapping(remainingRequest, subpathMapping, mappingTarget, assert) {\n  if (remainingRequest === undefined) {\n    assert(mappingTarget, false);\n    return mappingTarget;\n  }\n\n  if (subpathMapping) {\n    assert(mappingTarget, true);\n    return mappingTarget + remainingRequest;\n  }\n\n  assert(mappingTarget, false);\n  return mappingTarget.replace(/\\*/g, remainingRequest.replace(/\\$/g, \"$$\"));\n}\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping|null} direct mapping if found\n */\n\n\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n  /** @type {[ConditionalMapping, string[], number][]} */\n  let lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n\n  loop: while (lookup.length > 0) {\n    const [mapping, conditions, j] = lookup[lookup.length - 1];\n    const last = conditions.length - 1;\n\n    for (let i = j; i < conditions.length; i++) {\n      const condition = conditions[i]; // assert default. Could be last only\n\n      if (i !== last) {\n        if (condition === \"default\") {\n          throw new Error(\"Default condition should be last one\");\n        }\n      } else if (condition === \"default\") {\n        const innerMapping = mapping[condition]; // is nested\n\n        if (isConditionalMapping(innerMapping)) {\n          const conditionalMapping =\n          /** @type {ConditionalMapping} */\n          innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n          continue loop;\n        }\n\n        return (\n          /** @type {DirectMapping} */\n          innerMapping\n        );\n      }\n\n      if (conditionNames.has(condition)) {\n        const innerMapping = mapping[condition]; // is nested\n\n        if (isConditionalMapping(innerMapping)) {\n          const conditionalMapping =\n          /** @type {ConditionalMapping} */\n          innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n          continue loop;\n        }\n\n        return (\n          /** @type {DirectMapping} */\n          innerMapping\n        );\n      }\n    }\n\n    lookup.pop();\n  }\n\n  return null;\n}\n/**\n * Internal helper to create path tree node\n * to ensure that each node gets the same hidden class\n * @returns {PathTreeNode} node\n */\n\n\nfunction createNode() {\n  return {\n    children: null,\n    folder: null,\n    wildcards: null,\n    files: new Map()\n  };\n}\n/**\n * Internal helper for building path tree\n * @param {PathTreeNode} root root\n * @param {string} path path\n * @param {MappingValue} target target\n */\n\n\nfunction walkPath(root, path, target) {\n  if (path.length === 0) {\n    root.folder = target;\n    return;\n  }\n\n  let node = root; // Typical path tree can looks like\n  // root\n  // - files: [\"a.js\", \"b.js\"]\n  // - children:\n  //    node1:\n  //    - files: [\"a.js\", \"b.js\"]\n\n  let lastNonSlashIndex = 0;\n  let slashIndex = path.indexOf(\"/\", 0);\n\n  while (slashIndex !== -1) {\n    const folder = path.slice(lastNonSlashIndex, slashIndex);\n    let newNode;\n\n    if (node.children === null) {\n      newNode = createNode();\n      node.children = new Map();\n      node.children.set(folder, newNode);\n    } else {\n      newNode = node.children.get(folder);\n\n      if (!newNode) {\n        newNode = createNode();\n        node.children.set(folder, newNode);\n      }\n    }\n\n    node = newNode;\n    lastNonSlashIndex = slashIndex + 1;\n    slashIndex = path.indexOf(\"/\", lastNonSlashIndex);\n  }\n\n  if (lastNonSlashIndex >= path.length) {\n    node.folder = target;\n  } else {\n    const file = lastNonSlashIndex > 0 ? path.slice(lastNonSlashIndex) : path;\n\n    if (file.endsWith(\"*\")) {\n      if (node.wildcards === null) node.wildcards = new Map();\n      node.wildcards.set(file.slice(0, -1), target);\n    } else {\n      node.files.set(file, target);\n    }\n  }\n}\n/**\n * @param {ExportsField} field exports field\n * @returns {PathTreeNode} tree root\n */\n\n\nfunction buildExportsFieldPathTree(field) {\n  const root = createNode(); // handle syntax sugar, if exports field is direct mapping for \".\"\n\n  if (typeof field === \"string\") {\n    root.files.set(\"\", field);\n    return root;\n  } else if (Array.isArray(field)) {\n    root.files.set(\"\", field.slice());\n    return root;\n  }\n\n  const keys = Object.keys(field);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n\n    if (key.charCodeAt(0) !== dotCode) {\n      // handle syntax sugar, if exports field is conditional mapping for \".\"\n      if (i === 0) {\n        while (i < keys.length) {\n          const charCode = keys[i].charCodeAt(0);\n\n          if (charCode === dotCode || charCode === slashCode) {\n            throw new Error(`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(key)})`);\n          }\n\n          i++;\n        }\n\n        root.files.set(\"\", field);\n        return root;\n      }\n\n      throw new Error(`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(key)})`);\n    }\n\n    if (key.length === 1) {\n      root.files.set(\"\", field[key]);\n      continue;\n    }\n\n    if (key.charCodeAt(1) !== slashCode) {\n      throw new Error(`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(key)})`);\n    }\n\n    walkPath(root, key.slice(2), field[key]);\n  }\n\n  return root;\n}\n/**\n * @param {ImportsField} field imports field\n * @returns {PathTreeNode} root\n */\n\n\nfunction buildImportsFieldPathTree(field) {\n  const root = createNode();\n  const keys = Object.keys(field);\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n\n    if (key.charCodeAt(0) !== hashCode) {\n      throw new Error(`Imports field key should start with \"#\" (key: ${JSON.stringify(key)})`);\n    }\n\n    if (key.length === 1) {\n      throw new Error(`Imports field key should have at least 2 characters (key: ${JSON.stringify(key)})`);\n    }\n\n    if (key.charCodeAt(1) === slashCode) {\n      throw new Error(`Imports field key should not start with \"#/\" (key: ${JSON.stringify(key)})`);\n    }\n\n    walkPath(root, key.slice(1), field[key]);\n  }\n\n  return root;\n}","map":{"version":3,"names":["slashCode","charCodeAt","dotCode","hashCode","module","exports","processExportsField","exportsField","createFieldProcessor","buildExportsFieldPathTree","assertExportsFieldRequest","assertExportTarget","processImportsField","importsField","buildImportsFieldPathTree","assertImportsFieldRequest","assertImportTarget","treeRoot","assertRequest","assertTarget","fieldProcessor","request","conditionNames","match","findMatch","mapping","remainRequestIndex","direct","isConditionalMapping","conditionalMapping","remainingRequest","length","undefined","slice","directMapping","Error","exp","expectFolder","JSON","stringify","isFolder","imp","value","files","get","children","folder","wildcards","node","lastNonSlashIndex","slashIndex","indexOf","lastFolderMatch","applyFolderMapping","folderMapping","applyWildcardMappings","wildcardMappings","key","target","startsWith","newNode","Array","isArray","subpathMapping","mappingTarget","assert","targetMapping","targets","push","innerExports","innerExport","replace","conditionalMapping_","lookup","Object","keys","loop","conditions","j","last","i","condition","innerMapping","has","pop","createNode","Map","walkPath","root","path","set","file","endsWith","field","charCode"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/enhanced-resolve/lib/util/entrypoints.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * @typedef {Object} PathTreeNode\n * @property {Map<string, PathTreeNode>|null} children\n * @property {MappingValue} folder\n * @property {Map<string, MappingValue>|null} wildcards\n * @property {Map<string, MappingValue>} files\n */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {string[]} resolved paths\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\n\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\n\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processExportsField = function processExportsField(\n\texportsField\n) {\n\treturn createFieldProcessor(\n\t\tbuildExportsFieldPathTree(exportsField),\n\t\tassertExportsFieldRequest,\n\t\tassertExportTarget\n\t);\n};\n\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processImportsField = function processImportsField(\n\timportsField\n) {\n\treturn createFieldProcessor(\n\t\tbuildImportsFieldPathTree(importsField),\n\t\tassertImportsFieldRequest,\n\t\tassertImportTarget\n\t);\n};\n\n/**\n * @param {PathTreeNode} treeRoot root\n * @param {(s: string) => string} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\nfunction createFieldProcessor(treeRoot, assertRequest, assertTarget) {\n\treturn function fieldProcessor(request, conditionNames) {\n\t\trequest = assertRequest(request);\n\n\t\tconst match = findMatch(request, treeRoot);\n\n\t\tif (match === null) return [];\n\n\t\tconst [mapping, remainRequestIndex] = match;\n\n\t\t/** @type {DirectMapping|null} */\n\t\tlet direct = null;\n\n\t\tif (isConditionalMapping(mapping)) {\n\t\t\tdirect = conditionalMapping(\n\t\t\t\t/** @type {ConditionalMapping} */ (mapping),\n\t\t\t\tconditionNames\n\t\t\t);\n\n\t\t\t// matching not found\n\t\t\tif (direct === null) return [];\n\t\t} else {\n\t\t\tdirect = /** @type {DirectMapping} */ (mapping);\n\t\t}\n\n\t\tconst remainingRequest =\n\t\t\tremainRequestIndex === request.length + 1\n\t\t\t\t? undefined\n\t\t\t\t: remainRequestIndex < 0\n\t\t\t\t? request.slice(-remainRequestIndex - 1)\n\t\t\t\t: request.slice(remainRequestIndex);\n\n\t\treturn directMapping(\n\t\t\tremainingRequest,\n\t\t\tremainRequestIndex < 0,\n\t\t\tdirect,\n\t\t\tconditionNames,\n\t\t\tassertTarget\n\t\t);\n\t};\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertExportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== dotCode) {\n\t\tthrow new Error('Request should be relative path and start with \".\"');\n\t}\n\tif (request.length === 1) return \"\";\n\tif (request.charCodeAt(1) !== slashCode) {\n\t\tthrow new Error('Request should be relative path and start with \"./\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(2);\n}\n\n/**\n * @param {string} request request\n * @returns {string} updated request\n */\nfunction assertImportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== hashCode) {\n\t\tthrow new Error('Request should start with \"#\"');\n\t}\n\tif (request.length === 1) {\n\t\tthrow new Error(\"Request should have at least 2 characters\");\n\t}\n\tif (request.charCodeAt(1) === slashCode) {\n\t\tthrow new Error('Request should not start with \"#/\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n\n\treturn request.slice(1);\n}\n\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertExportTarget(exp, expectFolder) {\n\tif (\n\t\texp.charCodeAt(0) === slashCode ||\n\t\t(exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode)\n\t) {\n\t\tthrow new Error(\n\t\t\t`Export should be relative path and start with \"./\", got ${JSON.stringify(\n\t\t\t\texp\n\t\t\t)}.`\n\t\t);\n\t}\n\n\tconst isFolder = exp.charCodeAt(exp.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertImportTarget(imp, expectFolder) {\n\tconst isFolder = imp.charCodeAt(imp.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {PathTreeNode} treeRoot path tree root\n * @returns {[MappingValue, number]|null} match or null, number is negative and one less when it's a folder mapping, number is request.length + 1 for direct mappings\n */\nfunction findMatch(request, treeRoot) {\n\tif (request.length === 0) {\n\t\tconst value = treeRoot.files.get(\"\");\n\n\t\treturn value ? [value, 1] : null;\n\t}\n\n\tif (\n\t\ttreeRoot.children === null &&\n\t\ttreeRoot.folder === null &&\n\t\ttreeRoot.wildcards === null\n\t) {\n\t\tconst value = treeRoot.files.get(request);\n\n\t\treturn value ? [value, request.length + 1] : null;\n\t}\n\n\tlet node = treeRoot;\n\tlet lastNonSlashIndex = 0;\n\tlet slashIndex = request.indexOf(\"/\", 0);\n\n\t/** @type {[MappingValue, number]|null} */\n\tlet lastFolderMatch = null;\n\n\tconst applyFolderMapping = () => {\n\t\tconst folderMapping = node.folder;\n\t\tif (folderMapping) {\n\t\t\tif (lastFolderMatch) {\n\t\t\t\tlastFolderMatch[0] = folderMapping;\n\t\t\t\tlastFolderMatch[1] = -lastNonSlashIndex - 1;\n\t\t\t} else {\n\t\t\t\tlastFolderMatch = [folderMapping, -lastNonSlashIndex - 1];\n\t\t\t}\n\t\t}\n\t};\n\n\tconst applyWildcardMappings = (wildcardMappings, remainingRequest) => {\n\t\tif (wildcardMappings) {\n\t\t\tfor (const [key, target] of wildcardMappings) {\n\t\t\t\tif (remainingRequest.startsWith(key)) {\n\t\t\t\t\tif (!lastFolderMatch) {\n\t\t\t\t\t\tlastFolderMatch = [target, lastNonSlashIndex + key.length];\n\t\t\t\t\t} else if (lastFolderMatch[1] < lastNonSlashIndex + key.length) {\n\t\t\t\t\t\tlastFolderMatch[0] = target;\n\t\t\t\t\t\tlastFolderMatch[1] = lastNonSlashIndex + key.length;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\twhile (slashIndex !== -1) {\n\t\tapplyFolderMapping();\n\n\t\tconst wildcardMappings = node.wildcards;\n\n\t\tif (!wildcardMappings && node.children === null) return lastFolderMatch;\n\n\t\tconst folder = request.slice(lastNonSlashIndex, slashIndex);\n\n\t\tapplyWildcardMappings(wildcardMappings, folder);\n\n\t\tif (node.children === null) return lastFolderMatch;\n\n\t\tconst newNode = node.children.get(folder);\n\n\t\tif (!newNode) {\n\t\t\treturn lastFolderMatch;\n\t\t}\n\n\t\tnode = newNode;\n\t\tlastNonSlashIndex = slashIndex + 1;\n\t\tslashIndex = request.indexOf(\"/\", lastNonSlashIndex);\n\t}\n\n\tconst remainingRequest =\n\t\tlastNonSlashIndex > 0 ? request.slice(lastNonSlashIndex) : request;\n\n\tconst value = node.files.get(remainingRequest);\n\n\tif (value) {\n\t\treturn [value, request.length + 1];\n\t}\n\n\tapplyFolderMapping();\n\n\tapplyWildcardMappings(node.wildcards, remainingRequest);\n\n\treturn lastFolderMatch;\n}\n\n/**\n * @param {ConditionalMapping|DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\nfunction isConditionalMapping(mapping) {\n\treturn (\n\t\tmapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping)\n\t);\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} subpathMapping true, for subpath mappings\n * @param {DirectMapping|null} mappingTarget direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\nfunction directMapping(\n\tremainingRequest,\n\tsubpathMapping,\n\tmappingTarget,\n\tconditionNames,\n\tassert\n) {\n\tif (mappingTarget === null) return [];\n\n\tif (typeof mappingTarget === \"string\") {\n\t\treturn [\n\t\t\ttargetMapping(remainingRequest, subpathMapping, mappingTarget, assert)\n\t\t];\n\t}\n\n\tconst targets = [];\n\n\tfor (const exp of mappingTarget) {\n\t\tif (typeof exp === \"string\") {\n\t\t\ttargets.push(\n\t\t\t\ttargetMapping(remainingRequest, subpathMapping, exp, assert)\n\t\t\t);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst mapping = conditionalMapping(exp, conditionNames);\n\t\tif (!mapping) continue;\n\t\tconst innerExports = directMapping(\n\t\t\tremainingRequest,\n\t\t\tsubpathMapping,\n\t\t\tmapping,\n\t\t\tconditionNames,\n\t\t\tassert\n\t\t);\n\t\tfor (const innerExport of innerExports) {\n\t\t\ttargets.push(innerExport);\n\t\t}\n\t}\n\n\treturn targets;\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {boolean} subpathMapping true, for subpath mappings\n * @param {string} mappingTarget direct export\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string} mapping result\n */\nfunction targetMapping(\n\tremainingRequest,\n\tsubpathMapping,\n\tmappingTarget,\n\tassert\n) {\n\tif (remainingRequest === undefined) {\n\t\tassert(mappingTarget, false);\n\t\treturn mappingTarget;\n\t}\n\tif (subpathMapping) {\n\t\tassert(mappingTarget, true);\n\t\treturn mappingTarget + remainingRequest;\n\t}\n\tassert(mappingTarget, false);\n\treturn mappingTarget.replace(/\\*/g, remainingRequest.replace(/\\$/g, \"$$\"));\n}\n\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping|null} direct mapping if found\n */\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n\t/** @type {[ConditionalMapping, string[], number][]} */\n\tlet lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n\n\tloop: while (lookup.length > 0) {\n\t\tconst [mapping, conditions, j] = lookup[lookup.length - 1];\n\t\tconst last = conditions.length - 1;\n\n\t\tfor (let i = j; i < conditions.length; i++) {\n\t\t\tconst condition = conditions[i];\n\n\t\t\t// assert default. Could be last only\n\t\t\tif (i !== last) {\n\t\t\t\tif (condition === \"default\") {\n\t\t\t\t\tthrow new Error(\"Default condition should be last one\");\n\t\t\t\t}\n\t\t\t} else if (condition === \"default\") {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (innerMapping);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\n\t\t\tif (conditionNames.has(condition)) {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (innerMapping);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\t\t}\n\n\t\tlookup.pop();\n\t}\n\n\treturn null;\n}\n\n/**\n * Internal helper to create path tree node\n * to ensure that each node gets the same hidden class\n * @returns {PathTreeNode} node\n */\nfunction createNode() {\n\treturn {\n\t\tchildren: null,\n\t\tfolder: null,\n\t\twildcards: null,\n\t\tfiles: new Map()\n\t};\n}\n\n/**\n * Internal helper for building path tree\n * @param {PathTreeNode} root root\n * @param {string} path path\n * @param {MappingValue} target target\n */\nfunction walkPath(root, path, target) {\n\tif (path.length === 0) {\n\t\troot.folder = target;\n\t\treturn;\n\t}\n\n\tlet node = root;\n\t// Typical path tree can looks like\n\t// root\n\t// - files: [\"a.js\", \"b.js\"]\n\t// - children:\n\t//    node1:\n\t//    - files: [\"a.js\", \"b.js\"]\n\tlet lastNonSlashIndex = 0;\n\tlet slashIndex = path.indexOf(\"/\", 0);\n\n\twhile (slashIndex !== -1) {\n\t\tconst folder = path.slice(lastNonSlashIndex, slashIndex);\n\t\tlet newNode;\n\n\t\tif (node.children === null) {\n\t\t\tnewNode = createNode();\n\t\t\tnode.children = new Map();\n\t\t\tnode.children.set(folder, newNode);\n\t\t} else {\n\t\t\tnewNode = node.children.get(folder);\n\n\t\t\tif (!newNode) {\n\t\t\t\tnewNode = createNode();\n\t\t\t\tnode.children.set(folder, newNode);\n\t\t\t}\n\t\t}\n\n\t\tnode = newNode;\n\t\tlastNonSlashIndex = slashIndex + 1;\n\t\tslashIndex = path.indexOf(\"/\", lastNonSlashIndex);\n\t}\n\n\tif (lastNonSlashIndex >= path.length) {\n\t\tnode.folder = target;\n\t} else {\n\t\tconst file = lastNonSlashIndex > 0 ? path.slice(lastNonSlashIndex) : path;\n\t\tif (file.endsWith(\"*\")) {\n\t\t\tif (node.wildcards === null) node.wildcards = new Map();\n\t\t\tnode.wildcards.set(file.slice(0, -1), target);\n\t\t} else {\n\t\t\tnode.files.set(file, target);\n\t\t}\n\t}\n}\n\n/**\n * @param {ExportsField} field exports field\n * @returns {PathTreeNode} tree root\n */\nfunction buildExportsFieldPathTree(field) {\n\tconst root = createNode();\n\n\t// handle syntax sugar, if exports field is direct mapping for \".\"\n\tif (typeof field === \"string\") {\n\t\troot.files.set(\"\", field);\n\n\t\treturn root;\n\t} else if (Array.isArray(field)) {\n\t\troot.files.set(\"\", field.slice());\n\n\t\treturn root;\n\t}\n\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== dotCode) {\n\t\t\t// handle syntax sugar, if exports field is conditional mapping for \".\"\n\t\t\tif (i === 0) {\n\t\t\t\twhile (i < keys.length) {\n\t\t\t\t\tconst charCode = keys[i].charCodeAt(0);\n\t\t\t\t\tif (charCode === dotCode || charCode === slashCode) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\troot.files.set(\"\", field);\n\t\t\t\treturn root;\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\troot.files.set(\"\", field[key]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key.charCodeAt(1) !== slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\twalkPath(root, key.slice(2), field[key]);\n\t}\n\n\treturn root;\n}\n\n/**\n * @param {ImportsField} field imports field\n * @returns {PathTreeNode} root\n */\nfunction buildImportsFieldPathTree(field) {\n\tconst root = createNode();\n\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== hashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should start with \"#\" (key: ${JSON.stringify(key)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should have at least 2 characters (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.charCodeAt(1) === slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should not start with \"#/\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\twalkPath(root, key.slice(1), field[key]);\n\t}\n\n\treturn root;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}