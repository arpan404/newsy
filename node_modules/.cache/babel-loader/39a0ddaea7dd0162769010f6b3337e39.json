{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\\\/]/;\nconst SEGMENTS_SPLIT_REGEXP = /([|!])/;\nconst WINDOWS_PATH_SEPARATOR_REGEXP = /\\\\/g;\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\nconst relativePathToRequest = relativePath => {\n  if (relativePath === \"\") return \"./.\";\n  if (relativePath === \"..\") return \"../.\";\n  if (relativePath.startsWith(\"../\")) return relativePath;\n  return `./${relativePath}`;\n};\n/**\n * @param {string} context context for relative path\n * @param {string} maybeAbsolutePath path to make relative\n * @returns {string} relative path in request style\n */\n\n\nconst absoluteToRequest = (context, maybeAbsolutePath) => {\n  if (maybeAbsolutePath[0] === \"/\") {\n    if (maybeAbsolutePath.length > 1 && maybeAbsolutePath[maybeAbsolutePath.length - 1] === \"/\") {\n      // this 'path' is actually a regexp generated by dynamic requires.\n      // Don't treat it as an absolute path.\n      return maybeAbsolutePath;\n    }\n\n    const querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);\n    resource = relativePathToRequest(path.posix.relative(context, resource));\n    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);\n  }\n\n  if (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {\n    const querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n    let resource = querySplitPos === -1 ? maybeAbsolutePath : maybeAbsolutePath.slice(0, querySplitPos);\n    resource = path.win32.relative(context, resource);\n\n    if (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {\n      resource = relativePathToRequest(resource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, \"/\"));\n    }\n\n    return querySplitPos === -1 ? resource : resource + maybeAbsolutePath.slice(querySplitPos);\n  } // not an absolute path\n\n\n  return maybeAbsolutePath;\n};\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\n\n\nconst requestToAbsolute = (context, relativePath) => {\n  if (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\")) return path.join(context, relativePath);\n  return relativePath;\n};\n\nconst makeCacheable = realFn => {\n  /** @type {WeakMap<object, Map<string, ParsedResource>>} */\n  const cache = new WeakMap();\n\n  const getCache = associatedObjectForCache => {\n    const entry = cache.get(associatedObjectForCache);\n    if (entry !== undefined) return entry;\n    /** @type {Map<string, ParsedResource>} */\n\n    const map = new Map();\n    cache.set(associatedObjectForCache, map);\n    return map;\n  };\n  /**\n   * @param {string} str the path with query and fragment\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {ParsedResource} parsed parts\n   */\n\n\n  const fn = (str, associatedObjectForCache) => {\n    if (!associatedObjectForCache) return realFn(str);\n    const cache = getCache(associatedObjectForCache);\n    const entry = cache.get(str);\n    if (entry !== undefined) return entry;\n    const result = realFn(str);\n    cache.set(str, result);\n    return result;\n  };\n\n  fn.bindCache = associatedObjectForCache => {\n    const cache = getCache(associatedObjectForCache);\n    return str => {\n      const entry = cache.get(str);\n      if (entry !== undefined) return entry;\n      const result = realFn(str);\n      cache.set(str, result);\n      return result;\n    };\n  };\n\n  return fn;\n};\n\nconst makeCacheableWithContext = fn => {\n  /** @type {WeakMap<object, Map<string, Map<string, string>>>} */\n  const cache = new WeakMap();\n  /**\n   * @param {string} context context used to create relative path\n   * @param {string} identifier identifier used to create relative path\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {string} the returned relative path\n   */\n\n  const cachedFn = (context, identifier, associatedObjectForCache) => {\n    if (!associatedObjectForCache) return fn(context, identifier);\n    let innerCache = cache.get(associatedObjectForCache);\n\n    if (innerCache === undefined) {\n      innerCache = new Map();\n      cache.set(associatedObjectForCache, innerCache);\n    }\n\n    let cachedResult;\n    let innerSubCache = innerCache.get(context);\n\n    if (innerSubCache === undefined) {\n      innerCache.set(context, innerSubCache = new Map());\n    } else {\n      cachedResult = innerSubCache.get(identifier);\n    }\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    } else {\n      const result = fn(context, identifier);\n      innerSubCache.set(identifier, result);\n      return result;\n    }\n  };\n  /**\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {function(string, string): string} cached function\n   */\n\n\n  cachedFn.bindCache = associatedObjectForCache => {\n    let innerCache;\n\n    if (associatedObjectForCache) {\n      innerCache = cache.get(associatedObjectForCache);\n\n      if (innerCache === undefined) {\n        innerCache = new Map();\n        cache.set(associatedObjectForCache, innerCache);\n      }\n    } else {\n      innerCache = new Map();\n    }\n    /**\n     * @param {string} context context used to create relative path\n     * @param {string} identifier identifier used to create relative path\n     * @returns {string} the returned relative path\n     */\n\n\n    const boundFn = (context, identifier) => {\n      let cachedResult;\n      let innerSubCache = innerCache.get(context);\n\n      if (innerSubCache === undefined) {\n        innerCache.set(context, innerSubCache = new Map());\n      } else {\n        cachedResult = innerSubCache.get(identifier);\n      }\n\n      if (cachedResult !== undefined) {\n        return cachedResult;\n      } else {\n        const result = fn(context, identifier);\n        innerSubCache.set(identifier, result);\n        return result;\n      }\n    };\n\n    return boundFn;\n  };\n  /**\n   * @param {string} context context used to create relative path\n   * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n   * @returns {function(string): string} cached function\n   */\n\n\n  cachedFn.bindContextCache = (context, associatedObjectForCache) => {\n    let innerSubCache;\n\n    if (associatedObjectForCache) {\n      let innerCache = cache.get(associatedObjectForCache);\n\n      if (innerCache === undefined) {\n        innerCache = new Map();\n        cache.set(associatedObjectForCache, innerCache);\n      }\n\n      innerSubCache = innerCache.get(context);\n\n      if (innerSubCache === undefined) {\n        innerCache.set(context, innerSubCache = new Map());\n      }\n    } else {\n      innerSubCache = new Map();\n    }\n    /**\n     * @param {string} identifier identifier used to create relative path\n     * @returns {string} the returned relative path\n     */\n\n\n    const boundFn = identifier => {\n      const cachedResult = innerSubCache.get(identifier);\n\n      if (cachedResult !== undefined) {\n        return cachedResult;\n      } else {\n        const result = fn(context, identifier);\n        innerSubCache.set(identifier, result);\n        return result;\n      }\n    };\n\n    return boundFn;\n  };\n\n  return cachedFn;\n};\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\n\n\nconst _makePathsRelative = (context, identifier) => {\n  return identifier.split(SEGMENTS_SPLIT_REGEXP).map(str => absoluteToRequest(context, str)).join(\"\");\n};\n\nexports.makePathsRelative = makeCacheableWithContext(_makePathsRelative);\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\n\nconst _makePathsAbsolute = (context, identifier) => {\n  return identifier.split(SEGMENTS_SPLIT_REGEXP).map(str => requestToAbsolute(context, str)).join(\"\");\n};\n\nexports.makePathsAbsolute = makeCacheableWithContext(_makePathsAbsolute);\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\n\nconst _contextify = (context, request) => {\n  return request.split(\"!\").map(r => absoluteToRequest(context, r)).join(\"!\");\n};\n\nconst contextify = makeCacheableWithContext(_contextify);\nexports.contextify = contextify;\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\n\nconst _absolutify = (context, request) => {\n  return request.split(\"!\").map(r => requestToAbsolute(context, r)).join(\"!\");\n};\n\nconst absolutify = makeCacheableWithContext(_absolutify);\nexports.absolutify = absolutify;\nconst PATH_QUERY_FRAGMENT_REGEXP = /^((?:\\0.|[^?#\\0])*)(\\?(?:\\0.|[^#\\0])*)?(#.*)?$/;\nconst PATH_QUERY_REGEXP = /^((?:\\0.|[^?\\0])*)(\\?.*)?$/;\n/** @typedef {{ resource: string, path: string, query: string, fragment: string }} ParsedResource */\n\n/** @typedef {{ resource: string, path: string, query: string }} ParsedResourceWithoutFragment */\n\n/**\n * @param {string} str the path with query and fragment\n * @returns {ParsedResource} parsed parts\n */\n\nconst _parseResource = str => {\n  const match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);\n  return {\n    resource: str,\n    path: match[1].replace(/\\0(.)/g, \"$1\"),\n    query: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\",\n    fragment: match[3] || \"\"\n  };\n};\n\nexports.parseResource = makeCacheable(_parseResource);\n/**\n * Parse resource, skips fragment part\n * @param {string} str the path with query and fragment\n * @returns {ParsedResourceWithoutFragment} parsed parts\n */\n\nconst _parseResourceWithoutFragment = str => {\n  const match = PATH_QUERY_REGEXP.exec(str);\n  return {\n    resource: str,\n    path: match[1].replace(/\\0(.)/g, \"$1\"),\n    query: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\"\n  };\n};\n\nexports.parseResourceWithoutFragment = makeCacheable(_parseResourceWithoutFragment);\n/**\n * @param {string} filename the filename which should be undone\n * @param {string} outputPath the output path that is restored (only relevant when filename contains \"..\")\n * @param {boolean} enforceRelative true returns ./ for empty paths\n * @returns {string} repeated ../ to leave the directory of the provided filename to be back on output dir\n */\n\nexports.getUndoPath = (filename, outputPath, enforceRelative) => {\n  let depth = -1;\n  let append = \"\";\n  outputPath = outputPath.replace(/[\\\\/]$/, \"\");\n\n  for (const part of filename.split(/[/\\\\]+/)) {\n    if (part === \"..\") {\n      if (depth > -1) {\n        depth--;\n      } else {\n        const i = outputPath.lastIndexOf(\"/\");\n        const j = outputPath.lastIndexOf(\"\\\\\");\n        const pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n        if (pos < 0) return outputPath + \"/\";\n        append = outputPath.slice(pos + 1) + \"/\" + append;\n        outputPath = outputPath.slice(0, pos);\n      }\n    } else if (part !== \".\") {\n      depth++;\n    }\n  }\n\n  return depth > 0 ? `${\"../\".repeat(depth)}${append}` : enforceRelative ? `./${append}` : append;\n};","map":{"version":3,"names":["path","require","WINDOWS_ABS_PATH_REGEXP","SEGMENTS_SPLIT_REGEXP","WINDOWS_PATH_SEPARATOR_REGEXP","relativePathToRequest","relativePath","startsWith","absoluteToRequest","context","maybeAbsolutePath","length","querySplitPos","indexOf","resource","slice","posix","relative","test","win32","replace","requestToAbsolute","join","makeCacheable","realFn","cache","WeakMap","getCache","associatedObjectForCache","entry","get","undefined","map","Map","set","fn","str","result","bindCache","makeCacheableWithContext","cachedFn","identifier","innerCache","cachedResult","innerSubCache","boundFn","bindContextCache","_makePathsRelative","split","exports","makePathsRelative","_makePathsAbsolute","makePathsAbsolute","_contextify","request","r","contextify","_absolutify","absolutify","PATH_QUERY_FRAGMENT_REGEXP","PATH_QUERY_REGEXP","_parseResource","match","exec","query","fragment","parseResource","_parseResourceWithoutFragment","parseResourceWithoutFragment","getUndoPath","filename","outputPath","enforceRelative","depth","append","part","i","lastIndexOf","j","pos","Math","max","repeat"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/util/identifier.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\\\/]/;\nconst SEGMENTS_SPLIT_REGEXP = /([|!])/;\nconst WINDOWS_PATH_SEPARATOR_REGEXP = /\\\\/g;\n\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\nconst relativePathToRequest = relativePath => {\n\tif (relativePath === \"\") return \"./.\";\n\tif (relativePath === \"..\") return \"../.\";\n\tif (relativePath.startsWith(\"../\")) return relativePath;\n\treturn `./${relativePath}`;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} maybeAbsolutePath path to make relative\n * @returns {string} relative path in request style\n */\nconst absoluteToRequest = (context, maybeAbsolutePath) => {\n\tif (maybeAbsolutePath[0] === \"/\") {\n\t\tif (\n\t\t\tmaybeAbsolutePath.length > 1 &&\n\t\t\tmaybeAbsolutePath[maybeAbsolutePath.length - 1] === \"/\"\n\t\t) {\n\t\t\t// this 'path' is actually a regexp generated by dynamic requires.\n\t\t\t// Don't treat it as an absolute path.\n\t\t\treturn maybeAbsolutePath;\n\t\t}\n\n\t\tconst querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n\t\tlet resource =\n\t\t\tquerySplitPos === -1\n\t\t\t\t? maybeAbsolutePath\n\t\t\t\t: maybeAbsolutePath.slice(0, querySplitPos);\n\t\tresource = relativePathToRequest(path.posix.relative(context, resource));\n\t\treturn querySplitPos === -1\n\t\t\t? resource\n\t\t\t: resource + maybeAbsolutePath.slice(querySplitPos);\n\t}\n\n\tif (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {\n\t\tconst querySplitPos = maybeAbsolutePath.indexOf(\"?\");\n\t\tlet resource =\n\t\t\tquerySplitPos === -1\n\t\t\t\t? maybeAbsolutePath\n\t\t\t\t: maybeAbsolutePath.slice(0, querySplitPos);\n\t\tresource = path.win32.relative(context, resource);\n\t\tif (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {\n\t\t\tresource = relativePathToRequest(\n\t\t\t\tresource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, \"/\")\n\t\t\t);\n\t\t}\n\t\treturn querySplitPos === -1\n\t\t\t? resource\n\t\t\t: resource + maybeAbsolutePath.slice(querySplitPos);\n\t}\n\n\t// not an absolute path\n\treturn maybeAbsolutePath;\n};\n\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\nconst requestToAbsolute = (context, relativePath) => {\n\tif (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\"))\n\t\treturn path.join(context, relativePath);\n\treturn relativePath;\n};\n\nconst makeCacheable = realFn => {\n\t/** @type {WeakMap<object, Map<string, ParsedResource>>} */\n\tconst cache = new WeakMap();\n\n\tconst getCache = associatedObjectForCache => {\n\t\tconst entry = cache.get(associatedObjectForCache);\n\t\tif (entry !== undefined) return entry;\n\t\t/** @type {Map<string, ParsedResource>} */\n\t\tconst map = new Map();\n\t\tcache.set(associatedObjectForCache, map);\n\t\treturn map;\n\t};\n\n\t/**\n\t * @param {string} str the path with query and fragment\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {ParsedResource} parsed parts\n\t */\n\tconst fn = (str, associatedObjectForCache) => {\n\t\tif (!associatedObjectForCache) return realFn(str);\n\t\tconst cache = getCache(associatedObjectForCache);\n\t\tconst entry = cache.get(str);\n\t\tif (entry !== undefined) return entry;\n\t\tconst result = realFn(str);\n\t\tcache.set(str, result);\n\t\treturn result;\n\t};\n\n\tfn.bindCache = associatedObjectForCache => {\n\t\tconst cache = getCache(associatedObjectForCache);\n\t\treturn str => {\n\t\t\tconst entry = cache.get(str);\n\t\t\tif (entry !== undefined) return entry;\n\t\t\tconst result = realFn(str);\n\t\t\tcache.set(str, result);\n\t\t\treturn result;\n\t\t};\n\t};\n\n\treturn fn;\n};\n\nconst makeCacheableWithContext = fn => {\n\t/** @type {WeakMap<object, Map<string, Map<string, string>>>} */\n\tconst cache = new WeakMap();\n\n\t/**\n\t * @param {string} context context used to create relative path\n\t * @param {string} identifier identifier used to create relative path\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {string} the returned relative path\n\t */\n\tconst cachedFn = (context, identifier, associatedObjectForCache) => {\n\t\tif (!associatedObjectForCache) return fn(context, identifier);\n\n\t\tlet innerCache = cache.get(associatedObjectForCache);\n\t\tif (innerCache === undefined) {\n\t\t\tinnerCache = new Map();\n\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t}\n\n\t\tlet cachedResult;\n\t\tlet innerSubCache = innerCache.get(context);\n\t\tif (innerSubCache === undefined) {\n\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t} else {\n\t\t\tcachedResult = innerSubCache.get(identifier);\n\t\t}\n\n\t\tif (cachedResult !== undefined) {\n\t\t\treturn cachedResult;\n\t\t} else {\n\t\t\tconst result = fn(context, identifier);\n\t\t\tinnerSubCache.set(identifier, result);\n\t\t\treturn result;\n\t\t}\n\t};\n\n\t/**\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {function(string, string): string} cached function\n\t */\n\tcachedFn.bindCache = associatedObjectForCache => {\n\t\tlet innerCache;\n\t\tif (associatedObjectForCache) {\n\t\t\tinnerCache = cache.get(associatedObjectForCache);\n\t\t\tif (innerCache === undefined) {\n\t\t\t\tinnerCache = new Map();\n\t\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t\t}\n\t\t} else {\n\t\t\tinnerCache = new Map();\n\t\t}\n\n\t\t/**\n\t\t * @param {string} context context used to create relative path\n\t\t * @param {string} identifier identifier used to create relative path\n\t\t * @returns {string} the returned relative path\n\t\t */\n\t\tconst boundFn = (context, identifier) => {\n\t\t\tlet cachedResult;\n\t\t\tlet innerSubCache = innerCache.get(context);\n\t\t\tif (innerSubCache === undefined) {\n\t\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t\t} else {\n\t\t\t\tcachedResult = innerSubCache.get(identifier);\n\t\t\t}\n\n\t\t\tif (cachedResult !== undefined) {\n\t\t\t\treturn cachedResult;\n\t\t\t} else {\n\t\t\t\tconst result = fn(context, identifier);\n\t\t\t\tinnerSubCache.set(identifier, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\treturn boundFn;\n\t};\n\n\t/**\n\t * @param {string} context context used to create relative path\n\t * @param {Object=} associatedObjectForCache an object to which the cache will be attached\n\t * @returns {function(string): string} cached function\n\t */\n\tcachedFn.bindContextCache = (context, associatedObjectForCache) => {\n\t\tlet innerSubCache;\n\t\tif (associatedObjectForCache) {\n\t\t\tlet innerCache = cache.get(associatedObjectForCache);\n\t\t\tif (innerCache === undefined) {\n\t\t\t\tinnerCache = new Map();\n\t\t\t\tcache.set(associatedObjectForCache, innerCache);\n\t\t\t}\n\n\t\t\tinnerSubCache = innerCache.get(context);\n\t\t\tif (innerSubCache === undefined) {\n\t\t\t\tinnerCache.set(context, (innerSubCache = new Map()));\n\t\t\t}\n\t\t} else {\n\t\t\tinnerSubCache = new Map();\n\t\t}\n\n\t\t/**\n\t\t * @param {string} identifier identifier used to create relative path\n\t\t * @returns {string} the returned relative path\n\t\t */\n\t\tconst boundFn = identifier => {\n\t\t\tconst cachedResult = innerSubCache.get(identifier);\n\t\t\tif (cachedResult !== undefined) {\n\t\t\t\treturn cachedResult;\n\t\t\t} else {\n\t\t\t\tconst result = fn(context, identifier);\n\t\t\t\tinnerSubCache.set(identifier, result);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t};\n\n\t\treturn boundFn;\n\t};\n\n\treturn cachedFn;\n};\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsRelative = (context, identifier) => {\n\treturn identifier\n\t\t.split(SEGMENTS_SPLIT_REGEXP)\n\t\t.map(str => absoluteToRequest(context, str))\n\t\t.join(\"\");\n};\n\nexports.makePathsRelative = makeCacheableWithContext(_makePathsRelative);\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsAbsolute = (context, identifier) => {\n\treturn identifier\n\t\t.split(SEGMENTS_SPLIT_REGEXP)\n\t\t.map(str => requestToAbsolute(context, str))\n\t\t.join(\"\");\n};\n\nexports.makePathsAbsolute = makeCacheableWithContext(_makePathsAbsolute);\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\nconst _contextify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => absoluteToRequest(context, r))\n\t\t.join(\"!\");\n};\n\nconst contextify = makeCacheableWithContext(_contextify);\nexports.contextify = contextify;\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\nconst _absolutify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => requestToAbsolute(context, r))\n\t\t.join(\"!\");\n};\n\nconst absolutify = makeCacheableWithContext(_absolutify);\nexports.absolutify = absolutify;\n\nconst PATH_QUERY_FRAGMENT_REGEXP =\n\t/^((?:\\0.|[^?#\\0])*)(\\?(?:\\0.|[^#\\0])*)?(#.*)?$/;\nconst PATH_QUERY_REGEXP = /^((?:\\0.|[^?\\0])*)(\\?.*)?$/;\n\n/** @typedef {{ resource: string, path: string, query: string, fragment: string }} ParsedResource */\n/** @typedef {{ resource: string, path: string, query: string }} ParsedResourceWithoutFragment */\n\n/**\n * @param {string} str the path with query and fragment\n * @returns {ParsedResource} parsed parts\n */\nconst _parseResource = str => {\n\tconst match = PATH_QUERY_FRAGMENT_REGEXP.exec(str);\n\treturn {\n\t\tresource: str,\n\t\tpath: match[1].replace(/\\0(.)/g, \"$1\"),\n\t\tquery: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\",\n\t\tfragment: match[3] || \"\"\n\t};\n};\nexports.parseResource = makeCacheable(_parseResource);\n\n/**\n * Parse resource, skips fragment part\n * @param {string} str the path with query and fragment\n * @returns {ParsedResourceWithoutFragment} parsed parts\n */\nconst _parseResourceWithoutFragment = str => {\n\tconst match = PATH_QUERY_REGEXP.exec(str);\n\treturn {\n\t\tresource: str,\n\t\tpath: match[1].replace(/\\0(.)/g, \"$1\"),\n\t\tquery: match[2] ? match[2].replace(/\\0(.)/g, \"$1\") : \"\"\n\t};\n};\nexports.parseResourceWithoutFragment = makeCacheable(\n\t_parseResourceWithoutFragment\n);\n\n/**\n * @param {string} filename the filename which should be undone\n * @param {string} outputPath the output path that is restored (only relevant when filename contains \"..\")\n * @param {boolean} enforceRelative true returns ./ for empty paths\n * @returns {string} repeated ../ to leave the directory of the provided filename to be back on output dir\n */\nexports.getUndoPath = (filename, outputPath, enforceRelative) => {\n\tlet depth = -1;\n\tlet append = \"\";\n\toutputPath = outputPath.replace(/[\\\\/]$/, \"\");\n\tfor (const part of filename.split(/[/\\\\]+/)) {\n\t\tif (part === \"..\") {\n\t\t\tif (depth > -1) {\n\t\t\t\tdepth--;\n\t\t\t} else {\n\t\t\t\tconst i = outputPath.lastIndexOf(\"/\");\n\t\t\t\tconst j = outputPath.lastIndexOf(\"\\\\\");\n\t\t\t\tconst pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);\n\t\t\t\tif (pos < 0) return outputPath + \"/\";\n\t\t\t\tappend = outputPath.slice(pos + 1) + \"/\" + append;\n\t\t\t\toutputPath = outputPath.slice(0, pos);\n\t\t\t}\n\t\t} else if (part !== \".\") {\n\t\t\tdepth++;\n\t\t}\n\t}\n\treturn depth > 0\n\t\t? `${\"../\".repeat(depth)}${append}`\n\t\t: enforceRelative\n\t\t? `./${append}`\n\t\t: append;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}