{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst TOMBSTONE = Symbol(\"tombstone\");\nconst UNDEFINED_MARKER = Symbol(\"undefined\");\n/**\n * @template T\n * @typedef {T | undefined} Cell<T>\n */\n\n/**\n * @template T\n * @typedef {T | typeof TOMBSTONE | typeof UNDEFINED_MARKER} InternalCell<T>\n */\n\n/**\n * @template K\n * @template V\n * @param {[K, InternalCell<V>]} pair the internal cell\n * @returns {[K, Cell<V>]} its “safe” representation\n */\n\nconst extractPair = pair => {\n  const key = pair[0];\n  const val = pair[1];\n\n  if (val === UNDEFINED_MARKER || val === TOMBSTONE) {\n    return [key, undefined];\n  } else {\n    return (\n      /** @type {[K, Cell<V>]} */\n      pair\n    );\n  }\n};\n/**\n * @template K\n * @template V\n */\n\n\nclass StackedMap {\n  /**\n   * @param {Map<K, InternalCell<V>>[]=} parentStack an optional parent\n   */\n  constructor(parentStack) {\n    /** @type {Map<K, InternalCell<V>>} */\n    this.map = new Map();\n    /** @type {Map<K, InternalCell<V>>[]} */\n\n    this.stack = parentStack === undefined ? [] : parentStack.slice();\n    this.stack.push(this.map);\n  }\n  /**\n   * @param {K} item the key of the element to add\n   * @param {V} value the value of the element to add\n   * @returns {void}\n   */\n\n\n  set(item, value) {\n    this.map.set(item, value === undefined ? UNDEFINED_MARKER : value);\n  }\n  /**\n   * @param {K} item the item to delete\n   * @returns {void}\n   */\n\n\n  delete(item) {\n    if (this.stack.length > 1) {\n      this.map.set(item, TOMBSTONE);\n    } else {\n      this.map.delete(item);\n    }\n  }\n  /**\n   * @param {K} item the item to test\n   * @returns {boolean} true if the item exists in this set\n   */\n\n\n  has(item) {\n    const topValue = this.map.get(item);\n\n    if (topValue !== undefined) {\n      return topValue !== TOMBSTONE;\n    }\n\n    if (this.stack.length > 1) {\n      for (let i = this.stack.length - 2; i >= 0; i--) {\n        const value = this.stack[i].get(item);\n\n        if (value !== undefined) {\n          this.map.set(item, value);\n          return value !== TOMBSTONE;\n        }\n      }\n\n      this.map.set(item, TOMBSTONE);\n    }\n\n    return false;\n  }\n  /**\n   * @param {K} item the key of the element to return\n   * @returns {Cell<V>} the value of the element\n   */\n\n\n  get(item) {\n    const topValue = this.map.get(item);\n\n    if (topValue !== undefined) {\n      return topValue === TOMBSTONE || topValue === UNDEFINED_MARKER ? undefined : topValue;\n    }\n\n    if (this.stack.length > 1) {\n      for (let i = this.stack.length - 2; i >= 0; i--) {\n        const value = this.stack[i].get(item);\n\n        if (value !== undefined) {\n          this.map.set(item, value);\n          return value === TOMBSTONE || value === UNDEFINED_MARKER ? undefined : value;\n        }\n      }\n\n      this.map.set(item, TOMBSTONE);\n    }\n\n    return undefined;\n  }\n\n  _compress() {\n    if (this.stack.length === 1) return;\n    this.map = new Map();\n\n    for (const data of this.stack) {\n      for (const pair of data) {\n        if (pair[1] === TOMBSTONE) {\n          this.map.delete(pair[0]);\n        } else {\n          this.map.set(pair[0], pair[1]);\n        }\n      }\n    }\n\n    this.stack = [this.map];\n  }\n\n  asArray() {\n    this._compress();\n\n    return Array.from(this.map.keys());\n  }\n\n  asSet() {\n    this._compress();\n\n    return new Set(this.map.keys());\n  }\n\n  asPairArray() {\n    this._compress();\n\n    return Array.from(this.map.entries(), extractPair);\n  }\n\n  asMap() {\n    return new Map(this.asPairArray());\n  }\n\n  get size() {\n    this._compress();\n\n    return this.map.size;\n  }\n\n  createChild() {\n    return new StackedMap(this.stack);\n  }\n\n}\n\nmodule.exports = StackedMap;","map":{"version":3,"names":["TOMBSTONE","Symbol","UNDEFINED_MARKER","extractPair","pair","key","val","undefined","StackedMap","constructor","parentStack","map","Map","stack","slice","push","set","item","value","delete","length","has","topValue","get","i","_compress","data","asArray","Array","from","keys","asSet","Set","asPairArray","entries","asMap","size","createChild","module","exports"],"sources":["/Users/arpanbhandari/Documents/cod-ing/React/newsapp/node_modules/webpack/lib/util/StackedMap.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst TOMBSTONE = Symbol(\"tombstone\");\nconst UNDEFINED_MARKER = Symbol(\"undefined\");\n\n/**\n * @template T\n * @typedef {T | undefined} Cell<T>\n */\n\n/**\n * @template T\n * @typedef {T | typeof TOMBSTONE | typeof UNDEFINED_MARKER} InternalCell<T>\n */\n\n/**\n * @template K\n * @template V\n * @param {[K, InternalCell<V>]} pair the internal cell\n * @returns {[K, Cell<V>]} its “safe” representation\n */\nconst extractPair = pair => {\n\tconst key = pair[0];\n\tconst val = pair[1];\n\tif (val === UNDEFINED_MARKER || val === TOMBSTONE) {\n\t\treturn [key, undefined];\n\t} else {\n\t\treturn /** @type {[K, Cell<V>]} */ (pair);\n\t}\n};\n\n/**\n * @template K\n * @template V\n */\nclass StackedMap {\n\t/**\n\t * @param {Map<K, InternalCell<V>>[]=} parentStack an optional parent\n\t */\n\tconstructor(parentStack) {\n\t\t/** @type {Map<K, InternalCell<V>>} */\n\t\tthis.map = new Map();\n\t\t/** @type {Map<K, InternalCell<V>>[]} */\n\t\tthis.stack = parentStack === undefined ? [] : parentStack.slice();\n\t\tthis.stack.push(this.map);\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to add\n\t * @param {V} value the value of the element to add\n\t * @returns {void}\n\t */\n\tset(item, value) {\n\t\tthis.map.set(item, value === undefined ? UNDEFINED_MARKER : value);\n\t}\n\n\t/**\n\t * @param {K} item the item to delete\n\t * @returns {void}\n\t */\n\tdelete(item) {\n\t\tif (this.stack.length > 1) {\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t} else {\n\t\t\tthis.map.delete(item);\n\t\t}\n\t}\n\n\t/**\n\t * @param {K} item the item to test\n\t * @returns {boolean} true if the item exists in this set\n\t */\n\thas(item) {\n\t\tconst topValue = this.map.get(item);\n\t\tif (topValue !== undefined) {\n\t\t\treturn topValue !== TOMBSTONE;\n\t\t}\n\t\tif (this.stack.length > 1) {\n\t\t\tfor (let i = this.stack.length - 2; i >= 0; i--) {\n\t\t\t\tconst value = this.stack[i].get(item);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tthis.map.set(item, value);\n\t\t\t\t\treturn value !== TOMBSTONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {K} item the key of the element to return\n\t * @returns {Cell<V>} the value of the element\n\t */\n\tget(item) {\n\t\tconst topValue = this.map.get(item);\n\t\tif (topValue !== undefined) {\n\t\t\treturn topValue === TOMBSTONE || topValue === UNDEFINED_MARKER\n\t\t\t\t? undefined\n\t\t\t\t: topValue;\n\t\t}\n\t\tif (this.stack.length > 1) {\n\t\t\tfor (let i = this.stack.length - 2; i >= 0; i--) {\n\t\t\t\tconst value = this.stack[i].get(item);\n\t\t\t\tif (value !== undefined) {\n\t\t\t\t\tthis.map.set(item, value);\n\t\t\t\t\treturn value === TOMBSTONE || value === UNDEFINED_MARKER\n\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t: value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.map.set(item, TOMBSTONE);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t_compress() {\n\t\tif (this.stack.length === 1) return;\n\t\tthis.map = new Map();\n\t\tfor (const data of this.stack) {\n\t\t\tfor (const pair of data) {\n\t\t\t\tif (pair[1] === TOMBSTONE) {\n\t\t\t\t\tthis.map.delete(pair[0]);\n\t\t\t\t} else {\n\t\t\t\t\tthis.map.set(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.stack = [this.map];\n\t}\n\n\tasArray() {\n\t\tthis._compress();\n\t\treturn Array.from(this.map.keys());\n\t}\n\n\tasSet() {\n\t\tthis._compress();\n\t\treturn new Set(this.map.keys());\n\t}\n\n\tasPairArray() {\n\t\tthis._compress();\n\t\treturn Array.from(this.map.entries(), extractPair);\n\t}\n\n\tasMap() {\n\t\treturn new Map(this.asPairArray());\n\t}\n\n\tget size() {\n\t\tthis._compress();\n\t\treturn this.map.size;\n\t}\n\n\tcreateChild() {\n\t\treturn new StackedMap(this.stack);\n\t}\n}\n\nmodule.exports = StackedMap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}